```text
ida_hexrays
    array used for translating cexpr_t->op type to their names. 

ida_hexrays.ACFL_BLKOPT
    perform interblock transformations

ida_hexrays.ACFL_GLBDEL
    perform dead code eliminition

ida_hexrays.ACFL_GLBPROP
    perform global propagation

ida_hexrays.ACFL_GUESS
    may guess calling conventions

ida_hexrays.ACFL_LOCOPT
    perform local propagation (requires ACFL_BLKOPT)

ida_hexrays.ALLOW_UNUSED_LABELS
    Unused labels are permitted.

ida_hexrays.ANCHOR_BLKCMT
    block comment (for ctree items)

ida_hexrays.ANCHOR_CITEM
    c-tree item

ida_hexrays.ANCHOR_ITP
    item type preciser

ida_hexrays.ANCHOR_LVAR
    declaration of local variable

ida_hexrays.ANY_FPSIZE
    any size of floating operand is permitted

ida_hexrays.ANY_REGSIZE
    any register size is permitted

ida_hexrays.BLT_0WAY
    does not have successors (tail is a noret function)

ida_hexrays.BLT_1WAY
    passes execution to one block (regular or goto block)

ida_hexrays.BLT_2WAY
    passes execution to two blocks (conditional jump)

ida_hexrays.BLT_NONE
    unknown block type

ida_hexrays.BLT_NWAY
    passes execution to many blocks (switch idiom)

ida_hexrays.BLT_STOP
    stops execution regularly (must be the last block)

ida_hexrays.BLT_XTRN
    external block (out of function address)

ida_hexrays.CALC_CURLY_BRACES
    print curly braces if necessary

ida_hexrays.CFL_FINAL
    call type is final, should not be changed

ida_hexrays.CFL_HELPER
    created from a decompiler helper function

ida_hexrays.CFL_NORET
    call does not return

ida_hexrays.CFS_BOUNDS
    'eamap' and 'boundaries' are ready

ida_hexrays.CFS_LOCKED
    cfunc is temporarily locked

ida_hexrays.CFS_LVARS_HIDDEN
    local variable definitions are collapsed

ida_hexrays.CFS_TEXT
    'sv' is ready (and hdrlines)

ida_hexrays.CHF_FAKE
    fake chain created by widen_chains()

ida_hexrays.CHF_INITED
    is chain initialized? (valid only after lvar allocation)

ida_hexrays.CHF_OVER
    overlapped chain

ida_hexrays.CHF_PASSTHRU
    pass-thru chain, must use the input variable to the block

ida_hexrays.CHF_REPLACED
    chain operands have been replaced?

ida_hexrays.CHF_TERM
    terminating chain; the variable does not survive across the block

ida_hexrays.CIT_COLLAPSED
    display ctree item in collapsed form

ida_hexrays.CMAT_BUILT
    just generated

ida_hexrays.CMAT_CASTED
    added necessary casts

ida_hexrays.CMAT_CPA
    corrected pointer arithmetic

ida_hexrays.CMAT_FINAL
    ready-to-use

ida_hexrays.CMAT_NICE
    nicefied expressions

ida_hexrays.CMAT_TRANS1
    applied first wave of transformations

ida_hexrays.CMAT_TRANS2
    applied second wave of transformations

ida_hexrays.CMAT_TRANS3
    applied third wave of transformations

ida_hexrays.CMAT_ZERO
    does not exist

ida_hexrays.CMT_ALL
    All comments.

ida_hexrays.CMT_BLOCK1
    Anterioir block comment.

ida_hexrays.CMT_BLOCK2
    Posterior block comment.

ida_hexrays.CMT_FUNC
    Function comment.

ida_hexrays.CMT_LVAR
    Local variable comment.

ida_hexrays.CMT_NONE
    No comment is possible.

ida_hexrays.CMT_TAIL
    Indented comment.

ida_hexrays.CPBLK_FAST
    do not update minbstkref and minbargref

ida_hexrays.CPBLK_MINREF
    update minbstkref and minbargref

ida_hexrays.CPBLK_OPTJMP
    del the jump insn at the end of the block if it becomes useless 
            

ida_hexrays.CV_FAST
    do not maintain parent information

ida_hexrays.CV_INSNS
    visit only statements, prune all expressions do not use before the final ctree maturity because expressions may contain statements at intermediate stages (see cot_insn). Otherwise you risk missing statements embedded into expressions. 
            

ida_hexrays.CV_PARENTS
    maintain parent information

ida_hexrays.CV_POST
    call the leave...() functions

ida_hexrays.CV_PRUNE
    this bit is set by visit...() to prune the walk

ida_hexrays.CV_RESTART
    restart enumeration at the top expr (apply_to_exprs)

ida_hexrays.DECOMP_ALL_BLKS
    generate microcode for unreachable blocks

ida_hexrays.DECOMP_GXREFS_DEFLT
    the default behavior: do not update the global xrefs cache upon decompile() call, but when the pseudocode text is generated (e.g., through cfunc_t.get_pseudocode()) 
            

ida_hexrays.DECOMP_GXREFS_FORCE
    update the global xrefs cache immediately

ida_hexrays.DECOMP_GXREFS_NOUPD
    do not update the global xrefs cache

ida_hexrays.DECOMP_NO_CACHE
    do not use decompilation cache (snippets are never cached)

ida_hexrays.DECOMP_NO_FRAME
    do not use function frame info (only snippet mode)

ida_hexrays.DECOMP_NO_HIDE
    do not close display waitbox. see close_hexrays_waitboxes()

ida_hexrays.DECOMP_NO_WAIT
    do not display waitbox

ida_hexrays.DECOMP_OUTLINE
    generate code for an outline

ida_hexrays.DECOMP_VOID_MBA
    return empty mba object (to be used with gen_microcode)

ida_hexrays.DECOMP_WARNINGS
    display warnings in the output window

ida_hexrays.DecompilationFailure

ida_hexrays.EQ_CMPDEST
    compare instruction destinations

ida_hexrays.EQ_IGNCODE
    ignore instruction opcodes

ida_hexrays.EQ_IGNSIZE
    ignore source operand sizes

ida_hexrays.EQ_OPTINSN
    optimize mop_d operands

ida_hexrays.EXFL_ALL
    all currently defined bits

ida_hexrays.EXFL_ALONE
    standalone helper

ida_hexrays.EXFL_CPADONE
    pointer arithmetic correction done

ida_hexrays.EXFL_CSTR
    string literal

ida_hexrays.EXFL_FPOP
    floating point operation

ida_hexrays.EXFL_JUMPOUT
    jump out-of-function

ida_hexrays.EXFL_LVALUE
    expression is lvalue even if it doesn't look like it

ida_hexrays.EXFL_PARTIAL
    type of the expression is considered partial

ida_hexrays.EXFL_UNDEF
    expression uses undefined value

ida_hexrays.EXFL_VFTABLE
    is ptr to vftable (used for cot_memptr, cot_memref)

ida_hexrays.FCI_DEAD
    some return registers were determined dead

ida_hexrays.FCI_EXPLOCS
    all arglocs are specified explicitly

ida_hexrays.FCI_FINAL
    call type is final, should not be changed

ida_hexrays.FCI_HASCALL
    A function is an synthetic helper combined from several instructions and at least one of them was a call to a real functions 
            

ida_hexrays.FCI_HASFMT
    A variadic function with recognized printf- or scanf-style format string 
            

ida_hexrays.FCI_NORET
    call does not return

ida_hexrays.FCI_NOSIDE
    call does not have side effects

ida_hexrays.FCI_PROP
    call has been propagated

ida_hexrays.FCI_PURE
    pure function

ida_hexrays.FCI_SPLOK
    spoiled/visible_memory lists have been optimized. for some functions we can reduce them as soon as information about the arguments becomes available. in order not to try optimize them again we use this bit. 
            

ida_hexrays.FD_BACKWARD
    search direction

ida_hexrays.FD_DEF
    look for definition

ida_hexrays.FD_DIRTY
    ignore possible implicit definitions by function calls and indirect memory access 
            

ida_hexrays.FD_FORWARD
    search direction

ida_hexrays.FD_USE
    look for use

ida_hexrays.FORBID_UNUSED_LABELS
    Unused labels cause interr.

ida_hexrays.GCA_ALLOC
    enumerate only allocated chains

ida_hexrays.GCA_EMPTY
    include empty chains

ida_hexrays.GCA_NALLOC
    enumerate only non-allocated chains

ida_hexrays.GCA_OFIRST
    consider only chains of the first block

ida_hexrays.GCA_OLAST
    consider only chains of the last block

ida_hexrays.GCA_SPEC
    include chains for special registers

ida_hexrays.GCO_DEF
    is destination operand?

ida_hexrays.GCO_REG
    is register? otherwise a stack variable

ida_hexrays.GCO_STK
    a stack variable

ida_hexrays.GCO_USE
    is source operand?

ida_hexrays.GC_ASR
    all the above and assertions

ida_hexrays.GC_DIRTY_ALL
    bitmask to represent all chains

ida_hexrays.GC_END
    number of chain types

ida_hexrays.GC_REGS_AND_STKVARS
    registers and stkvars (restricted memory only)

ida_hexrays.GC_XDSU
    only registers calculated with FULL_XDSU

ida_hexrays.GLN_ALL
    get both

ida_hexrays.GLN_CURRENT
    get label of the current item

ida_hexrays.GLN_GOTO_TARGET
    get goto target

ida_hexrays.Hexrays_Hooks

ida_hexrays.Hexrays_Hooks.__disown__(self)

ida_hexrays.Hexrays_Hooks.__init__(self, _flags: int = 0, _hkcb_flags: int = 1)

ida_hexrays.Hexrays_Hooks.begin_inlining(self, cdg: "codegen_t", decomp_flags: int) -> int
    Starting to inline outlined functions. 
              
    @param cdg: (codegen_t *)
    @param decomp_flags: (int)
    @returns Microcode error codes code This is an opportunity to inline other ranges.

ida_hexrays.Hexrays_Hooks.build_callinfo(self, blk: "mblock_t", type: "tinfo_t") -> "PyObject *"
    Analyzing a call instruction. 
              
    @param blk: (mblock_t *) blk->tail is the call.
    @param type: (tinfo_t *) buffer for the output type.

ida_hexrays.Hexrays_Hooks.callinfo_built(self, blk: "mblock_t") -> int
    A call instruction has been anallyzed. 
              
    @param blk: (mblock_t *) blk->tail is the call.

ida_hexrays.Hexrays_Hooks.calls_done(self, mba: "mba_t") -> int
    All calls have been analyzed. 
              
    @param mba: (mba_t *) This event is generated immediately after analyzing all calls, before any optimizitions, call unmerging and block merging.

ida_hexrays.Hexrays_Hooks.close_pseudocode(self, vu: "vdui_t") -> int
    Pseudocode view is being closed. 
              
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.cmt_changed(self, cfunc: "cfunc_t", loc: "treeloc_t", cmt: str) -> int
    Comment got changed. 
              
    @param cfunc: (cfunc_t *)
    @param loc: (const treeloc_t *)
    @param cmt: (const char *)

ida_hexrays.Hexrays_Hooks.collect_warnings(self, cfunc: "cfunc_t") -> int
    Collect warning messages from plugins. These warnings will be displayed at the function header, after the user-defined comments. 
              
    @param cfunc: (cfunc_t *)

ida_hexrays.Hexrays_Hooks.combine(self, blk: "mblock_t", insn: "minsn_t") -> int
    Trying to combine instructions of basic block. 
              
    @param blk: (mblock_t *)
    @param insn: (minsn_t *) Should return: 1 if combined the current instruction with a preceding one -1 if the instruction should not be combined 0 else

ida_hexrays.Hexrays_Hooks.create_hint(self, vu: "vdui_t") -> "PyObject *"
    Create a hint for the current item. 
              
    @param vu: (vdui_t *)
    @retval 0: continue collecting hints with other subscribers
    @retval 1: stop collecting hints

ida_hexrays.Hexrays_Hooks.curpos(self, vu: "vdui_t") -> int
    Current cursor position has been changed. (for example, by left-clicking or using keyboard)
    
              
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.double_click(self, vu: "vdui_t", shift_state: int) -> int
    Mouse double click. 
              
    @param vu: (vdui_t *)
    @param shift_state: (int) Should return: 1 if the event has been handled

ida_hexrays.Hexrays_Hooks.flowchart(self, fc: "qflow_chart_t", mba: "mba_t", reachable_blocks: "bitset_t", decomp_flags: int) -> int
    Flowchart has been generated. 
              
    @param fc: (qflow_chart_t *)
    @param mba: (mba_t *)
    @param reachable_blocks: (bitset_t *)
    @param decomp_flags: (int)
    @returns Microcode error codes code

ida_hexrays.Hexrays_Hooks.func_printed(self, cfunc: "cfunc_t") -> int
    Function text has been generated. Plugins may modify the text in cfunc_t::sv. However, it is too late to modify the ctree or microcode. The text uses regular color codes (see lines.hpp) COLOR_ADDR is used to store pointers to ctree items. 
              
    @param cfunc: (cfunc_t *)

ida_hexrays.Hexrays_Hooks.glbopt(self, mba: "mba_t") -> int
    Global optimization has been finished. If microcode is modified, MERR_LOOP must be returned. It will cause a complete restart of the optimization. 
              
    @param mba: (mba_t *)
    @returns Microcode error codes code

ida_hexrays.Hexrays_Hooks.hook(self) -> bool

ida_hexrays.Hexrays_Hooks.inlined_func(self, cdg: "codegen_t", blk: int, mbr: "mba_ranges_t", i1: int, i2: int) -> int
    A set of ranges got inlined. 
              
    @param cdg: (codegen_t *)
    @param blk: (int) the block containing call/jump to inline
    @param mbr: (mba_ranges_t *) the range to inline
    @param i1: (int) blknum of the first inlined block
    @param i2: (int) blknum of the last inlined block (excluded)

ida_hexrays.Hexrays_Hooks.inlining_func(self, cdg: "codegen_t", blk: int, mbr: "mba_ranges_t") -> int
    A set of ranges is going to be inlined. 
              
    @param cdg: (codegen_t *)
    @param blk: (int) the block containing call/jump to inline
    @param mbr: (mba_ranges_t *) the range to inline

ida_hexrays.Hexrays_Hooks.interr(self, errcode: int) -> int
    Internal error has occurred. 
              
    @param errcode: (int )

ida_hexrays.Hexrays_Hooks.keyboard(self, vu: "vdui_t", key_code: int, shift_state: int) -> int
    Keyboard has been hit. 
              
    @param vu: (vdui_t *)
    @param key_code: (int) VK_...
    @param shift_state: (int) Should return: 1 if the event has been handled

ida_hexrays.Hexrays_Hooks.locopt(self, mba: "mba_t") -> int
    Basic block level optimization has been finished. 
              
    @param mba: (mba_t *)
    @returns Microcode error codes code

ida_hexrays.Hexrays_Hooks.lvar_cmt_changed(self, vu: "vdui_t", v: "lvar_t", cmt: str) -> int
    Local variable comment got changed. 
              
    @param vu: (vdui_t *)
    @param v: (lvar_t *)
    @param cmt: (const char *) Please note that it is possible to read/write user settings for lvars directly from the idb.

ida_hexrays.Hexrays_Hooks.lvar_mapping_changed(self, vu: "vdui_t", frm: "lvar_t", to: "lvar_t") -> int
    Local variable mapping got changed. 
              
    @param vu: (vdui_t *)
    @param to: (lvar_t *) Please note that it is possible to read/write user settings for lvars directly from the idb.

ida_hexrays.Hexrays_Hooks.lvar_name_changed(self, vu: "vdui_t", v: "lvar_t", name: str, is_user_name: bool) -> int
    Local variable got renamed. 
              
    @param vu: (vdui_t *)
    @param v: (lvar_t *)
    @param name: (const char *)
    @param is_user_name: (bool) Please note that it is possible to read/write user settings for lvars directly from the idb.

ida_hexrays.Hexrays_Hooks.lvar_type_changed(self, vu: "vdui_t", v: "lvar_t", tinfo: "tinfo_t") -> int
    Local variable type got changed. 
              
    @param vu: (vdui_t *)
    @param v: (lvar_t *)
    @param tinfo: (const tinfo_t *) Please note that it is possible to read/write user settings for lvars directly from the idb.

ida_hexrays.Hexrays_Hooks.maturity(self, cfunc: "cfunc_t", new_maturity: "ctree_maturity_t") -> int
    Ctree maturity level is being changed. 
              
    @param cfunc: (cfunc_t *)
    @param new_maturity: (ctree_maturity_t)

ida_hexrays.Hexrays_Hooks.microcode(self, mba: "mba_t") -> int
    Microcode has been generated. 
              
    @param mba: (mba_t *)
    @returns Microcode error codes code

ida_hexrays.Hexrays_Hooks.open_pseudocode(self, vu: "vdui_t") -> int
    New pseudocode view has been opened. 
              
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.populating_popup(self, widget: "TWidget *", popup_handle: "TPopupMenu *", vu: "vdui_t") -> int
    Populating popup menu. We can add menu items now. 
              
    @param widget: (TWidget *)
    @param popup_handle: (TPopupMenu *)
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.pre_structural(self, ct: "control_graph_t *", cfunc: "cfunc_t", g: "simple_graph_t") -> int
    Structure analysis is starting. 
              
    @param ct: (control_graph_t *) in/out: control graph
    @param cfunc: (cfunc_t *) in: the current function
    @param g: (const simple_graph_t *) in: control flow graph
    @returns Microcode error codes code; MERR_BLOCK means that the analysis has been performed by a plugin

ida_hexrays.Hexrays_Hooks.prealloc(self, mba: "mba_t") -> int
    Local variables: preallocation step begins. 
              
    @param mba: (mba_t *) This event may occur several times. Should return: 1 if modified microcode Negative values are Microcode error codes error codes

ida_hexrays.Hexrays_Hooks.preoptimized(self, mba: "mba_t") -> int
    Microcode has been preoptimized. 
              
    @param mba: (mba_t *)
    @returns Microcode error codes code

ida_hexrays.Hexrays_Hooks.print_func(self, cfunc: "cfunc_t", vp: "vc_printer_t") -> int
    Printing ctree and generating text. 
              
    @param cfunc: (cfunc_t *)
    @param vp: (vc_printer_t *) Returns: 1 if text has been generated by the plugin It is forbidden to modify ctree at this event.

ida_hexrays.Hexrays_Hooks.prolog(self, mba: "mba_t", fc: "qflow_chart_t", reachable_blocks: "bitset_t", decomp_flags: int) -> int
    Prolog analysis has been finished. 
              
    @param mba: (mba_t *)
    @param fc: (qflow_chart_t *)
    @param reachable_blocks: (const bitset_t *)
    @param decomp_flags: (int)
    @returns Microcode error codes code This event is generated for each inlined range as well.

ida_hexrays.Hexrays_Hooks.refresh_pseudocode(self, vu: "vdui_t") -> int
    Existing pseudocode text has been refreshed. Adding/removing pseudocode lines is forbidden in this event. 
              
    @param vu: (vdui_t *) See also hxe_text_ready, which happens earlier

ida_hexrays.Hexrays_Hooks.resolve_stkaddrs(self, mba: "mba_t") -> int
    The optimizer is about to resolve stack addresses. 
              
    @param mba: (mba_t *)

ida_hexrays.Hexrays_Hooks.right_click(self, vu: "vdui_t") -> int
    Mouse right click. Use hxe_populating_popup instead, in case you want to add items in the popup menu. 
              
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.stkpnts(self, mba: "mba_t", _sps: "stkpnts_t *") -> int
    SP change points have been calculated. 
              
    @param mba: (mba_t *)
    @returns Microcode error codes code This event is generated for each inlined range as well.

ida_hexrays.Hexrays_Hooks.structural(self, ct: "control_graph_t *") -> int
    Structural analysis has been finished. 
              
    @param ct: (control_graph_t *)

ida_hexrays.Hexrays_Hooks.switch_pseudocode(self, vu: "vdui_t") -> int
    Existing pseudocode view has been reloaded with a new function. Its text has not been refreshed yet, only cfunc and mba pointers are ready. 
              
    @param vu: (vdui_t *)

ida_hexrays.Hexrays_Hooks.text_ready(self, vu: "vdui_t") -> int
    Decompiled text is ready. 
              
    @param vu: (vdui_t *) This event can be used to modify the output text (sv). Obsolete. Please use hxe_func_printed instead.

ida_hexrays.Hexrays_Hooks.unhook(self) -> bool

ida_hexrays.INLINE_DONTCOPY
    Do not reuse old inlined copy even if it exists.

ida_hexrays.INLINE_EXTFRAME
    Inlined function has its own (external) frame.

ida_hexrays.IPROP_ASSERT
    assertion: usually mov #val, op. assertions are used to help the optimizer. assertions are ignored when generating ctree 
            

ida_hexrays.IPROP_CLNPOP
    the purpose of the instruction is to clean stack (e.g. "pop ecx" is often used for that) 
            

ida_hexrays.IPROP_COMBINED
    insn has been modified because of a partial reference

ida_hexrays.IPROP_DONT_COMB
    may not combine this instruction with others

ida_hexrays.IPROP_DONT_PROP
    may not propagate

ida_hexrays.IPROP_EXTSTX
    this is m_ext propagated into m_stx

ida_hexrays.IPROP_FARCALL
    call of a far function using push cs/call sequence

ida_hexrays.IPROP_FPINSN
    floating point insn

ida_hexrays.IPROP_IGNLOWSRC
    low part of the instruction source operand has been created artificially (this bit is used only for 'and x, 80...') 
            

ida_hexrays.IPROP_INV_JX
    inverted conditional jump

ida_hexrays.IPROP_MBARRIER
    this instruction acts as a memory barrier (instructions accessing memory may not be reordered past it) 
            

ida_hexrays.IPROP_MULTI_MOV
    bits that can be set by plugins:
    
    the minsn was generated as part of insn that moves multiple registers (example: STM on ARM may transfer multiple registers) 
            

ida_hexrays.IPROP_OPTIONAL
    optional instruction

ida_hexrays.IPROP_PERSIST
    persistent insn; they are not destroyed

ida_hexrays.IPROP_SPLIT
    the instruction has been split:

ida_hexrays.IPROP_SPLIT1
    into 1 byte

ida_hexrays.IPROP_SPLIT2
    into 2 bytes

ida_hexrays.IPROP_SPLIT4
    into 4 bytes

ida_hexrays.IPROP_SPLIT8
    into 8 bytes

ida_hexrays.IPROP_TAILCALL
    tail call

ida_hexrays.IPROP_UNMERGED
    'goto' instruction was transformed info 'call'

ida_hexrays.IPROP_UNPAIRED
    instruction is a result of del_dest_pairs() transformation

ida_hexrays.IPROP_WAS_NORET
    was noret icall

ida_hexrays.IPROP_WILDMATCH
    match multiple insns

ida_hexrays.ITP_ARG1
    , (64 entries are reserved for 64 call arguments)

ida_hexrays.ITP_ASM
    __asm-line

ida_hexrays.ITP_BLOCK1
    opening block comment. this comment is printed before the item (other comments are indented and printed after the item) 
              

ida_hexrays.ITP_BLOCK2
    closing block comment.

ida_hexrays.ITP_BRACE2
    )

ida_hexrays.ITP_CASE
    bit for switch cases

ida_hexrays.ITP_COLON
    : (label)

ida_hexrays.ITP_CURLY1
    {

ida_hexrays.ITP_CURLY2
    }

ida_hexrays.ITP_DO
    do-line

ida_hexrays.ITP_ELSE
    else-line

ida_hexrays.ITP_EMPTY
    nothing

ida_hexrays.ITP_SEMI
    semicolon

ida_hexrays.ITP_SIGN
    if this bit is set too, then we have a negative case value

ida_hexrays.ITP_TRY
    C++ try statement.

ida_hexrays.LOCOPT_ALL
    redo optimization for all blocks. if this bit is not set, only dirty blocks will be optimized 
            

ida_hexrays.LOCOPT_REFINE
    refine return type, ok to fail

ida_hexrays.LOCOPT_REFINE2
    refine return type, try harder

ida_hexrays.LVINF_KEEP
    preserve saved user settings regardless of vars for example, if a var loses all its user-defined attributes or even gets destroyed, keep its lvar_saved_info_t. this is used for ephemeral variables that get destroyed by macro recognition. 
            

ida_hexrays.LVINF_NOMAP
    forbid automatic mapping of the variable

ida_hexrays.LVINF_NOPTR
    variable type should not be a pointer

ida_hexrays.LVINF_SPLIT
    split allocation of a new variable. forces the decompiler to create a new variable at ll.defea 
            

ida_hexrays.LVINF_UNUSED
    unused argument, corresponds to CVAR_UNUSED

ida_hexrays.MBA2_ARGIDX_OK
    may verify input argument list?

ida_hexrays.MBA2_ARGIDX_SORTED
    args finally sorted according to ABI (e.g. reverse stkarg order in Borland) 
            

ida_hexrays.MBA2_CODE16_BIT
    the code16 bit got removed

ida_hexrays.MBA2_DONT_VERIFY
    Do not verify microcode. This flag is recomended to be set only when debugging decompiler plugins 
            

ida_hexrays.MBA2_HAS_OUTLINES
    calls to outlined code have been inlined

ida_hexrays.MBA2_IS_CTR
    is constructor?

ida_hexrays.MBA2_IS_DTR
    is destructor?

ida_hexrays.MBA2_LVARNAMES_OK
    may verify lvar_names?

ida_hexrays.MBA2_LVARS_RENAMED
    accept empty names now?

ida_hexrays.MBA2_NO_DUP_CALLS
    forbid multiple calls with the same ea

ida_hexrays.MBA2_NO_DUP_LVARS
    forbid multiple lvars with the same ea

ida_hexrays.MBA2_NO_FRAME
    do not use function frame info (only snippet mode)

ida_hexrays.MBA2_OVER_CHAINS
    has overlapped chains?

ida_hexrays.MBA2_PROP_COMPLEX
    allow propagation of more complex variable definitions

ida_hexrays.MBA2_STACK_RETVAL
    the return value is on the stack

ida_hexrays.MBA2_UNDEF_RETVAR
    return value is undefined

ida_hexrays.MBA2_VALRNG_DONE
    calculated valranges?

ida_hexrays.MBA_ASRPROP
    assertion have been propagated

ida_hexrays.MBA_ASRTOK
    assertions have been generated

ida_hexrays.MBA_CALLS
    callinfo has been built

ida_hexrays.MBA_CHVARS
    can verify chain varnums

ida_hexrays.MBA_CMBBLK
    request to combine blocks

ida_hexrays.MBA_CMNSTK
    stkvars+stkargs should be considered as one area

ida_hexrays.MBA_COLGDL
    display graph after each reduction

ida_hexrays.MBA_DELPAIRS
    pairs have been deleted once

ida_hexrays.MBA_GLBOPT
    microcode has been optimized globally

ida_hexrays.MBA_INSGDL
    display instruction in graphs

ida_hexrays.MBA_LOADED
    loaded gdl, no instructions (debugging)

ida_hexrays.MBA_LVARS0
    lvar pre-allocation has been performed

ida_hexrays.MBA_LVARS1
    lvar real allocation has been performed

ida_hexrays.MBA_NICE
    apply transformations to c code

ida_hexrays.MBA_NOFUNC
    function is not present, addresses might be wrong

ida_hexrays.MBA_NUMADDR
    display definition addresses for numbers

ida_hexrays.MBA_PASSREGS
    has mcallinfo_t::pass_regs

ida_hexrays.MBA_PATTERN
    microcode pattern, callinfo is present

ida_hexrays.MBA_PRCDEFS
    use precise defeas for chain-allocated lvars

ida_hexrays.MBA_PREOPT
    preoptimization stage complete

ida_hexrays.MBA_REFINE
    may refine return value size

ida_hexrays.MBA_RETFP
    function returns floating point value

ida_hexrays.MBA_RETREF
    return type has been refined

ida_hexrays.MBA_SAVRST
    save-restore analysis has been performed

ida_hexrays.MBA_SHORT
    use short display

ida_hexrays.MBA_SPLINFO
    (final_type ? idb_spoiled : spoiled_regs) is valid

ida_hexrays.MBA_THUNK
    thunk function

ida_hexrays.MBA_VALNUM
    display value numbers

ida_hexrays.MBA_WINGR32
    use wingraph32

ida_hexrays.MBL_BACKPROP
    performed backprop_cc

ida_hexrays.MBL_CALL
    call information has been built

ida_hexrays.MBL_COMB
    needs "combine" pass

ida_hexrays.MBL_DEAD
    needs "eliminate deads" pass

ida_hexrays.MBL_DMT64
    needs "demote 64bits"

ida_hexrays.MBL_DSLOT
    block for delay slot

ida_hexrays.MBL_EXTFRAME
    an inlined block with an external frame

ida_hexrays.MBL_FAKE
    fake block

ida_hexrays.MBL_GOTO
    this block is a goto target

ida_hexrays.MBL_INCONST
    inconsistent lists: we are building them

ida_hexrays.MBL_INLINED
    block was inlined, not originally part of mbr

ida_hexrays.MBL_KEEP
    do not remove even if unreachable

ida_hexrays.MBL_LIST
    use/def lists are ready (not dirty)

ida_hexrays.MBL_NONFAKE
    regular block

ida_hexrays.MBL_NORET
    dead end block: doesn't return execution control

ida_hexrays.MBL_PRIV
    private block - no instructions except the specified are accepted (used in patterns) 
            

ida_hexrays.MBL_PROP
    needs 'propagation' pass

ida_hexrays.MBL_PUSH
    needs "convert push/pop instructions"

ida_hexrays.MBL_TCAL
    aritifical call block for tail calls

ida_hexrays.MBL_VALRANGES
    should optimize using value ranges

ida_hexrays.MERR_BADARCH
    current architecture is not supported

ida_hexrays.MERR_BADBLK
    bad block found

ida_hexrays.MERR_BADCALL
    could not determine call arguments

ida_hexrays.MERR_BADFRAME
    function frame is wrong

ida_hexrays.MERR_BADIDB
    inconsistent database information

ida_hexrays.MERR_BADRANGES
    bad input ranges

ida_hexrays.MERR_BADSP
    positive sp value has been found

ida_hexrays.MERR_BITNESS
    16-bit functions cannot be decompiled

ida_hexrays.MERR_BLOCK
    no error, switch to new block

ida_hexrays.MERR_BUSY
    already decompiling a function

ida_hexrays.MERR_CANCELED
    decompilation has been cancelled

ida_hexrays.MERR_CLOUD
    cloud: s

ida_hexrays.MERR_COMPLEX
    too complex function

ida_hexrays.MERR_DSLOT
    bad instruction in the delay slot

ida_hexrays.MERR_EXCEPTION
    exception analysis failed

ida_hexrays.MERR_EXTERN
    special segments cannot be decompiled

ida_hexrays.MERR_FARPTR
    far memory model is supported only for pc

ida_hexrays.MERR_FUNCSIZE
    too big function

ida_hexrays.MERR_HUGESTACK
    stack frame is too big

ida_hexrays.MERR_INSN
    cannot convert to microcode

ida_hexrays.MERR_INTERR
    internal error

ida_hexrays.MERR_LICENSE
    no license available

ida_hexrays.MERR_LOOP
    internal code: redo last loop (never reported)

ida_hexrays.MERR_LVARS
    local variable allocation failed

ida_hexrays.MERR_MEM
    not enough memory

ida_hexrays.MERR_OK
    ok

ida_hexrays.MERR_ONLY32
    only 32-bit functions can be decompiled for the current database

ida_hexrays.MERR_ONLY64
    only 64-bit functions can be decompiled for the current database

ida_hexrays.MERR_OVERLAP
    variables would overlap: s

ida_hexrays.MERR_PARTINIT
    partially initialized variable s

ida_hexrays.MERR_PROLOG
    prolog analysis failed

ida_hexrays.MERR_RECDEPTH
    max recursion depth reached during lvar allocation

ida_hexrays.MERR_REDO
    redecompilation has been requested

ida_hexrays.MERR_SIZEOF
    wrong basic type sizes in compiler settings

ida_hexrays.MERR_STOP
    no error, stop the analysis

ida_hexrays.MERR_SWITCH
    wrong switch idiom

ida_hexrays.MERR_UNKTYPE
    undefined type s (currently unused error code)

ida_hexrays.MLI_CLR_FLAGS
    clear LVINF_... bits

ida_hexrays.MLI_CMT
    apply lvar comment

ida_hexrays.MLI_NAME
    apply lvar name

ida_hexrays.MLI_SET_FLAGS
    set LVINF_... bits

ida_hexrays.MLI_TYPE
    apply lvar type

ida_hexrays.MMAT_CALLS
    detected call arguments. see also hxe_calls_done

ida_hexrays.MMAT_GENERATED
    generated microcode

ida_hexrays.MMAT_GLBOPT1
    performed the first pass of global optimization

ida_hexrays.MMAT_GLBOPT2
    most global optimization passes are done

ida_hexrays.MMAT_GLBOPT3
    completed all global optimization. microcode is fixed now.

ida_hexrays.MMAT_LOCOPT
    local optimization of each basic block is complete. control flow graph is ready too. 
              

ida_hexrays.MMAT_LVARS
    allocated local variables

ida_hexrays.MMAT_PREOPTIMIZED
    preoptimized pass is complete

ida_hexrays.MMAT_ZERO
    microcode does not exist

ida_hexrays.MMIDX_ARGS
    stack: regular stack arguments

ida_hexrays.MMIDX_GLBHIGH
    global memory: high part

ida_hexrays.MMIDX_GLBLOW
    global memory: low part

ida_hexrays.MMIDX_LVARS
    stack: local variables

ida_hexrays.MMIDX_RETADDR
    stack: return address

ida_hexrays.MMIDX_SHADOW
    stack: shadow arguments

ida_hexrays.NALT_VD
    this index is not used by ida

ida_hexrays.NF_BINVDONE
    temporary internal bit: inverting bits is done

ida_hexrays.NF_BITNOT
    The user asked to invert bits of the constant.

ida_hexrays.NF_FIXED
    number format has been defined by the user

ida_hexrays.NF_NEGATE
    The user asked to negate the constant.

ida_hexrays.NF_NEGDONE
    temporary internal bit: negation has been performed

ida_hexrays.NF_VALID
    internal bit: stroff or enum is valid for enums: this bit is set immediately for stroffs: this bit is set at the end of decompilation 
            

ida_hexrays.NOSIZE
    wrong or unexisting operand size

ida_hexrays.NO_CURLY_BRACES
    don't print curly braces

ida_hexrays.NO_SIDEFF
    change operand size but ignore side effects if you decide to keep the changed operand, handle_new_size() must be called 
              

ida_hexrays.ONLY_SIDEFF
    only handle side effects

ida_hexrays.OPF_NEW_WINDOW
    open new window

ida_hexrays.OPF_NO_WAIT
    do not display waitbox if decompilation happens

ida_hexrays.OPF_REUSE
    reuse existing window

ida_hexrays.OPF_REUSE_ACTIVE
    reuse existing window, only if the currently active widget is a pseudocode view 
            

ida_hexrays.OPROP_CCFLAGS
    mop_n: a pc-relative value mop_a: an address obtained from a relocation else: value of a condition code register (like mr_cc) 
            

ida_hexrays.OPROP_FLOAT
    possibly floating value

ida_hexrays.OPROP_IMPDONE
    imported operand (a pointer) has been dereferenced

ida_hexrays.OPROP_LOWADDR
    a low address offset

ida_hexrays.OPROP_UDEFVAL
    uses undefined value

ida_hexrays.OPROP_UDT
    a struct or union

ida_hexrays.OPTI_ADDREXPRS
    optimize all address expressions (&x+N; &x-&y)

ida_hexrays.OPTI_COMBINSNS
    may combine insns (only for optimize_insn)

ida_hexrays.OPTI_MINSTKREF
    may update minstkref

ida_hexrays.OPTI_NO_LDXOPT
    the function is called after the propagation attempt, we do not optimize low/high(ldx) in this case 
            

ida_hexrays.OPTI_NO_VALRNG
    forbid using valranges

ida_hexrays.RETRIEVE_ALWAYS
    Retrieve comment even if it has been used.

ida_hexrays.RETRIEVE_ONCE
    Retrieve comment if it has not been used yet.

ida_hexrays.ROLE_3WAYCMP0
    3-way compare helper, returns -1/0/1

ida_hexrays.ROLE_3WAYCMP1
    3-way compare helper, returns 0/1/2

ida_hexrays.ROLE_ABS
    integer absolute value

ida_hexrays.ROLE_ALLOCA
    alloca() function

ida_hexrays.ROLE_BITTEST
    [lock] bt

ida_hexrays.ROLE_BITTESTANDCOMPLEMENT
    [lock] btc

ida_hexrays.ROLE_BITTESTANDRESET
    [lock] btr

ida_hexrays.ROLE_BITTESTANDSET
    [lock] bts

ida_hexrays.ROLE_BSWAP
    bswap() function (any size)

ida_hexrays.ROLE_BUG
    BUG() helper macro: never returns, causes exception.

ida_hexrays.ROLE_CFSUB3
    carry flag after subtract with carry

ida_hexrays.ROLE_CONTAINING_RECORD
    CONTAINING_RECORD() macro.

ida_hexrays.ROLE_EMPTY
    empty, does not do anything (maybe spoils regs)

ida_hexrays.ROLE_FASTFAIL
    __fastfail()

ida_hexrays.ROLE_IS_MUL_OK
    is_mul_ok

ida_hexrays.ROLE_MEMCPY
    memcpy(void *dst, const void *src, size_t count);

ida_hexrays.ROLE_MEMSET
    memset(void *dst, uchar value, size_t count);

ida_hexrays.ROLE_MEMSET32
    memset32(void *dst, uint32 value, size_t count);

ida_hexrays.ROLE_MEMSET64
    memset64(void *dst, uint64 value, size_t count);

ida_hexrays.ROLE_OFSUB3
    overflow flag after subtract with carry

ida_hexrays.ROLE_PRESENT
    present() function (used in patterns)

ida_hexrays.ROLE_READFLAGS
    __readeflags, __readcallersflags

ida_hexrays.ROLE_ROL
    rotate left

ida_hexrays.ROLE_ROR
    rotate right

ida_hexrays.ROLE_SATURATED_MUL
    saturated_mul

ida_hexrays.ROLE_SSE_CMP4
    e.g. _mm_cmpgt_ss

ida_hexrays.ROLE_SSE_CMP8
    e.g. _mm_cmpgt_sd

ida_hexrays.ROLE_STRCAT
    strcat(char *dst, const char *src);

ida_hexrays.ROLE_STRCPY
    strcpy(char *dst, const char *src);

ida_hexrays.ROLE_STRLEN
    strlen(const char *src);

ida_hexrays.ROLE_TAIL
    char *tail(const char *str);

ida_hexrays.ROLE_UNK
    unknown function role

ida_hexrays.ROLE_VA_ARG
    va_arg() macro

ida_hexrays.ROLE_VA_COPY
    va_copy() function

ida_hexrays.ROLE_VA_END
    va_end() function

ida_hexrays.ROLE_VA_START
    va_start() function

ida_hexrays.ROLE_WCSCAT
    wchar_t *wcscat(wchar_t *dst, const wchar_t *src)

ida_hexrays.ROLE_WCSCPY
    wchar_t *wcscpy(wchar_t *dst, const wchar_t *src);

ida_hexrays.ROLE_WCSLEN
    size_t wcslen(const wchar_t *s)

ida_hexrays.ROLE_WMEMCPY
    wchar_t *wmemcpy(wchar_t *dst, const wchar_t *src, size_t n)

ida_hexrays.ROLE_WMEMSET
    wchar_t *wmemset(wchar_t *dst, wchar_t wc, size_t n)

ida_hexrays.SHINS_LDXEA
    display address of ldx expressions (not used)

ida_hexrays.SHINS_NUMADDR
    display definition addresses for numbers

ida_hexrays.SHINS_SHORT
    do not display use-def chains and other attrs

ida_hexrays.SHINS_VALNUM
    display value numbers

ida_hexrays.ULV_PRECISE_DEFEA
    Use precise defea's for lvar locations.

ida_hexrays.USE_CURLY_BRACES
    print curly braces without any checks

ida_hexrays.USE_KEYBOARD
    Keyboard.

ida_hexrays.USE_MOUSE
    Mouse.

ida_hexrays.VDI_EXPR
    c-tree item

ida_hexrays.VDI_FUNC
    the function itself (the very first line with the function prototype)

ida_hexrays.VDI_LVAR
    declaration of local variable

ida_hexrays.VDI_NONE
    undefined

ida_hexrays.VDI_TAIL
    cursor is at (beyond) the line end (commentable line)

ida_hexrays.VDRUN_APPEND
    Create a new file or append to existing file.

ida_hexrays.VDRUN_CMDLINE
    Called from ida's command line.

ida_hexrays.VDRUN_LUMINA
    Use lumina server.

ida_hexrays.VDRUN_MAYSTOP
    The user can cancel decompilation.

ida_hexrays.VDRUN_NEWFILE
    Create a new file or overwrite existing file.

ida_hexrays.VDRUN_ONLYNEW
    Fail if output file already exists.

ida_hexrays.VDRUN_SENDIDB
    Send problematic databases to hex-rays.com.

ida_hexrays.VDRUN_SILENT
    Silent decompilation.

ida_hexrays.VDRUN_STATS
    Print statistics into vd_stats.txt.

ida_hexrays.VDUI_VALID
    is valid?

ida_hexrays.VDUI_VISIBLE
    is visible?

ida_hexrays.VR_AT_END
    get value ranges after the instruction or at the block end, just after the last instruction (if M is nullptr) 
            

ida_hexrays.VR_AT_START
    get value ranges before the instruction or at the block start (if M is nullptr) 
            

ida_hexrays.VR_EXACT
    find exact match. if not set, the returned valrng size will be >= vivl.size 
            

ida_hexrays.WARN_ADDR_OUTARGS
    6 cannot handle address arithmetics in outgoing argument area of stack frame - unused

ida_hexrays.WARN_ARRAY_INARG
    21 array has been used for an input argument

ida_hexrays.WARN_BAD_CALL_SP
    38 bad sp value at call

ida_hexrays.WARN_BAD_FIELD_TYPE
    23 incorrect structure member type for s::s, ignored

ida_hexrays.WARN_BAD_INSN
    49 bad instruction

ida_hexrays.WARN_BAD_MAPDST
    48 too short map destination 's' for variable 's'

ida_hexrays.WARN_BAD_PURGED
    12 inconsistent function type and number of purged bytes

ida_hexrays.WARN_BAD_RETVAR
    25 wrong return variable

ida_hexrays.WARN_BAD_SHADOW
    45 ignored the value written to the shadow area of the succeeding call

ida_hexrays.WARN_BAD_SP
    40 positive sp value a has been found

ida_hexrays.WARN_BAD_STD_TYPE
    37 corrupted or unexisting local type 's'

ida_hexrays.WARN_BAD_STKPNT
    41 wrong sp change point

ida_hexrays.WARN_BAD_STROFF
    33 user specified stroff has not been processed: s

ida_hexrays.WARN_BAD_VALRNG
    44 values range analysis failed

ida_hexrays.WARN_BAD_VARSIZE
    34 inconsistent variable size for 's'

ida_hexrays.WARN_CBUILD_LOOPS
    13 too many cbuild loops

ida_hexrays.WARN_CR_BADOFF
    32 CONTAINING_RECORD: too small offset d for struct 's'

ida_hexrays.WARN_CR_NOFIELD
    31 CONTAINING_RECORD: no field 's' in struct 's' at d

ida_hexrays.WARN_DEP_UNK_CALLS
    7 found interdependent unknown calls

ida_hexrays.WARN_EXP_LINVAR
    10 failed to expand a linear variable

ida_hexrays.WARN_FIXED_INSN
    29 fixed broken insn

ida_hexrays.WARN_FRAG_LVAR
    26 fragmented variable at s may be wrong

ida_hexrays.WARN_GUESSED_TYPE
    9 using guessed type s;

ida_hexrays.WARN_HUGE_STKOFF
    27 exceedingly huge offset into the stack frame

ida_hexrays.WARN_ILL_ELLIPSIS
    8 erroneously detected ellipsis type has been ignored

ida_hexrays.WARN_ILL_FPU_STACK
    18 inconsistent fpu stack

ida_hexrays.WARN_ILL_FUNCTYPE
    2 invalid function type 's' has been ignored

ida_hexrays.WARN_ILL_PURGED
    1 odd caller purged bytes d, correcting

ida_hexrays.WARN_JUMPOUT
    43 control flows out of bounds

ida_hexrays.WARN_MAX
    may be used in notes as a placeholder when the warning id is not available 
              

ida_hexrays.WARN_MAX_ARGS
    22 too many input arguments, some ignored

ida_hexrays.WARN_MISSED_SWITCH
    39 wrong markup of switch jump, skipped it

ida_hexrays.WARN_MUST_RET_FP
    17 function return type is incorrect (must be floating point)

ida_hexrays.WARN_NO_SAVE_REST
    14 could not find valid save-restore pair for s

ida_hexrays.WARN_ODD_ABI
    50 encountered odd instruction for the current ABI

ida_hexrays.WARN_ODD_ADDR_USE
    16 odd use of a variable address

ida_hexrays.WARN_ODD_INPUT_REG
    15 odd input register s

ida_hexrays.WARN_OPT_USELESS_JCND
    54 simplified comparisons for 's': s became s

ida_hexrays.WARN_OPT_VALRNG
    46 conditional instruction was optimized away because s

ida_hexrays.WARN_OPT_VALRNG2
    52 mask 0xX is shortened because s <= 0xX"

ida_hexrays.WARN_OPT_VALRNG3
    53 masking with 0XX was optimized away because s <= 0xX

ida_hexrays.WARN_RET_LOCREF
    47 returning address of temporary local variable 's'

ida_hexrays.WARN_SELFREF_PROP
    19 self-referencing variable has been detected

ida_hexrays.WARN_SUBFRAME_OVERFLOW
    55 call arguments overflow the function chunk frame

ida_hexrays.WARN_UNALIGNED_ARG
    36 unaligned function argument 's'

ida_hexrays.WARN_UNBALANCED_STACK
    51 unbalanced stack, ignored a potential tail call

ida_hexrays.WARN_UNDEF_LVAR
    42 variable 's' is possibly undefined

ida_hexrays.WARN_UNINITED_REG
    28 reference to an uninitialized register has been removed: s

ida_hexrays.WARN_UNSUPP_REG
    35 unsupported processor register 's'

ida_hexrays.WARN_VARARG_MANY
    5 too many varargs, some ignored

ida_hexrays.WARN_VARARG_NOSTK
    4 call vararg without local stack

ida_hexrays.WARN_VARARG_REGS
    0 cannot handle register arguments in vararg function, discarded them

ida_hexrays.WARN_VARARG_TCAL
    3 cannot handle tail call to vararg

ida_hexrays.WARN_WIDEN_CHAINS
    11 failed to widen chains

ida_hexrays.WARN_WOULD_OVERLAP
    20 variables would overlap: s

ida_hexrays.WARN_WRITE_CONST
    24 write access to const memory at a has been detected

ida_hexrays.WARN_WRONG_VA_OFF
    30 wrong offset of va_list variable

ida_hexrays.WITH_SIDEFF
    change operand size and handle side effects

ida_hexrays.__cbhooks_t

ida_hexrays.__cbhooks_t.__init__(self, callback)

ida_hexrays.__cbhooks_t.close_pseudocode(self, *args)
    Close pseudocode window. 
            
    @param f: pointer to window
    @returns false if failed

ida_hexrays.__cbhooks_t.create_hint(self, *args)

ida_hexrays.__cbhooks_t.curpos(self, *args)

ida_hexrays.__cbhooks_t.double_click(self, *args)

ida_hexrays.__cbhooks_t.func_printed(self, *args)

ida_hexrays.__cbhooks_t.interr(self, *args)

ida_hexrays.__cbhooks_t.keyboard(self, *args)

ida_hexrays.__cbhooks_t.maturity(self, *args)

ida_hexrays.__cbhooks_t.open_pseudocode(self, *args)
    Open pseudocode window. The specified function is decompiled and the pseudocode window is opened. 
            
    @param ea: function to decompile
    @param flags: a combination of OPF_ flags
    @returns false if failed

ida_hexrays.__cbhooks_t.populating_popup(self, *args)

ida_hexrays.__cbhooks_t.print_func(self, *args)

ida_hexrays.__cbhooks_t.refresh_pseudocode(self, *args)

ida_hexrays.__cbhooks_t.right_click(self, *args)

ida_hexrays.__cbhooks_t.switch_pseudocode(self, *args)

ida_hexrays.__cbhooks_t.text_ready(self, *args)

ida_hexrays._call_with_transferrable_ownership(fun, *args)

ida_hexrays._kludge_force_declare_TPopupMenu(arg1: "TPopupMenu const *") -> None

ida_hexrays._ll_call_helper(*args) -> "cexpr_t *"

ida_hexrays._ll_create_helper(*args) -> "cexpr_t *"

ida_hexrays._ll_dereference(e: "cexpr_t", ptrsize: int, is_flt: bool = False) -> "cexpr_t *"

ida_hexrays._ll_lnot(e: "cexpr_t") -> "cexpr_t *"

ida_hexrays._ll_make_num(*args) -> "cexpr_t *"

ida_hexrays._ll_make_ref(e: "cexpr_t") -> "cexpr_t *"

ida_hexrays._ll_new_block() -> "cinsn_t *"

ida_hexrays._map_as_dict(maptype, name, keytype, valuetype)

ida_hexrays._map_as_dict._map___contains__(self, key)
    Returns true if the specified key exists in the . 

ida_hexrays._map_as_dict._map___delitem__(self, key)
    Removes the value associated with the provided key. 

ida_hexrays._map_as_dict._map___getitem__(self, key)
    Returns the value associated with the provided key. 

ida_hexrays._map_as_dict._map___iter__(self)
    Iterate over dictionary keys. 

ida_hexrays._map_as_dict._map___setitem__(self, key, value)
    Returns the value associated with the provided key. 

ida_hexrays._map_as_dict._map_clear(self)

ida_hexrays._map_as_dict._map_copy(self)

ida_hexrays._map_as_dict._map_get(self, key, default = None)

ida_hexrays._map_as_dict._map_has_key(self, key)

ida_hexrays._map_as_dict._map_items(self)

ida_hexrays._map_as_dict._map_iteritems(self)

ida_hexrays._map_as_dict._map_iterkeys(self)

ida_hexrays._map_as_dict._map_itervalues(self)

ida_hexrays._map_as_dict._map_keys(self)

ida_hexrays._map_as_dict._map_pop(self, key)
    Sets the value associated with the provided key. 

ida_hexrays._map_as_dict._map_popitem(self)
    Sets the value associated with the provided key. 

ida_hexrays._map_as_dict._map_setdefault(self, key, default = None)
    Sets the value associated with the provided key. 

ida_hexrays._map_as_dict._map_values(self)

ida_hexrays.accepts_small_udts(op: "ctype_t") -> bool
    Is the operator allowed on small structure or union?

ida_hexrays.accepts_udts(op: "ctype_t") -> bool

ida_hexrays.arglocs_overlap(loc1: "vdloc_t", w1: "size_t", loc2: "vdloc_t", w2: "size_t") -> bool
    Do two arglocs overlap?

ida_hexrays.array_of_bitsets

ida_hexrays.array_of_bitsets.__eq__(self, r: "array_of_bitsets") -> bool

ida_hexrays.array_of_bitsets.__getitem__(self, i: "size_t") -> "bitset_t const &"

ida_hexrays.array_of_bitsets.__init__(self, *args)

ida_hexrays.array_of_bitsets.__len__(self) -> "size_t"

ida_hexrays.array_of_bitsets.__ne__(self, r: "array_of_bitsets") -> bool

ida_hexrays.array_of_bitsets.__setitem__(self, i: "size_t", v: "bitset_t") -> None

ida_hexrays.array_of_bitsets._del(self, x: "bitset_t") -> bool

ida_hexrays.array_of_bitsets.add_unique(self, x: "bitset_t") -> bool

ida_hexrays.array_of_bitsets.append(self, x: "bitset_t") -> None

ida_hexrays.array_of_bitsets.at(self, _idx: "size_t") -> "bitset_t const &"

ida_hexrays.array_of_bitsets.begin(self, *args) -> "qvector< bitset_t >::const_iterator"

ida_hexrays.array_of_bitsets.capacity(self) -> "size_t"

ida_hexrays.array_of_bitsets.clear(self) -> None

ida_hexrays.array_of_bitsets.empty(self) -> bool

ida_hexrays.array_of_bitsets.end(self, *args) -> "qvector< bitset_t >::const_iterator"

ida_hexrays.array_of_bitsets.erase(self, *args) -> "qvector< bitset_t >::iterator"

ida_hexrays.array_of_bitsets.extend(self, x: "array_of_bitsets") -> None

ida_hexrays.array_of_bitsets.extract(self) -> "bitset_t *"

ida_hexrays.array_of_bitsets.find(self, *args) -> "qvector< bitset_t >::const_iterator"

ida_hexrays.array_of_bitsets.grow(self, *args) -> None

ida_hexrays.array_of_bitsets.has(self, x: "bitset_t") -> bool

ida_hexrays.array_of_bitsets.inject(self, s: "bitset_t", len: "size_t") -> None

ida_hexrays.array_of_bitsets.insert(self, it: "bitset_t", x: "bitset_t") -> "qvector< bitset_t >::iterator"

ida_hexrays.array_of_bitsets.pop_back(self) -> None

ida_hexrays.array_of_bitsets.push_back(self, *args) -> "bitset_t &"

ida_hexrays.array_of_bitsets.qclear(self) -> None

ida_hexrays.array_of_bitsets.reserve(self, cnt: "size_t") -> None

ida_hexrays.array_of_bitsets.resize(self, *args) -> None

ida_hexrays.array_of_bitsets.size(self) -> "size_t"

ida_hexrays.array_of_bitsets.swap(self, r: "array_of_bitsets") -> None

ida_hexrays.array_of_bitsets.truncate(self) -> None

ida_hexrays.array_of_ivlsets

ida_hexrays.array_of_ivlsets.__eq__(self, r: "array_of_ivlsets") -> bool

ida_hexrays.array_of_ivlsets.__getitem__(self, i: "size_t") -> "ivlset_t const &"

ida_hexrays.array_of_ivlsets.__init__(self, *args)

ida_hexrays.array_of_ivlsets.__len__(self) -> "size_t"

ida_hexrays.array_of_ivlsets.__ne__(self, r: "array_of_ivlsets") -> bool

ida_hexrays.array_of_ivlsets.__setitem__(self, i: "size_t", v: "ivlset_t") -> None

ida_hexrays.array_of_ivlsets._del(self, x: "ivlset_t") -> bool

ida_hexrays.array_of_ivlsets.add_unique(self, x: "ivlset_t") -> bool

ida_hexrays.array_of_ivlsets.append(self, x: "ivlset_t") -> None

ida_hexrays.array_of_ivlsets.at(self, _idx: "size_t") -> "ivlset_t const &"

ida_hexrays.array_of_ivlsets.begin(self, *args) -> "qvector< ivlset_t >::const_iterator"

ida_hexrays.array_of_ivlsets.capacity(self) -> "size_t"

ida_hexrays.array_of_ivlsets.clear(self) -> None

ida_hexrays.array_of_ivlsets.empty(self) -> bool

ida_hexrays.array_of_ivlsets.end(self, *args) -> "qvector< ivlset_t >::const_iterator"

ida_hexrays.array_of_ivlsets.erase(self, *args) -> "qvector< ivlset_t >::iterator"

ida_hexrays.array_of_ivlsets.extend(self, x: "array_of_ivlsets") -> None

ida_hexrays.array_of_ivlsets.extract(self) -> "ivlset_t *"

ida_hexrays.array_of_ivlsets.find(self, *args) -> "qvector< ivlset_t >::const_iterator"

ida_hexrays.array_of_ivlsets.grow(self, *args) -> None

ida_hexrays.array_of_ivlsets.has(self, x: "ivlset_t") -> bool

ida_hexrays.array_of_ivlsets.inject(self, s: "ivlset_t", len: "size_t") -> None

ida_hexrays.array_of_ivlsets.insert(self, it: "ivlset_t", x: "ivlset_t") -> "qvector< ivlset_t >::iterator"

ida_hexrays.array_of_ivlsets.pop_back(self) -> None

ida_hexrays.array_of_ivlsets.push_back(self, *args) -> "ivlset_t &"

ida_hexrays.array_of_ivlsets.qclear(self) -> None

ida_hexrays.array_of_ivlsets.reserve(self, cnt: "size_t") -> None

ida_hexrays.array_of_ivlsets.resize(self, *args) -> None

ida_hexrays.array_of_ivlsets.size(self) -> "size_t"

ida_hexrays.array_of_ivlsets.swap(self, r: "array_of_ivlsets") -> None

ida_hexrays.array_of_ivlsets.truncate(self) -> None

ida_hexrays.array_of_node_bitset_t

ida_hexrays.array_of_node_bitset_t.__init__(self)

ida_hexrays.asgop(cop: "ctype_t") -> "ctype_t"
    Convert plain operator into assignment operator. For example, cot_add returns cot_asgadd.

ida_hexrays.asgop_revert(cop: "ctype_t") -> "ctype_t"
    Convert assignment operator into plain operator. For example, cot_asgadd returns cot_add 
            
    @returns cot_empty is the input operator is not an assignment operator.

ida_hexrays.bit_bound_t

ida_hexrays.bit_bound_t.__init__(self, n: int = 0, s: int = 0)

ida_hexrays.bitset_t

ida_hexrays.bitset_t.__eq__(self, r: "bitset_t") -> bool

ida_hexrays.bitset_t.__ge__(self, r: "bitset_t") -> bool

ida_hexrays.bitset_t.__gt__(self, r: "bitset_t") -> bool

ida_hexrays.bitset_t.__init__(self, *args)

ida_hexrays.bitset_t.__iter__(self)

ida_hexrays.bitset_t.__le__(self, r: "bitset_t") -> bool

ida_hexrays.bitset_t.__lt__(self, r: "bitset_t") -> bool

ida_hexrays.bitset_t.__ne__(self, r: "bitset_t") -> bool

ida_hexrays.bitset_t.add(self, *args) -> bool
    This function has the following signatures:
    
        0. add(bit: int) -> bool
        1. add(bit: int, width: int) -> bool
        2. add(ml: const bitset_t &) -> bool
    
    # 0: add(bit: int) -> bool
    
    
    # 1: add(bit: int, width: int) -> bool
    
    
    # 2: add(ml: const bitset_t &) -> bool

ida_hexrays.bitset_t.back(self) -> int

ida_hexrays.bitset_t.begin(self) -> "bitset_t::iterator"

ida_hexrays.bitset_t.clear(self) -> None

ida_hexrays.bitset_t.compare(self, r: "bitset_t") -> int

ida_hexrays.bitset_t.copy(self, m: "bitset_t") -> "bitset_t &"

ida_hexrays.bitset_t.count(self, *args) -> int
    This function has the following signatures:
    
        0. count() -> int
        1. count(bit: int) -> int
    
    # 0: count() -> int
    
    
    # 1: count(bit: int) -> int

ida_hexrays.bitset_t.cut_at(self, maxbit: int) -> bool

ida_hexrays.bitset_t.dstr(self) -> str

ida_hexrays.bitset_t.empty(self) -> bool

ida_hexrays.bitset_t.end(self) -> "bitset_t::iterator"

ida_hexrays.bitset_t.fill_with_ones(self, maxbit: int) -> None

ida_hexrays.bitset_t.front(self) -> int

ida_hexrays.bitset_t.has(self, bit: int) -> bool

ida_hexrays.bitset_t.has_all(self, bit: int, width: int) -> bool

ida_hexrays.bitset_t.has_any(self, bit: int, width: int) -> bool

ida_hexrays.bitset_t.has_common(self, ml: "bitset_t") -> bool

ida_hexrays.bitset_t.inc(self, p: "iterator", n: int = 1) -> None

ida_hexrays.bitset_t.includes(self, ml: "bitset_t") -> bool

ida_hexrays.bitset_t.intersect(self, ml: "bitset_t") -> bool

ida_hexrays.bitset_t.is_subset_of(self, ml: "bitset_t") -> bool

ida_hexrays.bitset_t.itat(self, n: int) -> "bitset_t::iterator"

ida_hexrays.bitset_t.itv(self, it: "iterator") -> int

ida_hexrays.bitset_t.last(self) -> int

ida_hexrays.bitset_t.shift_down(self, shift: int) -> None

ida_hexrays.bitset_t.sub(self, *args) -> bool
    This function has the following signatures:
    
        0. sub(bit: int) -> bool
        1. sub(bit: int, width: int) -> bool
        2. sub(ml: const bitset_t &) -> bool
    
    # 0: sub(bit: int) -> bool
    
    
    # 1: sub(bit: int, width: int) -> bool
    
    
    # 2: sub(ml: const bitset_t &) -> bool

ida_hexrays.bitset_t.swap(self, r: "bitset_t") -> None

ida_hexrays.block_chains_begin(set: "block_chains_t") -> "block_chains_iterator_t"
    Get iterator pointing to the beginning of block_chains_t.

ida_hexrays.block_chains_clear(set: "block_chains_t") -> None
    Clear block_chains_t.

ida_hexrays.block_chains_end(set: "block_chains_t") -> "block_chains_iterator_t"
    Get iterator pointing to the end of block_chains_t.

ida_hexrays.block_chains_erase(set: "block_chains_t", p: "block_chains_iterator_t") -> None
    Erase current element from block_chains_t.

ida_hexrays.block_chains_find(set: "block_chains_t", val: "chain_t") -> "block_chains_iterator_t"
    Find the specified key in set block_chains_t.

ida_hexrays.block_chains_free(set: "block_chains_t") -> None
    Delete block_chains_t instance.

ida_hexrays.block_chains_get(p: "block_chains_iterator_t") -> "chain_t &"
    Get reference to the current set value.

ida_hexrays.block_chains_insert(set: "block_chains_t", val: "chain_t") -> "block_chains_iterator_t"
    Insert new (chain_t) into set block_chains_t.

ida_hexrays.block_chains_iterator_t

ida_hexrays.block_chains_iterator_t.__eq__(self, p: "block_chains_iterator_t") -> bool

ida_hexrays.block_chains_iterator_t.__init__(self)

ida_hexrays.block_chains_iterator_t.__ne__(self, p: "block_chains_iterator_t") -> bool

ida_hexrays.block_chains_new() -> "block_chains_t *"
    Create a new block_chains_t instance.

ida_hexrays.block_chains_next(p: "block_chains_iterator_t") -> "block_chains_iterator_t"
    Move to the next element.

ida_hexrays.block_chains_prev(p: "block_chains_iterator_t") -> "block_chains_iterator_t"
    Move to the previous element.

ida_hexrays.block_chains_size(set: "block_chains_t") -> "size_t"
    Get size of block_chains_t.

ida_hexrays.block_chains_t

ida_hexrays.block_chains_t.__init__(self)

ida_hexrays.block_chains_t._print(self) -> None

ida_hexrays.block_chains_t.dstr(self) -> str

ida_hexrays.block_chains_t.get_chain(self, *args) -> "chain_t *"
    This function has the following signatures:
    
        0. get_chain(k: const voff_t &, width: int=1) -> const chain_t *
        1. get_chain(k: const voff_t &, width: int=1) -> chain_t *
        2. get_chain(ch: const chain_t &) -> const chain_t *
        3. get_chain(ch: const chain_t &) -> chain_t *
    
    # 0: get_chain(k: const voff_t &, width: int=1) -> const chain_t *
    
    Get chain for the specified value offset. 
            
    
    # 1: get_chain(k: const voff_t &, width: int=1) -> chain_t *
    
    
    # 2: get_chain(ch: const chain_t &) -> const chain_t *
    
    Get chain similar to the specified chain 
            
    
    # 3: get_chain(ch: const chain_t &) -> chain_t *

ida_hexrays.block_chains_t.get_reg_chain(self, reg: "mreg_t", width: int = 1) -> "chain_t *"
    Get chain for the specified register 
            
    @param reg: register number
    @param width: size of register in bytes

ida_hexrays.block_chains_t.get_stk_chain(self, off: int, width: int = 1) -> "chain_t *"
    Get chain for the specified stack offset 
            
    @param off: stack offset
    @param width: size of stack value in bytes

ida_hexrays.block_chains_vec_t

ida_hexrays.block_chains_vec_t.__getitem__(self, i: "size_t") -> "block_chains_t const &"

ida_hexrays.block_chains_vec_t.__init__(self, *args)

ida_hexrays.block_chains_vec_t.__len__(self) -> "size_t"

ida_hexrays.block_chains_vec_t.__setitem__(self, i: "size_t", v: "block_chains_t") -> None

ida_hexrays.block_chains_vec_t.append(self, x: "block_chains_t") -> None

ida_hexrays.block_chains_vec_t.at(self, _idx: "size_t") -> "block_chains_t const &"

ida_hexrays.block_chains_vec_t.begin(self, *args) -> "qvector< block_chains_t >::const_iterator"

ida_hexrays.block_chains_vec_t.capacity(self) -> "size_t"

ida_hexrays.block_chains_vec_t.clear(self) -> None

ida_hexrays.block_chains_vec_t.empty(self) -> bool

ida_hexrays.block_chains_vec_t.end(self, *args) -> "qvector< block_chains_t >::const_iterator"

ida_hexrays.block_chains_vec_t.erase(self, *args) -> "qvector< block_chains_t >::iterator"

ida_hexrays.block_chains_vec_t.extend(self, x: "block_chains_vec_t") -> None

ida_hexrays.block_chains_vec_t.extract(self) -> "block_chains_t *"

ida_hexrays.block_chains_vec_t.grow(self, *args) -> None

ida_hexrays.block_chains_vec_t.inject(self, s: "block_chains_t", len: "size_t") -> None

ida_hexrays.block_chains_vec_t.insert(self, it: "block_chains_t", x: "block_chains_t") -> "qvector< block_chains_t >::iterator"

ida_hexrays.block_chains_vec_t.pop_back(self) -> None

ida_hexrays.block_chains_vec_t.push_back(self, *args) -> "block_chains_t &"

ida_hexrays.block_chains_vec_t.qclear(self) -> None

ida_hexrays.block_chains_vec_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.block_chains_vec_t.resize(self, *args) -> None

ida_hexrays.block_chains_vec_t.size(self) -> "size_t"

ida_hexrays.block_chains_vec_t.swap(self, r: "block_chains_vec_t") -> None

ida_hexrays.block_chains_vec_t.truncate(self) -> None

ida_hexrays.boundaries_begin(map: "boundaries_t") -> "boundaries_iterator_t"
    Get iterator pointing to the beginning of boundaries_t.

ida_hexrays.boundaries_clear(map: "boundaries_t") -> None
    Clear boundaries_t.

ida_hexrays.boundaries_end(map: "boundaries_t") -> "boundaries_iterator_t"
    Get iterator pointing to the end of boundaries_t.

ida_hexrays.boundaries_erase(map: "boundaries_t", p: "boundaries_iterator_t") -> None
    Erase current element from boundaries_t.

ida_hexrays.boundaries_find(map: "boundaries_t", key: "cinsn_t") -> "boundaries_iterator_t"
    Find the specified key in boundaries_t.

ida_hexrays.boundaries_first(p: "boundaries_iterator_t") -> "cinsn_t *const &"
    Get reference to the current map key.

ida_hexrays.boundaries_free(map: "boundaries_t") -> None
    Delete boundaries_t instance.

ida_hexrays.boundaries_insert(map: "boundaries_t", key: "cinsn_t", val: "rangeset_t") -> "boundaries_iterator_t"
    Insert new (cinsn_t *, rangeset_t) pair into boundaries_t.

ida_hexrays.boundaries_iterator_t

ida_hexrays.boundaries_iterator_t.__eq__(self, p: "boundaries_iterator_t") -> bool

ida_hexrays.boundaries_iterator_t.__init__(self)

ida_hexrays.boundaries_iterator_t.__ne__(self, p: "boundaries_iterator_t") -> bool

ida_hexrays.boundaries_new() -> "boundaries_t *"
    Create a new boundaries_t instance.

ida_hexrays.boundaries_next(p: "boundaries_iterator_t") -> "boundaries_iterator_t"
    Move to the next element.

ida_hexrays.boundaries_prev(p: "boundaries_iterator_t") -> "boundaries_iterator_t"
    Move to the previous element.

ida_hexrays.boundaries_second(p: "boundaries_iterator_t") -> "rangeset_t &"
    Get reference to the current map value.

ida_hexrays.boundaries_size(map: "boundaries_t") -> "size_t"
    Get size of boundaries_t.

ida_hexrays.boundaries_t

ida_hexrays.boundaries_t.__init__(self)

ida_hexrays.boundaries_t.at(self, _Keyval: "cinsn_t") -> "rangeset_t &"

ida_hexrays.boundaries_t.size(self) -> "size_t"

ida_hexrays.call_helper(rettype, args, *rest)
    Create a helper call.

ida_hexrays.carg_t

ida_hexrays.carg_t.__eq__(self, r: "carg_t") -> bool

ida_hexrays.carg_t.__ge__(self, r: "carg_t") -> bool

ida_hexrays.carg_t.__gt__(self, r: "carg_t") -> bool

ida_hexrays.carg_t.__init__(self)

ida_hexrays.carg_t.__le__(self, r: "carg_t") -> bool

ida_hexrays.carg_t.__lt__(self, r: "carg_t") -> bool

ida_hexrays.carg_t.__ne__(self, r: "carg_t") -> bool

ida_hexrays.carg_t.compare(self, r: "carg_t") -> int

ida_hexrays.carg_t.consume_cexpr(self, e: "cexpr_t") -> None

ida_hexrays.carg_t.formal_type
    formal parameter type (if known)

ida_hexrays.carg_t.is_vararg
    is a vararg (matches ...)

ida_hexrays.carglist_t

ida_hexrays.carglist_t.__eq__(self, r: "carglist_t") -> bool

ida_hexrays.carglist_t.__ge__(self, r: "carglist_t") -> bool

ida_hexrays.carglist_t.__gt__(self, r: "carglist_t") -> bool

ida_hexrays.carglist_t.__init__(self, *args)

ida_hexrays.carglist_t.__le__(self, r: "carglist_t") -> bool

ida_hexrays.carglist_t.__lt__(self, r: "carglist_t") -> bool

ida_hexrays.carglist_t.__ne__(self, r: "carglist_t") -> bool

ida_hexrays.carglist_t.compare(self, r: "carglist_t") -> int

ida_hexrays.carglist_t.flags
    call flags

ida_hexrays.carglist_t.functype
    function object type

ida_hexrays.casm_t

ida_hexrays.casm_t.__eq__(self, r: "casm_t") -> bool

ida_hexrays.casm_t.__ge__(self, r: "casm_t") -> bool

ida_hexrays.casm_t.__gt__(self, r: "casm_t") -> bool

ida_hexrays.casm_t.__init__(self, *args)

ida_hexrays.casm_t.__le__(self, r: "casm_t") -> bool

ida_hexrays.casm_t.__lt__(self, r: "casm_t") -> bool

ida_hexrays.casm_t.__ne__(self, r: "casm_t") -> bool

ida_hexrays.casm_t.compare(self, r: "casm_t") -> int

ida_hexrays.casm_t.one_insn(self) -> bool

ida_hexrays.catchexpr_t

ida_hexrays.catchexpr_t.__eq__(self, r: "catchexpr_t") -> bool

ida_hexrays.catchexpr_t.__ge__(self, r: "catchexpr_t") -> bool

ida_hexrays.catchexpr_t.__gt__(self, r: "catchexpr_t") -> bool

ida_hexrays.catchexpr_t.__init__(self)

ida_hexrays.catchexpr_t.__le__(self, r: "catchexpr_t") -> bool

ida_hexrays.catchexpr_t.__lt__(self, r: "catchexpr_t") -> bool

ida_hexrays.catchexpr_t.__ne__(self, r: "catchexpr_t") -> bool

ida_hexrays.catchexpr_t.compare(self, r: "catchexpr_t") -> int

ida_hexrays.catchexpr_t.fake_type
    if not empty, type of the caught object. ideally, obj.type should be enough. however, in some cases the detailed type info is not available. 
            

ida_hexrays.catchexpr_t.is_catch_all(self) -> bool

ida_hexrays.catchexpr_t.obj
    the caught object. if obj.op==cot_empty, no object. ideally, obj.op==cot_var 
            

ida_hexrays.catchexpr_t.swap(self, r: "catchexpr_t") -> None

ida_hexrays.cblock_pos_t

ida_hexrays.cblock_pos_t.__init__(self)

ida_hexrays.cblock_pos_t.insn(self) -> "cinsn_t *"

ida_hexrays.cblock_pos_t.is_first_insn(self) -> bool

ida_hexrays.cblock_pos_t.prev_insn(self) -> "cinsn_t *"

ida_hexrays.cblock_posvec_t

ida_hexrays.cblock_posvec_t.__getitem__(self, i: "size_t") -> "cblock_pos_t const &"

ida_hexrays.cblock_posvec_t.__init__(self, *args)

ida_hexrays.cblock_posvec_t.__len__(self) -> "size_t"

ida_hexrays.cblock_posvec_t.__setitem__(self, i: "size_t", v: "cblock_pos_t") -> None

ida_hexrays.cblock_posvec_t.append(self, x: "cblock_pos_t") -> None

ida_hexrays.cblock_posvec_t.at(self, _idx: "size_t") -> "cblock_pos_t const &"

ida_hexrays.cblock_posvec_t.begin(self, *args) -> "qvector< cblock_pos_t >::const_iterator"

ida_hexrays.cblock_posvec_t.capacity(self) -> "size_t"

ida_hexrays.cblock_posvec_t.clear(self) -> None

ida_hexrays.cblock_posvec_t.empty(self) -> bool

ida_hexrays.cblock_posvec_t.end(self, *args) -> "qvector< cblock_pos_t >::const_iterator"

ida_hexrays.cblock_posvec_t.erase(self, *args) -> "qvector< cblock_pos_t >::iterator"

ida_hexrays.cblock_posvec_t.extend(self, x: "cblock_posvec_t") -> None

ida_hexrays.cblock_posvec_t.extract(self) -> "cblock_pos_t *"

ida_hexrays.cblock_posvec_t.grow(self, *args) -> None

ida_hexrays.cblock_posvec_t.inject(self, s: "cblock_pos_t", len: "size_t") -> None

ida_hexrays.cblock_posvec_t.insert(self, it: "cblock_pos_t", x: "cblock_pos_t") -> "qvector< cblock_pos_t >::iterator"

ida_hexrays.cblock_posvec_t.pop_back(self) -> None

ida_hexrays.cblock_posvec_t.push_back(self, *args) -> "cblock_pos_t &"

ida_hexrays.cblock_posvec_t.qclear(self) -> None

ida_hexrays.cblock_posvec_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.cblock_posvec_t.resize(self, *args) -> None

ida_hexrays.cblock_posvec_t.size(self) -> "size_t"

ida_hexrays.cblock_posvec_t.swap(self, r: "cblock_posvec_t") -> None

ida_hexrays.cblock_posvec_t.truncate(self) -> None

ida_hexrays.cblock_t

ida_hexrays.cblock_t.__eq__(self, r: "cblock_t") -> bool

ida_hexrays.cblock_t.__ge__(self, r: "cblock_t") -> bool

ida_hexrays.cblock_t.__gt__(self, r: "cblock_t") -> bool

ida_hexrays.cblock_t.__init__(self)

ida_hexrays.cblock_t.__le__(self, r: "cblock_t") -> bool

ida_hexrays.cblock_t.__lt__(self, r: "cblock_t") -> bool

ida_hexrays.cblock_t.__ne__(self, r: "cblock_t") -> bool

ida_hexrays.cblock_t._deregister(self) -> None

ida_hexrays.cblock_t.compare(self, r: "cblock_t") -> int

ida_hexrays.ccase_t

ida_hexrays.ccase_t.__eq__(self, r: "ccase_t") -> bool

ida_hexrays.ccase_t.__ge__(self, r: "ccase_t") -> bool

ida_hexrays.ccase_t.__gt__(self, r: "ccase_t") -> bool

ida_hexrays.ccase_t.__init__(self)

ida_hexrays.ccase_t.__le__(self, r: "ccase_t") -> bool

ida_hexrays.ccase_t.__lt__(self, r: "ccase_t") -> bool

ida_hexrays.ccase_t.__ne__(self, r: "ccase_t") -> bool

ida_hexrays.ccase_t.compare(self, r: "ccase_t") -> int

ida_hexrays.ccase_t.size(self) -> "size_t"

ida_hexrays.ccase_t.value(self, i: int) -> "uint64 const &"

ida_hexrays.ccase_t.values
    List of case values. if empty, then 'default' case 
            

ida_hexrays.ccases_t

ida_hexrays.ccases_t.__eq__(self, r: "ccases_t") -> bool

ida_hexrays.ccases_t.__ge__(self, r: "ccases_t") -> bool

ida_hexrays.ccases_t.__gt__(self, r: "ccases_t") -> bool

ida_hexrays.ccases_t.__init__(self)

ida_hexrays.ccases_t.__le__(self, r: "ccases_t") -> bool

ida_hexrays.ccases_t.__lt__(self, r: "ccases_t") -> bool

ida_hexrays.ccases_t.__ne__(self, r: "ccases_t") -> bool

ida_hexrays.ccases_t.compare(self, r: "ccases_t") -> int

ida_hexrays.ccatch_t

ida_hexrays.ccatch_t.__eq__(self, r: "ccatch_t") -> bool

ida_hexrays.ccatch_t.__ge__(self, r: "ccatch_t") -> bool

ida_hexrays.ccatch_t.__gt__(self, r: "ccatch_t") -> bool

ida_hexrays.ccatch_t.__init__(self, *args, **kwargs)

ida_hexrays.ccatch_t.__le__(self, r: "ccatch_t") -> bool

ida_hexrays.ccatch_t.__lt__(self, r: "ccatch_t") -> bool

ida_hexrays.ccatch_t.__ne__(self, r: "ccatch_t") -> bool

ida_hexrays.ccatch_t.compare(self, r: "ccatch_t") -> int

ida_hexrays.ccatch_t.is_catch_all(self) -> bool

ida_hexrays.ccatch_t.swap(self, r: "ccatch_t") -> None

ida_hexrays.cdg_insn_iterator_t

ida_hexrays.cdg_insn_iterator_t.__init__(self, *args)

ida_hexrays.cdg_insn_iterator_t.dslot_with_xrefs(self) -> bool

ida_hexrays.cdg_insn_iterator_t.has_dslot(self) -> bool

ida_hexrays.cdg_insn_iterator_t.is_severed_dslot(self) -> bool

ida_hexrays.cdg_insn_iterator_t.next(self, ins: "insn_t *") -> "merror_t"

ida_hexrays.cdg_insn_iterator_t.ok(self) -> bool

ida_hexrays.cdg_insn_iterator_t.start(self, rng: "range_t") -> None

ida_hexrays.cdo_t

ida_hexrays.cdo_t.__eq__(self, r: "cdo_t") -> bool

ida_hexrays.cdo_t.__ge__(self, r: "cdo_t") -> bool

ida_hexrays.cdo_t.__gt__(self, r: "cdo_t") -> bool

ida_hexrays.cdo_t.__init__(self)

ida_hexrays.cdo_t.__le__(self, r: "cdo_t") -> bool

ida_hexrays.cdo_t.__lt__(self, r: "cdo_t") -> bool

ida_hexrays.cdo_t.__ne__(self, r: "cdo_t") -> bool

ida_hexrays.cdo_t.compare(self, r: "cdo_t") -> int

ida_hexrays.ceinsn_t

ida_hexrays.ceinsn_t.__init__(self)

ida_hexrays.ceinsn_t.expr
    Expression of the statement.

ida_hexrays.cexpr_operands(self)
    return a dictionary with the operands of a cexpr_t. 

ida_hexrays.cexpr_t

ida_hexrays.cexpr_t.__eq__(self, r: "cexpr_t") -> bool

ida_hexrays.cexpr_t.__ge__(self, r: "cexpr_t") -> bool

ida_hexrays.cexpr_t.__gt__(self, r: "cexpr_t") -> bool

ida_hexrays.cexpr_t.__init__(self, *args)

ida_hexrays.cexpr_t.__le__(self, r: "cexpr_t") -> bool

ida_hexrays.cexpr_t.__lt__(self, r: "cexpr_t") -> bool

ida_hexrays.cexpr_t.__ne__(self, r: "cexpr_t") -> bool

ida_hexrays.cexpr_t._deregister(self) -> None

ida_hexrays.cexpr_t._get_a(self) -> "carglist_t *"

ida_hexrays.cexpr_t._get_fpc(self) -> "fnumber_t *"

ida_hexrays.cexpr_t._get_helper(self) -> str

ida_hexrays.cexpr_t._get_insn(self) -> "cinsn_t *"

ida_hexrays.cexpr_t._get_m(self) -> int

ida_hexrays.cexpr_t._get_n(self) -> "cnumber_t *"

ida_hexrays.cexpr_t._get_obj_ea(self) -> ida_idaapi.ea_t

ida_hexrays.cexpr_t._get_ptrsize(self) -> int

ida_hexrays.cexpr_t._get_refwidth(self) -> int

ida_hexrays.cexpr_t._get_string(self) -> str

ida_hexrays.cexpr_t._get_x(self) -> "cexpr_t *"

ida_hexrays.cexpr_t._get_y(self) -> "cexpr_t *"

ida_hexrays.cexpr_t._get_z(self) -> "cexpr_t *"

ida_hexrays.cexpr_t._register(self) -> None

ida_hexrays.cexpr_t._replace_by(self, r: "cexpr_t") -> None

ida_hexrays.cexpr_t._set_a(self, _v: "carglist_t") -> None

ida_hexrays.cexpr_t._set_fpc(self, _v: "fnumber_t") -> None

ida_hexrays.cexpr_t._set_helper(self, _v: str) -> None

ida_hexrays.cexpr_t._set_insn(self, _v: "cinsn_t") -> None

ida_hexrays.cexpr_t._set_m(self, _v: int) -> None

ida_hexrays.cexpr_t._set_n(self, _v: "cnumber_t") -> None

ida_hexrays.cexpr_t._set_obj_ea(self, _v: ida_idaapi.ea_t) -> None

ida_hexrays.cexpr_t._set_ptrsize(self, _v: int) -> None

ida_hexrays.cexpr_t._set_refwidth(self, _v: int) -> None

ida_hexrays.cexpr_t._set_string(self, _v: str) -> None

ida_hexrays.cexpr_t._set_x(self, _v: "cexpr_t") -> None

ida_hexrays.cexpr_t._set_y(self, _v: "cexpr_t") -> None

ida_hexrays.cexpr_t._set_z(self, _v: "cexpr_t") -> None

ida_hexrays.cexpr_t.a
    argument list (used for cot_call)

ida_hexrays.cexpr_t.assign(self, r: "cexpr_t") -> "cexpr_t &"

ida_hexrays.cexpr_t.calc_type(self, recursive: bool) -> None
    Calculate the type of the expression. Use this function to calculate the expression type when a new expression is built 
            
    @param recursive: if true, types of all children expression will be calculated before calculating our type

ida_hexrays.cexpr_t.cleanup(self) -> None
    Cleanup the expression. This function properly deletes all children and sets the item type to cot_empty. 
            

ida_hexrays.cexpr_t.compare(self, r: "cexpr_t") -> int

ida_hexrays.cexpr_t.contains_comma(self, times: int = 1) -> bool
    Does the expression contain a comma operator?

ida_hexrays.cexpr_t.contains_comma_or_insn_or_label(self, maxcommas: int = 1) -> bool
    Does the expression contain a comma operator or an embedded statement operator or a label?

ida_hexrays.cexpr_t.contains_insn(self, times: int = 1) -> bool
    Does the expression contain an embedded statement operator?

ida_hexrays.cexpr_t.contains_insn_or_label(self) -> bool
    Does the expression contain an embedded statement operator or a label?

ida_hexrays.cexpr_t.contains_operator(self, needed_op: "ctype_t", times: int = 1) -> bool
    Check if the expression contains the specified operator. 
            
    @param needed_op: operator code to search for
    @param times: how many times the operator code should be present
    @returns true if the expression has at least TIMES children with NEEDED_OP

ida_hexrays.cexpr_t.cpadone(self) -> bool
    Pointer arithmetic correction done for this expression?

ida_hexrays.cexpr_t.dstr(self) -> str

ida_hexrays.cexpr_t.equal_effect(self, r: "cexpr_t") -> bool
    Compare two expressions. This function tries to compare two expressions in an 'intelligent' manner. For example, it knows about commutitive operators and can ignore useless casts. 
            
    @param r: the expression to compare against the current expression
    @returns true expressions can be considered equal

ida_hexrays.cexpr_t.exflags
    Expression attributes 
            

ida_hexrays.cexpr_t.find_num_op(self) -> "cexpr_t *"
    Find the operand with a numeric value.

ida_hexrays.cexpr_t.find_op(self, _op: "ctype_t") -> "cexpr_t *"
    Find the child with the specified operator.

ida_hexrays.cexpr_t.fpc
    used for cot_fnum

ida_hexrays.cexpr_t.get_1num_op(self, o1: "cexpr_t **", o2: "cexpr_t **") -> bool
    Get pointers to operands. at last one operand should be a number o1 will be pointer to the number 
            

ida_hexrays.cexpr_t.get_const_value(self) -> bool
    Get expression value. 
            
    @returns true if the expression is a number.

ida_hexrays.cexpr_t.get_high_nbit_bound(self) -> "bit_bound_t"
    Get max number of bits that can really be used by the expression. For example, x % 16 can yield only 4 non-zero bits, higher bits are zero 
            

ida_hexrays.cexpr_t.get_low_nbit_bound(self) -> int
    Get min number of bits that are certainly required to represent the expression. For example, constant 16 always uses 5 bits: 10000. 
            

ida_hexrays.cexpr_t.get_ptr_or_array(self) -> "cexpr_t *"
    Find pointer or array child.

ida_hexrays.cexpr_t.get_type_sign(self) -> "type_sign_t"
    Get expression sign.

ida_hexrays.cexpr_t.get_v(self) -> "var_ref_t *"

ida_hexrays.cexpr_t.has_side_effects(self) -> bool
    Check if the expression has side effects. Calls, pre/post inc/dec, and assignments have side effects. 
            

ida_hexrays.cexpr_t.helper
    helper name (used for cot_helper)

ida_hexrays.cexpr_t.insn
    an embedded statement, they are prohibited at the final maturity stage (CMAT_FINAL) 
            

ida_hexrays.cexpr_t.is_call_arg_of(self, parent: "citem_t") -> bool
    Is call argument? 
            
    @returns true if our expression is a call argument of the specified parent expression.

ida_hexrays.cexpr_t.is_call_object_of(self, parent: "citem_t") -> bool
    Is call object? 
            
    @returns true if our expression is the call object of the specified parent expression.

ida_hexrays.cexpr_t.is_child_of(self, parent: "citem_t") -> bool
    Verify if the specified item is our parent. 
            
    @param parent: possible parent item
    @returns true if the specified item is our parent

ida_hexrays.cexpr_t.is_const_value(self, _v: "uint64") -> bool
    Check if the expression is a number with the specified value.

ida_hexrays.cexpr_t.is_cstr(self) -> bool

ida_hexrays.cexpr_t.is_fpop(self) -> bool

ida_hexrays.cexpr_t.is_jumpout(self) -> bool

ida_hexrays.cexpr_t.is_negative_const(self) -> bool
    Check if the expression is a negative number.

ida_hexrays.cexpr_t.is_nice_cond(self) -> bool
    Is nice condition?. Nice condition is a nice expression of the boolean type. 
            

ida_hexrays.cexpr_t.is_nice_expr(self) -> bool
    Is nice expression? Nice expressions do not contain comma operators, embedded statements, or labels. 
            

ida_hexrays.cexpr_t.is_non_negative_const(self) -> bool
    Check if the expression is a non-negative number.

ida_hexrays.cexpr_t.is_non_zero_const(self) -> bool
    Check if the expression is a non-zero number.

ida_hexrays.cexpr_t.is_odd_lvalue(self) -> bool

ida_hexrays.cexpr_t.is_type_signed(self) -> bool
    Is expression signed?

ida_hexrays.cexpr_t.is_type_unsigned(self) -> bool
    Is expression unsigned?

ida_hexrays.cexpr_t.is_undef_val(self) -> bool

ida_hexrays.cexpr_t.is_vftable(self) -> bool

ida_hexrays.cexpr_t.is_zero_const(self) -> bool
    Check if the expression is a zero.

ida_hexrays.cexpr_t.m
    member offset (used for cot_memptr, cot_memref) for unions, the member number 
            

ida_hexrays.cexpr_t.maybe_ptr(self) -> bool
    May the expression be a pointer?

ida_hexrays.cexpr_t.n
    used for cot_num

ida_hexrays.cexpr_t.numval(self) -> "uint64"
    Get numeric value of the expression. This function can be called only on cot_num expressions! 
            

ida_hexrays.cexpr_t.obj_ea
    used for cot_obj

ida_hexrays.cexpr_t.print1(self, func: "cfunc_t") -> None
    Print expression into one line. 
            
    @param func: parent function. This argument is used to find out the referenced variable names.

ida_hexrays.cexpr_t.ptrsize
    memory access size (used for cot_ptr, cot_memptr)

ida_hexrays.cexpr_t.put_number(self, *args) -> None
    Assign a number to the expression. 
            
    @param func: current function
    @param value: number value
    @param nbytes: size of the number in bytes
    @param sign: number sign

ida_hexrays.cexpr_t.refwidth
    how many bytes are accessed? (-1: none)

ida_hexrays.cexpr_t.requires_lvalue(self, child: "cexpr_t") -> bool
    Check if the expression requires an lvalue. 
            
    @param child: The function will check if this child of our expression must be an lvalue.
    @returns true if child must be an lvalue.

ida_hexrays.cexpr_t.set_cpadone(self) -> None

ida_hexrays.cexpr_t.set_v(self, v: "var_ref_t") -> None

ida_hexrays.cexpr_t.set_vftable(self) -> None

ida_hexrays.cexpr_t.string
    utf8 string constant, user representation (used for cot_str)

ida_hexrays.cexpr_t.swap(self, r: "cexpr_t") -> None

ida_hexrays.cexpr_t.theother(self, what: "cexpr_t") -> "cexpr_t *"
    Get the other operand. This function returns the other operand (not the specified one) for binary expressions. 
            

ida_hexrays.cexpr_t.type
    expression type. must be carefully maintained

ida_hexrays.cexpr_t.v
    used for cot_var

ida_hexrays.cexpr_t.x
    the first operand of the expression

ida_hexrays.cexpr_t.y
    the second operand of the expression

ida_hexrays.cexpr_t.z
    the third operand of the expression

ida_hexrays.cfor_t

ida_hexrays.cfor_t.__eq__(self, r: "cfor_t") -> bool

ida_hexrays.cfor_t.__ge__(self, r: "cfor_t") -> bool

ida_hexrays.cfor_t.__gt__(self, r: "cfor_t") -> bool

ida_hexrays.cfor_t.__init__(self)

ida_hexrays.cfor_t.__le__(self, r: "cfor_t") -> bool

ida_hexrays.cfor_t.__lt__(self, r: "cfor_t") -> bool

ida_hexrays.cfor_t.__ne__(self, r: "cfor_t") -> bool

ida_hexrays.cfor_t.compare(self, r: "cfor_t") -> int

ida_hexrays.cfor_t.init
    Initialization expression.

ida_hexrays.cfor_t.step
    Step expression.

ida_hexrays.cfunc_parentee_t

ida_hexrays.cfunc_parentee_t.__disown__(self)

ida_hexrays.cfunc_parentee_t.__init__(self, f: "cfunc_t", post: bool = False)

ida_hexrays.cfunc_parentee_t.calc_rvalue_type(self, target: "tinfo_t", e: "cexpr_t") -> bool
    Calculate rvalue type. This function tries to determine the type of the specified item based on its context. For example, if the current expression is the right side of an assignment operator, the type of its left side will be returned. This function can be used to determine the 'best' type of the specified expression. 
            
    @param target: 'best' type of the expression will be returned here
    @param e: expression to determine the desired type
    @returns false if failed

ida_hexrays.cfunc_parentee_t.func
    Pointer to current function.

ida_hexrays.cfunc_t

ida_hexrays.cfunc_t.__init__(self, *args, **kwargs)

ida_hexrays.cfunc_t.__str__(self) -> str

ida_hexrays.cfunc_t.argidx
    list of arguments (indexes into vars)

ida_hexrays.cfunc_t.body
    function body, must be a block

ida_hexrays.cfunc_t.build_c_tree(self) -> None
    Generate the function body. This function (re)generates the function body from the underlying microcode. 
            

ida_hexrays.cfunc_t.del_orphan_cmts(self) -> int
    Delete all orphan comments. The save_user_cmts() function must be called after this call. 
            

ida_hexrays.cfunc_t.entry_ea
    function entry address

ida_hexrays.cfunc_t.find_item_coords(self, *args)
    This method has the following signatures:
    
        1. find_item_coords(item: citem_t) -> Tuple[int, int]
        2. find_item_coords(item: citem_t, x: int_pointer, y: int_pointer) -> bool
    
    NOTE: The second form is retained for backward-compatibility,
    but we strongly recommend using the first.
    
    @param item The item to find coordinates for in the pseudocode listing

ida_hexrays.cfunc_t.find_label(self, label: int) -> "citem_t *"
    Find the label. 
            
    @returns pointer to the ctree item with the specified label number.

ida_hexrays.cfunc_t.gather_derefs(self, ci: "ctree_item_t", udm: "udt_type_data_t" = None) -> bool

ida_hexrays.cfunc_t.get_boundaries(self) -> "boundaries_t &"
    Get pointer to map of instruction boundaries. This function initializes the boundary map if not done yet. 
            

ida_hexrays.cfunc_t.get_eamap(self) -> "eamap_t &"
    Get pointer to ea->insn map. This function initializes eamap if not done yet. 
            

ida_hexrays.cfunc_t.get_func_type(self, type: "tinfo_t") -> bool
    Get the function type. 
            
    @param type: variable where the function type is returned
    @returns false if failure

ida_hexrays.cfunc_t.get_line_item(self, line: str, x: int, is_ctree_line: bool, phead: "ctree_item_t", pitem: "ctree_item_t", ptail: "ctree_item_t") -> bool
    Get ctree item for the specified cursor position. 
            
    @param line: line of decompilation text (element of sv)
    @param x: x cursor coordinate in the line
    @param is_ctree_line: does the line belong to statement area? (if not, it is assumed to belong to the declaration area)
    @param phead: ptr to the first item on the line (used to attach block comments). May be nullptr
    @param pitem: ptr to the current item. May be nullptr
    @param ptail: ptr to the last item on the line (used to attach indented comments). May be nullptr
    @returns false if failed to get the current item

ida_hexrays.cfunc_t.get_lvars(self) -> "lvars_t *"
    Get vector of local variables. 
            
    @returns pointer to the vector of local variables. If you modify this vector, the ctree must be regenerated in order to have correct cast operators. Use build_c_tree() for that. Removing lvars should be done carefully: all references in ctree and microcode must be corrected after that.

ida_hexrays.cfunc_t.get_pseudocode(self) -> "strvec_t const &"
    Get pointer to decompilation output: the pseudocode. This function generates pseudocode if not done yet. 
            

ida_hexrays.cfunc_t.get_stkoff_delta(self) -> int
    Get stack offset delta. The local variable stack offsets retrieved by v.location.stkoff() should be adjusted before being used as stack frame offsets in IDA. 
            
    @returns the delta to apply. example: ida_stkoff = v.location.stkoff() - f->get_stkoff_delta()

ida_hexrays.cfunc_t.get_user_cmt(self, loc: "treeloc_t", rt: "cmt_retrieval_type_t") -> str
    Retrieve a user defined comment. 
            
    @param loc: ctree location
    @param rt: should already retrieved comments retrieved again?
    @returns pointer to the comment string or nullptr

ida_hexrays.cfunc_t.get_user_iflags(self, loc: "citem_locator_t") -> int
    Retrieve citem iflags. 
            
    @param loc: citem locator
    @returns ctree item iflags bits or 0

ida_hexrays.cfunc_t.get_user_union_selection(self, ea: ida_idaapi.ea_t, path: "intvec_t") -> bool
    Retrieve a user defined union field selection. 
            
    @param ea: address
    @param path: out: path describing the union selection.
    @returns pointer to the path or nullptr

ida_hexrays.cfunc_t.get_warnings(self) -> "hexwarns_t &"
    Get information about decompilation warnings. 
            
    @returns reference to the vector of warnings

ida_hexrays.cfunc_t.has_orphan_cmts(self) -> bool
    Check if there are orphan comments.

ida_hexrays.cfunc_t.hdrlines
    number of lines in the declaration area

ida_hexrays.cfunc_t.locked(self) -> bool

ida_hexrays.cfunc_t.maturity
    maturity level

ida_hexrays.cfunc_t.mba
    underlying microcode

ida_hexrays.cfunc_t.numforms
    user-defined number formats.

ida_hexrays.cfunc_t.print_dcl(self) -> None
    Print function prototype. 
            

ida_hexrays.cfunc_t.print_func(self, vp: "vc_printer_t") -> None
    Print function text. 
            
    @param vp: printer helper class to receive the generated text.

ida_hexrays.cfunc_t.refcnt
    reference count to this object. use cfuncptr_t

ida_hexrays.cfunc_t.refresh_func_ctext(self) -> None
    Refresh ctext after a ctree modification. This function informs the decompiler that ctree (body) have been modified and ctext (sv) does not correspond to it anymore. It also refreshes the pseudocode windows if there is any. 
            

ida_hexrays.cfunc_t.release(self) -> None

ida_hexrays.cfunc_t.remove_unused_labels(self) -> None
    Remove unused labels. This function checks what labels are really used by the function and removes the unused ones. You must call it after deleting a goto statement. 
            

ida_hexrays.cfunc_t.save_user_cmts(self) -> None
    Save user-defined comments into the database.

ida_hexrays.cfunc_t.save_user_iflags(self) -> None
    Save user-defined iflags into the database.

ida_hexrays.cfunc_t.save_user_labels(self) -> None
    Save user-defined labels into the database.

ida_hexrays.cfunc_t.save_user_numforms(self) -> None
    Save user-defined number formats into the database.

ida_hexrays.cfunc_t.save_user_unions(self) -> None
    Save user-defined union field selections into the database.

ida_hexrays.cfunc_t.set_user_cmt(self, loc: "treeloc_t", cmt: str) -> None
    Set a user defined comment. This function stores the specified comment in the cfunc_t structure. The save_user_cmts() function must be called after it. 
            
    @param loc: ctree location
    @param cmt: new comment. if empty or nullptr, then an existing comment is deleted.

ida_hexrays.cfunc_t.set_user_iflags(self, loc: "citem_locator_t", iflags: int) -> None
    Set citem iflags. 
            
    @param loc: citem locator
    @param iflags: new iflags

ida_hexrays.cfunc_t.set_user_union_selection(self, ea: ida_idaapi.ea_t, path: "intvec_t") -> None
    Set a union field selection. The save_user_unions() function must be called after calling this function. 
            
    @param ea: address
    @param path: in: path describing the union selection.

ida_hexrays.cfunc_t.statebits
    current cfunc_t state. see cfunc state bits 
            

ida_hexrays.cfunc_t.treeitems
    vector of pointers to citem_t objects (nodes constituting the ctree)

ida_hexrays.cfunc_t.user_cmts
    user-defined comments.

ida_hexrays.cfunc_t.user_iflags
    user-defined item flags ctree item iflags bits

ida_hexrays.cfunc_t.user_labels
    user-defined labels.

ida_hexrays.cfunc_t.user_unions
    user-defined union field selections. 
            

ida_hexrays.cfunc_t.verify(self, aul: "allow_unused_labels_t", even_without_debugger: bool) -> None
    Verify the ctree. This function verifies the ctree. If the ctree is malformed, an internal error is generated. Use it to verify the ctree after your modifications. 
            
    @param aul: Are unused labels acceptable?
    @param even_without_debugger: if false and there is no debugger, the verification will be skipped

ida_hexrays.cfunc_type(self)
    Get the function's return type tinfo_t object. 

ida_hexrays.cfuncptr_t

ida_hexrays.cfuncptr_t.__deref__(self) -> "cfunc_t *"

ida_hexrays.cfuncptr_t.__init__(self, *args)

ida_hexrays.cfuncptr_t.__ptrval__(self) -> "size_t"

ida_hexrays.cfuncptr_t.__ref__(self) -> "cfunc_t &"

ida_hexrays.cfuncptr_t.__str__(self) -> str

ida_hexrays.cfuncptr_t.build_c_tree(self) -> None

ida_hexrays.cfuncptr_t.del_orphan_cmts(self) -> int

ida_hexrays.cfuncptr_t.find_item_coords(self, *args)
    This method has the following signatures:
    
        1. find_item_coords(item: citem_t) -> Tuple[int, int]
        2. find_item_coords(item: citem_t, x: int_pointer, y: int_pointer) -> bool
    
    NOTE: The second form is retained for backward-compatibility,
    but we strongly recommend using the first.
    
    @param item The item to find coordinates for in the pseudocode listing

ida_hexrays.cfuncptr_t.find_label(self, label: int) -> "citem_t *"

ida_hexrays.cfuncptr_t.gather_derefs(self, ci: "ctree_item_t", udm: "udt_type_data_t" = None) -> bool

ida_hexrays.cfuncptr_t.get_boundaries(self) -> "boundaries_t &"

ida_hexrays.cfuncptr_t.get_eamap(self) -> "eamap_t &"

ida_hexrays.cfuncptr_t.get_func_type(self, type: "tinfo_t") -> bool

ida_hexrays.cfuncptr_t.get_line_item(self, line: str, x: int, is_ctree_line: bool, phead: "ctree_item_t", pitem: "ctree_item_t", ptail: "ctree_item_t") -> bool

ida_hexrays.cfuncptr_t.get_lvars(self) -> "lvars_t *"

ida_hexrays.cfuncptr_t.get_pseudocode(self) -> "strvec_t const &"

ida_hexrays.cfuncptr_t.get_stkoff_delta(self) -> int

ida_hexrays.cfuncptr_t.get_user_cmt(self, loc: "treeloc_t", rt: "cmt_retrieval_type_t") -> str

ida_hexrays.cfuncptr_t.get_user_iflags(self, loc: "citem_locator_t") -> int

ida_hexrays.cfuncptr_t.get_user_union_selection(self, ea: ida_idaapi.ea_t, path: "intvec_t") -> bool

ida_hexrays.cfuncptr_t.get_warnings(self) -> "hexwarns_t &"

ida_hexrays.cfuncptr_t.has_orphan_cmts(self) -> bool

ida_hexrays.cfuncptr_t.locked(self) -> bool

ida_hexrays.cfuncptr_t.print_dcl(self) -> None

ida_hexrays.cfuncptr_t.print_func(self, vp: "vc_printer_t") -> None

ida_hexrays.cfuncptr_t.refresh_func_ctext(self) -> None

ida_hexrays.cfuncptr_t.release(self) -> None

ida_hexrays.cfuncptr_t.remove_unused_labels(self) -> None

ida_hexrays.cfuncptr_t.reset(self) -> None

ida_hexrays.cfuncptr_t.save_user_cmts(self) -> None
    Save user defined comments into the database. 
            

ida_hexrays.cfuncptr_t.save_user_iflags(self) -> None
    Save user defined citem iflags into the database. 
            

ida_hexrays.cfuncptr_t.save_user_labels(self) -> None
    Save user defined labels into the database. 
            

ida_hexrays.cfuncptr_t.save_user_numforms(self) -> None
    Save user defined number formats into the database. 
            

ida_hexrays.cfuncptr_t.save_user_unions(self) -> None
    Save user defined union field selections into the database. 
            

ida_hexrays.cfuncptr_t.set_user_cmt(self, loc: "treeloc_t", cmt: str) -> None

ida_hexrays.cfuncptr_t.set_user_iflags(self, loc: "citem_locator_t", iflags: int) -> None

ida_hexrays.cfuncptr_t.set_user_union_selection(self, ea: ida_idaapi.ea_t, path: "intvec_t") -> None

ida_hexrays.cfuncptr_t.verify(self, aul: "allow_unused_labels_t", even_without_debugger: bool) -> None

ida_hexrays.cgoto_t

ida_hexrays.cgoto_t.__eq__(self, r: "cgoto_t") -> bool

ida_hexrays.cgoto_t.__ge__(self, r: "cgoto_t") -> bool

ida_hexrays.cgoto_t.__gt__(self, r: "cgoto_t") -> bool

ida_hexrays.cgoto_t.__init__(self)

ida_hexrays.cgoto_t.__le__(self, r: "cgoto_t") -> bool

ida_hexrays.cgoto_t.__lt__(self, r: "cgoto_t") -> bool

ida_hexrays.cgoto_t.__ne__(self, r: "cgoto_t") -> bool

ida_hexrays.cgoto_t.compare(self, r: "cgoto_t") -> int

ida_hexrays.cgoto_t.label_num
    Target label number.

ida_hexrays.chain_keeper_t

ida_hexrays.chain_keeper_t.__init__(self, _gc: "graph_chains_t")

ida_hexrays.chain_keeper_t.back(self) -> "block_chains_t &"

ida_hexrays.chain_keeper_t.for_all_chains(self, cv: "chain_visitor_t", gca: int) -> int

ida_hexrays.chain_keeper_t.front(self) -> "block_chains_t &"

ida_hexrays.chain_t

ida_hexrays.chain_t.__init__(self, *args)

ida_hexrays.chain_t.__lt__(self, r: "chain_t") -> bool

ida_hexrays.chain_t._print(self) -> None

ida_hexrays.chain_t.append_list(self, mba: "mba_t", list: "mlist_t") -> None
    Append the contents of the chain to the specified list of locations.

ida_hexrays.chain_t.clear_varnum(self) -> None

ida_hexrays.chain_t.dstr(self) -> str

ida_hexrays.chain_t.endoff(self) -> "voff_t const"

ida_hexrays.chain_t.flags
    combination Chain properties bits 
            

ida_hexrays.chain_t.get_reg(self) -> "mreg_t"

ida_hexrays.chain_t.get_stkoff(self) -> int

ida_hexrays.chain_t.includes(self, r: "chain_t") -> bool

ida_hexrays.chain_t.is_fake(self) -> bool

ida_hexrays.chain_t.is_inited(self) -> bool

ida_hexrays.chain_t.is_overlapped(self) -> bool

ida_hexrays.chain_t.is_passreg(self) -> bool

ida_hexrays.chain_t.is_reg(self) -> bool

ida_hexrays.chain_t.is_replaced(self) -> bool

ida_hexrays.chain_t.is_stkoff(self) -> bool

ida_hexrays.chain_t.is_term(self) -> bool

ida_hexrays.chain_t.key(self) -> "voff_t const &"

ida_hexrays.chain_t.overlap(self, r: "chain_t") -> bool

ida_hexrays.chain_t.set_inited(self, b: bool) -> None

ida_hexrays.chain_t.set_overlapped(self, b: bool) -> None

ida_hexrays.chain_t.set_replaced(self, b: bool) -> None

ida_hexrays.chain_t.set_term(self, b: bool) -> None

ida_hexrays.chain_t.set_value(self, r: "chain_t") -> None

ida_hexrays.chain_t.varnum
    allocated variable index (-1 - not allocated yet)

ida_hexrays.chain_t.width
    size of the value in bytes

ida_hexrays.chain_visitor_t

ida_hexrays.chain_visitor_t.__disown__(self)

ida_hexrays.chain_visitor_t.__init__(self)

ida_hexrays.chain_visitor_t.parent
    parent of the current chain

ida_hexrays.chain_visitor_t.visit_chain(self, nblock: int, ch: "chain_t") -> int

ida_hexrays.change_hexrays_config(directive: str) -> bool
    Parse DIRECTIVE and update the current configuration variables. For the syntax see hexrays.cfg 
            

ida_hexrays.cif_t

ida_hexrays.cif_t.__eq__(self, r: "cif_t") -> bool

ida_hexrays.cif_t.__ge__(self, r: "cif_t") -> bool

ida_hexrays.cif_t.__gt__(self, r: "cif_t") -> bool

ida_hexrays.cif_t.__init__(self, *args)

ida_hexrays.cif_t.__le__(self, r: "cif_t") -> bool

ida_hexrays.cif_t.__lt__(self, r: "cif_t") -> bool

ida_hexrays.cif_t.__ne__(self, r: "cif_t") -> bool

ida_hexrays.cif_t.assign(self, r: "cif_t") -> "cif_t &"

ida_hexrays.cif_t.cleanup(self) -> None

ida_hexrays.cif_t.compare(self, r: "cif_t") -> int

ida_hexrays.cif_t.ielse
    Else-branch of the if-statement. May be nullptr.

ida_hexrays.cif_t.ithen
    Then-branch of the if-statement.

ida_hexrays.cinsn_details(self)
    return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.

ida_hexrays.cinsn_list_t

ida_hexrays.cinsn_list_t.__eq__(self, x: "cinsn_list_t") -> bool

ida_hexrays.cinsn_list_t.__getitem__(self, i: "size_t") -> "cinsn_t const &"

ida_hexrays.cinsn_list_t.__init__(self, *args)

ida_hexrays.cinsn_list_t.__len__(self) -> "size_t"

ida_hexrays.cinsn_list_t.__ne__(self, x: "cinsn_list_t") -> bool

ida_hexrays.cinsn_list_t.__setitem__(self, i: "size_t", v: "cinsn_t") -> None

ida_hexrays.cinsn_list_t.at(self, index)

ida_hexrays.cinsn_list_t.back(self, *args) -> "cinsn_t const &"

ida_hexrays.cinsn_list_t.begin(self) -> "cinsn_list_t_iterator"

ida_hexrays.cinsn_list_t.clear(self) -> None

ida_hexrays.cinsn_list_t.empty(self) -> bool

ida_hexrays.cinsn_list_t.end(self) -> "cinsn_list_t_iterator"

ida_hexrays.cinsn_list_t.erase(self, p: "cinsn_list_t_iterator") -> None

ida_hexrays.cinsn_list_t.find(self, item)

ida_hexrays.cinsn_list_t.front(self, *args) -> "cinsn_t const &"

ida_hexrays.cinsn_list_t.index(self, item)

ida_hexrays.cinsn_list_t.insert(self, *args) -> "cinsn_list_t_iterator"

ida_hexrays.cinsn_list_t.pop_back(self) -> None

ida_hexrays.cinsn_list_t.pop_front(self) -> None

ida_hexrays.cinsn_list_t.push_back(self, *args) -> "cinsn_t &"

ida_hexrays.cinsn_list_t.push_front(self, x: "cinsn_t") -> None

ida_hexrays.cinsn_list_t.rbegin(self, *args) -> "qlist< cinsn_t >::const_reverse_iterator"

ida_hexrays.cinsn_list_t.remove(self, v: "cinsn_t") -> bool

ida_hexrays.cinsn_list_t.rend(self, *args) -> "qlist< cinsn_t >::const_reverse_iterator"

ida_hexrays.cinsn_list_t.size(self) -> "size_t"

ida_hexrays.cinsn_list_t.splice(self, pos: "qlist< cinsn_t >::iterator", other: "cinsn_list_t", first: "qlist< cinsn_t >::iterator", last: "qlist< cinsn_t >::iterator") -> None

ida_hexrays.cinsn_list_t.swap(self, x: "cinsn_list_t") -> None

ida_hexrays.cinsn_list_t_iterator

ida_hexrays.cinsn_list_t_iterator.__eq__(self, x: "cinsn_list_t_iterator") -> bool

ida_hexrays.cinsn_list_t_iterator.__init__(self)

ida_hexrays.cinsn_list_t_iterator.__ne__(self, x: "cinsn_list_t_iterator") -> bool

ida_hexrays.cinsn_list_t_iterator.__next__(self) -> None

ida_hexrays.cinsn_t

ida_hexrays.cinsn_t.__eq__(self, r: "cinsn_t") -> bool

ida_hexrays.cinsn_t.__ge__(self, r: "cinsn_t") -> bool

ida_hexrays.cinsn_t.__gt__(self, r: "cinsn_t") -> bool

ida_hexrays.cinsn_t.__init__(self, *args)

ida_hexrays.cinsn_t.__le__(self, r: "cinsn_t") -> bool

ida_hexrays.cinsn_t.__lt__(self, r: "cinsn_t") -> bool

ida_hexrays.cinsn_t.__ne__(self, r: "cinsn_t") -> bool

ida_hexrays.cinsn_t._deregister(self) -> None

ida_hexrays.cinsn_t._get_casm(self) -> "casm_t *"

ida_hexrays.cinsn_t._get_cblock(self) -> "cblock_t *"

ida_hexrays.cinsn_t._get_cdo(self) -> "cdo_t *"

ida_hexrays.cinsn_t._get_cexpr(self) -> "cexpr_t *"

ida_hexrays.cinsn_t._get_cfor(self) -> "cfor_t *"

ida_hexrays.cinsn_t._get_cgoto(self) -> "cgoto_t *"

ida_hexrays.cinsn_t._get_cif(self) -> "cif_t *"

ida_hexrays.cinsn_t._get_creturn(self) -> "creturn_t *"

ida_hexrays.cinsn_t._get_cswitch(self) -> "cswitch_t *"

ida_hexrays.cinsn_t._get_cwhile(self) -> "cwhile_t *"

ida_hexrays.cinsn_t._print(self, indent: int, vp: "vc_printer_t", use_curly: "use_curly_t" = CALC_CURLY_BRACES) -> None

ida_hexrays.cinsn_t._register(self) -> None

ida_hexrays.cinsn_t._replace_by(self, r: "cinsn_t") -> None

ida_hexrays.cinsn_t._set_casm(self, _v: "casm_t") -> None

ida_hexrays.cinsn_t._set_cblock(self, _v: "cblock_t") -> None

ida_hexrays.cinsn_t._set_cdo(self, _v: "cdo_t") -> None

ida_hexrays.cinsn_t._set_cexpr(self, _v: "cexpr_t") -> None

ida_hexrays.cinsn_t._set_cfor(self, _v: "cfor_t") -> None

ida_hexrays.cinsn_t._set_cgoto(self, _v: "cgoto_t") -> None

ida_hexrays.cinsn_t._set_cif(self, _v: "cif_t") -> None

ida_hexrays.cinsn_t._set_creturn(self, _v: "creturn_t") -> None

ida_hexrays.cinsn_t._set_cswitch(self, _v: "cswitch_t") -> None

ida_hexrays.cinsn_t._set_cwhile(self, _v: "cwhile_t") -> None

ida_hexrays.cinsn_t.assign(self, r: "cinsn_t") -> "cinsn_t &"

ida_hexrays.cinsn_t.casm
    details of asm-statement

ida_hexrays.cinsn_t.cblock
    details of block-statement

ida_hexrays.cinsn_t.cdo
    details of do-statement

ida_hexrays.cinsn_t.cexpr
    details of expression-statement

ida_hexrays.cinsn_t.cfor
    details of for-statement

ida_hexrays.cinsn_t.cgoto
    details of goto-statement

ida_hexrays.cinsn_t.cif
    details of if-statement

ida_hexrays.cinsn_t.cleanup(self) -> None
    Cleanup the statement. This function properly deletes all children and sets the item type to cit_empty. 
            

ida_hexrays.cinsn_t.collect_free_breaks(self, breaks: "cinsnptrvec_t") -> bool
    Collect free `break` statements. This function finds all free `break` statements within the current statement. A `break` statement is free if it does not have a loop or switch parent that that is also within the current statement. 
            
    @param breaks: pointer to the variable where the vector of all found free `break` statements is returned. This argument can be nullptr.
    @returns true if some free `break` statements have been found

ida_hexrays.cinsn_t.collect_free_continues(self, continues: "cinsnptrvec_t") -> bool
    Collect free `continue` statements. This function finds all free `continue` statements within the current statement. A `continue` statement is free if it does not have a loop parent that that is also within the current statement. 
            
    @param continues: pointer to the variable where the vector of all found free `continue` statements is returned. This argument can be nullptr.
    @returns true if some free `continue` statements have been found

ida_hexrays.cinsn_t.compare(self, r: "cinsn_t") -> int

ida_hexrays.cinsn_t.contains_free_break(self) -> bool
    Check if the statement has free `break` statements.

ida_hexrays.cinsn_t.contains_free_continue(self) -> bool
    Check if the statement has free `continue` statements.

ida_hexrays.cinsn_t.contains_insn(self, type: "ctype_t", times: int = 1) -> bool
    Check if the statement contains a statement of the specified type. 
            
    @param type: statement opcode to look for
    @param times: how many times TYPE should be present
    @returns true if the statement has at least TIMES children with opcode == TYPE

ida_hexrays.cinsn_t.create_if(self, cnd: "cexpr_t") -> "cif_t &"
    Create a new if-statement. The current statement must be a block. The new statement will be appended to it. 
            
    @param cnd: if condition. It will be deleted after being copied.

ida_hexrays.cinsn_t.creturn
    details of return-statement

ida_hexrays.cinsn_t.cswitch
    details of switch-statement

ida_hexrays.cinsn_t.cthrow
    details of throw-statement

ida_hexrays.cinsn_t.ctry
    details of try-statement

ida_hexrays.cinsn_t.cwhile
    details of while-statement

ida_hexrays.cinsn_t.dstr(self) -> str

ida_hexrays.cinsn_t.insn_is_epilog(insn: "cinsn_t") -> bool

ida_hexrays.cinsn_t.is_epilog(self)

ida_hexrays.cinsn_t.is_ordinary_flow(self) -> bool
    Check if the statement passes execution to the next statement. 
            
    @returns false if the statement breaks the control flow (like goto, return, etc)

ida_hexrays.cinsn_t.new_insn(self, insn_ea: ida_idaapi.ea_t) -> "cinsn_t &"
    Create a new statement. The current statement must be a block. The new statement will be appended to it. 
            
    @param insn_ea: statement address

ida_hexrays.cinsn_t.print1(self, func: "cfunc_t") -> None
    Print the statement into one line. Currently this function is not available. 
            
    @param func: parent function. This argument is used to find out the referenced variable names.

ida_hexrays.cinsn_t.swap(self, r: "cinsn_t") -> None

ida_hexrays.cinsn_t.zero(self) -> None
    Overwrite with zeroes without cleaning memory or deleting children.

ida_hexrays.cinsnptrvec_t

ida_hexrays.cinsnptrvec_t.__eq__(self, r: "cinsnptrvec_t") -> bool

ida_hexrays.cinsnptrvec_t.__getitem__(self, i: "size_t") -> "cinsn_t *const &"

ida_hexrays.cinsnptrvec_t.__init__(self, *args)

ida_hexrays.cinsnptrvec_t.__len__(self) -> "size_t"

ida_hexrays.cinsnptrvec_t.__ne__(self, r: "cinsnptrvec_t") -> bool

ida_hexrays.cinsnptrvec_t.__setitem__(self, i: "size_t", v: "cinsn_t") -> None

ida_hexrays.cinsnptrvec_t._del(self, x: "cinsn_t") -> bool

ida_hexrays.cinsnptrvec_t.add_unique(self, x: "cinsn_t") -> bool

ida_hexrays.cinsnptrvec_t.append(self, x: "cinsn_t") -> None

ida_hexrays.cinsnptrvec_t.at(self, _idx: "size_t") -> "cinsn_t *const &"

ida_hexrays.cinsnptrvec_t.begin(self, *args) -> "qvector< cinsn_t * >::const_iterator"

ida_hexrays.cinsnptrvec_t.capacity(self) -> "size_t"

ida_hexrays.cinsnptrvec_t.clear(self) -> None

ida_hexrays.cinsnptrvec_t.empty(self) -> bool

ida_hexrays.cinsnptrvec_t.end(self, *args) -> "qvector< cinsn_t * >::const_iterator"

ida_hexrays.cinsnptrvec_t.erase(self, *args) -> "qvector< cinsn_t * >::iterator"

ida_hexrays.cinsnptrvec_t.extend(self, x: "cinsnptrvec_t") -> None

ida_hexrays.cinsnptrvec_t.extract(self) -> "cinsn_t **"

ida_hexrays.cinsnptrvec_t.find(self, *args) -> "qvector< cinsn_t * >::const_iterator"

ida_hexrays.cinsnptrvec_t.has(self, x: "cinsn_t") -> bool

ida_hexrays.cinsnptrvec_t.inject(self, s: "cinsn_t **", len: "size_t") -> None

ida_hexrays.cinsnptrvec_t.insert(self, it: "qvector< cinsn_t * >::iterator", x: "cinsn_t") -> "qvector< cinsn_t * >::iterator"

ida_hexrays.cinsnptrvec_t.pop_back(self) -> None

ida_hexrays.cinsnptrvec_t.push_back(self, *args) -> "cinsn_t *&"

ida_hexrays.cinsnptrvec_t.qclear(self) -> None

ida_hexrays.cinsnptrvec_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.cinsnptrvec_t.resize(self, *args) -> None

ida_hexrays.cinsnptrvec_t.size(self) -> "size_t"

ida_hexrays.cinsnptrvec_t.swap(self, r: "cinsnptrvec_t") -> None

ida_hexrays.cinsnptrvec_t.truncate(self) -> None

ida_hexrays.cit_asm
    asm-statement

ida_hexrays.cit_block
    block-statement: { ... }

ida_hexrays.cit_break
    break-statement

ida_hexrays.cit_continue
    continue-statement

ida_hexrays.cit_do
    do-statement

ida_hexrays.cit_empty
    instruction types start here

ida_hexrays.cit_expr
    expression-statement: expr;

ida_hexrays.cit_for
    for-statement

ida_hexrays.cit_goto
    goto-statement

ida_hexrays.cit_if
    if-statement

ida_hexrays.cit_return
    return-statement

ida_hexrays.cit_switch
    switch-statement

ida_hexrays.cit_throw
    C++ throw-statement.

ida_hexrays.cit_try
    C++ try-statement.

ida_hexrays.cit_while
    while-statement

ida_hexrays.citem_cmt_t

ida_hexrays.citem_cmt_t.__init__(self, *args)

ida_hexrays.citem_cmt_t.__str__(self) -> str

ida_hexrays.citem_cmt_t.c_str(self) -> str

ida_hexrays.citem_cmt_t.used
    the comment has been retrieved?

ida_hexrays.citem_locator_t

ida_hexrays.citem_locator_t.__eq__(self, r: "citem_locator_t") -> bool

ida_hexrays.citem_locator_t.__ge__(self, r: "citem_locator_t") -> bool

ida_hexrays.citem_locator_t.__gt__(self, r: "citem_locator_t") -> bool

ida_hexrays.citem_locator_t.__init__(self, *args)

ida_hexrays.citem_locator_t.__le__(self, r: "citem_locator_t") -> bool

ida_hexrays.citem_locator_t.__lt__(self, r: "citem_locator_t") -> bool

ida_hexrays.citem_locator_t.__ne__(self, r: "citem_locator_t") -> bool

ida_hexrays.citem_locator_t.compare(self, r: "citem_locator_t") -> int

ida_hexrays.citem_locator_t.ea
    citem address

ida_hexrays.citem_locator_t.op
    citem operation

ida_hexrays.citem_t

ida_hexrays.citem_t.__dbg_get_meminfo(self) -> str

ida_hexrays.citem_t.__dbg_get_registered_kind(self) -> int

ida_hexrays.citem_t.__init__(self, o: "ctype_t" = cot_empty)

ida_hexrays.citem_t._acquire_ownership(self, v, acquire)

ida_hexrays.citem_t._ensure_cond(self, ok, cond_str)

ida_hexrays.citem_t._ensure_no_obj(self, o, attr, attr_is_acquired)

ida_hexrays.citem_t._ensure_no_op(self)

ida_hexrays.citem_t._ensure_ownership_transferrable(self, v)

ida_hexrays.citem_t._get_op(self) -> "ctype_t"

ida_hexrays.citem_t._maybe_disown_and_deregister(self)

ida_hexrays.citem_t._meminfo(self)

ida_hexrays.citem_t._obj_id(self) -> "PyObject *"

ida_hexrays.citem_t._own_and_register(self)

ida_hexrays.citem_t._set_op(self, v: "ctype_t") -> None

ida_hexrays.citem_t.contains_expr(self, e: "cexpr_t") -> bool
    Does the item contain an expression?

ida_hexrays.citem_t.contains_label(self) -> bool
    Does the item contain a label?

ida_hexrays.citem_t.ea
    address that corresponds to the item. may be BADADDR

ida_hexrays.citem_t.find_closest_addr(self, _ea: ida_idaapi.ea_t) -> "citem_t *"

ida_hexrays.citem_t.find_parent_of(self, item: "citem_t") -> "citem_t *"
    Find parent of the specified item. 
            
    @param item: Item to find the parent of. The search will be performed among the children of the item pointed by `this`.
    @returns nullptr if not found

ida_hexrays.citem_t.index
    an index in cfunc_t::treeitems. meaningful only after print_func() 
            

ida_hexrays.citem_t.is_expr(self) -> bool
    Is an expression?

ida_hexrays.citem_t.label_num
    label number. -1 means no label. items of the expression types (cot_...) should not have labels at the final maturity level, but at the intermediate levels any ctree item may have a label. Labels must be unique. Usually they correspond to the basic block numbers. 
            

ida_hexrays.citem_t.op
    item type

ida_hexrays.citem_t.print1(self, func: "cfunc_t") -> None
    Print item into one line. 
            
    @param func: parent function. This argument is used to find out the referenced variable names.
    @returns length of the generated text.

ida_hexrays.citem_t.replace_by(self, o)

ida_hexrays.citem_t.swap(self, r: "citem_t") -> None
    Swap two citem_t.

ida_hexrays.citem_to_specific_type(self)
    cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 

ida_hexrays.clear_cached_cfuncs() -> None
    Flush all cached decompilation results.

ida_hexrays.cloop_t

ida_hexrays.cloop_t.__init__(self, *args)

ida_hexrays.cloop_t.assign(self, r: "cloop_t") -> "cloop_t &"

ida_hexrays.cloop_t.cleanup(self) -> None

ida_hexrays.close_hexrays_waitbox() -> None
    Close the waitbox displayed by the decompiler. Useful if DECOMP_NO_HIDE was used during decompilation. 
            

ida_hexrays.close_pseudocode(f: "TWidget *") -> bool
    Close pseudocode window. 
            
    @param f: pointer to window
    @returns false if failed

ida_hexrays.cnumber_t

ida_hexrays.cnumber_t.__eq__(self, r: "cnumber_t") -> bool

ida_hexrays.cnumber_t.__ge__(self, r: "cnumber_t") -> bool

ida_hexrays.cnumber_t.__gt__(self, r: "cnumber_t") -> bool

ida_hexrays.cnumber_t.__init__(self, _opnum: int = 0)

ida_hexrays.cnumber_t.__le__(self, r: "cnumber_t") -> bool

ida_hexrays.cnumber_t.__lt__(self, r: "cnumber_t") -> bool

ida_hexrays.cnumber_t.__ne__(self, r: "cnumber_t") -> bool

ida_hexrays.cnumber_t._print(self, type: "tinfo_t", parent: "citem_t" = None, nice_stroff: "bool *" = None) -> None

ida_hexrays.cnumber_t._value
    its value

ida_hexrays.cnumber_t.assign(self, v: "uint64", nbytes: int, sign: "type_sign_t") -> None
    Assign new value 
            
    @param v: new value
    @param nbytes: size of the new value in bytes
    @param sign: sign of the value

ida_hexrays.cnumber_t.compare(self, r: "cnumber_t") -> int

ida_hexrays.cnumber_t.nf
    how to represent it

ida_hexrays.cnumber_t.value(self, type: "tinfo_t") -> "uint64"
    Get value. This function will properly extend the number sign to 64bits depending on the type sign. 
            

ida_hexrays.codegen_t

ida_hexrays.codegen_t.__init__(self, *args, **kwargs)

ida_hexrays.codegen_t.analyze_prolog(self, fc: "qflow_chart_t", reachable: "bitset_t") -> "merror_t"
    Analyze prolog/epilog of the function to decompile. If prolog is found, allocate and fill 'mba->pi' structure. 
            
    @param fc: flow chart
    @param reachable: bitmap of reachable blocks
    @returns error code

ida_hexrays.codegen_t.clear(self) -> None

ida_hexrays.codegen_t.emit(self, *args) -> "minsn_t *"
    This function has the following signatures:
    
        0. emit(code: mcode_t, width: int, l: int, r: int, d: int, offsize: int) -> minsn_t *
        1. emit(code: mcode_t, l: const mop_t *, r: const mop_t *, d: const mop_t *) -> minsn_t *
    
    # 0: emit(code: mcode_t, width: int, l: int, r: int, d: int, offsize: int) -> minsn_t *
    
    Emit one microinstruction. The L, R, D arguments usually mean the register number. However, they depend on CODE. For example:
    * for m_goto and m_jcnd L is the target address
    * for m_ldc L is the constant value to load
    
    
    
    @returns created microinstruction. can be nullptr if the instruction got immediately optimized away.
    
    # 1: emit(code: mcode_t, l: const mop_t *, r: const mop_t *, d: const mop_t *) -> minsn_t *
    
    Emit one microinstruction. This variant accepts pointers to operands. It is more difficult to use but permits to create virtually any instruction. Operands may be nullptr when it makes sense. 
            

ida_hexrays.codegen_t.emit_micro_mvm(self, code: "mcode_t", dtype: "op_dtype_t", l: int, r: int, d: int, offsize: int) -> "minsn_t *"
    Emit one microinstruction. This variant takes a data type not a size. 
            

ida_hexrays.codegen_t.gen_micro(self) -> "merror_t"
    Generate microcode for one instruction. The instruction is in INSN 
            
    @returns MERR_OK - all ok MERR_BLOCK - all ok, need to switch to new block MERR_BADBLK - delete current block and continue other error codes are fatal

ida_hexrays.codegen_t.load_effective_address(self, n: int, flags: int = 0) -> "mreg_t"
    Generate microcode to calculate the address of a memory operand. 
            
    @param n: - number of INSN operand
    @param flags: - reserved for future use
    @returns register containing the operand address. mr_none - failed (not a memory operand)

ida_hexrays.codegen_t.load_operand(self, opnum: int, flags: int = 0) -> "mreg_t"
    Generate microcode to load one operand. 
            
    @param opnum: number of INSN operand
    @param flags: reserved for future use
    @returns register containing the operand.

ida_hexrays.codegen_t.microgen_completed(self) -> None
    This method is called when the microcode generation is done.

ida_hexrays.codegen_t.prepare_gen_micro(self) -> "merror_t"
    Setup internal data to handle new instruction. This method should be called before calling gen_micro(). Usually gen_micro() is called by the decompiler. You have to call this function explicitly only if you yourself call gen_micro(). The instruction is in INSN 
            
    @returns MERR_OK - all ok other error codes are fatal

ida_hexrays.codegen_t.store_operand(self, n: int, mop: "mop_t", flags: int = 0, outins: "minsn_t **" = None) -> bool
    Generate microcode to store an operand. In case of success an arbitrary number of instructions can be generated (and even no instruction if the source and target are the same) 
            
    @param n: - number of target INSN operand
    @param mop: - operand to be stored
    @param flags: - reserved for future use
    @param outins: - (OUT) the last generated instruction
    @returns success

ida_hexrays.convert_to_user_call(udc: "udcall_t", cdg: "codegen_t") -> "merror_t"
    try to generate user-defined call for an instruction 
            
    @returns Microcode error codes code: MERR_OK - user-defined call generated else - error (MERR_INSN == inacceptable udc.tif)

ida_hexrays.cot_add
    x + y

ida_hexrays.cot_asg
    x = y

ida_hexrays.cot_asgadd
    x += y

ida_hexrays.cot_asgband
    x &= y

ida_hexrays.cot_asgbor
    x |= y

ida_hexrays.cot_asgmul
    x *= y

ida_hexrays.cot_asgsdiv
    x /= y signed

ida_hexrays.cot_asgshl
    x <<= y

ida_hexrays.cot_asgsmod
    x %= y signed

ida_hexrays.cot_asgsshr
    x >>= y signed

ida_hexrays.cot_asgsub
    x -= y

ida_hexrays.cot_asgudiv
    x /= y unsigned

ida_hexrays.cot_asgumod
    x %= y unsigned

ida_hexrays.cot_asgushr
    x >>= y unsigned

ida_hexrays.cot_asgxor
    x ^= y

ida_hexrays.cot_band
    x & y

ida_hexrays.cot_bnot
    ~x

ida_hexrays.cot_bor
    x | y

ida_hexrays.cot_call
    x(...)

ida_hexrays.cot_cast
    (type)x

ida_hexrays.cot_comma
    x, y

ida_hexrays.cot_eq
    x == y int or fpu (see EXFL_FPOP)

ida_hexrays.cot_fadd
    x + y fp

ida_hexrays.cot_fdiv
    x / y fp

ida_hexrays.cot_fmul
    x * y fp

ida_hexrays.cot_fneg
    -x fp

ida_hexrays.cot_fnum
    fpc

ida_hexrays.cot_fsub
    x - y fp

ida_hexrays.cot_helper
    arbitrary name

ida_hexrays.cot_idx
    x[y]

ida_hexrays.cot_insn
    instruction in expression, internal representation only

ida_hexrays.cot_land
    x && y

ida_hexrays.cot_lnot
    !x

ida_hexrays.cot_lor
    x || y

ida_hexrays.cot_memptr
    x->m, access size in 'ptrsize'

ida_hexrays.cot_memref
    x.m

ida_hexrays.cot_mul
    x * y

ida_hexrays.cot_ne
    x != y int or fpu (see EXFL_FPOP)

ida_hexrays.cot_neg
    -x

ida_hexrays.cot_num
    n

ida_hexrays.cot_obj
    obj_ea

ida_hexrays.cot_postdec
    x-

ida_hexrays.cot_postinc
    x++

ida_hexrays.cot_predec
    -x

ida_hexrays.cot_preinc
    ++x

ida_hexrays.cot_ptr
    *x, access size in 'ptrsize'

ida_hexrays.cot_ref
    &x

ida_hexrays.cot_sdiv
    x / y signed

ida_hexrays.cot_sge
    x >= y signed or fpu (see EXFL_FPOP)

ida_hexrays.cot_sgt
    x > y signed or fpu (see EXFL_FPOP)

ida_hexrays.cot_shl
    x << y

ida_hexrays.cot_sizeof
    sizeof(x)

ida_hexrays.cot_sle
    x <= y signed or fpu (see EXFL_FPOP)

ida_hexrays.cot_slt
    x < y signed or fpu (see EXFL_FPOP)

ida_hexrays.cot_smod
    x % y signed

ida_hexrays.cot_sshr
    x >> y signed

ida_hexrays.cot_str
    string constant (user representation)

ida_hexrays.cot_sub
    x - y

ida_hexrays.cot_tern
    x ? y : z

ida_hexrays.cot_type
    arbitrary type

ida_hexrays.cot_udiv
    x / y unsigned

ida_hexrays.cot_uge
    x >= y unsigned

ida_hexrays.cot_ugt
    x > y unsigned

ida_hexrays.cot_ule
    x <= y unsigned

ida_hexrays.cot_ult
    x < y unsigned

ida_hexrays.cot_umod
    x % y unsigned

ida_hexrays.cot_ushr
    x >> y unsigned

ida_hexrays.cot_var
    v

ida_hexrays.cot_xor
    x ^ y

ida_hexrays.create_cfunc(mba: "mba_t") -> "cfuncptr_t"
    Create a new cfunc_t object. 
            
    @param mba: microcode object. After creating the cfunc object it takes the ownership of MBA.

ida_hexrays.create_empty_mba(mbr: "mba_ranges_t", hf: "hexrays_failure_t" = None) -> "mba_t *"
    Create an empty microcode object.

ida_hexrays.create_field_name(*args) -> str

ida_hexrays.create_helper(*args)
    Create a helper object..

ida_hexrays.create_typedef(*args) -> "tinfo_t"
    This function has the following signatures:
    
        0. create_typedef(name: str) -> tinfo_t
        1. create_typedef(n: int) -> tinfo_t
    
    # 0: create_typedef(name: str) -> tinfo_t
    
    Create a reference to a named type. 
            
    @returns type which refers to the specified name. For example, if name is "DWORD", the type info which refers to "DWORD" is created.
    
    # 1: create_typedef(n: int) -> tinfo_t
    
    Create a reference to an ordinal type. 
            
    @returns type which refers to the specified ordinal. For example, if n is 1, the type info which refers to ordinal type 1 is created.

ida_hexrays.creturn_t

ida_hexrays.creturn_t.__eq__(self, r: "creturn_t") -> bool

ida_hexrays.creturn_t.__ge__(self, r: "creturn_t") -> bool

ida_hexrays.creturn_t.__gt__(self, r: "creturn_t") -> bool

ida_hexrays.creturn_t.__init__(self)

ida_hexrays.creturn_t.__le__(self, r: "creturn_t") -> bool

ida_hexrays.creturn_t.__lt__(self, r: "creturn_t") -> bool

ida_hexrays.creturn_t.__ne__(self, r: "creturn_t") -> bool

ida_hexrays.creturn_t.compare(self, r: "creturn_t") -> int

ida_hexrays.cswitch_t

ida_hexrays.cswitch_t.__eq__(self, r: "cswitch_t") -> bool

ida_hexrays.cswitch_t.__ge__(self, r: "cswitch_t") -> bool

ida_hexrays.cswitch_t.__gt__(self, r: "cswitch_t") -> bool

ida_hexrays.cswitch_t.__init__(self)

ida_hexrays.cswitch_t.__le__(self, r: "cswitch_t") -> bool

ida_hexrays.cswitch_t.__lt__(self, r: "cswitch_t") -> bool

ida_hexrays.cswitch_t.__ne__(self, r: "cswitch_t") -> bool

ida_hexrays.cswitch_t.cases
    Switch cases: values and instructions.

ida_hexrays.cswitch_t.compare(self, r: "cswitch_t") -> int

ida_hexrays.cswitch_t.mvnf
    Maximal switch value and number format.

ida_hexrays.ctext_position_t

ida_hexrays.ctext_position_t.__eq__(self, r: "ctext_position_t") -> bool

ida_hexrays.ctext_position_t.__ge__(self, r: "ctext_position_t") -> bool

ida_hexrays.ctext_position_t.__gt__(self, r: "ctext_position_t") -> bool

ida_hexrays.ctext_position_t.__init__(self, _lnnum: int = -1, _x: int = 0, _y: int = 0)

ida_hexrays.ctext_position_t.__le__(self, r: "ctext_position_t") -> bool

ida_hexrays.ctext_position_t.__lt__(self, r: "ctext_position_t") -> bool

ida_hexrays.ctext_position_t.__ne__(self, r: "ctext_position_t") -> bool

ida_hexrays.ctext_position_t.compare(self, r: "ctext_position_t") -> int

ida_hexrays.ctext_position_t.in_ctree(self, hdrlines: int) -> bool
    Is the cursor in the variable/type declaration area? 
            
    @param hdrlines: Number of lines of the declaration area

ida_hexrays.ctext_position_t.lnnum
    Line number.

ida_hexrays.ctext_position_t.x
    x coordinate of the cursor within the window

ida_hexrays.ctext_position_t.y
    y coordinate of the cursor within the window 
            

ida_hexrays.cthrow_t

ida_hexrays.cthrow_t.__eq__(self, r: "cthrow_t") -> bool

ida_hexrays.cthrow_t.__ge__(self, r: "cthrow_t") -> bool

ida_hexrays.cthrow_t.__gt__(self, r: "cthrow_t") -> bool

ida_hexrays.cthrow_t.__init__(self)

ida_hexrays.cthrow_t.__le__(self, r: "cthrow_t") -> bool

ida_hexrays.cthrow_t.__lt__(self, r: "cthrow_t") -> bool

ida_hexrays.cthrow_t.__ne__(self, r: "cthrow_t") -> bool

ida_hexrays.cthrow_t.compare(self, r: "cthrow_t") -> int

ida_hexrays.ctree_anchor_t

ida_hexrays.ctree_anchor_t.__init__(self)

ida_hexrays.ctree_anchor_t.get_index(self) -> int

ida_hexrays.ctree_anchor_t.get_itp(self) -> "item_preciser_t"

ida_hexrays.ctree_anchor_t.is_blkcmt_anchor(self) -> bool

ida_hexrays.ctree_anchor_t.is_citem_anchor(self) -> bool

ida_hexrays.ctree_anchor_t.is_itp_anchor(self) -> bool

ida_hexrays.ctree_anchor_t.is_lvar_anchor(self) -> bool

ida_hexrays.ctree_anchor_t.is_valid_anchor(self) -> bool

ida_hexrays.ctree_item_t

ida_hexrays.ctree_item_t.__init__(self)

ida_hexrays.ctree_item_t._get_e(self) -> "cexpr_t *"

ida_hexrays.ctree_item_t._get_f(self) -> "cfunc_t *"

ida_hexrays.ctree_item_t._get_i(self) -> "cinsn_t *"

ida_hexrays.ctree_item_t._get_it(self) -> "citem_t *"

ida_hexrays.ctree_item_t._get_l(self) -> "lvar_t *"

ida_hexrays.ctree_item_t._print(self) -> None

ida_hexrays.ctree_item_t.citype
    Item type.

ida_hexrays.ctree_item_t.dstr(self) -> str

ida_hexrays.ctree_item_t.e
    VDI_EXPR: Expression.

ida_hexrays.ctree_item_t.e
    VDI_EXPR: Expression.

ida_hexrays.ctree_item_t.f
    VDI_FUNC: Function.

ida_hexrays.ctree_item_t.f
    VDI_FUNC: Function.

ida_hexrays.ctree_item_t.get_ea(self) -> ida_idaapi.ea_t
    Get address of the current item. Each ctree item has an address. 
            
    @returns BADADDR if failed

ida_hexrays.ctree_item_t.get_edm(self, parent: "tinfo_t") -> int
    Get type of an enum member. If the current item is a symbolic constant, this function will return information about it. 
            
    @param parent: pointer to buffer for the enum type.
    @returns member index or -1 if failed

ida_hexrays.ctree_item_t.get_label_num(self, gln_flags: int) -> int
    Get label number of the current item. 
            
    @param gln_flags: Combination of get_label_num control bits
    @returns -1 if failed or no label

ida_hexrays.ctree_item_t.get_lvar(self) -> "lvar_t *"
    Get pointer to local variable. If the current item is a local variable, this function will return pointer to its definition. 
            
    @returns nullptr if failed

ida_hexrays.ctree_item_t.get_udm(self, udm: "udm_t" = None, parent: "tinfo_t" = None, p_offset: "uint64 *" = None) -> int
    Get type of a structure field. If the current item is a structure/union field, this function will return information about it. 
            
    @param udm: pointer to buffer for the udt member info.
    @param parent: pointer to buffer for the struct/union type.
    @param p_offset: pointer to the offset in bits inside udt.
    @returns member index or -1 if failed Both output parameters can be nullptr.

ida_hexrays.ctree_item_t.i
    VDI_EXPR: Statement.

ida_hexrays.ctree_item_t.i
    VDI_EXPR: Statement.

ida_hexrays.ctree_item_t.is_citem(self) -> bool
    Is the current item is a ctree item?

ida_hexrays.ctree_item_t.l
    VDI_LVAR: Local variable.

ida_hexrays.ctree_item_t.l
    VDI_LVAR: Local variable.

ida_hexrays.ctree_item_t.loc
    VDI_TAIL: Line tail.

ida_hexrays.ctree_items_t

ida_hexrays.ctree_items_t.__eq__(self, r: "ctree_items_t") -> bool

ida_hexrays.ctree_items_t.__getitem__(self, i: "size_t") -> "citem_t *const &"

ida_hexrays.ctree_items_t.__init__(self, *args)

ida_hexrays.ctree_items_t.__len__(self) -> "size_t"

ida_hexrays.ctree_items_t.__ne__(self, r: "ctree_items_t") -> bool

ida_hexrays.ctree_items_t.__setitem__(self, i: "size_t", v: "citem_t") -> None

ida_hexrays.ctree_items_t._del(self, x: "citem_t") -> bool

ida_hexrays.ctree_items_t.add_unique(self, x: "citem_t") -> bool

ida_hexrays.ctree_items_t.append(self, x: "citem_t") -> None

ida_hexrays.ctree_items_t.at(self, _idx: "size_t") -> "citem_t *const &"

ida_hexrays.ctree_items_t.begin(self, *args) -> "qvector< citem_t * >::const_iterator"

ida_hexrays.ctree_items_t.capacity(self) -> "size_t"

ida_hexrays.ctree_items_t.clear(self) -> None

ida_hexrays.ctree_items_t.empty(self) -> bool

ida_hexrays.ctree_items_t.end(self, *args) -> "qvector< citem_t * >::const_iterator"

ida_hexrays.ctree_items_t.erase(self, *args) -> "qvector< citem_t * >::iterator"

ida_hexrays.ctree_items_t.extend(self, x: "ctree_items_t") -> None

ida_hexrays.ctree_items_t.extract(self) -> "citem_t **"

ida_hexrays.ctree_items_t.find(self, *args) -> "qvector< citem_t * >::const_iterator"

ida_hexrays.ctree_items_t.has(self, x: "citem_t") -> bool

ida_hexrays.ctree_items_t.inject(self, s: "citem_t **", len: "size_t") -> None

ida_hexrays.ctree_items_t.insert(self, it: "qvector< citem_t * >::iterator", x: "citem_t") -> "qvector< citem_t * >::iterator"

ida_hexrays.ctree_items_t.pop_back(self) -> None

ida_hexrays.ctree_items_t.push_back(self, *args) -> "citem_t *&"

ida_hexrays.ctree_items_t.qclear(self) -> None

ida_hexrays.ctree_items_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.ctree_items_t.resize(self, *args) -> None

ida_hexrays.ctree_items_t.size(self) -> "size_t"

ida_hexrays.ctree_items_t.swap(self, r: "ctree_items_t") -> None

ida_hexrays.ctree_items_t.truncate(self) -> None

ida_hexrays.ctree_parentee_t

ida_hexrays.ctree_parentee_t.__disown__(self)

ida_hexrays.ctree_parentee_t.__init__(self, post: bool = False)

ida_hexrays.ctree_parentee_t.recalc_parent_types(self) -> bool
    Recalculate type of parent nodes. If a node type has been changed, the visitor must recalculate all parent types, otherwise the ctree becomes inconsistent. If during this recalculation a parent node is added/deleted, this function returns true. In this case the traversal must be stopped because the information about parent nodes is stale. 
            
    @returns false-ok to continue the traversal, true-must stop.

ida_hexrays.ctree_visitor_t

ida_hexrays.ctree_visitor_t.__disown__(self)

ida_hexrays.ctree_visitor_t.__init__(self, _flags: int)

ida_hexrays.ctree_visitor_t.apply_to(self, item: "citem_t", parent: "citem_t") -> int
    Traverse ctree. The traversal will start at the specified item and continue until of one the visit_...() functions return a non-zero value. 
            
    @param item: root of the ctree to traverse
    @param parent: parent of the specified item. can be specified as nullptr.
    @returns 0 or a non-zero value returned by a visit_...() function

ida_hexrays.ctree_visitor_t.apply_to_exprs(self, item: "citem_t", parent: "citem_t") -> int
    Traverse only expressions. The traversal will start at the specified item and continue until of one the visit_...() functions return a non-zero value. 
            
    @param item: root of the ctree to traverse
    @param parent: parent of the specified item. can be specified as nullptr.
    @returns 0 or a non-zero value returned by a visit_...() function

ida_hexrays.ctree_visitor_t.bposvec
    Vector of block positions. Only cit_block and cit_try parents have the corresponding element in this vector. 
            

ida_hexrays.ctree_visitor_t.clr_prune(self) -> None
    Do not prune children. This is an internal function, no need to call it.

ida_hexrays.ctree_visitor_t.clr_restart(self) -> None
    Do not restart. This is an internal function, no need to call it.

ida_hexrays.ctree_visitor_t.cv_flags
    Ctree visitor property bits 
            

ida_hexrays.ctree_visitor_t.is_postorder(self) -> bool
    Should the leave...() functions be called?

ida_hexrays.ctree_visitor_t.leave_expr(self, arg0: "cexpr_t") -> int
    Visit an expression after having visited its children. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs post-order traserval, i.e. an item is visited after its children. 
            
    @returns 0 to continue the traversal, nonzero to stop.

ida_hexrays.ctree_visitor_t.leave_insn(self, arg0: "cinsn_t") -> int
    Visit a statement after having visited its children. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs post-order traserval, i.e. an item is visited after its children. 
            
    @returns 0 to continue the traversal, nonzero to stop.

ida_hexrays.ctree_visitor_t.maintain_parents(self) -> bool
    Should the parent information by maintained?

ida_hexrays.ctree_visitor_t.must_prune(self) -> bool
    Should the traversal skip the children of the current item?

ida_hexrays.ctree_visitor_t.must_restart(self) -> bool
    Should the traversal restart?

ida_hexrays.ctree_visitor_t.only_insns(self) -> bool
    Should all expressions be automatically pruned?

ida_hexrays.ctree_visitor_t.parent_expr(self) -> "cexpr_t *"
    Get parent of the current item as an expression.

ida_hexrays.ctree_visitor_t.parent_insn(self) -> "cinsn_t *"
    Get parent of the current item as a statement.

ida_hexrays.ctree_visitor_t.parents
    Vector of parents of the current item.

ida_hexrays.ctree_visitor_t.prune_now(self) -> None
    Prune children. This function may be called by a visitor() to skip all children of the current item. 
            

ida_hexrays.ctree_visitor_t.set_restart(self) -> None
    Restart the travesal. Meaningful only in apply_to_exprs()

ida_hexrays.ctree_visitor_t.visit_expr(self, arg0: "cexpr_t") -> int
    Visit an expression. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs pre-order traserval, i.e. an item is visited before its children. 
            
    @returns 0 to continue the traversal, nonzero to stop.

ida_hexrays.ctree_visitor_t.visit_insn(self, arg0: "cinsn_t") -> int
    Visit a statement. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs pre-order traserval, i.e. an item is visited before its children. 
            
    @returns 0 to continue the traversal, nonzero to stop.

ida_hexrays.ctry_t

ida_hexrays.ctry_t.__eq__(self, r: "ctry_t") -> bool

ida_hexrays.ctry_t.__ge__(self, r: "ctry_t") -> bool

ida_hexrays.ctry_t.__gt__(self, r: "ctry_t") -> bool

ida_hexrays.ctry_t.__init__(self, *args, **kwargs)

ida_hexrays.ctry_t.__le__(self, r: "ctry_t") -> bool

ida_hexrays.ctry_t.__lt__(self, r: "ctry_t") -> bool

ida_hexrays.ctry_t.__ne__(self, r: "ctry_t") -> bool

ida_hexrays.ctry_t.catchs
    "catch all", if present, must be the last element. wind-statements must have "catch all" and nothing else. 
            

ida_hexrays.ctry_t.compare(self, r: "ctry_t") -> int

ida_hexrays.ctry_t.is_wind
    Is C++ wind statement? (not part of the C++ language) MSVC generates code like the following to keep track of constructed objects and destroy them upon an exception. Example:
    // an object is constructed at this point __wind { // some other code that may throw an exception } __unwind { // this code is executed only if there was an exception // in the __wind block. normally here we destroy the object // after that the exception is passed to the // exception handler, regular control flow is interrupted here. } // regular logic continues here, if there were no exceptions // also the object's destructor is called 
            

ida_hexrays.ctry_t.new_state
    new state number (internal, MSVC related)

ida_hexrays.ctry_t.old_state
    old state number (internal, MSVC related)

ida_hexrays.cwhile_t

ida_hexrays.cwhile_t.__eq__(self, r: "cwhile_t") -> bool

ida_hexrays.cwhile_t.__ge__(self, r: "cwhile_t") -> bool

ida_hexrays.cwhile_t.__gt__(self, r: "cwhile_t") -> bool

ida_hexrays.cwhile_t.__init__(self)

ida_hexrays.cwhile_t.__le__(self, r: "cwhile_t") -> bool

ida_hexrays.cwhile_t.__lt__(self, r: "cwhile_t") -> bool

ida_hexrays.cwhile_t.__ne__(self, r: "cwhile_t") -> bool

ida_hexrays.cwhile_t.compare(self, r: "cwhile_t") -> int

ida_hexrays.debug_hexrays_ctree(level: int, msg: str) -> None

ida_hexrays.decompile(mbr: "mba_ranges_t", hf: "hexrays_failure_t" = None, decomp_flags: int = 0) -> "cfuncptr_t"
    Decompile a snippet or a function. 
            
    @param mbr: what to decompile
    @param hf: extended error information (if failed)
    @param decomp_flags: bitwise combination of decompile() flags... bits
    @returns pointer to the decompilation result (a reference counted pointer). nullptr if failed.

ida_hexrays.decompile(ea, hf = None, flags = 0)
    Decompile a snippet or a function. 
            
    @param hf: extended error information (if failed)
    @returns pointer to the decompilation result (a reference counted pointer). nullptr if failed.

ida_hexrays.decompile_func(pfn: "func_t *", hf: "hexrays_failure_t" = None, decomp_flags: int = 0) -> "cfuncptr_t"
    Decompile a function. Multiple decompilations of the same function return the same object. 
            
    @param pfn: pointer to function to decompile
    @param hf: extended error information (if failed)
    @param decomp_flags: bitwise combination of decompile() flags... bits
    @returns pointer to the decompilation result (a reference counted pointer). nullptr if failed.

ida_hexrays.decompile_many(outfile: str, funcaddrs: "uint64vec_t", flags: int) -> bool
    Batch decompilation. Decompile all or the specified functions 
            
    @param outfile: name of the output file
    @param funcaddrs: list of functions to decompile. If nullptr or empty, then decompile all nonlib functions
    @param flags: Batch decompilation bits
    @returns true if no internal error occurred and the user has not cancelled decompilation

ida_hexrays.dereference(e, ptrsize, is_float = False)
    Dereference a pointer. This function dereferences a pointer expression. It performs the following conversion: "ptr" => "*ptr" It can handle discrepancies in the pointer type and the access size. 
            
    @param e: expression to deference
    @param ptrsize: access size
    @returns dereferenced expression

ida_hexrays.dstr(tif: "tinfo_t") -> str
    Print the specified type info. This function can be used from a debugger by typing "tif->dstr()" 
            

ida_hexrays.dummy_ptrtype(ptrsize: int, isfp: bool) -> "tinfo_t"
    Generate a dummy pointer type 
            
    @param ptrsize: size of pointed object
    @param isfp: is floating point object?

ida_hexrays.eamap_begin(map: "eamap_t") -> "eamap_iterator_t"
    Get iterator pointing to the beginning of eamap_t.

ida_hexrays.eamap_clear(map: "eamap_t") -> None
    Clear eamap_t.

ida_hexrays.eamap_end(map: "eamap_t") -> "eamap_iterator_t"
    Get iterator pointing to the end of eamap_t.

ida_hexrays.eamap_erase(map: "eamap_t", p: "eamap_iterator_t") -> None
    Erase current element from eamap_t.

ida_hexrays.eamap_find(map: "eamap_t", key: "ea_t const &") -> "eamap_iterator_t"
    Find the specified key in eamap_t.

ida_hexrays.eamap_first(p: "eamap_iterator_t") -> "ea_t const &"
    Get reference to the current map key.

ida_hexrays.eamap_free(map: "eamap_t") -> None
    Delete eamap_t instance.

ida_hexrays.eamap_insert(map: "eamap_t", key: "ea_t const &", val: "cinsnptrvec_t") -> "eamap_iterator_t"
    Insert new (ea_t, cinsnptrvec_t) pair into eamap_t.

ida_hexrays.eamap_iterator_t

ida_hexrays.eamap_iterator_t.__eq__(self, p: "eamap_iterator_t") -> bool

ida_hexrays.eamap_iterator_t.__init__(self)

ida_hexrays.eamap_iterator_t.__ne__(self, p: "eamap_iterator_t") -> bool

ida_hexrays.eamap_new() -> "eamap_t *"
    Create a new eamap_t instance.

ida_hexrays.eamap_next(p: "eamap_iterator_t") -> "eamap_iterator_t"
    Move to the next element.

ida_hexrays.eamap_prev(p: "eamap_iterator_t") -> "eamap_iterator_t"
    Move to the previous element.

ida_hexrays.eamap_second(p: "eamap_iterator_t") -> "cinsnptrvec_t &"
    Get reference to the current map value.

ida_hexrays.eamap_size(map: "eamap_t") -> "size_t"
    Get size of eamap_t.

ida_hexrays.eamap_t

ida_hexrays.eamap_t.__init__(self)

ida_hexrays.eamap_t.at(self, _Keyval: "unsigned long long const &") -> "cinsnptrvec_t &"

ida_hexrays.eamap_t.size(self) -> "size_t"

ida_hexrays.fnumber_t

ida_hexrays.fnumber_t.__eq__(self, r: "fnumber_t") -> bool

ida_hexrays.fnumber_t.__ge__(self, r: "fnumber_t") -> bool

ida_hexrays.fnumber_t.__gt__(self, r: "fnumber_t") -> bool

ida_hexrays.fnumber_t.__init__(self)

ida_hexrays.fnumber_t.__le__(self, r: "fnumber_t") -> bool

ida_hexrays.fnumber_t.__lt__(self, r: "fnumber_t") -> bool

ida_hexrays.fnumber_t.__ne__(self, r: "fnumber_t") -> bool

ida_hexrays.fnumber_t._print(self) -> None

ida_hexrays.fnumber_t.calc_max_exp(self) -> int

ida_hexrays.fnumber_t.compare(self, r: "fnumber_t") -> int

ida_hexrays.fnumber_t.dereference_const_uint16(self) -> "uint16 const *"

ida_hexrays.fnumber_t.dereference_uint16(self) -> "uint16 *"

ida_hexrays.fnumber_t.fnum
    Internal representation of the number.

ida_hexrays.fnumber_t.is_nan(self) -> bool

ida_hexrays.fnumber_t.nbytes
    Original size of the constant in bytes.

ida_hexrays.gco_info_t

ida_hexrays.gco_info_t.__init__(self)

ida_hexrays.gco_info_t.append_to_list(self, list: "mlist_t", mba: "mba_t") -> bool
    Append operand info to LIST. This function converts IDA register number or stack offset to a decompiler list. 
            
    @param list: list to append to
    @param mba: microcode object

ida_hexrays.gco_info_t.cvt_to_ivl(self) -> "vivl_t"
    Convert operand info to VIVL. The returned VIVL can be used, for example, in a call of get_valranges(). 
            

ida_hexrays.gco_info_t.is_def(self) -> bool

ida_hexrays.gco_info_t.is_reg(self) -> bool

ida_hexrays.gco_info_t.is_use(self) -> bool

ida_hexrays.gco_info_t.name
    register or stkvar name

ida_hexrays.gco_info_t.regnum
    if register, the register id

ida_hexrays.gco_info_t.size
    operand size

ida_hexrays.gco_info_t.stkoff
    if stkvar, stack offset

ida_hexrays.gen_microcode(mbr: "mba_ranges_t", hf: "hexrays_failure_t" = None, retlist: "mlist_t" = None, decomp_flags: int = 0, reqmat: "mba_maturity_t" = MMAT_GLBOPT3) -> "mba_t *"
    Generate microcode of an arbitrary code snippet 
            
    @param mbr: snippet ranges
    @param hf: extended error information (if failed)
    @param retlist: list of registers the snippet returns
    @param decomp_flags: bitwise combination of decompile() flags... bits
    @param reqmat: required microcode maturity
    @returns pointer to the microcode, nullptr if failed.

ida_hexrays.get_ctype_name(op: "ctype_t") -> str

ida_hexrays.get_current_operand(out: "gco_info_t") -> bool
    Get the instruction operand under the cursor. This function determines the operand that is under the cursor in the active disassembly listing. If the operand refers to a register or stack variable, it returns true. 
            

ida_hexrays.get_float_type(width: int) -> "tinfo_t"
    Get a type of a floating point value with the specified width 
            
    @param width: width of the desired type
    @returns type info object

ida_hexrays.get_hexrays_version() -> str
    Get decompiler version. The returned string is of the form <major>.<minor>.<revision>.<build-date> 
            
    @returns pointer to version string. For example: "2.0.0.140605"

ida_hexrays.get_int_type_by_width_and_sign(srcwidth: int, sign: "type_sign_t") -> "tinfo_t"
    Create a type info by width and sign. Returns a simple type (examples: int, short) with the given width and sign. 
            
    @param srcwidth: size of the type in bytes
    @param sign: sign of the type

ida_hexrays.get_merror_desc(code: "merror_t", mba: "mba_t") -> str
    Get textual description of an error code 
            
    @param code: Microcode error codes
    @param mba: the microcode array
    @returns the error address

ida_hexrays.get_mreg_name(reg: "mreg_t", width: int, ud: "void *" = None) -> str
    Get the microregister name. 
            
    @param reg: microregister number
    @param width: size of microregister in bytes. may be bigger than the real register size.
    @param ud: reserved, must be nullptr
    @returns width of the printed register. this value may be less than the WIDTH argument.

ida_hexrays.get_op_signness(op: "ctype_t") -> "type_sign_t"
    Get operator sign. Meaningful for sign-dependent operators, like cot_sdiv.

ida_hexrays.get_signed_mcode(code: "mcode_t") -> "mcode_t"

ida_hexrays.get_temp_regs() -> "mlist_t const &"
    Get list of temporary registers. Tempregs are temporary registers that are used during code generation. They do not map to regular processor registers. They are used only to store temporary values during execution of one instruction. Tempregs may not be used to pass a value from one block to another. In other words, at the end of a block all tempregs must be dead. 
            

ida_hexrays.get_type(id: int, tif: "tinfo_t", guess: "type_source_t") -> bool
    Get a global type. Global types are types of addressable objects and struct/union/enum types 
            
    @param id: address or id of the object
    @param tif: buffer for the answer
    @param guess: what kind of types to consider
    @returns success

ida_hexrays.get_unk_type(size: int) -> "tinfo_t"
    Create a partial type info by width. Returns a partially defined type (examples: _DWORD, _BYTE) with the given width. 
            
    @param size: size of the type in bytes

ida_hexrays.get_unsigned_mcode(code: "mcode_t") -> "mcode_t"

ida_hexrays.get_widget_vdui(f: "TWidget *") -> "vdui_t *"
    Get the vdui_t instance associated to the TWidget 
            
    @param f: pointer to window
    @returns a vdui_t *, or nullptr

ida_hexrays.getb_reginsn(ins: "minsn_t") -> "minsn_t *"
    Skip assertions backward.

ida_hexrays.getf_reginsn(ins: "minsn_t") -> "minsn_t *"
    Skip assertions forward.

ida_hexrays.graph_chains_t

ida_hexrays.graph_chains_t.__init__(self)

ida_hexrays.graph_chains_t.acquire(self) -> None
    Lock the chains.

ida_hexrays.graph_chains_t.for_all_chains(self, cv: "chain_visitor_t", gca_flags: int) -> int
    Visit all chains 
            
    @param cv: chain visitor
    @param gca_flags: combination of GCA_ bits

ida_hexrays.graph_chains_t.is_locked(self) -> bool
    Are the chains locked? It is a good idea to lock the chains before using them. This ensures that they won't be recalculated and reallocated during the use. See the chain_keeper_t class for that. 
            

ida_hexrays.graph_chains_t.release(self) -> None
    Unlock the chains.

ida_hexrays.graph_chains_t.swap(self, r: "graph_chains_t") -> None

ida_hexrays.has_cached_cfunc(ea: ida_idaapi.ea_t) -> bool
    Do we have a cached decompilation result for 'ea'?

ida_hexrays.has_mcode_seloff(op: "mcode_t") -> bool

ida_hexrays.hexrays_alloc(size: "size_t") -> "void *"

ida_hexrays.hexrays_failure_t

ida_hexrays.hexrays_failure_t.__init__(self, *args)

ida_hexrays.hexrays_failure_t.code
    Microcode error codes

ida_hexrays.hexrays_failure_t.desc(self) -> str

ida_hexrays.hexrays_failure_t.errea
    associated address

ida_hexrays.hexrays_failure_t.str
    string information

ida_hexrays.hexrays_free(ptr: "void *") -> None

ida_hexrays.hexwarn_t

ida_hexrays.hexwarn_t.__eq__(self, r: "hexwarn_t") -> bool

ida_hexrays.hexwarn_t.__ge__(self, r: "hexwarn_t") -> bool

ida_hexrays.hexwarn_t.__gt__(self, r: "hexwarn_t") -> bool

ida_hexrays.hexwarn_t.__init__(self)

ida_hexrays.hexwarn_t.__le__(self, r: "hexwarn_t") -> bool

ida_hexrays.hexwarn_t.__lt__(self, r: "hexwarn_t") -> bool

ida_hexrays.hexwarn_t.__ne__(self, r: "hexwarn_t") -> bool

ida_hexrays.hexwarn_t.compare(self, r: "hexwarn_t") -> int

ida_hexrays.hexwarn_t.ea
    Address where the warning occurred.

ida_hexrays.hexwarn_t.id
    Warning id.

ida_hexrays.hexwarn_t.text
    Fully formatted text of the warning.

ida_hexrays.hexwarns_t

ida_hexrays.hexwarns_t.__eq__(self, r: "hexwarns_t") -> bool

ida_hexrays.hexwarns_t.__getitem__(self, i: "size_t") -> "hexwarn_t const &"

ida_hexrays.hexwarns_t.__init__(self, *args)

ida_hexrays.hexwarns_t.__len__(self) -> "size_t"

ida_hexrays.hexwarns_t.__ne__(self, r: "hexwarns_t") -> bool

ida_hexrays.hexwarns_t.__setitem__(self, i: "size_t", v: "hexwarn_t") -> None

ida_hexrays.hexwarns_t._del(self, x: "hexwarn_t") -> bool

ida_hexrays.hexwarns_t.add_unique(self, x: "hexwarn_t") -> bool

ida_hexrays.hexwarns_t.append(self, x: "hexwarn_t") -> None

ida_hexrays.hexwarns_t.at(self, _idx: "size_t") -> "hexwarn_t const &"

ida_hexrays.hexwarns_t.begin(self, *args) -> "qvector< hexwarn_t >::const_iterator"

ida_hexrays.hexwarns_t.capacity(self) -> "size_t"

ida_hexrays.hexwarns_t.clear(self) -> None

ida_hexrays.hexwarns_t.empty(self) -> bool

ida_hexrays.hexwarns_t.end(self, *args) -> "qvector< hexwarn_t >::const_iterator"

ida_hexrays.hexwarns_t.erase(self, *args) -> "qvector< hexwarn_t >::iterator"

ida_hexrays.hexwarns_t.extend(self, x: "hexwarns_t") -> None

ida_hexrays.hexwarns_t.extract(self) -> "hexwarn_t *"

ida_hexrays.hexwarns_t.find(self, *args) -> "qvector< hexwarn_t >::const_iterator"

ida_hexrays.hexwarns_t.grow(self, *args) -> None

ida_hexrays.hexwarns_t.has(self, x: "hexwarn_t") -> bool

ida_hexrays.hexwarns_t.inject(self, s: "hexwarn_t", len: "size_t") -> None

ida_hexrays.hexwarns_t.insert(self, it: "hexwarn_t", x: "hexwarn_t") -> "qvector< hexwarn_t >::iterator"

ida_hexrays.hexwarns_t.pop_back(self) -> None

ida_hexrays.hexwarns_t.push_back(self, *args) -> "hexwarn_t &"

ida_hexrays.hexwarns_t.qclear(self) -> None

ida_hexrays.hexwarns_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.hexwarns_t.resize(self, *args) -> None

ida_hexrays.hexwarns_t.size(self) -> "size_t"

ida_hexrays.hexwarns_t.swap(self, r: "hexwarns_t") -> None

ida_hexrays.hexwarns_t.truncate(self) -> None

ida_hexrays.history_item_t

ida_hexrays.history_item_t.__init__(self, *args)

ida_hexrays.history_item_t.curr_ea
    Current address.

ida_hexrays.history_item_t.end
    BADADDR-decompile a function; otherwise end of the range.

ida_hexrays.history_item_t.func_ea
    The entry address of the decompiled function.

ida_hexrays.history_t

ida_hexrays.history_t.__init__(self)

ida_hexrays.history_t.pop(self) -> "history_item_t"

ida_hexrays.history_t.push(self, v: "history_item_t") -> None

ida_hexrays.history_t.top(self, *args) -> "history_item_t &"

ida_hexrays.hxe_begin_inlining
    Starting to inline outlined functions. 
              

ida_hexrays.hxe_build_callinfo
    Analyzing a call instruction. 
              

ida_hexrays.hxe_callinfo_built
    A call instruction has been anallyzed. 
              

ida_hexrays.hxe_calls_done
    All calls have been analyzed. 
              

ida_hexrays.hxe_close_pseudocode
    Pseudocode view is being closed. 
              

ida_hexrays.hxe_cmt_changed
    Comment got changed. 
              

ida_hexrays.hxe_collect_warnings
    Collect warning messages from plugins. These warnings will be displayed at the function header, after the user-defined comments. 
              

ida_hexrays.hxe_combine
    Trying to combine instructions of basic block. 
              

ida_hexrays.hxe_create_hint
    Create a hint for the current item. 
              

ida_hexrays.hxe_curpos
    Current cursor position has been changed. (for example, by left-clicking or using keyboard)
    
              

ida_hexrays.hxe_double_click
    Mouse double click. 
              

ida_hexrays.hxe_flowchart
    Flowchart has been generated. 
              

ida_hexrays.hxe_func_printed
    Function text has been generated. Plugins may modify the text in cfunc_t::sv. However, it is too late to modify the ctree or microcode. The text uses regular color codes (see lines.hpp) COLOR_ADDR is used to store pointers to ctree items. 
              

ida_hexrays.hxe_glbopt
    Global optimization has been finished. If microcode is modified, MERR_LOOP must be returned. It will cause a complete restart of the optimization. 
              

ida_hexrays.hxe_inlined_func
    A set of ranges got inlined. 
              

ida_hexrays.hxe_inlining_func
    A set of ranges is going to be inlined. 
              

ida_hexrays.hxe_interr
    Internal error has occurred. 
              

ida_hexrays.hxe_keyboard
    Keyboard has been hit. 
              

ida_hexrays.hxe_locopt
    Basic block level optimization has been finished. 
              

ida_hexrays.hxe_maturity
    Ctree maturity level is being changed. 
              

ida_hexrays.hxe_microcode
    Microcode has been generated. 
              

ida_hexrays.hxe_open_pseudocode
    New pseudocode view has been opened. 
              

ida_hexrays.hxe_populating_popup
    Populating popup menu. We can add menu items now. 
              

ida_hexrays.hxe_pre_structural
    Structure analysis is starting. 
              

ida_hexrays.hxe_prealloc
    Local variables: preallocation step begins. 
              

ida_hexrays.hxe_preoptimized
    Microcode has been preoptimized. 
              

ida_hexrays.hxe_print_func
    Printing ctree and generating text. 
              

ida_hexrays.hxe_prolog
    Prolog analysis has been finished. 
              

ida_hexrays.hxe_refresh_pseudocode
    Existing pseudocode text has been refreshed. Adding/removing pseudocode lines is forbidden in this event. 
              

ida_hexrays.hxe_resolve_stkaddrs
    The optimizer is about to resolve stack addresses. 
              

ida_hexrays.hxe_right_click
    Mouse right click. Use hxe_populating_popup instead, in case you want to add items in the popup menu. 
              

ida_hexrays.hxe_stkpnts
    SP change points have been calculated. 
              

ida_hexrays.hxe_structural
    Structural analysis has been finished. 
              

ida_hexrays.hxe_switch_pseudocode
    Existing pseudocode view has been reloaded with a new function. Its text has not been refreshed yet, only cfunc and mba pointers are ready. 
              

ida_hexrays.hxe_text_ready
    Decompiled text is ready. 
              

ida_hexrays.init_hexrays_plugin(flags: int = 0) -> bool
    Check that your plugin is compatible with hex-rays decompiler. This function must be called before calling any other decompiler function. 
            
    @param flags: reserved, must be 0
    @returns true if the decompiler exists and is compatible with your plugin

ida_hexrays.install_hexrays_callback(callback)
    Install handler for decompiler events. 
            
    @param callback: handler to install
    @returns false if failed

ida_hexrays.install_microcode_filter(filter: "microcode_filter_t", install: bool = True) -> bool
    register/unregister non-standard microcode generator 
            
    @param filter: - microcode generator object
    @param install: - TRUE - register the object, FALSE - unregister
    @returns success

ida_hexrays.is_additive(op: "ctype_t") -> bool
    Is additive operator?

ida_hexrays.is_assignment(op: "ctype_t") -> bool
    Is assignment operator?

ida_hexrays.is_binary(op: "ctype_t") -> bool
    Is binary operator?

ida_hexrays.is_bitop(op: "ctype_t") -> bool
    Is bit related operator?

ida_hexrays.is_bool_type(type: "tinfo_t") -> bool
    Is a boolean type? 
            
    @returns true if the type is a boolean type

ida_hexrays.is_break_consumer(op: "ctype_t") -> bool
    Does a break statement influence the specified statement code?

ida_hexrays.is_cmpop_with_eq(cmpop: "cmpop_t") -> bool

ida_hexrays.is_cmpop_without_eq(cmpop: "cmpop_t") -> bool

ida_hexrays.is_commutative(op: "ctype_t") -> bool
    Is commutative operator?

ida_hexrays.is_inplace_def(type: "tinfo_t") -> bool
    Is struct/union/enum definition (not declaration)?

ida_hexrays.is_kreg(r: "mreg_t") -> bool
    Is a kernel register? Kernel registers are temporary registers that can be used freely. They may be used to store values that cross instruction or basic block boundaries. Kernel registers do not map to regular processor registers. See also mba_t::alloc_kreg() 
            

ida_hexrays.is_logical(op: "ctype_t") -> bool
    Is logical operator?

ida_hexrays.is_loop(op: "ctype_t") -> bool
    Is loop statement code?

ida_hexrays.is_lvalue(op: "ctype_t") -> bool
    Is Lvalue operator?

ida_hexrays.is_may_access(maymust: "maymust_t") -> bool

ida_hexrays.is_mcode_addsub(mcode: "mcode_t") -> bool

ida_hexrays.is_mcode_call(mcode: "mcode_t") -> bool

ida_hexrays.is_mcode_commutative(mcode: "mcode_t") -> bool

ida_hexrays.is_mcode_convertible_to_jmp(mcode: "mcode_t") -> bool

ida_hexrays.is_mcode_convertible_to_set(mcode: "mcode_t") -> bool

ida_hexrays.is_mcode_divmod(op: "mcode_t") -> bool

ida_hexrays.is_mcode_fpu(mcode: "mcode_t") -> bool

ida_hexrays.is_mcode_j1(mcode: "mcode_t") -> bool

ida_hexrays.is_mcode_jcond(mcode: "mcode_t") -> bool

ida_hexrays.is_mcode_propagatable(mcode: "mcode_t") -> bool
    May opcode be propagated? Such opcodes can be used in sub-instructions (nested instructions) There is a handful of non-propagatable opcodes, like jumps, ret, nop, etc All other regular opcodes are propagatable and may appear in a nested instruction. 
            

ida_hexrays.is_mcode_set(mcode: "mcode_t") -> bool

ida_hexrays.is_mcode_set1(mcode: "mcode_t") -> bool

ida_hexrays.is_mcode_shift(mcode: "mcode_t") -> bool

ida_hexrays.is_mcode_xdsu(mcode: "mcode_t") -> bool

ida_hexrays.is_multiplicative(op: "ctype_t") -> bool
    Is multiplicative operator?

ida_hexrays.is_nonbool_type(type: "tinfo_t") -> bool
    Is definitely a non-boolean type? 
            
    @returns true if the type is a non-boolean type (non bool and well defined)

ida_hexrays.is_paf(t: "type_t") -> bool
    Is a pointer, array, or function type?

ida_hexrays.is_prepost(op: "ctype_t") -> bool
    Is pre/post increment/decrement operator?

ida_hexrays.is_ptr_or_array(t: "type_t") -> bool
    Is a pointer or array type?

ida_hexrays.is_relational(op: "ctype_t") -> bool
    Is comparison operator?

ida_hexrays.is_signed_cmpop(cmpop: "cmpop_t") -> bool

ida_hexrays.is_signed_mcode(code: "mcode_t") -> bool

ida_hexrays.is_small_udt(tif: "tinfo_t") -> bool
    Is a small structure or union? 
            
    @returns true if the type is a small UDT (user defined type). Small UDTs fit into a register (or pair or registers) as a rule.

ida_hexrays.is_type_correct(ptr: "type_t const *") -> bool
    Verify a type string. 
            
    @returns true if type string is correct

ida_hexrays.is_unary(op: "ctype_t") -> bool
    Is unary operator?

ida_hexrays.is_unsigned_cmpop(cmpop: "cmpop_t") -> bool

ida_hexrays.is_unsigned_mcode(code: "mcode_t") -> bool

ida_hexrays.iterator

ida_hexrays.iterator.__eq__(self, n: "iterator") -> bool

ida_hexrays.iterator.__init__(self, n: int = -1)

ida_hexrays.iterator.__ne__(self, n: "iterator") -> bool

ida_hexrays.iterator.__ref__(self) -> int

ida_hexrays.ivl_t

ida_hexrays.ivl_t.__eq__(self, r: "ivl_t") -> bool

ida_hexrays.ivl_t.__ge__(self, r: "ivl_t") -> bool

ida_hexrays.ivl_t.__gt__(self, r: "ivl_t") -> bool

ida_hexrays.ivl_t.__init__(self, _off: int = 0, _size: int = 0)

ida_hexrays.ivl_t.__le__(self, r: "ivl_t") -> bool

ida_hexrays.ivl_t.__lt__(self, r: "ivl_t") -> bool

ida_hexrays.ivl_t.__ne__(self, r: "ivl_t") -> bool

ida_hexrays.ivl_t.clear(self) -> None

ida_hexrays.ivl_t.compare(self, r: "ivl_t") -> int

ida_hexrays.ivl_t.contains(self, off2: int) -> bool

ida_hexrays.ivl_t.dstr(self) -> str

ida_hexrays.ivl_t.empty(self) -> bool

ida_hexrays.ivl_t.extend_to_cover(self, r: "ivl_t") -> bool

ida_hexrays.ivl_t.includes(self, ivl: "ivl_t") -> bool

ida_hexrays.ivl_t.intersect(self, r: "ivl_t") -> None

ida_hexrays.ivl_t.overlap(self, ivl: "ivl_t") -> bool

ida_hexrays.ivl_with_name_t

ida_hexrays.ivl_with_name_t.__init__(self)

ida_hexrays.ivlset_t

ida_hexrays.ivlset_t.__eq__(self, r: "ivlset_t") -> bool

ida_hexrays.ivlset_t.__ge__(self, r: "ivlset_t") -> bool

ida_hexrays.ivlset_t.__gt__(self, r: "ivlset_t") -> bool

ida_hexrays.ivlset_t.__init__(self, *args)

ida_hexrays.ivlset_t.__le__(self, r: "ivlset_t") -> bool

ida_hexrays.ivlset_t.__lt__(self, r: "ivlset_t") -> bool

ida_hexrays.ivlset_t.__ne__(self, r: "ivlset_t") -> bool

ida_hexrays.ivlset_t._print(self) -> None

ida_hexrays.ivlset_t.add(self, *args) -> bool
    This function has the following signatures:
    
        0. add(ivl: const ivl_t &) -> bool
        1. add(ea: ida_idaapi.ea_t, size: asize_t) -> bool
        2. add(ivs: const ivlset_t &) -> bool
    
    # 0: add(ivl: const ivl_t &) -> bool
    
    
    # 1: add(ea: ida_idaapi.ea_t, size: asize_t) -> bool
    
    
    # 2: add(ivs: const ivlset_t &) -> bool

ida_hexrays.ivlset_t.addmasked(self, ivs: "ivlset_t", mask: "ivl_t") -> bool

ida_hexrays.ivlset_t.compare(self, r: "ivlset_t") -> int

ida_hexrays.ivlset_t.contains(self, off: int) -> bool

ida_hexrays.ivlset_t.count(self) -> "asize_t"

ida_hexrays.ivlset_t.dstr(self) -> str

ida_hexrays.ivlset_t.has_common(self, *args) -> bool
    This function has the following signatures:
    
        0. has_common(ivl: const ivl_t &, strict: bool=false) -> bool
        1. has_common(ivs: const ivlset_t &) -> bool
    
    # 0: has_common(ivl: const ivl_t &, strict: bool=false) -> bool
    
    
    # 1: has_common(ivs: const ivlset_t &) -> bool

ida_hexrays.ivlset_t.includes(self, ivs: "ivlset_t") -> bool

ida_hexrays.ivlset_t.intersect(self, ivs: "ivlset_t") -> bool

ida_hexrays.ivlset_t.sub(self, *args) -> bool
    This function has the following signatures:
    
        0. sub(ivl: const ivl_t &) -> bool
        1. sub(ea: ida_idaapi.ea_t, size: asize_t) -> bool
        2. sub(ivs: const ivlset_t &) -> bool
    
    # 0: sub(ivl: const ivl_t &) -> bool
    
    
    # 1: sub(ea: ida_idaapi.ea_t, size: asize_t) -> bool
    
    
    # 2: sub(ivs: const ivlset_t &) -> bool

ida_hexrays.jcnd2set(code: "mcode_t") -> "mcode_t"

ida_hexrays.lexcompare(a: "mop_t", b: "mop_t") -> int

ida_hexrays.lnot(e)
    Logically negate the specified expression. The specified expression will be logically negated. For example, "x == y" is converted into "x != y" by this function. 
            
    @param e: expression to negate. After the call, e must not be used anymore because it can be changed by the function. The function return value must be used to refer to the expression.
    @returns logically negated expression.

ida_hexrays.locate_lvar(out: "lvar_locator_t", func_ea: ida_idaapi.ea_t, varname: str) -> bool
    Find a variable by name. 
            
    @param out: output buffer for the variable locator
    @param func_ea: function start address
    @param varname: variable name
    @returns success Since VARNAME is not always enough to find the variable, it may decompile the function.

ida_hexrays.lvar_locator_t

ida_hexrays.lvar_locator_t.__eq__(self, r: "lvar_locator_t") -> bool

ida_hexrays.lvar_locator_t.__ge__(self, r: "lvar_locator_t") -> bool

ida_hexrays.lvar_locator_t.__gt__(self, r: "lvar_locator_t") -> bool

ida_hexrays.lvar_locator_t.__init__(self, *args)

ida_hexrays.lvar_locator_t.__le__(self, r: "lvar_locator_t") -> bool

ida_hexrays.lvar_locator_t.__lt__(self, r: "lvar_locator_t") -> bool

ida_hexrays.lvar_locator_t.__ne__(self, r: "lvar_locator_t") -> bool

ida_hexrays.lvar_locator_t.compare(self, r: "lvar_locator_t") -> int

ida_hexrays.lvar_locator_t.defea
    Definition address. Usually, this is the address of the instruction that initializes the variable. In some cases it can be a fictional address. 
            

ida_hexrays.lvar_locator_t.get_reg1(self) -> "mreg_t"
    Get the register number of the variable.

ida_hexrays.lvar_locator_t.get_reg2(self) -> "mreg_t"
    Get the number of the second register (works only for ALOC_REG2 lvars)

ida_hexrays.lvar_locator_t.get_scattered(self) -> "scattered_aloc_t &"
    Get information about scattered variable.

ida_hexrays.lvar_locator_t.get_stkoff(self) -> int
    Get offset of the varialbe in the stack frame. 
            
    @returns a non-negative value for stack variables. The value is an offset from the bottom of the stack frame in terms of vd-offsets. negative values mean error (not a stack variable)

ida_hexrays.lvar_locator_t.is_reg1(self) -> bool
    Is variable located on one register?

ida_hexrays.lvar_locator_t.is_reg2(self) -> bool
    Is variable located on two registers?

ida_hexrays.lvar_locator_t.is_reg_var(self) -> bool
    Is variable located on register(s)?

ida_hexrays.lvar_locator_t.is_scattered(self) -> bool
    Is variable scattered?

ida_hexrays.lvar_locator_t.is_stk_var(self) -> bool
    Is variable located on the stack?

ida_hexrays.lvar_locator_t.location
    Variable location.

ida_hexrays.lvar_mapping_begin(map: "lvar_mapping_t") -> "lvar_mapping_iterator_t"
    Get iterator pointing to the beginning of lvar_mapping_t.

ida_hexrays.lvar_mapping_clear(map: "lvar_mapping_t") -> None
    Clear lvar_mapping_t.

ida_hexrays.lvar_mapping_end(map: "lvar_mapping_t") -> "lvar_mapping_iterator_t"
    Get iterator pointing to the end of lvar_mapping_t.

ida_hexrays.lvar_mapping_erase(map: "lvar_mapping_t", p: "lvar_mapping_iterator_t") -> None
    Erase current element from lvar_mapping_t.

ida_hexrays.lvar_mapping_find(map: "lvar_mapping_t", key: "lvar_locator_t") -> "lvar_mapping_iterator_t"
    Find the specified key in lvar_mapping_t.

ida_hexrays.lvar_mapping_first(p: "lvar_mapping_iterator_t") -> "lvar_locator_t const &"
    Get reference to the current map key.

ida_hexrays.lvar_mapping_free(map: "lvar_mapping_t") -> None
    Delete lvar_mapping_t instance.

ida_hexrays.lvar_mapping_insert(map: "lvar_mapping_t", key: "lvar_locator_t", val: "lvar_locator_t") -> "lvar_mapping_iterator_t"
    Insert new (lvar_locator_t, lvar_locator_t) pair into lvar_mapping_t.

ida_hexrays.lvar_mapping_iterator_t

ida_hexrays.lvar_mapping_iterator_t.__eq__(self, p: "lvar_mapping_iterator_t") -> bool

ida_hexrays.lvar_mapping_iterator_t.__init__(self)

ida_hexrays.lvar_mapping_iterator_t.__ne__(self, p: "lvar_mapping_iterator_t") -> bool

ida_hexrays.lvar_mapping_new() -> "lvar_mapping_t *"
    Create a new lvar_mapping_t instance.

ida_hexrays.lvar_mapping_next(p: "lvar_mapping_iterator_t") -> "lvar_mapping_iterator_t"
    Move to the next element.

ida_hexrays.lvar_mapping_prev(p: "lvar_mapping_iterator_t") -> "lvar_mapping_iterator_t"
    Move to the previous element.

ida_hexrays.lvar_mapping_second(p: "lvar_mapping_iterator_t") -> "lvar_locator_t &"
    Get reference to the current map value.

ida_hexrays.lvar_mapping_size(map: "lvar_mapping_t") -> "size_t"
    Get size of lvar_mapping_t.

ida_hexrays.lvar_mapping_t

ida_hexrays.lvar_mapping_t.__init__(self)

ida_hexrays.lvar_mapping_t.at(self, _Keyval: "lvar_locator_t") -> "lvar_locator_t &"

ida_hexrays.lvar_mapping_t.size(self) -> "size_t"

ida_hexrays.lvar_ref_t

ida_hexrays.lvar_ref_t.__eq__(self, r: "lvar_ref_t") -> bool

ida_hexrays.lvar_ref_t.__ge__(self, r: "lvar_ref_t") -> bool

ida_hexrays.lvar_ref_t.__gt__(self, r: "lvar_ref_t") -> bool

ida_hexrays.lvar_ref_t.__init__(self, *args)

ida_hexrays.lvar_ref_t.__le__(self, r: "lvar_ref_t") -> bool

ida_hexrays.lvar_ref_t.__lt__(self, r: "lvar_ref_t") -> bool

ida_hexrays.lvar_ref_t.__ne__(self, r: "lvar_ref_t") -> bool

ida_hexrays.lvar_ref_t.compare(self, r: "lvar_ref_t") -> int

ida_hexrays.lvar_ref_t.idx
    index into mba->vars

ida_hexrays.lvar_ref_t.mba
    Pointer to the parent mba_t object. Since we need to access the 'mba->vars' array in order to retrieve the referenced variable, we keep a pointer to mba_t here. Note: this means this class and consequently mop_t, minsn_t, mblock_t are specific to a mba_t object and cannot migrate between them. fortunately this is not something we need to do. second, lvar_ref_t's appear only after MMAT_LVARS. 
            

ida_hexrays.lvar_ref_t.off
    offset from the beginning of the variable

ida_hexrays.lvar_ref_t.swap(self, r: "lvar_ref_t") -> None

ida_hexrays.lvar_ref_t.var(self) -> "lvar_t &"
    Retrieve the referenced variable.

ida_hexrays.lvar_saved_info_t

ida_hexrays.lvar_saved_info_t.__eq__(self, r: "lvar_saved_info_t") -> bool

ida_hexrays.lvar_saved_info_t.__init__(self)

ida_hexrays.lvar_saved_info_t.__ne__(self, r: "lvar_saved_info_t") -> bool

ida_hexrays.lvar_saved_info_t.clear_keep(self) -> None

ida_hexrays.lvar_saved_info_t.clr_nomap_lvar(self) -> None

ida_hexrays.lvar_saved_info_t.clr_noptr_lvar(self) -> None

ida_hexrays.lvar_saved_info_t.clr_split_lvar(self) -> None

ida_hexrays.lvar_saved_info_t.clr_unused_lvar(self) -> None

ida_hexrays.lvar_saved_info_t.cmt
    Comment.

ida_hexrays.lvar_saved_info_t.flags
    saved user lvar info property bits 
            

ida_hexrays.lvar_saved_info_t.has_info(self) -> bool

ida_hexrays.lvar_saved_info_t.is_kept(self) -> bool

ida_hexrays.lvar_saved_info_t.is_nomap_lvar(self) -> bool

ida_hexrays.lvar_saved_info_t.is_noptr_lvar(self) -> bool

ida_hexrays.lvar_saved_info_t.is_split_lvar(self) -> bool

ida_hexrays.lvar_saved_info_t.is_unused_lvar(self) -> bool

ida_hexrays.lvar_saved_info_t.ll
    Variable locator.

ida_hexrays.lvar_saved_info_t.name
    Name.

ida_hexrays.lvar_saved_info_t.set_keep(self) -> None

ida_hexrays.lvar_saved_info_t.set_nomap_lvar(self) -> None

ida_hexrays.lvar_saved_info_t.set_noptr_lvar(self) -> None

ida_hexrays.lvar_saved_info_t.set_split_lvar(self) -> None

ida_hexrays.lvar_saved_info_t.set_unused_lvar(self) -> None

ida_hexrays.lvar_saved_info_t.size
    Type size (if not initialized then -1)

ida_hexrays.lvar_saved_info_t.type
    Type.

ida_hexrays.lvar_saved_infos_t

ida_hexrays.lvar_saved_infos_t.__eq__(self, r: "lvar_saved_infos_t") -> bool

ida_hexrays.lvar_saved_infos_t.__getitem__(self, i: "size_t") -> "lvar_saved_info_t const &"

ida_hexrays.lvar_saved_infos_t.__init__(self, *args)

ida_hexrays.lvar_saved_infos_t.__len__(self) -> "size_t"

ida_hexrays.lvar_saved_infos_t.__ne__(self, r: "lvar_saved_infos_t") -> bool

ida_hexrays.lvar_saved_infos_t.__setitem__(self, i: "size_t", v: "lvar_saved_info_t") -> None

ida_hexrays.lvar_saved_infos_t._del(self, x: "lvar_saved_info_t") -> bool

ida_hexrays.lvar_saved_infos_t.add_unique(self, x: "lvar_saved_info_t") -> bool

ida_hexrays.lvar_saved_infos_t.append(self, x: "lvar_saved_info_t") -> None

ida_hexrays.lvar_saved_infos_t.at(self, _idx: "size_t") -> "lvar_saved_info_t const &"

ida_hexrays.lvar_saved_infos_t.begin(self, *args) -> "qvector< lvar_saved_info_t >::const_iterator"

ida_hexrays.lvar_saved_infos_t.capacity(self) -> "size_t"

ida_hexrays.lvar_saved_infos_t.clear(self) -> None

ida_hexrays.lvar_saved_infos_t.empty(self) -> bool

ida_hexrays.lvar_saved_infos_t.end(self, *args) -> "qvector< lvar_saved_info_t >::const_iterator"

ida_hexrays.lvar_saved_infos_t.erase(self, *args) -> "qvector< lvar_saved_info_t >::iterator"

ida_hexrays.lvar_saved_infos_t.extend(self, x: "lvar_saved_infos_t") -> None

ida_hexrays.lvar_saved_infos_t.extract(self) -> "lvar_saved_info_t *"

ida_hexrays.lvar_saved_infos_t.find(self, *args) -> "qvector< lvar_saved_info_t >::const_iterator"

ida_hexrays.lvar_saved_infos_t.grow(self, *args) -> None

ida_hexrays.lvar_saved_infos_t.has(self, x: "lvar_saved_info_t") -> bool

ida_hexrays.lvar_saved_infos_t.inject(self, s: "lvar_saved_info_t", len: "size_t") -> None

ida_hexrays.lvar_saved_infos_t.insert(self, it: "lvar_saved_info_t", x: "lvar_saved_info_t") -> "qvector< lvar_saved_info_t >::iterator"

ida_hexrays.lvar_saved_infos_t.pop_back(self) -> None

ida_hexrays.lvar_saved_infos_t.push_back(self, *args) -> "lvar_saved_info_t &"

ida_hexrays.lvar_saved_infos_t.qclear(self) -> None

ida_hexrays.lvar_saved_infos_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.lvar_saved_infos_t.resize(self, *args) -> None

ida_hexrays.lvar_saved_infos_t.size(self) -> "size_t"

ida_hexrays.lvar_saved_infos_t.swap(self, r: "lvar_saved_infos_t") -> None

ida_hexrays.lvar_saved_infos_t.truncate(self) -> None

ida_hexrays.lvar_t

ida_hexrays.lvar_t.__init__(self, *args, **kwargs)

ida_hexrays.lvar_t.accepts_type(self, t: "tinfo_t", may_change_thisarg: bool = False) -> bool
    Check if the variable accept the specified type. Some types are forbidden (void, function types, wrong arrays, etc) 
            

ida_hexrays.lvar_t.append_list(self, mba: "mba_t", lst: "mlist_t", pad_if_scattered: bool = False) -> None
    Append local variable to mlist. 
            
    @param mba: ptr to the current mba_t
    @param lst: list to append to
    @param pad_if_scattered: if true, append padding bytes in case of scattered lvar

ida_hexrays.lvar_t.clear_used(self) -> None

ida_hexrays.lvar_t.clr_arg_var(self) -> None

ida_hexrays.lvar_t.clr_automapped(self) -> None

ida_hexrays.lvar_t.clr_decl_unused(self) -> None

ida_hexrays.lvar_t.clr_dummy_arg(self) -> None

ida_hexrays.lvar_t.clr_fake_var(self) -> None

ida_hexrays.lvar_t.clr_floating_var(self) -> None

ida_hexrays.lvar_t.clr_mapdst_var(self) -> None

ida_hexrays.lvar_t.clr_mreg_done(self) -> None

ida_hexrays.lvar_t.clr_noptr_var(self) -> None

ida_hexrays.lvar_t.clr_notarg(self) -> None

ida_hexrays.lvar_t.clr_overlapped_var(self) -> None

ida_hexrays.lvar_t.clr_scattered_arg(self) -> None

ida_hexrays.lvar_t.clr_shared(self) -> None

ida_hexrays.lvar_t.clr_split_var(self) -> None

ida_hexrays.lvar_t.clr_spoiled_var(self) -> None

ida_hexrays.lvar_t.clr_thisarg(self) -> None

ida_hexrays.lvar_t.clr_unknown_width(self) -> None

ida_hexrays.lvar_t.clr_used_byref(self) -> None

ida_hexrays.lvar_t.clr_user_info(self) -> None

ida_hexrays.lvar_t.clr_user_name(self) -> None

ida_hexrays.lvar_t.clr_user_type(self) -> None

ida_hexrays.lvar_t.cmt
    variable comment string

ida_hexrays.lvar_t.defblk
    first block defining the variable. 0 for args, -1 if unknown 
            

ida_hexrays.lvar_t.divisor
    max known divisor of the variable

ida_hexrays.lvar_t.has_common(self, v: "lvar_t") -> bool
    Do variables overlap?

ida_hexrays.lvar_t.has_common_bit(self, loc: "vdloc_t", width2: "asize_t") -> bool
    Does the variable overlap with the specified location?

ida_hexrays.lvar_t.has_nice_name(self) -> bool
    Does the variable have a nice name?

ida_hexrays.lvar_t.has_regname(self) -> bool
    Has a register name? (like _RAX)

ida_hexrays.lvar_t.has_user_info(self) -> bool
    Has any user-defined information?

ida_hexrays.lvar_t.has_user_name(self) -> bool
    Has user-defined name?

ida_hexrays.lvar_t.has_user_type(self) -> bool
    Has user-defined type?

ida_hexrays.lvar_t.in_asm(self) -> bool
    Is variable used in an instruction translated into __asm?

ida_hexrays.lvar_t.is_aliasable(self, mba: "mba_t") -> bool
    Is the variable aliasable? 
            
    @param mba: ptr to the current mba_t Aliasable variables may be modified indirectly (through a pointer)

ida_hexrays.lvar_t.is_arg_var(self) -> bool
    Is the function argument?

ida_hexrays.lvar_t.is_automapped(self) -> bool
    Was the variable automatically mapped to another variable?

ida_hexrays.lvar_t.is_decl_unused(self) -> bool
    Was declared as __unused by the user? See CVAR_UNUSED.

ida_hexrays.lvar_t.is_dummy_arg(self) -> bool
    Is a dummy argument (added to fill a hole in the argument list)

ida_hexrays.lvar_t.is_fake_var(self) -> bool
    Is fake return variable?

ida_hexrays.lvar_t.is_floating_var(self) -> bool
    Used by a fpu insn?

ida_hexrays.lvar_t.is_mapdst_var(self) -> bool
    Other variable(s) map to this var?

ida_hexrays.lvar_t.is_noptr_var(self) -> bool
    Variable type should not be a pointer.

ida_hexrays.lvar_t.is_notarg(self) -> bool
    Is a local variable? (local variable cannot be an input argument)

ida_hexrays.lvar_t.is_overlapped_var(self) -> bool
    Is overlapped variable?

ida_hexrays.lvar_t.is_result_var(self) -> bool
    Is the function result?

ida_hexrays.lvar_t.is_shared(self) -> bool
    Is lvar mapped to several chains.

ida_hexrays.lvar_t.is_split_var(self) -> bool
    Is a split variable?

ida_hexrays.lvar_t.is_spoiled_var(self) -> bool
    Is spoiled var? (meaningful only during lvar allocation)

ida_hexrays.lvar_t.is_thisarg(self) -> bool
    Is 'this' argument of a C++ member function?

ida_hexrays.lvar_t.is_unknown_width(self) -> bool
    Do we know the width of the variable?

ida_hexrays.lvar_t.is_used_byref(self) -> bool
    Was the address of the variable taken?

ida_hexrays.lvar_t.mreg_done(self) -> bool
    Have corresponding microregs been replaced by references to this variable?

ida_hexrays.lvar_t.name
    variable name. use mba_t::set_nice_lvar_name() and mba_t::set_user_lvar_name() to modify it 
            

ida_hexrays.lvar_t.set_arg_var(self) -> None

ida_hexrays.lvar_t.set_automapped(self) -> None

ida_hexrays.lvar_t.set_decl_unused(self) -> None

ida_hexrays.lvar_t.set_dummy_arg(self) -> None

ida_hexrays.lvar_t.set_fake_var(self) -> None

ida_hexrays.lvar_t.set_final_lvar_type(self, t: "tinfo_t") -> None
    Set final variable type.

ida_hexrays.lvar_t.set_floating_var(self) -> None

ida_hexrays.lvar_t.set_lvar_type(self, t: "tinfo_t", may_fail: bool = False) -> bool
    Set variable type Note: this function does not modify the idb, only the lvar instance in the memory. For permanent changes see modify_user_lvars() Also, the variable type is not considered as final by the decompiler and may be modified later by the type derivation. In some cases set_final_var_type() may work better, but it does not do persistent changes to the database neither. 
            
    @param t: new type
    @param may_fail: if false and type is bad, interr
    @returns success

ida_hexrays.lvar_t.set_mapdst_var(self) -> None

ida_hexrays.lvar_t.set_mreg_done(self) -> None

ida_hexrays.lvar_t.set_non_typed(self) -> None

ida_hexrays.lvar_t.set_noptr_var(self) -> None

ida_hexrays.lvar_t.set_notarg(self) -> None

ida_hexrays.lvar_t.set_overlapped_var(self) -> None

ida_hexrays.lvar_t.set_scattered_arg(self) -> None

ida_hexrays.lvar_t.set_shared(self) -> None

ida_hexrays.lvar_t.set_split_var(self) -> None

ida_hexrays.lvar_t.set_spoiled_var(self) -> None

ida_hexrays.lvar_t.set_thisarg(self) -> None

ida_hexrays.lvar_t.set_typed(self) -> None

ida_hexrays.lvar_t.set_unknown_width(self) -> None

ida_hexrays.lvar_t.set_used(self) -> None

ida_hexrays.lvar_t.set_used_byref(self) -> None

ida_hexrays.lvar_t.set_user_name(self) -> None

ida_hexrays.lvar_t.set_user_type(self) -> None

ida_hexrays.lvar_t.set_width(self, w: int, svw_flags: int = 0) -> bool
    Change the variable width. We call the variable size 'width', it is represents the number of bytes. This function may change the variable type using set_lvar_type(). 
            
    @param w: new width
    @param svw_flags: combination of SVW_... bits
    @returns success

ida_hexrays.lvar_t.tif
    variable type

ida_hexrays.lvar_t.type(self) -> "tinfo_t &"
    Get variable type.

ida_hexrays.lvar_t.typed(self) -> bool
    Has the variable a type?

ida_hexrays.lvar_t.used(self) -> bool
    Is the variable used in the code?

ida_hexrays.lvar_t.was_scattered_arg(self) -> bool
    Was lvar transformed from a scattered argument?

ida_hexrays.lvar_t.width
    variable size in bytes

ida_hexrays.lvar_uservec_t

ida_hexrays.lvar_uservec_t.__init__(self)

ida_hexrays.lvar_uservec_t.clear(self) -> None

ida_hexrays.lvar_uservec_t.empty(self) -> bool

ida_hexrays.lvar_uservec_t.find_info(self, vloc: "lvar_locator_t") -> "lvar_saved_info_t *"
    find saved user settings for given var

ida_hexrays.lvar_uservec_t.keep_info(self, v: "lvar_t") -> None
    Preserve user settings for given var.

ida_hexrays.lvar_uservec_t.lmaps
    Local variable mapping (used for merging variables)

ida_hexrays.lvar_uservec_t.lvvec
    User-specified names, types, comments for lvars. Variables without user-specified info are not present in this vector. 
            

ida_hexrays.lvar_uservec_t.stkoff_delta
    Delta to add to IDA stack offset to calculate Hex-Rays stack offsets. Should be set by the caller before calling save_user_lvar_settings(); 
            

ida_hexrays.lvar_uservec_t.swap(self, r: "lvar_uservec_t") -> None

ida_hexrays.lvar_uservec_t.ulv_flags
    Various flags. Possible values are from lvar_uservec_t property bits.

ida_hexrays.lvars_t

ida_hexrays.lvars_t.__init__(self)

ida_hexrays.lvars_t.find(self, ll: "lvar_locator_t") -> "lvar_t *"
    Find a variable at the specified location. 
            
    @param ll: variable location
    @returns pointer to variable or nullptr

ida_hexrays.lvars_t.find_input_lvar(self, argloc: "vdloc_t", _size: int) -> int
    Find an input variable at the specified location. 
            
    @param argloc: variable location
    @param _size: variable size in bytes
    @returns -1 if failed, otherwise an index into 'vars'

ida_hexrays.lvars_t.find_input_reg(self, reg: int, _size: int = 1) -> int
    Find an input register variable. 
            
    @param reg: register to find
    @param _size: variable size in bytes
    @returns -1 if failed, otherwise an index into 'vars'

ida_hexrays.lvars_t.find_lvar(self, location: "vdloc_t", width: int, defblk: int = -1) -> int
    Find a variable at the specified location. 
            
    @param location: variable location
    @param width: variable size in bytes
    @param defblk: definition block of the lvar. -1 means any block
    @returns -1 if failed, otherwise an index into 'vars'

ida_hexrays.lvars_t.find_stkvar(self, spoff: int, width: int) -> int
    Find a stack variable at the specified location. 
            
    @param spoff: offset from the minimal sp
    @param width: variable size in bytes
    @returns -1 if failed, otherwise an index into 'vars'

ida_hexrays.lxe_lvar_cmt_changed
    Local variable comment got changed. 
              

ida_hexrays.lxe_lvar_mapping_changed
    Local variable mapping got changed. 
              

ida_hexrays.lxe_lvar_name_changed
    Local variable got renamed. 
              

ida_hexrays.lxe_lvar_type_changed
    Local variable type got changed. 
              

ida_hexrays.make_num(*args)
    Create a number expression 
            
    @param n: value
    @param func: current function
    @param ea: definition address of the number
    @param opnum: operand number of the number (in the disassembly listing)
    @param sign: number sign
    @param size: size of number in bytes Please note that the type of the resulting expression can be anything because it can be inherited from the disassembly listing or taken from the user specified number representation in the pseudocode view.

ida_hexrays.make_pointer(type: "tinfo_t") -> "tinfo_t"
    Create a pointer type. This function performs the following conversion: "type" -> "type*" 
            
    @param type: object type.
    @returns "type*". for example, if 'char' is passed as the argument,

ida_hexrays.make_ref(e)
    Create a reference. This function performs the following conversion: "obj" => "&obj". It can handle casts, annihilate "&*", and process other special cases. 
            

ida_hexrays.mark_cfunc_dirty(ea: ida_idaapi.ea_t, close_views: bool = False) -> bool
    Flush the cached decompilation results. Erases a cache entry for the specified function. 
            
    @param ea: function to erase from the cache
    @param close_views: close pseudocode windows that show the function
    @returns if a cache entry existed.

ida_hexrays.max_vlr_svalue(size: int) -> "uvlr_t"

ida_hexrays.max_vlr_value(size: int) -> "uvlr_t"

ida_hexrays.mba_range_iterator_t

ida_hexrays.mba_range_iterator_t.__init__(self)

ida_hexrays.mba_range_iterator_t.chunk(self) -> "range_t const &"

ida_hexrays.mba_range_iterator_t.is_snippet(self) -> bool

ida_hexrays.mba_range_iterator_t.next(self) -> bool

ida_hexrays.mba_range_iterator_t.set(self, mbr: "mba_ranges_t") -> bool

ida_hexrays.mba_ranges_t

ida_hexrays.mba_ranges_t.__init__(self, *args)

ida_hexrays.mba_ranges_t.clear(self) -> None

ida_hexrays.mba_ranges_t.empty(self) -> bool

ida_hexrays.mba_ranges_t.is_fragmented(self) -> bool

ida_hexrays.mba_ranges_t.is_snippet(self) -> bool

ida_hexrays.mba_ranges_t.pfn
    function to decompile. if not null, then function mode.

ida_hexrays.mba_ranges_t.ranges
    snippet mode: ranges to decompile. function mode: list of outlined ranges 
            

ida_hexrays.mba_ranges_t.start(self) -> ida_idaapi.ea_t

ida_hexrays.mba_t
    Deprecated. Please do not use.

ida_hexrays.mba_t.__init__(self, *args, **kwargs)

ida_hexrays.mba_t._deregister(self) -> None

ida_hexrays.mba_t._print(self, vp: "vd_printer_t") -> None

ida_hexrays.mba_t._register(self) -> None

ida_hexrays.mba_t.aliased_memory
    aliased_memory+restricted_memory=ALLMEM

ida_hexrays.mba_t.alloc_fict_ea(self, real_ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Allocate a fictional address. This function can be used to allocate a new unique address for a new instruction, if re-using any existing address leads to conflicts. For example, if the last instruction of the function modifies R0 and falls through to the next function, it will be a tail call: LDM R0!, {R4,R7} end of the function start of another function In this case R0 generates two different lvars at the same address:
    * one modified by LDM
    * another that represents the return value from the tail call
    
    
    Another example: a third-party plugin makes a copy of an instruction. This may lead to the generation of two variables at the same address. Example 3: fictional addresses can be used for new instructions created while modifying the microcode. This function can be used to allocate a new unique address for a new instruction or a variable. The fictional address is selected from an unallocated address range. 
            
    @param real_ea: real instruction address (BADADDR is ok too)
    @returns a unique fictional address

ida_hexrays.mba_t.alloc_kreg(self, size: "size_t", check_size: bool = True) -> "mreg_t"
    Allocate a kernel register. 
            
    @param size: size of the register in bytes
    @param check_size: if true, only the sizes that correspond to a size of a basic type will be accepted.
    @returns allocated register. mr_none means failure.

ida_hexrays.mba_t.alloc_lvars(self) -> None
    Allocate local variables. Must be called only immediately after optimize_global(), with no modifications to the microcode. Converts registers, stack variables, and similar operands into mop_l. This call will not fail because all necessary checks were performed in optimize_global(). After this call the microcode reaches its final state. 
            

ida_hexrays.mba_t.analyze_calls(self, acflags: int) -> int
    Analyze calls and determine calling conventions. 
            
    @param acflags: permitted actions that are necessary for successful detection of calling conventions. See Bits for analyze_calls()
    @returns number of calls. -1 means error.

ida_hexrays.mba_t.arg(self, n: int) -> "lvar_t &"
    Get input argument of the decompiled function. 
            
    @param n: argument number (0..nargs-1)

ida_hexrays.mba_t.argbase(self) -> int

ida_hexrays.mba_t.argidx
    input arguments (indexes into 'vars')

ida_hexrays.mba_t.argidx_ok(self) -> bool

ida_hexrays.mba_t.argidx_sorted(self) -> bool

ida_hexrays.mba_t.bad_call_sp_detected(self) -> bool

ida_hexrays.mba_t.blocks
    double linked list of blocks

ida_hexrays.mba_t.build_graph(self) -> "merror_t"
    Build control flow graph. This function may be called only once. It calculates the type of each basic block and the adjacency list. optimize_local() calls this function if necessary. You need to call this function only before MMAT_LOCOPT. 
            
    @returns error code

ida_hexrays.mba_t.calc_shins_flags(self) -> int

ida_hexrays.mba_t.callinfo_built(self) -> bool

ida_hexrays.mba_t.cc
    calling convention

ida_hexrays.mba_t.chain_varnums_ok(self) -> bool

ida_hexrays.mba_t.clr_cdtr(self) -> None

ida_hexrays.mba_t.clr_mba_flags(self, f: int) -> None

ida_hexrays.mba_t.clr_mba_flags2(self, f: int) -> None

ida_hexrays.mba_t.code16_bit_removed(self) -> bool

ida_hexrays.mba_t.common_stkvars_stkargs(self) -> bool

ida_hexrays.mba_t.consumed_argregs
    registers converted into stack arguments, should not be used as arguments

ida_hexrays.mba_t.copy_block(self, blk: "mblock_t", new_serial: int, cpblk_flags: int = 3) -> "mblock_t *"
    Make a copy of a block. This function makes a simple copy of the block. It does not fix the predecessor and successor lists, they must be fixed if necessary. 
            
    @param blk: block to copy
    @param new_serial: position of the copied block
    @param cpblk_flags: combination of Batch decompilation bits... bits
    @returns pointer to the new copy

ida_hexrays.mba_t.create_helper_call(self, ea: ida_idaapi.ea_t, helper: str, rettype: "tinfo_t" = None, callargs: "mcallargs_t" = None, out: "mop_t" = None) -> "minsn_t *"
    Create a call of a helper function. 
            
    @param ea: The desired address of the instruction
    @param helper: The helper name
    @param rettype: The return type (nullptr or empty type means 'void')
    @param callargs: The helper arguments (nullptr-no arguments)
    @param out: The operand where the call result should be stored. If this argument is not nullptr, "mov helper_call(), out" will be generated. Otherwise "call helper()" will be generated. Note: the size of this operand must be equal to the RETTYPE size
    @returns pointer to the created instruction or nullptr if error

ida_hexrays.mba_t.deleted_pairs(self) -> bool

ida_hexrays.mba_t.deserialize(bytes: "uchar const *") -> "mba_t *"
    Deserialize a byte sequence into mbl array. 
            
    @param bytes: pointer to the beginning of the byte sequence.
    @returns new mbl array

ida_hexrays.mba_t.display_numaddrs(self) -> bool

ida_hexrays.mba_t.display_valnums(self) -> bool

ida_hexrays.mba_t.dump(self) -> None
    Dump microcode to a file. The file will be created in the directory pointed by IDA_DUMPDIR envvar. Dump will be created only if IDA is run under debugger. 
            

ida_hexrays.mba_t.dump_mba(self, _verify: bool, title: str) -> None

ida_hexrays.mba_t.error_ea
    during microcode generation holds ins.ea

ida_hexrays.mba_t.final_type
    is the function type final? (specified by the user)

ida_hexrays.mba_t.find_mop(self, ctx: "op_parent_info_t", ea: ida_idaapi.ea_t, is_dest: bool, list: "mlist_t") -> "mop_t *"
    Find an operand in the microcode. This function tries to find the operand that matches LIST. Any operand that overlaps with LIST is considered as a match. 
            
    @param ctx: context information for the result
    @param ea: desired address of the operand. BADADDR means to accept any address.
    @param is_dest: search for destination operand? this argument may be ignored if the exact match could not be found
    @param list: list of locations the correspond to the operand
    @returns pointer to the operand or nullptr.

ida_hexrays.mba_t.for_all_insns(self, mv: "minsn_visitor_t") -> int
    Visit all instructions. This function visits all instruction and subinstructions. 
            
    @param mv: instruction visitor
    @returns non-zero value returned by mv.visit_mop() or zero

ida_hexrays.mba_t.for_all_ops(self, mv: "mop_visitor_t") -> int
    Visit all operands of all instructions. 
            
    @param mv: operand visitor
    @returns non-zero value returned by mv.visit_mop() or zero

ida_hexrays.mba_t.for_all_topinsns(self, mv: "minsn_visitor_t") -> int
    Visit all top level instructions. 
            
    @param mv: instruction visitor
    @returns non-zero value returned by mv.visit_mop() or zero

ida_hexrays.mba_t.fpd
    frame pointer delta

ida_hexrays.mba_t.free_kreg(self, reg: "mreg_t", size: "size_t") -> None
    Free a kernel register. If wrong arguments are passed, this function will generate an internal error. 
            
    @param reg: a previously allocated kernel register
    @param size: size of the register in bytes

ida_hexrays.mba_t.frregs
    size of saved registers range in the stack frame

ida_hexrays.mba_t.frsize
    size of local stkvars range in the stack frame

ida_hexrays.mba_t.fti_flags
    FTI_... constants for the current function.

ida_hexrays.mba_t.fullsize
    Full stack size including incoming args.

ida_hexrays.mba_t.generated_asserts(self) -> bool

ida_hexrays.mba_t.get_args_region(self) -> "ivl_t const &"

ida_hexrays.mba_t.get_curfunc(self) -> "func_t *"

ida_hexrays.mba_t.get_func_output_lists(self, *args) -> None
    Prepare the lists of registers & memory that are defined/killed by a function 
            
    @param return_regs: defined regs to return (eax,edx)
    @param spoiled: spoiled regs (flags,ecx,mem)
    @param type: the function type
    @param call_ea: the call insn address (if known)
    @param tail_call: is it the tail call?

ida_hexrays.mba_t.get_graph(self) -> "mbl_graph_t *"
    Get control graph. Call build_graph() if you need the graph before MMAT_LOCOPT. 
            

ida_hexrays.mba_t.get_ida_argloc(self, v: "lvar_t") -> "argloc_t"

ida_hexrays.mba_t.get_lvars_region(self) -> "ivl_t const &"

ida_hexrays.mba_t.get_mba_flags(self) -> int

ida_hexrays.mba_t.get_mba_flags2(self) -> int

ida_hexrays.mba_t.get_mblock(self, n: "uint") -> "mblock_t *"
    Get basic block by its serial number.

ida_hexrays.mba_t.get_shadow_region(self) -> "ivl_t const &"

ida_hexrays.mba_t.get_stack_region(self) -> "ivl_t"

ida_hexrays.mba_t.get_std_region(self, idx: "memreg_index_t") -> "ivl_t const &"
    Get information about various memory regions. We map the stack frame to the global memory, to some unused range. 
            

ida_hexrays.mba_t.gotoff_stkvars
    stkvars that hold .got offsets. considered to be unaliasable

ida_hexrays.mba_t.graph_insns(self) -> bool

ida_hexrays.mba_t.has_bad_sp(self) -> bool

ida_hexrays.mba_t.has_outlines(self) -> bool

ida_hexrays.mba_t.has_over_chains(self) -> bool

ida_hexrays.mba_t.has_passregs(self) -> bool

ida_hexrays.mba_t.has_stack_retval(self) -> bool

ida_hexrays.mba_t.idaloc2vd(self, loc: "argloc_t", width: int) -> "vdloc_t"

ida_hexrays.mba_t.idb_spoiled
    MBA_SPLINFO && final_type: info in ida format.

ida_hexrays.mba_t.idb_type
    function type as retrieved from the database

ida_hexrays.mba_t.inargoff
    offset of the first stack argument; after fix_scattered_movs() INARGOFF may be less than STACKSIZE 
            

ida_hexrays.mba_t.inline_func(self, cdg: "codegen_t", blknum: int, ranges: "mba_ranges_t", decomp_flags: int = 0, inline_flags: int = 0) -> "merror_t"
    Inline a range. Currently only functions are supported, not arbitrary ranges. This function may be called only during the initial microcode generation phase. 
            
    @param cdg: the codegenerator object
    @param blknum: the block contaning the call/jump instruction to inline
    @param ranges: the set of ranges to inline
    @param decomp_flags: combination of decompile() flags bits
    @param inline_flags: combination of inline_func() flags bits
    @returns error code

ida_hexrays.mba_t.insert_block(self, bblk: int) -> "mblock_t *"
    Insert a block in the middle of the mbl array. The very first block of microcode must be empty, it is the entry block. The very last block of microcode must be BLT_STOP, it is the exit block. Therefore inserting a new block before the entry point or after the exit block is not a good idea. 
            
    @param bblk: the new block will be inserted before BBLK
    @returns ptr to the new block

ida_hexrays.mba_t.is_cdtr(self) -> bool

ida_hexrays.mba_t.is_ctr(self) -> bool

ida_hexrays.mba_t.is_dtr(self) -> bool

ida_hexrays.mba_t.is_pattern(self) -> bool

ida_hexrays.mba_t.is_snippet(self) -> bool

ida_hexrays.mba_t.is_stkarg(self, v: "lvar_t") -> bool

ida_hexrays.mba_t.is_thunk(self) -> bool

ida_hexrays.mba_t.label
    name of the function or pattern (colored)

ida_hexrays.mba_t.loaded_gdl(self) -> bool

ida_hexrays.mba_t.locate_stkpnt(self, ea: ida_idaapi.ea_t) -> "stkpnt_t const *"

ida_hexrays.mba_t.lvar_names_ok(self) -> bool

ida_hexrays.mba_t.lvars_allocated(self) -> bool

ida_hexrays.mba_t.lvars_renamed(self) -> bool

ida_hexrays.mba_t.map_fict_ea(self, fict_ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Resolve a fictional address. This function provides a reverse of the mapping made by alloc_fict_ea(). 
            
    @param fict_ea: fictional definition address
    @returns the real instruction address

ida_hexrays.mba_t.mark_chains_dirty(self) -> None
    Mark the microcode use-def chains dirty. Call this function is any inter-block data dependencies got changed because of your modifications to the microcode. Failing to do so may cause an internal error. 
            

ida_hexrays.mba_t.maturity
    current maturity level

ida_hexrays.mba_t.may_refine_rettype(self) -> bool

ida_hexrays.mba_t.merge_blocks(self) -> bool
    Merge blocks. This function merges blocks constituting linear flow. It calls remove_empty_and_unreachable_blocks() as well. 
            
    @returns true if changed any blocks

ida_hexrays.mba_t.minargref
    The lowest stack argument location whose address was taken This location and locations above it can be aliased It controls locations >= inargoff-shadow_args 
            

ida_hexrays.mba_t.minstkref
    The lowest stack location whose address was taken.

ida_hexrays.mba_t.minstkref_ea
    address with lowest minstkref (for debugging)

ida_hexrays.mba_t.natural
    natural order of blocks

ida_hexrays.mba_t.nodel_memory
    global dead elimination may not delete references to this area

ida_hexrays.mba_t.npurged
    -1 - unknown

ida_hexrays.mba_t.optimize_global(self) -> "merror_t"
    Optimize microcode globally. This function applies various optimization methods until we reach the fixed point. After that it preallocates lvars unless reqmat forbids it. 
            
    @returns error code

ida_hexrays.mba_t.optimize_local(self, locopt_bits: int) -> int
    Optimize each basic block locally 
            
    @param locopt_bits: combination of Bits for optimize_local() bits
    @returns number of changes. 0 means nothing changed This function is called by the decompiler, usually there is no need to call it explicitly.

ida_hexrays.mba_t.optimized(self) -> bool

ida_hexrays.mba_t.pfn_flags
    copy of func_t::flags

ida_hexrays.mba_t.precise_defeas(self) -> bool

ida_hexrays.mba_t.prop_complex(self) -> bool

ida_hexrays.mba_t.propagated_asserts(self) -> bool

ida_hexrays.mba_t.qty
    number of basic blocks

ida_hexrays.mba_t.really_alloc(self) -> bool

ida_hexrays.mba_t.regargs_is_not_aligned(self) -> bool

ida_hexrays.mba_t.remove_block(self, blk: "mblock_t") -> bool
    Delete a block. 
            
    @param blk: block to delete
    @returns true if at least one of the other blocks became empty or unreachable

ida_hexrays.mba_t.remove_blocks(self, start_blk: int, end_blk: int) -> bool

ida_hexrays.mba_t.remove_empty_and_unreachable_blocks(self) -> bool
    Delete all empty and unreachable blocks. Blocks marked with MBL_KEEP won't be deleted. 
            

ida_hexrays.mba_t.reqmat
    required maturity level

ida_hexrays.mba_t.retsize
    size of return address in the stack frame

ida_hexrays.mba_t.returns_fpval(self) -> bool

ida_hexrays.mba_t.retvaridx
    index of variable holding the return value -1 means none 
            

ida_hexrays.mba_t.rtype_refined(self) -> bool

ida_hexrays.mba_t.save_snapshot(self, description: str) -> None
    Create and save microcode snapshot.

ida_hexrays.mba_t.saverest_done(self) -> bool

ida_hexrays.mba_t.serialize(self) -> None
    Serialize mbl array into a sequence of bytes.

ida_hexrays.mba_t.set_lvar_name(self, v: "lvar_t", name: str, flagbits: int) -> bool

ida_hexrays.mba_t.set_maturity(self, mat: "mba_maturity_t") -> bool
    Set maturity level. 
            
    @param mat: new maturity level
    @returns true if it is time to stop analysis Plugins may use this function to skip some parts of the analysis. The maturity level cannot be decreased.

ida_hexrays.mba_t.set_mba_flags(self, f: int) -> None

ida_hexrays.mba_t.set_mba_flags2(self, f: int) -> None

ida_hexrays.mba_t.set_nice_lvar_name(self, v: "lvar_t", name: str) -> bool

ida_hexrays.mba_t.set_user_lvar_name(self, v: "lvar_t", name: str) -> bool

ida_hexrays.mba_t.shadow_args
    size of shadow argument area

ida_hexrays.mba_t.short_display(self) -> bool

ida_hexrays.mba_t.should_beautify(self) -> bool

ida_hexrays.mba_t.show_reduction(self) -> bool

ida_hexrays.mba_t.spd_adjust
    If sp>0, the max positive sp value.

ida_hexrays.mba_t.split_block(self, blk: "mblock_t", start_insn: "minsn_t") -> "mblock_t *"
    Split a block: insert a new one after the block, move some instructions to new block 
            
    @param blk: block to be split
    @param start_insn: all instructions to be moved to new block: starting with this one up to the end
    @returns ptr to the new block

ida_hexrays.mba_t.spoiled_list
    MBA_SPLINFO && !final_type: info in vd format.

ida_hexrays.mba_t.stacksize
    The maximal size of the function stack including bytes allocated for outgoing call arguments (up to retaddr) 
            

ida_hexrays.mba_t.std_ivls
    we treat memory as consisting of 6 parts see memreg_index_t 
            

ida_hexrays.mba_t.stkoff_ida2vd(self, off: int) -> int

ida_hexrays.mba_t.stkoff_vd2ida(self, off: int) -> int

ida_hexrays.mba_t.term(self) -> None

ida_hexrays.mba_t.tmpstk_size
    size of the temporary stack part (which dynamically changes with push/pops) 
            

ida_hexrays.mba_t.use_frame(self) -> bool

ida_hexrays.mba_t.use_wingraph32(self) -> bool

ida_hexrays.mba_t.valranges_done(self) -> bool

ida_hexrays.mba_t.vars
    local variables

ida_hexrays.mba_t.vd2idaloc(self, *args) -> "argloc_t"
    This function has the following signatures:
    
        0. vd2idaloc(loc: const vdloc_t &, width: int) -> argloc_t
        1. vd2idaloc(loc: const vdloc_t &, width: int, spd: int) -> argloc_t
    
    # 0: vd2idaloc(loc: const vdloc_t &, width: int) -> argloc_t
    
    
    # 1: vd2idaloc(loc: const vdloc_t &, width: int, spd: int) -> argloc_t

ida_hexrays.mba_t.verify(self, always: bool) -> None
    Verify microcode consistency. 
            
    @param always: if false, the check will be performed only if ida runs under debugger If any inconsistency is discovered, an internal error will be generated. We strongly recommend you to call this function before returing control to the decompiler from your callbacks, in the case if you modified the microcode. If the microcode is inconsistent, this function will generate an internal error. We provide the source code of this function in the plugins/hexrays_sdk/verifier directory for your reference.

ida_hexrays.mba_t.write_to_const_detected(self) -> bool

ida_hexrays.mbl_graph_t

ida_hexrays.mbl_graph_t.__init__(self, *args, **kwargs)

ida_hexrays.mbl_graph_t.get_chain_stamp(self) -> int

ida_hexrays.mbl_graph_t.get_du(self, gctype: "gctype_t") -> "graph_chains_t *"
    Get def-use chains.

ida_hexrays.mbl_graph_t.get_mblock(self, n: int) -> "mblock_t *"

ida_hexrays.mbl_graph_t.get_ud(self, gctype: "gctype_t") -> "graph_chains_t *"
    Get use-def chains.

ida_hexrays.mbl_graph_t.is_du_chain_dirty(self, gctype: "gctype_t") -> bool
    Is the def-use chain of the specified kind dirty?

ida_hexrays.mbl_graph_t.is_redefined_globally(self, *args) -> bool
    Is LIST redefined in the graph?

ida_hexrays.mbl_graph_t.is_ud_chain_dirty(self, gctype: "gctype_t") -> bool
    Is the use-def chain of the specified kind dirty?

ida_hexrays.mbl_graph_t.is_used_globally(self, *args) -> bool
    Is LIST used in the graph?

ida_hexrays.mblock_t

ida_hexrays.mblock_t.__init__(self, *args, **kwargs)

ida_hexrays.mblock_t._print(self, vp: "vd_printer_t") -> None

ida_hexrays.mblock_t.append_def_list(self, list: "mlist_t", op: "mop_t", maymust: "maymust_t") -> None
    Append def-list of an operand. This function calculates list of locations that may or must be modified by the operand and appends it to LIST. 
            
    @param list: ptr to the output buffer. we will append to it.
    @param op: operand to calculate the def list of
    @param maymust: should we calculate 'may-def' or 'must-def' list? see maymust_t for more details.

ida_hexrays.mblock_t.append_use_list(self, *args) -> None
    Append use-list of an operand. This function calculates list of locations that may or must be used by the operand and appends it to LIST. 
            
    @param list: ptr to the output buffer. we will append to it.
    @param op: operand to calculate the use list of
    @param maymust: should we calculate 'may-use' or 'must-use' list? see maymust_t for more details.
    @param mask: if only part of the operand should be considered, a bitmask can be used to specify which part. example: op=AX,mask=0xFF means that we will consider only AL.

ida_hexrays.mblock_t.build_def_list(self, ins: "minsn_t", maymust: "maymust_t") -> "mlist_t"
    Build def-list of an instruction. This function calculates list of locations that may or must be modified by the instruction. Examples: "stx ebx.4, ds.2, eax.4", may-list: all aliasable memory "stx ebx.4, ds.2, eax.4", must-list: empty Since STX uses EAX for indirect access, it may modify any aliasable memory. On the other hand, we cannot tell for sure which memory cells will be modified, this is why the must-list is empty. 
            
    @param ins: instruction to calculate the def list of
    @param maymust: should we calculate 'may-def' or 'must-def' list? see maymust_t for more details.
    @returns the calculated def-list

ida_hexrays.mblock_t.build_lists(self, kill_deads: bool) -> int
    Build def-use lists and eliminate deads. 
            
    @param kill_deads: do delete dead instructions?
    @returns the number of eliminated instructions Better mblock_t::call make_lists_ready() rather than this function.

ida_hexrays.mblock_t.build_use_list(self, ins: "minsn_t", maymust: "maymust_t") -> "mlist_t"
    Build use-list of an instruction. This function calculates list of locations that may or must be used by the instruction. Examples: "ldx ds.2, eax.4, ebx.4", may-list: all aliasable memory "ldx ds.2, eax.4, ebx.4", must-list: empty Since LDX uses EAX for indirect access, it may access any aliasable memory. On the other hand, we cannot tell for sure which memory cells will be accessed, this is why the must-list is empty. 
            
    @param ins: instruction to calculate the use list of
    @param maymust: should we calculate 'may-use' or 'must-use' list? see maymust_t for more details.
    @returns the calculated use-list

ida_hexrays.mblock_t.dead_at_start
    data that is dead at the block entry

ida_hexrays.mblock_t.dnu
    data that is defined but not used in the block

ida_hexrays.mblock_t.dump(self) -> None
    Dump block info. This function is useful for debugging, see mba_t::dump for info 
            

ida_hexrays.mblock_t.dump_block(self, title: str) -> None

ida_hexrays.mblock_t.empty(self) -> bool

ida_hexrays.mblock_t.end
    end address note: we cannot rely on start/end addresses very much because instructions are propagated between blocks 
            

ida_hexrays.mblock_t.find_access(self, op: "mop_t", parent: "minsn_t **", mend: "minsn_t", fdflags: int) -> "minsn_t *"
    Find the instruction that accesses the specified operand. This function search inside one block. 
            
    @param op: operand to search for
    @param parent: ptr to ptr to a top level instruction. in: denotes the beginning of the search range. out: denotes the parent of the found instruction.
    @param mend: end instruction of the range (must be a top level insn) mend is excluded from the range. it can be specified as nullptr. parent and mend must belong to the same block.
    @param fdflags: combination of bits for mblock_t::find_access bits
    @returns the instruction that accesses the operand. this instruction may be a sub-instruction. to find out the top level instruction, check out *parent. nullptr means 'not found'.

ida_hexrays.mblock_t.find_def(self, op: "mop_t", p_i1: "minsn_t **", i2: "minsn_t", fdflags: int) -> "minsn_t *"

ida_hexrays.mblock_t.find_first_use(self, *args) -> "minsn_t *"
    This function has the following signatures:
    
        0. find_first_use(list: mlist_t *, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *
        1. find_first_use(list: mlist_t *, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *
    
    # 0: find_first_use(list: mlist_t *, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *
    
    Find the first insn that uses the specified list in the insn range. 
            
    @returns pointer to such instruction or nullptr. Upon return LIST will contain only locations not redefined by insns [i1..result]
    
    # 1: find_first_use(list: mlist_t *, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *

ida_hexrays.mblock_t.find_redefinition(self, *args) -> "minsn_t *"
    This function has the following signatures:
    
        0. find_redefinition(list: const mlist_t &, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *
        1. find_redefinition(list: const mlist_t &, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *
    
    # 0: find_redefinition(list: const mlist_t &, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *
    
    Find the first insn that redefines any part of the list in the insn range. 
            
    @returns pointer to such instruction or nullptr.
    
    # 1: find_redefinition(list: const mlist_t &, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *

ida_hexrays.mblock_t.find_use(self, op: "mop_t", p_i1: "minsn_t **", i2: "minsn_t", fdflags: int) -> "minsn_t *"

ida_hexrays.mblock_t.flags
    combination of Basic block properties bits 
            

ida_hexrays.mblock_t.for_all_insns(self, mv: "minsn_visitor_t") -> int
    Visit all instructions. This function visits subinstructions too. 
            
    @param mv: instruction visitor
    @returns zero or the value returned by mv.visit_insn() See also mba_t::for_all_topinsns()

ida_hexrays.mblock_t.for_all_ops(self, mv: "mop_visitor_t") -> int
    Visit all operands. This function visit subinstruction operands too. 
            
    @param mv: operand visitor
    @returns zero or the value returned by mv.visit_mop()

ida_hexrays.mblock_t.for_all_uses(self, list: "mlist_t", i1: "minsn_t", i2: "minsn_t", mmv: "mlist_mop_visitor_t") -> int
    Visit all operands that use LIST. 
            
    @param list: ptr to the list of locations. it may be modified: parts that get redefined by the instructions in [i1,i2) will be deleted.
    @param i1: starting instruction. must be a top level insn.
    @param i2: ending instruction (excluded). must be a top level insn.
    @param mmv: operand visitor
    @returns zero or the value returned by mmv.visit_mop()

ida_hexrays.mblock_t.get_reginsn_qty(self) -> "size_t"
    Calculate number of regular instructions in the block. Assertions are skipped by this function. 
            
    @returns Number of non-assertion instructions in the block.

ida_hexrays.mblock_t.get_valranges(self, *args) -> bool
    This function has the following signatures:
    
        0. get_valranges(res: valrng_t *, vivl: const vivl_t &, vrflags: int) -> bool
        1. get_valranges(res: valrng_t *, vivl: const vivl_t &, m: const minsn_t *, vrflags: int) -> bool
    
    # 0: get_valranges(res: valrng_t *, vivl: const vivl_t &, vrflags: int) -> bool
    
    Find possible values for a block. 
            
    
    # 1: get_valranges(res: valrng_t *, vivl: const vivl_t &, m: const minsn_t *, vrflags: int) -> bool
    
    Find possible values for an instruction. 
            

ida_hexrays.mblock_t.head
    pointer to the first instruction of the block

ida_hexrays.mblock_t.insert_into_block(self, nm: "minsn_t", om: "minsn_t") -> "minsn_t *"
    Insert instruction into the doubly linked list 
            
    @param nm: new instruction
    @param om: existing instruction, part of the doubly linked list if nullptr, then the instruction will be inserted at the beginning of the list NM will be inserted immediately after OM
    @returns pointer to NM

ida_hexrays.mblock_t.is_branch(self) -> bool

ida_hexrays.mblock_t.is_call_block(self) -> bool

ida_hexrays.mblock_t.is_nway(self) -> bool

ida_hexrays.mblock_t.is_redefined(self, *args) -> bool
    Is the list redefined by the specified instructions? 
            
    @param list: list of locations to check.
    @param i1: starting instruction of the range (must be a top level insn)
    @param i2: end instruction of the range (must be a top level insn) i2 is excluded from the range. it can be specified as nullptr. i1 and i2 must belong to the same block.
    @param maymust: should we search in 'may-access' or 'must-access' mode?

ida_hexrays.mblock_t.is_rhs_redefined(self, ins: "minsn_t", i1: "minsn_t", i2: "minsn_t") -> bool
    Is the right hand side of the instruction redefined the insn range? "right hand side" corresponds to the source operands of the instruction. 
            
    @param ins: instruction to consider
    @param i1: starting instruction of the range (must be a top level insn)
    @param i2: end instruction of the range (must be a top level insn) i2 is excluded from the range. it can be specified as nullptr. i1 and i2 must belong to the same block.

ida_hexrays.mblock_t.is_simple_goto_block(self) -> bool

ida_hexrays.mblock_t.is_simple_jcnd_block(self) -> bool

ida_hexrays.mblock_t.is_unknown_call(self) -> bool

ida_hexrays.mblock_t.is_used(self, *args) -> bool
    Is the list used by the specified instruction range? 
            
    @param list: list of locations. LIST may be modified by the function: redefined locations will be removed from it.
    @param i1: starting instruction of the range (must be a top level insn)
    @param i2: end instruction of the range (must be a top level insn) i2 is excluded from the range. it can be specified as nullptr. i1 and i2 must belong to the same block.
    @param maymust: should we search in 'may-access' or 'must-access' mode?

ida_hexrays.mblock_t.lists_dirty(self) -> bool

ida_hexrays.mblock_t.lists_ready(self) -> bool

ida_hexrays.mblock_t.make_lists_ready(self) -> int

ida_hexrays.mblock_t.make_nop(self, m: "minsn_t") -> None
    Erase the instruction (convert it to nop) and mark the lists dirty. This is the recommended function to use because it also marks the block use-def lists dirty. 
            

ida_hexrays.mblock_t.mark_lists_dirty(self) -> None

ida_hexrays.mblock_t.maxbsp
    maximal sp value in the block (0...stacksize)

ida_hexrays.mblock_t.maybdef
    data that may be defined by the block

ida_hexrays.mblock_t.maybuse
    data that may be used by the block

ida_hexrays.mblock_t.mba
    the parent micro block array

ida_hexrays.mblock_t.minbargref
    the same for arguments

ida_hexrays.mblock_t.minbstkref
    lowest stack location accessible with indirect addressing (offset from the stack bottom) initially it is 0 (not computed) 
            

ida_hexrays.mblock_t.mustbdef
    data that must be defined by the block

ida_hexrays.mblock_t.mustbuse
    data that must be used by the block

ida_hexrays.mblock_t.needs_propagation(self) -> bool

ida_hexrays.mblock_t.nextb
    next block in the doubly linked list

ida_hexrays.mblock_t.npred(self) -> int
    Get number of block predecessors.

ida_hexrays.mblock_t.nsucc(self) -> int
    Get number of block successors.

ida_hexrays.mblock_t.optimize_block(self) -> int
    Optimize a basic block. Usually there is no need to call this function explicitly because the decompiler will call it itself if optinsn_t::func or optblock_t::func return non-zero. 
            
    @returns number of changes made to the block

ida_hexrays.mblock_t.optimize_insn(self, *args) -> int
    Optimize one instruction in the context of the block. 
            
    @param m: pointer to a top level instruction
    @param optflags: combination of optimization flags bits
    @returns number of changes made to the block This function may change other instructions in the block too. However, it will not destroy top level instructions (it may convert them to nop's). This function performs only intrablock modifications. See also minsn_t::optimize_solo()

ida_hexrays.mblock_t.optimize_useless_jump(self) -> int
    Remove a jump at the end of the block if it is useless. This function preserves any side effects when removing a useless jump. Both conditional and unconditional jumps are handled (and jtbl too). This function deletes useless jumps, not only replaces them with a nop. (please note that \optimize_insn does not handle useless jumps). 
            
    @returns number of changes made to the block

ida_hexrays.mblock_t.pred(self, n: int) -> int

ida_hexrays.mblock_t.preds(self)
    Iterates the list of predecessor blocks

ida_hexrays.mblock_t.predset
    control flow graph: list of our predecessors use npred() and pred() to access it 
            

ida_hexrays.mblock_t.prevb
    previous block in the doubly linked list

ida_hexrays.mblock_t.remove_from_block(self, m: "minsn_t") -> "minsn_t *"
    Remove instruction from the doubly linked list 
            
    @param m: instruction to remove The removed instruction is not deleted, the caller gets its ownership
    @returns pointer to the next instruction

ida_hexrays.mblock_t.request_demote64(self) -> None

ida_hexrays.mblock_t.request_propagation(self) -> None

ida_hexrays.mblock_t.serial
    block number

ida_hexrays.mblock_t.start
    start address

ida_hexrays.mblock_t.succ(self, n: int) -> int

ida_hexrays.mblock_t.succs(self)
    Iterates the list of successor blocks

ida_hexrays.mblock_t.succset
    control flow graph: list of our successors use nsucc() and succ() to access it 
            

ida_hexrays.mblock_t.tail
    pointer to the last instruction of the block

ida_hexrays.mblock_t.type
    block type (BLT_NONE - not computed yet)

ida_hexrays.mcallarg_t

ida_hexrays.mcallarg_t.__init__(self, *args)

ida_hexrays.mcallarg_t._print(self, *args) -> None

ida_hexrays.mcallarg_t.argloc
    ida argloc

ida_hexrays.mcallarg_t.copy_mop(self, op: "mop_t") -> None

ida_hexrays.mcallarg_t.dstr(self) -> str

ida_hexrays.mcallarg_t.ea
    address where the argument was initialized. BADADDR means unknown. 
            

ida_hexrays.mcallarg_t.flags
    FAI_...

ida_hexrays.mcallarg_t.make_int(self, val: int, val_ea: ida_idaapi.ea_t, opno: int = 0) -> None

ida_hexrays.mcallarg_t.make_uint(self, val: int, val_ea: ida_idaapi.ea_t, opno: int = 0) -> None

ida_hexrays.mcallarg_t.name
    formal argument name

ida_hexrays.mcallarg_t.set_regarg(self, *args) -> None
    This function has the following signatures:
    
        0. set_regarg(mr: mreg_t, sz: int, tif: const tinfo_t &) -> None
        1. set_regarg(mr: mreg_t, tif: const tinfo_t &) -> None
        2. set_regarg(mr: mreg_t, dt: char, sign: type_sign_t=type_unsigned) -> None
    
    # 0: set_regarg(mr: mreg_t, sz: int, tif: const tinfo_t &) -> None
    
    
    # 1: set_regarg(mr: mreg_t, tif: const tinfo_t &) -> None
    
    
    # 2: set_regarg(mr: mreg_t, dt: char, sign: type_sign_t=type_unsigned) -> None

ida_hexrays.mcallarg_t.type
    formal argument type

ida_hexrays.mcallargs_t

ida_hexrays.mcallargs_t.__eq__(self, r: "mcallargs_t") -> bool

ida_hexrays.mcallargs_t.__getitem__(self, i: "size_t") -> "mcallarg_t const &"

ida_hexrays.mcallargs_t.__init__(self, *args)

ida_hexrays.mcallargs_t.__len__(self) -> "size_t"

ida_hexrays.mcallargs_t.__ne__(self, r: "mcallargs_t") -> bool

ida_hexrays.mcallargs_t.__setitem__(self, i: "size_t", v: "mcallarg_t") -> None

ida_hexrays.mcallargs_t._del(self, x: "mcallarg_t") -> bool

ida_hexrays.mcallargs_t.add_unique(self, x: "mcallarg_t") -> bool

ida_hexrays.mcallargs_t.append(self, x: "mcallarg_t") -> None

ida_hexrays.mcallargs_t.at(self, _idx: "size_t") -> "mcallarg_t const &"

ida_hexrays.mcallargs_t.begin(self, *args) -> "qvector< mcallarg_t >::const_iterator"

ida_hexrays.mcallargs_t.capacity(self) -> "size_t"

ida_hexrays.mcallargs_t.clear(self) -> None

ida_hexrays.mcallargs_t.empty(self) -> bool

ida_hexrays.mcallargs_t.end(self, *args) -> "qvector< mcallarg_t >::const_iterator"

ida_hexrays.mcallargs_t.erase(self, *args) -> "qvector< mcallarg_t >::iterator"

ida_hexrays.mcallargs_t.extend(self, x: "mcallargs_t") -> None

ida_hexrays.mcallargs_t.extract(self) -> "mcallarg_t *"

ida_hexrays.mcallargs_t.find(self, *args) -> "qvector< mcallarg_t >::const_iterator"

ida_hexrays.mcallargs_t.grow(self, *args) -> None

ida_hexrays.mcallargs_t.has(self, x: "mcallarg_t") -> bool

ida_hexrays.mcallargs_t.inject(self, s: "mcallarg_t", len: "size_t") -> None

ida_hexrays.mcallargs_t.insert(self, it: "mcallarg_t", x: "mcallarg_t") -> "qvector< mcallarg_t >::iterator"

ida_hexrays.mcallargs_t.pop_back(self) -> None

ida_hexrays.mcallargs_t.push_back(self, *args) -> "mcallarg_t &"

ida_hexrays.mcallargs_t.qclear(self) -> None

ida_hexrays.mcallargs_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.mcallargs_t.resize(self, *args) -> None

ida_hexrays.mcallargs_t.size(self) -> "size_t"

ida_hexrays.mcallargs_t.swap(self, r: "mcallargs_t") -> None

ida_hexrays.mcallargs_t.truncate(self) -> None

ida_hexrays.mcallinfo_t

ida_hexrays.mcallinfo_t.__init__(self, *args)

ida_hexrays.mcallinfo_t._print(self, *args) -> None

ida_hexrays.mcallinfo_t.args
    call arguments

ida_hexrays.mcallinfo_t.call_spd
    sp value at call insn

ida_hexrays.mcallinfo_t.callee
    address of the called function, if known

ida_hexrays.mcallinfo_t.cc
    calling convention

ida_hexrays.mcallinfo_t.dead_regs
    registers defined by the function but never used. upon propagation we do the following:
    * dead_regs += return_regs
    * retregs.clear() since the call is propagated 
    
    
            

ida_hexrays.mcallinfo_t.dstr(self) -> str

ida_hexrays.mcallinfo_t.flags
    combination of Call properties... bits 
            

ida_hexrays.mcallinfo_t.fti_attrs
    extended function attributes

ida_hexrays.mcallinfo_t.get_type(self) -> "tinfo_t"

ida_hexrays.mcallinfo_t.is_vararg(self) -> bool

ida_hexrays.mcallinfo_t.lexcompare(self, f: "mcallinfo_t") -> int

ida_hexrays.mcallinfo_t.pass_regs
    passthrough registers: registers that depend on input values (subset of spoiled) 
            

ida_hexrays.mcallinfo_t.retregs
    return register(s) (e.g., AX, AX:DX, etc.) this vector is built from return_regs 
            

ida_hexrays.mcallinfo_t.return_argloc
    location of the returned value

ida_hexrays.mcallinfo_t.return_regs
    list of values returned by the function

ida_hexrays.mcallinfo_t.return_type
    type of the returned value

ida_hexrays.mcallinfo_t.role
    function role

ida_hexrays.mcallinfo_t.set_type(self, type: "tinfo_t") -> bool

ida_hexrays.mcallinfo_t.solid_args
    number of solid args. there may be variadic args in addtion 
            

ida_hexrays.mcallinfo_t.spoiled
    list of spoiled locations (includes return_regs)

ida_hexrays.mcallinfo_t.stkargs_top
    first offset past stack arguments

ida_hexrays.mcallinfo_t.visible_memory
    what memory is visible to the call?

ida_hexrays.mcases_t

ida_hexrays.mcases_t.__eq__(self, r: "mcases_t") -> bool

ida_hexrays.mcases_t.__ge__(self, r: "mcases_t") -> bool

ida_hexrays.mcases_t.__gt__(self, r: "mcases_t") -> bool

ida_hexrays.mcases_t.__init__(self)

ida_hexrays.mcases_t.__le__(self, r: "mcases_t") -> bool

ida_hexrays.mcases_t.__lt__(self, r: "mcases_t") -> bool

ida_hexrays.mcases_t.__ne__(self, r: "mcases_t") -> bool

ida_hexrays.mcases_t._print(self) -> None

ida_hexrays.mcases_t.compare(self, r: "mcases_t") -> int

ida_hexrays.mcases_t.dstr(self) -> str

ida_hexrays.mcases_t.empty(self) -> bool

ida_hexrays.mcases_t.resize(self, s: int) -> None

ida_hexrays.mcases_t.size(self) -> "size_t"

ida_hexrays.mcases_t.swap(self, r: "mcases_t") -> None

ida_hexrays.mcases_t.targets
    target block numbers

ida_hexrays.mcases_t.values
    expression values for each target

ida_hexrays.mcode_modifies_d(mcode: "mcode_t") -> bool

ida_hexrays.microcode_filter_t

ida_hexrays.microcode_filter_t.__disown__(self)

ida_hexrays.microcode_filter_t.__init__(self)

ida_hexrays.microcode_filter_t.apply(self, cdg: "codegen_t") -> "merror_t"
    generate microcode for an instruction 
            
    @returns MERR_... code: MERR_OK - user-defined microcode generated, go to the next instruction MERR_INSN - not generated - the caller should try the standard way else - error

ida_hexrays.microcode_filter_t.match(self, cdg: "codegen_t") -> bool
    check if the filter object is to be applied 
            
    @returns success

ida_hexrays.min_vlr_svalue(size: int) -> "uvlr_t"

ida_hexrays.minsn_t

ida_hexrays.minsn_t.__dbg_get_meminfo(self) -> str

ida_hexrays.minsn_t.__dbg_get_registered_kind(self) -> int

ida_hexrays.minsn_t.__init__(self, *args)

ida_hexrays.minsn_t.__lt__(self, ri: "minsn_t") -> bool

ida_hexrays.minsn_t._acquire_ownership(self, v, acquire)

ida_hexrays.minsn_t._deregister(self) -> None

ida_hexrays.minsn_t._ensure_cond(self, ok, cond_str)

ida_hexrays.minsn_t._ensure_no_obj(self, o, attr, attr_is_acquired)

ida_hexrays.minsn_t._ensure_ownership_transferrable(self, v)

ida_hexrays.minsn_t._make_nop(self) -> None
    Convert instruction to nop. This function erases all info but the prev/next fields. In most cases it is better to use mblock_t::make_nop(), which also marks the block lists as dirty. 
            

ida_hexrays.minsn_t._maybe_disown_and_deregister(self)

ida_hexrays.minsn_t._meminfo(self)

ida_hexrays.minsn_t._obj_id(self) -> "PyObject *"

ida_hexrays.minsn_t._own_and_register(self)

ida_hexrays.minsn_t._print(self, *args) -> None

ida_hexrays.minsn_t._register(self) -> None

ida_hexrays.minsn_t.clr_assert(self) -> None

ida_hexrays.minsn_t.clr_combinable(self) -> None

ida_hexrays.minsn_t.clr_combined(self) -> None

ida_hexrays.minsn_t.clr_fpinsn(self) -> None

ida_hexrays.minsn_t.clr_ignlowsrc(self) -> None

ida_hexrays.minsn_t.clr_multimov(self) -> None

ida_hexrays.minsn_t.clr_noret_icall(self) -> None

ida_hexrays.minsn_t.clr_propagatable(self) -> None

ida_hexrays.minsn_t.clr_tailcall(self) -> None

ida_hexrays.minsn_t.contains_call(self, with_helpers: bool = False) -> bool
    Does the instruction contain a call?

ida_hexrays.minsn_t.contains_opcode(self, mcode: "mcode_t") -> bool
    Does the instruction have the specified opcode? This function searches subinstructions as well. 
            
    @param mcode: opcode to search for.

ida_hexrays.minsn_t.d
    destination operand

ida_hexrays.minsn_t.deserialize(self, bytes: "uchar const *", format_version: int) -> bool
    Deserialize an instruction 
            
    @param bytes: pointer to serialized data
    @param format_version: serialization format version. this value is returned by minsn_t::serialize()
    @returns success

ida_hexrays.minsn_t.dstr(self) -> str
    Get displayable text without tags in a static buffer.

ida_hexrays.minsn_t.ea
    instruction address

ida_hexrays.minsn_t.equal_insns(self, m: "minsn_t", eqflags: int) -> bool
    Compare instructions. This is the main comparison function for instructions. 
            
    @param m: instruction to compare with
    @param eqflags: combination of comparison bits bits

ida_hexrays.minsn_t.find_call(self, with_helpers: bool = False) -> "minsn_t *"
    Find a call instruction. Check for the current instruction and its subinstructions. 
            
    @param with_helpers: consider helper calls as well?

ida_hexrays.minsn_t.find_ins_op(self, op: "mcode_t" = m_nop) -> "minsn_t *"
    Find an operand that is a subinsruction with the specified opcode. This function checks only the 'l' and 'r' operands of the current insn. 
            
    @param op: opcode to search for
    @returns &l or &r or nullptr

ida_hexrays.minsn_t.find_num_op(self) -> "mop_t *"
    Find a numeric operand of the current instruction. This function checks only the 'l' and 'r' operands of the current insn. 
            
    @returns &l or &r or nullptr

ida_hexrays.minsn_t.find_opcode(self, mcode: "mcode_t") -> "minsn_t *"
    Find a (sub)insruction with the specified opcode. 
            
    @param mcode: opcode to search for.

ida_hexrays.minsn_t.for_all_insns(self, mv: "minsn_visitor_t") -> int
    Visit all instructions. This function visits the instruction itself and all its subinstructions. 
            
    @param mv: instruction visitor
    @returns non-zero value returned by mv.visit_mop() or zero

ida_hexrays.minsn_t.for_all_ops(self, mv: "mop_visitor_t") -> int
    Visit all instruction operands. This function visits subinstruction operands as well. 
            
    @param mv: operand visitor
    @returns non-zero value returned by mv.visit_mop() or zero

ida_hexrays.minsn_t.get_role(self) -> "funcrole_t"
    Get the function role of a call.

ida_hexrays.minsn_t.get_split_size(self) -> int

ida_hexrays.minsn_t.has_side_effects(self, include_ldx_and_divs: bool = False) -> bool
    Does the instruction have a side effect? 
            
    @param include_ldx_and_divs: consider ldx/div/mod as having side effects? stx is always considered as having side effects. Apart from ldx/std only call may have side effects.

ida_hexrays.minsn_t.iprops
    combination of instruction property bits bits

ida_hexrays.minsn_t.is_after(self, m: "minsn_t") -> bool
    Is the instruction after the specified one? 
            
    @param m: the instruction to compare against in the list

ida_hexrays.minsn_t.is_alloca(self) -> bool

ida_hexrays.minsn_t.is_assert(self) -> bool

ida_hexrays.minsn_t.is_between(self, m1: "minsn_t", m2: "minsn_t") -> bool
    Is the instruction in the specified range of instructions? 
            
    @param m1: beginning of the range in the doubly linked list
    @param m2: end of the range in the doubly linked list (excluded, may be nullptr) This function assumes that m1 and m2 belong to the same basic block and they are top level instructions.

ida_hexrays.minsn_t.is_bswap(self) -> bool

ida_hexrays.minsn_t.is_cleaning_pop(self) -> bool

ida_hexrays.minsn_t.is_combinable(self) -> bool

ida_hexrays.minsn_t.is_combined(self) -> bool

ida_hexrays.minsn_t.is_extstx(self) -> bool

ida_hexrays.minsn_t.is_farcall(self) -> bool

ida_hexrays.minsn_t.is_fpinsn(self) -> bool

ida_hexrays.minsn_t.is_helper(self, name: str) -> bool
    Is a helper call with the specified name? Helper calls usually have well-known function names (see Well known function names) but they may have any other name. The decompiler does not assume any special meaning for non-well-known names. 
            

ida_hexrays.minsn_t.is_ignlowsrc(self) -> bool

ida_hexrays.minsn_t.is_inverted_jx(self) -> bool

ida_hexrays.minsn_t.is_like_move(self) -> bool

ida_hexrays.minsn_t.is_mbarrier(self) -> bool

ida_hexrays.minsn_t.is_memcpy(self) -> bool

ida_hexrays.minsn_t.is_memset(self) -> bool

ida_hexrays.minsn_t.is_mov(self) -> bool

ida_hexrays.minsn_t.is_multimov(self) -> bool

ida_hexrays.minsn_t.is_noret_call(self, flags: int = 0) -> bool
    Is a non-returing call? 
            
    @param flags: combination of NORET_... bits

ida_hexrays.minsn_t.is_optional(self) -> bool

ida_hexrays.minsn_t.is_persistent(self) -> bool

ida_hexrays.minsn_t.is_propagatable(self) -> bool

ida_hexrays.minsn_t.is_readflags(self) -> bool

ida_hexrays.minsn_t.is_tailcall(self) -> bool

ida_hexrays.minsn_t.is_unknown_call(self) -> bool
    Is an unknown call? Unknown calls are calls without the argument list (mcallinfo_t). Usually the argument lists are determined by mba_t::analyze_calls(). Unknown calls exist until the MMAT_CALLS maturity level. See also mblock_t::is_call_block 
            

ida_hexrays.minsn_t.is_wild_match(self) -> bool

ida_hexrays.minsn_t.l
    left operand

ida_hexrays.minsn_t.lexcompare(self, ri: "minsn_t") -> int

ida_hexrays.minsn_t.may_use_aliased_memory(self) -> bool
    Is it possible for the instruction to use aliased memory?

ida_hexrays.minsn_t.modifies_d(self) -> bool
    Does the instruction modify its 'd' operand? Some instructions (e.g. m_stx) do not modify the 'd' operand. 
            

ida_hexrays.minsn_t.modifies_pair_mop(self) -> bool

ida_hexrays.minsn_t.next
    next insn in doubly linked list. check also nexti()

ida_hexrays.minsn_t.opcode
    instruction opcode

ida_hexrays.minsn_t.optimize_solo(self, optflags: int = 0) -> int
    Optimize one instruction without context. This function does not have access to the instruction context (the previous and next instructions in the list, the block number, etc). It performs only basic optimizations that are available without this info. 
            
    @param optflags: combination of optimization flags bits
    @returns number of changes, 0-unchanged See also mblock_t::optimize_insn()

ida_hexrays.minsn_t.optimize_subtree(self, blk: "mblock_t", top: "minsn_t", parent: "minsn_t", converted_call: "ea_t *", optflags: int = 2) -> int
    Optimize instruction in its context. Do not use this function, use mblock_t::optimize() 
            

ida_hexrays.minsn_t.prev
    prev insn in doubly linked list. check also previ()

ida_hexrays.minsn_t.r
    right operand

ida_hexrays.minsn_t.replace_by(self, o)

ida_hexrays.minsn_t.serialize(self, b: "bytevec_t *") -> int
    Serialize an instruction 
            
    @param b: the output buffer
    @returns the serialization format that was used to store info

ida_hexrays.minsn_t.set_assert(self) -> None

ida_hexrays.minsn_t.set_cleaning_pop(self) -> None

ida_hexrays.minsn_t.set_combinable(self) -> None

ida_hexrays.minsn_t.set_extstx(self) -> None

ida_hexrays.minsn_t.set_farcall(self) -> None

ida_hexrays.minsn_t.set_fpinsn(self) -> None

ida_hexrays.minsn_t.set_ignlowsrc(self) -> None

ida_hexrays.minsn_t.set_inverted_jx(self) -> None

ida_hexrays.minsn_t.set_mbarrier(self) -> None

ida_hexrays.minsn_t.set_multimov(self) -> None

ida_hexrays.minsn_t.set_noret_icall(self) -> None

ida_hexrays.minsn_t.set_optional(self) -> None

ida_hexrays.minsn_t.set_persistent(self) -> None

ida_hexrays.minsn_t.set_split_size(self, s: int) -> None

ida_hexrays.minsn_t.set_tailcall(self) -> None

ida_hexrays.minsn_t.set_unmerged(self) -> None

ida_hexrays.minsn_t.set_wild_match(self) -> None

ida_hexrays.minsn_t.setaddr(self, new_ea: ida_idaapi.ea_t) -> None
    Change the instruction address. This function modifies subinstructions as well. 
            

ida_hexrays.minsn_t.swap(self, m: "minsn_t") -> None
    Swap two instructions. The prev/next fields are not modified by this function because it would corrupt the doubly linked list. 
            

ida_hexrays.minsn_t.was_noret_icall(self) -> bool

ida_hexrays.minsn_t.was_split(self) -> bool

ida_hexrays.minsn_t.was_unmerged(self) -> bool

ida_hexrays.minsn_t.was_unpaired(self) -> bool

ida_hexrays.minsn_visitor_t

ida_hexrays.minsn_visitor_t.__disown__(self)

ida_hexrays.minsn_visitor_t.__init__(self, _mba: "mba_t" = None, _blk: "mblock_t" = None, _topins: "minsn_t" = None)

ida_hexrays.minsn_visitor_t.visit_minsn(self) -> int

ida_hexrays.mlist_mop_visitor_t

ida_hexrays.mlist_mop_visitor_t.__disown__(self)

ida_hexrays.mlist_mop_visitor_t.__init__(self)

ida_hexrays.mlist_mop_visitor_t.prune
    Should skip sub-operands of the current operand? visit_mop() may set 'prune=true' for that. 
            

ida_hexrays.mlist_mop_visitor_t.visit_mop(self, op: "mop_t") -> int

ida_hexrays.mlist_t

ida_hexrays.mlist_t.__eq__(self, r: "mlist_t") -> bool

ida_hexrays.mlist_t.__ge__(self, r: "mlist_t") -> bool

ida_hexrays.mlist_t.__gt__(self, r: "mlist_t") -> bool

ida_hexrays.mlist_t.__init__(self, *args)

ida_hexrays.mlist_t.__le__(self, r: "mlist_t") -> bool

ida_hexrays.mlist_t.__lt__(self, r: "mlist_t") -> bool

ida_hexrays.mlist_t.__ne__(self, r: "mlist_t") -> bool

ida_hexrays.mlist_t._print(self) -> None

ida_hexrays.mlist_t.add(self, *args) -> bool
    This function has the following signatures:
    
        0. add(r: mreg_t, size: int) -> bool
        1. add(r: const rlist_t &) -> bool
        2. add(ivl: const ivl_t &) -> bool
        3. add(lst: const mlist_t &) -> bool
    
    # 0: add(r: mreg_t, size: int) -> bool
    
    
    # 1: add(r: const rlist_t &) -> bool
    
    
    # 2: add(ivl: const ivl_t &) -> bool
    
    
    # 3: add(lst: const mlist_t &) -> bool

ida_hexrays.mlist_t.addmem(self, ea: ida_idaapi.ea_t, size: "asize_t") -> bool

ida_hexrays.mlist_t.clear(self) -> None

ida_hexrays.mlist_t.compare(self, r: "mlist_t") -> int

ida_hexrays.mlist_t.count(self) -> "asize_t"

ida_hexrays.mlist_t.dstr(self) -> str

ida_hexrays.mlist_t.empty(self) -> bool

ida_hexrays.mlist_t.has(self, r: "mreg_t") -> bool

ida_hexrays.mlist_t.has_all(self, r: "mreg_t", size: int) -> bool

ida_hexrays.mlist_t.has_any(self, r: "mreg_t", size: int) -> bool

ida_hexrays.mlist_t.has_common(self, lst: "mlist_t") -> bool

ida_hexrays.mlist_t.has_memory(self) -> bool

ida_hexrays.mlist_t.includes(self, lst: "mlist_t") -> bool

ida_hexrays.mlist_t.intersect(self, lst: "mlist_t") -> bool

ida_hexrays.mlist_t.is_subset_of(self, lst: "mlist_t") -> bool

ida_hexrays.mlist_t.sub(self, *args) -> bool
    This function has the following signatures:
    
        0. sub(r: mreg_t, size: int) -> bool
        1. sub(ivl: const ivl_t &) -> bool
        2. sub(lst: const mlist_t &) -> bool
    
    # 0: sub(r: mreg_t, size: int) -> bool
    
    
    # 1: sub(ivl: const ivl_t &) -> bool
    
    
    # 2: sub(lst: const mlist_t &) -> bool

ida_hexrays.mlist_t.swap(self, r: "mlist_t") -> None

ida_hexrays.mnumber_t

ida_hexrays.mnumber_t.__eq__(self, r: "mnumber_t") -> bool

ida_hexrays.mnumber_t.__ge__(self, r: "mnumber_t") -> bool

ida_hexrays.mnumber_t.__gt__(self, r: "mnumber_t") -> bool

ida_hexrays.mnumber_t.__init__(self, *args)

ida_hexrays.mnumber_t.__le__(self, r: "mnumber_t") -> bool

ida_hexrays.mnumber_t.__lt__(self, r: "mnumber_t") -> bool

ida_hexrays.mnumber_t.__ne__(self, r: "mnumber_t") -> bool

ida_hexrays.mnumber_t.compare(self, r: "mnumber_t") -> int

ida_hexrays.mnumber_t.update_value(self, val64: "uint64") -> None

ida_hexrays.modify_user_lvar_info(func_ea: ida_idaapi.ea_t, mli_flags: "uint", info: "lvar_saved_info_t") -> bool
    Modify saved local variable settings of one variable. 
            
    @param func_ea: function start address
    @param mli_flags: bits that specify which attrs defined by INFO are to be set
    @param info: local variable info attrs
    @returns true if modified, false if invalid MLI_FLAGS passed

ida_hexrays.modify_user_lvars(entry_ea: ida_idaapi.ea_t, mlv: "user_lvar_modifier_t") -> bool
    Modify saved local variable settings. 
            
    @param entry_ea: function start address
    @param mlv: local variable modifier
    @returns true if modified variables

ida_hexrays.mop_S
    local stack variable (they exist until MMAT_LVARS)

ida_hexrays.mop_a
    mop_addr_t: address of operand (mop_l, mop_v, mop_S, mop_r)

ida_hexrays.mop_addr_t

ida_hexrays.mop_addr_t.__init__(self, *args)

ida_hexrays.mop_addr_t.lexcompare(self, ra: "mop_addr_t") -> int

ida_hexrays.mop_b
    micro basic block (mblock_t)

ida_hexrays.mop_c
    mcases

ida_hexrays.mop_d
    result of another instruction

ida_hexrays.mop_f
    list of arguments

ida_hexrays.mop_fn
    floating point constant

ida_hexrays.mop_h
    helper function

ida_hexrays.mop_l
    local variable

ida_hexrays.mop_n
    immediate number constant

ida_hexrays.mop_p
    operand pair

ida_hexrays.mop_pair_t

ida_hexrays.mop_pair_t.__init__(self)

ida_hexrays.mop_pair_t.hop
    high operand

ida_hexrays.mop_pair_t.lop
    low operand

ida_hexrays.mop_r
    register (they exist until MMAT_LVARS)

ida_hexrays.mop_sc
    scattered

ida_hexrays.mop_str
    immediate string constant (user representation)

ida_hexrays.mop_t

ida_hexrays.mop_t.__dbg_get_meminfo(self) -> str

ida_hexrays.mop_t.__dbg_get_registered_kind(self) -> int

ida_hexrays.mop_t.__eq__(self, rop: "mop_t") -> bool

ida_hexrays.mop_t.__init__(self, *args)

ida_hexrays.mop_t.__lt__(self, rop: "mop_t") -> bool

ida_hexrays.mop_t.__ne__(self, rop: "mop_t") -> bool

ida_hexrays.mop_t._acquire_ownership(self, v, acquire)

ida_hexrays.mop_t._deregister(self) -> None

ida_hexrays.mop_t._ensure_cond(self, ok, cond_str)

ida_hexrays.mop_t._ensure_no_obj(self, o, attr, attr_is_acquired)

ida_hexrays.mop_t._ensure_no_t(self)

ida_hexrays.mop_t._ensure_ownership_transferrable(self, v)

ida_hexrays.mop_t._get_a(self) -> "mop_addr_t *"

ida_hexrays.mop_t._get_b(self) -> int

ida_hexrays.mop_t._get_c(self) -> "mcases_t *"

ida_hexrays.mop_t._get_cstr(self) -> str

ida_hexrays.mop_t._get_d(self) -> "minsn_t *"

ida_hexrays.mop_t._get_f(self) -> "mcallinfo_t *"

ida_hexrays.mop_t._get_fpc(self) -> "fnumber_t *"

ida_hexrays.mop_t._get_g(self) -> ida_idaapi.ea_t

ida_hexrays.mop_t._get_helper(self) -> str

ida_hexrays.mop_t._get_l(self) -> "lvar_ref_t *"

ida_hexrays.mop_t._get_nnn(self) -> "mnumber_t *"

ida_hexrays.mop_t._get_pair(self) -> "mop_pair_t *"

ida_hexrays.mop_t._get_r(self) -> "mreg_t"

ida_hexrays.mop_t._get_s(self) -> "stkvar_ref_t *"

ida_hexrays.mop_t._get_scif(self) -> "scif_t *"

ida_hexrays.mop_t._get_t(self) -> "mopt_t"

ida_hexrays.mop_t._make_blkref(self, blknum: int) -> None
    Create a block reference operand without erasing previous data. 
            
    @param blknum: block number Note: this function does not erase the previous contents of the operand; call erase() if necessary

ida_hexrays.mop_t._make_callinfo(self, fi: "mcallinfo_t") -> None
    Create a call info operand without erasing previous data. 
            
    @param fi: callinfo Note: this function does not erase the previous contents of the operand; call erase() if necessary

ida_hexrays.mop_t._make_cases(self, _cases: "mcases_t") -> None
    Create a 'switch cases' operand without erasing previous data. Note: this function does not erase the previous contents of the operand; call erase() if necessary 
            

ida_hexrays.mop_t._make_gvar(self, ea: ida_idaapi.ea_t) -> None
    Create a global variable operand without erasing previous data. 
            
    @param ea: address of the variable Note: this function does not erase the previous contents of the operand; call erase() if necessary

ida_hexrays.mop_t._make_insn(self, ins: "minsn_t") -> None
    Create a nested instruction without erasing previous data. 
            
    @param ins: pointer to the instruction to encapsulate into the operand Note: this function does not erase the previous contents of the operand; call erase() if necessary See also create_from_insn, which is higher level

ida_hexrays.mop_t._make_lvar(self, mba: "mba_t", idx: int, off: int = 0) -> None
    Create a local variable operand. 
            
    @param mba: pointer to microcode
    @param idx: index into mba->vars
    @param off: offset from the beginning of the variable Note: this function does not erase the previous contents of the operand; call erase() if necessary

ida_hexrays.mop_t._make_pair(self, _pair: "mop_pair_t") -> None
    Create a pair operand without erasing previous data. Note: this function does not erase the previous contents of the operand; call erase() if necessary 
            

ida_hexrays.mop_t._make_reg(self, *args) -> None
    This function has the following signatures:
    
        0. _make_reg(reg: mreg_t) -> None
        1. _make_reg(reg: mreg_t, _size: int) -> None
    
    # 0: _make_reg(reg: mreg_t) -> None
    
    Create a register operand without erasing previous data. 
            
    
    # 1: _make_reg(reg: mreg_t, _size: int) -> None

ida_hexrays.mop_t._make_stkvar(self, mba: "mba_t", off: int) -> None
    Create a stack variable operand. 
            
    @param mba: pointer to microcode
    @param off: decompiler stkoff Note: this function does not erase the previous contents of the operand; call erase() if necessary

ida_hexrays.mop_t._make_strlit(self, str: str) -> None
    Create a constant string operand.

ida_hexrays.mop_t._maybe_disown_and_deregister(self)

ida_hexrays.mop_t._meminfo(self)

ida_hexrays.mop_t._obj_id(self) -> "PyObject *"

ida_hexrays.mop_t._own_and_register(self)

ida_hexrays.mop_t._print(self, *args) -> None

ida_hexrays.mop_t._register(self) -> None

ida_hexrays.mop_t._set_a(self, _v: "mop_addr_t") -> None

ida_hexrays.mop_t._set_b(self, _v: int) -> None

ida_hexrays.mop_t._set_c(self, _v: "mcases_t") -> None

ida_hexrays.mop_t._set_cstr(self, _v: str) -> None

ida_hexrays.mop_t._set_d(self, _v: "minsn_t") -> None

ida_hexrays.mop_t._set_f(self, _v: "mcallinfo_t") -> None

ida_hexrays.mop_t._set_fpc(self, _v: "fnumber_t") -> None

ida_hexrays.mop_t._set_g(self, _v: ida_idaapi.ea_t) -> None

ida_hexrays.mop_t._set_helper(self, _v: str) -> None

ida_hexrays.mop_t._set_l(self, _v: "lvar_ref_t") -> None

ida_hexrays.mop_t._set_nnn(self, _v: "mnumber_t") -> None

ida_hexrays.mop_t._set_pair(self, _v: "mop_pair_t") -> None

ida_hexrays.mop_t._set_r(self, _v: "mreg_t") -> None

ida_hexrays.mop_t._set_s(self, _v: "stkvar_ref_t") -> None

ida_hexrays.mop_t._set_scif(self, _v: "scif_t") -> None

ida_hexrays.mop_t._set_t(self, v: "mopt_t") -> None

ida_hexrays.mop_t.apply_ld_mcode(self, mcode: "mcode_t", ea: ida_idaapi.ea_t, newsize: int) -> None
    Apply a unary opcode to the operand. 
            
    @param mcode: opcode to apply. it must accept 'l' and 'd' operands but not 'r'. examples: m_low/m_high/m_xds/m_xdu
    @param ea: value of minsn_t::ea for the newly created insruction
    @param newsize: new operand size Example: apply_ld_mcode(m_low) will convert op => low(op)

ida_hexrays.mop_t.apply_xds(self, ea: ida_idaapi.ea_t, newsize: int) -> None

ida_hexrays.mop_t.apply_xdu(self, ea: ida_idaapi.ea_t, newsize: int) -> None

ida_hexrays.mop_t.assign(self, rop: "mop_t") -> "mop_t &"

ida_hexrays.mop_t.change_size(self, nsize: int, sideff: "side_effect_t" = WITH_SIDEFF) -> bool
    Change the operand size. Examples: change_size(AL.1, 2) -> AX.2 change_size(qword_00000008.8, 4) -> dword_00000008.4 change_size(xdu.8(op.4), 4) -> op.4 change_size(#0x12345678.4, 1) -> #0x78.1 
            
    @param nsize: new operand size
    @param sideff: may modify the database because of the size change?
    @returns success

ida_hexrays.mop_t.create_from_insn(self, m: "minsn_t") -> None
    Create operand from an instruction. This function creates a nested instruction that can be used as an operand. Example: if m="add x,y,z", our operand will be (t=mop_d,d=m). The destination operand of 'add' (z) is lost. 
            
    @param m: instruction to embed into operand. may not be nullptr.

ida_hexrays.mop_t.create_from_ivlset(self, mba: "mba_t", ivs: "ivlset_t", fullsize: int) -> bool
    Create operand from ivlset_t. Example: if IVS contains [glbvar..glbvar+4), our operand will be (t=mop_v, g=&glbvar, size=4) 
            
    @param mba: pointer to microcode
    @param ivs: set of memory intervals
    @param fullsize: mba->fullsize
    @returns success

ida_hexrays.mop_t.create_from_mlist(self, mba: "mba_t", lst: "mlist_t", fullsize: int) -> bool
    Create operand from mlist_t. Example: if LST contains 4 bits for R0.4, our operand will be (t=mop_r, r=R0, size=4) 
            
    @param mba: pointer to microcode
    @param lst: list of locations
    @param fullsize: mba->fullsize
    @returns success

ida_hexrays.mop_t.create_from_scattered_vdloc(self, mba: "mba_t", name: str, type: "tinfo_t", loc: "vdloc_t") -> None
    Create operand from scattered vdloc_t. Example: if LOC is (ALOC_DIST, {EAX.4, EDX.4}) and TYPE is _LARGE_INTEGER, our operand will be (t=mop_sc, scif={EAX.4, EDX.4}) 
            
    @param mba: pointer to microcode
    @param name: name of the operand, if available
    @param type: type of the operand, must be present
    @param loc: a scattered location
    @returns success

ida_hexrays.mop_t.create_from_vdloc(self, mba: "mba_t", loc: "vdloc_t", _size: int) -> None
    Create operand from vdloc_t. Example: if LOC contains (type=ALOC_REG1, r=R0), our operand will be (t=mop_r, r=R0, size=_SIZE) 
            
    @param mba: pointer to microcode
    @param loc: location
    @param _size: operand size Note: this function cannot handle scattered locations.
    @returns success

ida_hexrays.mop_t.double_size(self, sideff: "side_effect_t" = WITH_SIDEFF) -> bool

ida_hexrays.mop_t.dstr(self) -> str

ida_hexrays.mop_t.empty(self) -> bool

ida_hexrays.mop_t.equal_mops(self, rop: "mop_t", eqflags: int) -> bool
    Compare operands. This is the main comparison function for operands. 
            
    @param rop: operand to compare with
    @param eqflags: combination of comparison bits bits

ida_hexrays.mop_t.erase(self) -> None

ida_hexrays.mop_t.erase_but_keep_size(self) -> None

ida_hexrays.mop_t.for_all_ops(self, mv: "mop_visitor_t", type: "tinfo_t" = None, is_target: bool = False) -> int
    Visit the operand and all its sub-operands. This function visits the current operand as well. 
            
    @param mv: visitor object
    @param type: operand type
    @param is_target: is a destination operand?

ida_hexrays.mop_t.for_all_scattered_submops(self, sv: "scif_visitor_t") -> int
    Visit all sub-operands of a scattered operand. This function does not visit the current operand, only its sub-operands. All sub-operands are synthetic and are destroyed after the visitor. This function works only with scattered operands. 
            
    @param sv: visitor object

ida_hexrays.mop_t.get_insn(self, code: "mcode_t") -> "minsn_t *"
    Get subinstruction of the operand. If the operand has a subinstruction with the specified opcode, return it. 
            
    @param code: desired opcode
    @returns pointer to the instruction or nullptr

ida_hexrays.mop_t.get_stkoff(self, p_vdoff: "sval_t *") -> bool
    Get the referenced stack offset. This function can also handle mop_sc if it is entirely mapped into a continuous stack region. 
            
    @param p_vdoff: the output buffer
    @returns success

ida_hexrays.mop_t.get_stkvar(self, udm: "udm_t" = None, p_idaoff: "uval_t *" = None) -> "ssize_t"
    Retrieve the referenced stack variable. 
            
    @param udm: stkvar, may be nullptr
    @param p_idaoff: if specified, will hold IDA stkoff after the call.
    @returns index of stkvar in the frame or -1

ida_hexrays.mop_t.has_side_effects(self, include_ldx_and_divs: bool = False) -> bool
    Has any side effects? 
            
    @param include_ldx_and_divs: consider ldx/div/mod as having side effects?

ida_hexrays.mop_t.is01(self) -> bool
    Are the possible values of the operand only 0 and 1? This function returns true for 0/1 constants, bit registers, the result of 'set' insns, etc. 
            

ida_hexrays.mop_t.is_arglist(self) -> bool
    Is a list of arguments?

ida_hexrays.mop_t.is_bit_reg(self, *args) -> bool
    This function has the following signatures:
    
        0. is_bit_reg() -> bool
        1. is_bit_reg(reg: mreg_t) -> bool
    
    # 0: is_bit_reg() -> bool
    
    
    # 1: is_bit_reg(reg: mreg_t) -> bool
    
    Is a bit register? This includes condition codes and eventually other bit registers 
            

ida_hexrays.mop_t.is_cc(self) -> bool
    Is a condition code?

ida_hexrays.mop_t.is_ccflags(self) -> bool

ida_hexrays.mop_t.is_constant(self, is_signed: bool = True) -> bool
    Retrieve value of a constant integer operand. 
            
    @param is_signed: should treat the value as signed
    @returns true if the operand is mop_n

ida_hexrays.mop_t.is_equal_to(self, n: "uint64", is_signed: bool = True) -> bool

ida_hexrays.mop_t.is_extended_from(self, nbytes: int, is_signed: bool) -> bool
    Does the high part of the operand consist of zero or sign bytes?

ida_hexrays.mop_t.is_glbaddr(self, *args) -> bool
    This function has the following signatures:
    
        0. is_glbaddr() -> bool
        1. is_glbaddr(ea: ida_idaapi.ea_t) -> bool
    
    # 0: is_glbaddr() -> bool
    
    Is address of a global memory cell?
    
    
    # 1: is_glbaddr(ea: ida_idaapi.ea_t) -> bool
    
    Is address of the specified global memory cell?

ida_hexrays.mop_t.is_glbaddr_from_fixup(self) -> bool

ida_hexrays.mop_t.is_impptr_done(self) -> bool

ida_hexrays.mop_t.is_insn(self, *args) -> bool
    This function has the following signatures:
    
        0. is_insn() -> bool
        1. is_insn(code: mcode_t) -> bool
    
    # 0: is_insn() -> bool
    
    Is a sub-instruction?
    
    
    # 1: is_insn(code: mcode_t) -> bool
    
    Is a sub-instruction with the specified opcode?

ida_hexrays.mop_t.is_kreg(self) -> bool
    Is a kernel register?

ida_hexrays.mop_t.is_lowaddr(self) -> bool

ida_hexrays.mop_t.is_mob(self, serial: int) -> bool
    Is a block reference to the specified block?

ida_hexrays.mop_t.is_negative_constant(self) -> bool

ida_hexrays.mop_t.is_one(self) -> bool

ida_hexrays.mop_t.is_pcval(self) -> bool

ida_hexrays.mop_t.is_positive_constant(self) -> bool

ida_hexrays.mop_t.is_reg(self, *args) -> bool
    This function has the following signatures:
    
        0. is_reg() -> bool
        1. is_reg(_r: mreg_t) -> bool
        2. is_reg(_r: mreg_t, _size: int) -> bool
    
    # 0: is_reg() -> bool
    
    Is a register operand? See also get_mreg_name() 
            
    
    # 1: is_reg(_r: mreg_t) -> bool
    
    Is the specified register?
    
    
    # 2: is_reg(_r: mreg_t, _size: int) -> bool
    
    Is the specified register of the specified size?

ida_hexrays.mop_t.is_scattered(self) -> bool
    Is a scattered operand?

ida_hexrays.mop_t.is_sign_extended_from(self, nbytes: int) -> bool
    Does the high part of the operand consist of the sign bytes? 
            
    @param nbytes: number of bytes that were sign extended. the remaining size-nbytes high bytes must be sign bytes Example: is_sign_extended_from(xds.4(op.1), 1) -> true because the high 3 bytes are certainly sign bits

ida_hexrays.mop_t.is_stkaddr(self) -> bool
    Is address of a stack variable?

ida_hexrays.mop_t.is_udt(self) -> bool

ida_hexrays.mop_t.is_undef_val(self) -> bool

ida_hexrays.mop_t.is_zero(self) -> bool

ida_hexrays.mop_t.is_zero_extended_from(self, nbytes: int) -> bool
    Does the high part of the operand consist of zero bytes? 
            
    @param nbytes: number of bytes that were zero extended. the remaining size-nbytes high bytes must be zero Example: is_zero_extended_from(xdu.8(op.1), 2) -> true because the high 6 bytes are certainly zero

ida_hexrays.mop_t.lexcompare(self, rop: "mop_t") -> int

ida_hexrays.mop_t.make_blkref(self, blknum: int) -> None
    Create a global variable operand.

ida_hexrays.mop_t.make_first_half(self, width: int) -> bool
    Make the first part of the operand. This function does not care about the memory endianness 
            
    @param width: the desired size of the operand part in bytes
    @returns success

ida_hexrays.mop_t.make_fpnum(self, bytes: "void const *") -> bool
    Create a floating point constant operand. 
            
    @param bytes: pointer to the floating point value as used by the current processor (e.g. for x86 it must be in IEEE 754)
    @returns success

ida_hexrays.mop_t.make_gvar(self, ea: ida_idaapi.ea_t) -> None
    Create a global variable operand.

ida_hexrays.mop_t.make_helper(self, name: str) -> None
    Create a helper operand. A helper operand usually keeps a built-in function name like "va_start" It is essentially just an arbitrary identifier without any additional info. 
            

ida_hexrays.mop_t.make_high_half(self, width: int) -> bool
    Make the high part of the operand. This function takes into account the memory endianness (byte sex) 
            
    @param width: the desired size of the operand part in bytes
    @returns success

ida_hexrays.mop_t.make_insn(self, ins: "minsn_t") -> None
    Create a nested instruction.

ida_hexrays.mop_t.make_low_half(self, width: int) -> bool
    Make the low part of the operand. This function takes into account the memory endianness (byte sex) 
            
    @param width: the desired size of the operand part in bytes
    @returns success

ida_hexrays.mop_t.make_number(self, *args) -> None
    Create an integer constant operand. 
            
    @param _value: value to store in the operand
    @param _size: size of the value in bytes (1,2,4,8)
    @param _ea: address of the processor instruction that made the value
    @param opnum: operand number of the processor instruction

ida_hexrays.mop_t.make_reg(self, *args) -> None
    This function has the following signatures:
    
        0. make_reg(reg: mreg_t) -> None
        1. make_reg(reg: mreg_t, _size: int) -> None
    
    # 0: make_reg(reg: mreg_t) -> None
    
    Create a register operand.
    
    
    # 1: make_reg(reg: mreg_t, _size: int) -> None

ida_hexrays.mop_t.make_reg_pair(self, loreg: int, hireg: int, halfsize: int) -> None
    Create pair of registers. 
            
    @param loreg: register holding the low part of the value
    @param hireg: register holding the high part of the value
    @param halfsize: the size of each of loreg/hireg

ida_hexrays.mop_t.make_second_half(self, width: int) -> bool
    Make the second part of the operand. This function does not care about the memory endianness 
            
    @param width: the desired size of the operand part in bytes
    @returns success

ida_hexrays.mop_t.make_stkvar(self, mba: "mba_t", off: int) -> None

ida_hexrays.mop_t.may_use_aliased_memory(self) -> bool
    Is it possible for the operand to use aliased memory?

ida_hexrays.mop_t.oprops
    Operand properties.

ida_hexrays.mop_t.preserve_side_effects(self, blk: "mblock_t", top: "minsn_t", moved_calls: "bool *" = None) -> bool
    Move subinstructions with side effects out of the operand. If we decide to delete an instruction operand, it is a good idea to call this function. Alternatively we should skip such operands by calling mop_t::has_side_effects() For example, if we transform: jnz x, x, @blk => goto @blk then we must call this function before deleting the X operands. 
            
    @param blk: current block
    @param top: top level instruction that contains our operand
    @param moved_calls: pointer to the boolean that will track if all side effects get handled correctly. must be false initially.
    @returns false failed to preserve a side effect, it is not safe to delete the operand true no side effects or successfully preserved them

ida_hexrays.mop_t.probably_floating(self) -> bool

ida_hexrays.mop_t.replace_by(self, o)

ida_hexrays.mop_t.set_impptr_done(self) -> None

ida_hexrays.mop_t.set_lowaddr(self) -> None

ida_hexrays.mop_t.set_udt(self) -> None

ida_hexrays.mop_t.set_undef_val(self) -> None

ida_hexrays.mop_t.shift_mop(self, offset: int) -> bool
    Shift the operand. This function shifts only the beginning of the operand. The operand size will be changed. Examples: shift_mop(AH.1, -1) -> AX.2 shift_mop(qword_00000008.8, 4) -> dword_0000000C.4 shift_mop(xdu.8(op.4), 4) -> #0.4 shift_mop(#0x12345678.4, 3) -> #12.1 
            
    @param offset: shift count (the number of bytes to shift)
    @returns success

ida_hexrays.mop_t.signed_value(self) -> "int64"

ida_hexrays.mop_t.size
    Operand size. Usually it is 1,2,4,8 or NOSIZE but for UDTs other sizes are permitted 
            

ida_hexrays.mop_t.swap(self, rop: "mop_t") -> None

ida_hexrays.mop_t.t
    Operand type.

ida_hexrays.mop_t.t
    Operand type.

ida_hexrays.mop_t.unsigned_value(self) -> "uint64"

ida_hexrays.mop_t.update_numop_value(self, val: "uint64") -> None

ida_hexrays.mop_t.valnum
    Value number. Zero means unknown. Operands with the same value number are equal. 
            

ida_hexrays.mop_t.value(self, is_signed: bool) -> "uint64"
    Retrieve value of a constant integer operand. These functions can be called only for mop_n operands. See is_constant() that can be called on any operand. 
            

ida_hexrays.mop_t.zero(self) -> None

ida_hexrays.mop_v
    global variable

ida_hexrays.mop_visitor_t

ida_hexrays.mop_visitor_t.__disown__(self)

ida_hexrays.mop_visitor_t.__init__(self, _mba: "mba_t" = None, _blk: "mblock_t" = None, _topins: "minsn_t" = None)

ida_hexrays.mop_visitor_t.prune
    Should skip sub-operands of the current operand? visit_mop() may set 'prune=true' for that. 
            

ida_hexrays.mop_visitor_t.visit_mop(self, op: "mop_t", type: "tinfo_t", is_target: bool) -> int

ida_hexrays.mop_z
    none

ida_hexrays.mopvec_t

ida_hexrays.mopvec_t.__eq__(self, r: "mopvec_t") -> bool

ida_hexrays.mopvec_t.__getitem__(self, i: "size_t") -> "mop_t const &"

ida_hexrays.mopvec_t.__init__(self, *args)

ida_hexrays.mopvec_t.__len__(self) -> "size_t"

ida_hexrays.mopvec_t.__ne__(self, r: "mopvec_t") -> bool

ida_hexrays.mopvec_t.__setitem__(self, i: "size_t", v: "mop_t") -> None

ida_hexrays.mopvec_t._del(self, x: "mop_t") -> bool

ida_hexrays.mopvec_t.add_unique(self, x: "mop_t") -> bool

ida_hexrays.mopvec_t.append(self, x: "mop_t") -> None

ida_hexrays.mopvec_t.at(self, _idx: "size_t") -> "mop_t const &"

ida_hexrays.mopvec_t.begin(self, *args) -> "qvector< mop_t >::const_iterator"

ida_hexrays.mopvec_t.capacity(self) -> "size_t"

ida_hexrays.mopvec_t.clear(self) -> None

ida_hexrays.mopvec_t.empty(self) -> bool

ida_hexrays.mopvec_t.end(self, *args) -> "qvector< mop_t >::const_iterator"

ida_hexrays.mopvec_t.erase(self, *args) -> "qvector< mop_t >::iterator"

ida_hexrays.mopvec_t.extend(self, x: "mopvec_t") -> None

ida_hexrays.mopvec_t.extract(self) -> "mop_t *"

ida_hexrays.mopvec_t.find(self, *args) -> "qvector< mop_t >::const_iterator"

ida_hexrays.mopvec_t.grow(self, *args) -> None

ida_hexrays.mopvec_t.has(self, x: "mop_t") -> bool

ida_hexrays.mopvec_t.inject(self, s: "mop_t", len: "size_t") -> None

ida_hexrays.mopvec_t.insert(self, it: "mop_t", x: "mop_t") -> "qvector< mop_t >::iterator"

ida_hexrays.mopvec_t.pop_back(self) -> None

ida_hexrays.mopvec_t.push_back(self, *args) -> "mop_t &"

ida_hexrays.mopvec_t.qclear(self) -> None

ida_hexrays.mopvec_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.mopvec_t.resize(self, *args) -> None

ida_hexrays.mopvec_t.size(self) -> "size_t"

ida_hexrays.mopvec_t.swap(self, r: "mopvec_t") -> None

ida_hexrays.mopvec_t.truncate(self) -> None

ida_hexrays.mreg2reg(reg: "mreg_t", width: int) -> int
    Map a microregister to a processor register. 
            
    @param reg: microregister number
    @param width: size of microregister in bytes
    @returns processor register id or -1

ida_hexrays.must_mcode_close_block(mcode: "mcode_t", including_calls: bool) -> bool
    Must an instruction with the given opcode be the last one in a block? Such opcodes are called closing opcodes. 
            
    @param mcode: instruction opcode
    @param including_calls: should m_call/m_icall be considered as the closing opcodes? If this function returns true, the opcode cannot appear in the middle of a block. Calls are a special case: unknown calls (is_unknown_call) are considered as closing opcodes.

ida_hexrays.negate_mcode_relation(code: "mcode_t") -> "mcode_t"

ida_hexrays.negated_relation(op: "ctype_t") -> "ctype_t"
    Negate a comparison operator. For example, cot_sge becomes cot_slt.

ida_hexrays.new_block()
    Create a new block-statement.

ida_hexrays.node_bitset_t

ida_hexrays.node_bitset_t.__init__(self, *args)

ida_hexrays.number_format_t

ida_hexrays.number_format_t.__init__(self, _opnum: int = 0)

ida_hexrays.number_format_t.flags
    ida flags, which describe number radix, enum, etc 
            

ida_hexrays.number_format_t.flags32
    low 32bit of flags (for compatibility)

ida_hexrays.number_format_t.get_radix(self) -> int
    Get number radix 
            
    @returns 2,8,10, or 16

ida_hexrays.number_format_t.has_unmutable_type(self) -> bool

ida_hexrays.number_format_t.is_char(self) -> bool
    Is a character constant?

ida_hexrays.number_format_t.is_dec(self) -> bool
    Is a decimal number?

ida_hexrays.number_format_t.is_enum(self) -> bool
    Is a symbolic constant?

ida_hexrays.number_format_t.is_fixed(self) -> bool
    Is number representation fixed? Fixed representation cannot be modified by the decompiler 
            

ida_hexrays.number_format_t.is_hex(self) -> bool
    Is a hexadecimal number?

ida_hexrays.number_format_t.is_numop(self) -> bool
    Is a number?

ida_hexrays.number_format_t.is_oct(self) -> bool
    Is a octal number?

ida_hexrays.number_format_t.is_stroff(self) -> bool
    Is a structure field offset?

ida_hexrays.number_format_t.needs_to_be_inverted(self) -> bool
    Does the number need to be negated or bitwise negated? Returns true if the user requested a negation but it is not done yet 
            

ida_hexrays.number_format_t.opnum
    operand number: 0..UA_MAXOP

ida_hexrays.number_format_t.org_nbytes
    original number size in bytes

ida_hexrays.number_format_t.props
    properties: combination of NF_ bits (Number format property bits) 
            

ida_hexrays.number_format_t.serial
    for enums: constant serial number

ida_hexrays.number_format_t.type_name
    for stroffs: structure for offsetof()
    for enums: enum name 
            

ida_hexrays.op_parent_info_t

ida_hexrays.op_parent_info_t.__disown__(self)

ida_hexrays.op_parent_info_t.__init__(self, _mba: "mba_t" = None, _blk: "mblock_t" = None, _topins: "minsn_t" = None)

ida_hexrays.op_uses_x(op: "ctype_t") -> bool
    Does operator use the 'x' field of cexpr_t?

ida_hexrays.op_uses_y(op: "ctype_t") -> bool
    Does operator use the 'y' field of cexpr_t?

ida_hexrays.op_uses_z(op: "ctype_t") -> bool
    Does operator use the 'z' field of cexpr_t?

ida_hexrays.open_pseudocode(ea: ida_idaapi.ea_t, flags: int) -> "vdui_t *"
    Open pseudocode window. The specified function is decompiled and the pseudocode window is opened. 
            
    @param ea: function to decompile
    @param flags: a combination of OPF_ flags
    @returns false if failed

ida_hexrays.operand_locator_t

ida_hexrays.operand_locator_t.__eq__(self, r: "operand_locator_t") -> bool

ida_hexrays.operand_locator_t.__ge__(self, r: "operand_locator_t") -> bool

ida_hexrays.operand_locator_t.__gt__(self, r: "operand_locator_t") -> bool

ida_hexrays.operand_locator_t.__init__(self, _ea: ida_idaapi.ea_t, _opnum: int)

ida_hexrays.operand_locator_t.__le__(self, r: "operand_locator_t") -> bool

ida_hexrays.operand_locator_t.__lt__(self, r: "operand_locator_t") -> bool

ida_hexrays.operand_locator_t.__ne__(self, r: "operand_locator_t") -> bool

ida_hexrays.operand_locator_t.compare(self, r: "operand_locator_t") -> int

ida_hexrays.operand_locator_t.ea
    address of the original processor instruction

ida_hexrays.operand_locator_t.opnum
    operand number in the instruction

ida_hexrays.optblock_t

ida_hexrays.optblock_t.__disown__(self)

ida_hexrays.optblock_t.__init__(self)

ida_hexrays.optblock_t.func(self, blk: "mblock_t") -> int
    Optimize a block. This function usually performs the optimizations that require analyzing the entire block and/or its neighbors. For example it can recognize patterns and perform conversions like: b0: b0: ... ... jnz x, 0, @b2 => jnz x, 0, @b2 b1: b1: add x, 0, y mov x, y ... ... 
            
    @param blk: Basic block to optimize as a whole.
    @returns number of changes made to the block. See also mark_lists_dirty.

ida_hexrays.optblock_t.install(self) -> None

ida_hexrays.optblock_t.remove(self) -> bool

ida_hexrays.optinsn_t

ida_hexrays.optinsn_t.__disown__(self)

ida_hexrays.optinsn_t.__init__(self)

ida_hexrays.optinsn_t.func(self, blk: "mblock_t", ins: "minsn_t", optflags: int) -> int
    Optimize an instruction. 
            
    @param blk: current basic block. maybe nullptr, which means that the instruction must be optimized without context
    @param ins: instruction to optimize; it is always a top-level instruction. the callback may not delete the instruction but may convert it into nop (see mblock_t::make_nop). to optimize sub-instructions, visit them using minsn_visitor_t. sub-instructions may not be converted into nop but can be converted to "mov x,x". for example: add x,0,x => mov x,x this callback may change other instructions in the block, but should do this with care, e.g. to no break the propagation algorithm if called with OPTI_NO_LDXOPT.
    @param optflags: combination of optimization flags bits
    @returns number of changes made to the instruction. if after this call the instruction's use/def lists have changed, you must mark the block level lists as dirty (see mark_lists_dirty)

ida_hexrays.optinsn_t.install(self) -> None

ida_hexrays.optinsn_t.remove(self) -> bool

ida_hexrays.parse_user_call(udc: "udcall_t", decl: str, silent: bool) -> bool
    Convert function type declaration into internal structure 
            
    @param udc: - pointer to output structure
    @param decl: - function type declaration
    @param silent: - if TRUE: do not show warning in case of incorrect type
    @returns success

ida_hexrays.partial_type_num(type: "tinfo_t") -> int
    Calculate number of partial subtypes. 
            
    @returns number of partial subtypes. The bigger is this number, the uglier is the type.

ida_hexrays.print_vdloc(loc: "vdloc_t", nbytes: int) -> str
    Print vdloc. Since vdloc does not always carry the size info, we pass it as NBYTES.. 
            

ida_hexrays.property_op_to_typename(self)

ida_hexrays.qstring_printer_t

ida_hexrays.qstring_printer_t.__init__(self, f: "cfunc_t", tags: bool)

ida_hexrays.qstring_printer_t._print(self, indent: int, format: str) -> int

ida_hexrays.qstring_printer_t.get_s(self) -> str

ida_hexrays.qstring_printer_t.s
    Reference to the output string 
            

ida_hexrays.qstring_printer_t.s
    Reference to the output string 
            

ida_hexrays.qstring_printer_t.with_tags
    Generate output with color tags.

ida_hexrays.qswap(a: "cinsn_t", b: "cinsn_t") -> None

ida_hexrays.qvector_carg_t

ida_hexrays.qvector_carg_t.__eq__(self, r: "qvector_carg_t") -> bool

ida_hexrays.qvector_carg_t.__getitem__(self, i: "size_t") -> "carg_t const &"

ida_hexrays.qvector_carg_t.__init__(self, *args)

ida_hexrays.qvector_carg_t.__len__(self) -> "size_t"

ida_hexrays.qvector_carg_t.__ne__(self, r: "qvector_carg_t") -> bool

ida_hexrays.qvector_carg_t.__setitem__(self, i: "size_t", v: "carg_t") -> None

ida_hexrays.qvector_carg_t._del(self, x: "carg_t") -> bool

ida_hexrays.qvector_carg_t.add_unique(self, x: "carg_t") -> bool

ida_hexrays.qvector_carg_t.append(self, x: "carg_t") -> None

ida_hexrays.qvector_carg_t.at(self, _idx: "size_t") -> "carg_t const &"

ida_hexrays.qvector_carg_t.begin(self, *args) -> "qvector< carg_t >::const_iterator"

ida_hexrays.qvector_carg_t.capacity(self) -> "size_t"

ida_hexrays.qvector_carg_t.clear(self) -> None

ida_hexrays.qvector_carg_t.empty(self) -> bool

ida_hexrays.qvector_carg_t.end(self, *args) -> "qvector< carg_t >::const_iterator"

ida_hexrays.qvector_carg_t.erase(self, *args) -> "qvector< carg_t >::iterator"

ida_hexrays.qvector_carg_t.extend(self, x: "qvector_carg_t") -> None

ida_hexrays.qvector_carg_t.extract(self) -> "carg_t *"

ida_hexrays.qvector_carg_t.find(self, *args) -> "qvector< carg_t >::const_iterator"

ida_hexrays.qvector_carg_t.grow(self, *args) -> None

ida_hexrays.qvector_carg_t.has(self, x: "carg_t") -> bool

ida_hexrays.qvector_carg_t.inject(self, s: "carg_t", len: "size_t") -> None

ida_hexrays.qvector_carg_t.insert(self, it: "carg_t", x: "carg_t") -> "qvector< carg_t >::iterator"

ida_hexrays.qvector_carg_t.pop_back(self) -> None

ida_hexrays.qvector_carg_t.push_back(self, *args) -> "carg_t &"

ida_hexrays.qvector_carg_t.qclear(self) -> None

ida_hexrays.qvector_carg_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.qvector_carg_t.resize(self, *args) -> None

ida_hexrays.qvector_carg_t.size(self) -> "size_t"

ida_hexrays.qvector_carg_t.swap(self, r: "qvector_carg_t") -> None

ida_hexrays.qvector_carg_t.truncate(self) -> None

ida_hexrays.qvector_catchexprs_t

ida_hexrays.qvector_catchexprs_t.__eq__(self, r: "qvector_catchexprs_t") -> bool

ida_hexrays.qvector_catchexprs_t.__getitem__(self, i: "size_t") -> "catchexpr_t const &"

ida_hexrays.qvector_catchexprs_t.__init__(self, *args)

ida_hexrays.qvector_catchexprs_t.__len__(self) -> "size_t"

ida_hexrays.qvector_catchexprs_t.__ne__(self, r: "qvector_catchexprs_t") -> bool

ida_hexrays.qvector_catchexprs_t.__setitem__(self, i: "size_t", v: "catchexpr_t") -> None

ida_hexrays.qvector_catchexprs_t._del(self, x: "catchexpr_t") -> bool

ida_hexrays.qvector_catchexprs_t.add_unique(self, x: "catchexpr_t") -> bool

ida_hexrays.qvector_catchexprs_t.append(self, x: "catchexpr_t") -> None

ida_hexrays.qvector_catchexprs_t.at(self, _idx: "size_t") -> "catchexpr_t const &"

ida_hexrays.qvector_catchexprs_t.begin(self, *args) -> "qvector< catchexpr_t >::const_iterator"

ida_hexrays.qvector_catchexprs_t.capacity(self) -> "size_t"

ida_hexrays.qvector_catchexprs_t.clear(self) -> None

ida_hexrays.qvector_catchexprs_t.empty(self) -> bool

ida_hexrays.qvector_catchexprs_t.end(self, *args) -> "qvector< catchexpr_t >::const_iterator"

ida_hexrays.qvector_catchexprs_t.erase(self, *args) -> "qvector< catchexpr_t >::iterator"

ida_hexrays.qvector_catchexprs_t.extend(self, x: "qvector_catchexprs_t") -> None

ida_hexrays.qvector_catchexprs_t.extract(self) -> "catchexpr_t *"

ida_hexrays.qvector_catchexprs_t.find(self, *args) -> "qvector< catchexpr_t >::const_iterator"

ida_hexrays.qvector_catchexprs_t.grow(self, *args) -> None

ida_hexrays.qvector_catchexprs_t.has(self, x: "catchexpr_t") -> bool

ida_hexrays.qvector_catchexprs_t.inject(self, s: "catchexpr_t", len: "size_t") -> None

ida_hexrays.qvector_catchexprs_t.insert(self, it: "catchexpr_t", x: "catchexpr_t") -> "qvector< catchexpr_t >::iterator"

ida_hexrays.qvector_catchexprs_t.pop_back(self) -> None

ida_hexrays.qvector_catchexprs_t.push_back(self, *args) -> "catchexpr_t &"

ida_hexrays.qvector_catchexprs_t.qclear(self) -> None

ida_hexrays.qvector_catchexprs_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.qvector_catchexprs_t.resize(self, *args) -> None

ida_hexrays.qvector_catchexprs_t.size(self) -> "size_t"

ida_hexrays.qvector_catchexprs_t.swap(self, r: "qvector_catchexprs_t") -> None

ida_hexrays.qvector_catchexprs_t.truncate(self) -> None

ida_hexrays.qvector_ccase_t

ida_hexrays.qvector_ccase_t.__eq__(self, r: "qvector_ccase_t") -> bool

ida_hexrays.qvector_ccase_t.__getitem__(self, i: "size_t") -> "ccase_t const &"

ida_hexrays.qvector_ccase_t.__init__(self, *args)

ida_hexrays.qvector_ccase_t.__len__(self) -> "size_t"

ida_hexrays.qvector_ccase_t.__ne__(self, r: "qvector_ccase_t") -> bool

ida_hexrays.qvector_ccase_t.__setitem__(self, i: "size_t", v: "ccase_t") -> None

ida_hexrays.qvector_ccase_t._del(self, x: "ccase_t") -> bool

ida_hexrays.qvector_ccase_t.add_unique(self, x: "ccase_t") -> bool

ida_hexrays.qvector_ccase_t.append(self, x: "ccase_t") -> None

ida_hexrays.qvector_ccase_t.at(self, _idx: "size_t") -> "ccase_t const &"

ida_hexrays.qvector_ccase_t.begin(self, *args) -> "qvector< ccase_t >::const_iterator"

ida_hexrays.qvector_ccase_t.capacity(self) -> "size_t"

ida_hexrays.qvector_ccase_t.clear(self) -> None

ida_hexrays.qvector_ccase_t.empty(self) -> bool

ida_hexrays.qvector_ccase_t.end(self, *args) -> "qvector< ccase_t >::const_iterator"

ida_hexrays.qvector_ccase_t.erase(self, *args) -> "qvector< ccase_t >::iterator"

ida_hexrays.qvector_ccase_t.extend(self, x: "qvector_ccase_t") -> None

ida_hexrays.qvector_ccase_t.extract(self) -> "ccase_t *"

ida_hexrays.qvector_ccase_t.find(self, *args) -> "qvector< ccase_t >::const_iterator"

ida_hexrays.qvector_ccase_t.grow(self, *args) -> None

ida_hexrays.qvector_ccase_t.has(self, x: "ccase_t") -> bool

ida_hexrays.qvector_ccase_t.inject(self, s: "ccase_t", len: "size_t") -> None

ida_hexrays.qvector_ccase_t.insert(self, it: "ccase_t", x: "ccase_t") -> "qvector< ccase_t >::iterator"

ida_hexrays.qvector_ccase_t.pop_back(self) -> None

ida_hexrays.qvector_ccase_t.push_back(self, *args) -> "ccase_t &"

ida_hexrays.qvector_ccase_t.qclear(self) -> None

ida_hexrays.qvector_ccase_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.qvector_ccase_t.resize(self, *args) -> None

ida_hexrays.qvector_ccase_t.size(self) -> "size_t"

ida_hexrays.qvector_ccase_t.swap(self, r: "qvector_ccase_t") -> None

ida_hexrays.qvector_ccase_t.truncate(self) -> None

ida_hexrays.qvector_ccatchvec_t

ida_hexrays.qvector_ccatchvec_t.__eq__(self, r: "qvector_ccatchvec_t") -> bool

ida_hexrays.qvector_ccatchvec_t.__getitem__(self, i: "size_t") -> "ccatch_t const &"

ida_hexrays.qvector_ccatchvec_t.__init__(self, *args)

ida_hexrays.qvector_ccatchvec_t.__len__(self) -> "size_t"

ida_hexrays.qvector_ccatchvec_t.__ne__(self, r: "qvector_ccatchvec_t") -> bool

ida_hexrays.qvector_ccatchvec_t.__setitem__(self, i: "size_t", v: "ccatch_t") -> None

ida_hexrays.qvector_ccatchvec_t._del(self, x: "ccatch_t") -> bool

ida_hexrays.qvector_ccatchvec_t.add_unique(self, x: "ccatch_t") -> bool

ida_hexrays.qvector_ccatchvec_t.append(self, x: "ccatch_t") -> None

ida_hexrays.qvector_ccatchvec_t.at(self, _idx: "size_t") -> "ccatch_t const &"

ida_hexrays.qvector_ccatchvec_t.begin(self, *args) -> "qvector< ccatch_t >::const_iterator"

ida_hexrays.qvector_ccatchvec_t.capacity(self) -> "size_t"

ida_hexrays.qvector_ccatchvec_t.clear(self) -> None

ida_hexrays.qvector_ccatchvec_t.empty(self) -> bool

ida_hexrays.qvector_ccatchvec_t.end(self, *args) -> "qvector< ccatch_t >::const_iterator"

ida_hexrays.qvector_ccatchvec_t.erase(self, *args) -> "qvector< ccatch_t >::iterator"

ida_hexrays.qvector_ccatchvec_t.extend(self, x: "qvector_ccatchvec_t") -> None

ida_hexrays.qvector_ccatchvec_t.extract(self) -> "ccatch_t *"

ida_hexrays.qvector_ccatchvec_t.find(self, *args) -> "qvector< ccatch_t >::const_iterator"

ida_hexrays.qvector_ccatchvec_t.grow(self, *args) -> None

ida_hexrays.qvector_ccatchvec_t.has(self, x: "ccatch_t") -> bool

ida_hexrays.qvector_ccatchvec_t.inject(self, s: "ccatch_t", len: "size_t") -> None

ida_hexrays.qvector_ccatchvec_t.insert(self, it: "ccatch_t", x: "ccatch_t") -> "qvector< ccatch_t >::iterator"

ida_hexrays.qvector_ccatchvec_t.pop_back(self) -> None

ida_hexrays.qvector_ccatchvec_t.push_back(self, *args) -> "ccatch_t &"

ida_hexrays.qvector_ccatchvec_t.qclear(self) -> None

ida_hexrays.qvector_ccatchvec_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.qvector_ccatchvec_t.resize(self, *args) -> None

ida_hexrays.qvector_ccatchvec_t.size(self) -> "size_t"

ida_hexrays.qvector_ccatchvec_t.swap(self, r: "qvector_ccatchvec_t") -> None

ida_hexrays.qvector_ccatchvec_t.truncate(self) -> None

ida_hexrays.qvector_history_t

ida_hexrays.qvector_history_t.__eq__(self, r: "qvector_history_t") -> bool

ida_hexrays.qvector_history_t.__getitem__(self, i: "size_t") -> "history_item_t const &"

ida_hexrays.qvector_history_t.__init__(self, *args)

ida_hexrays.qvector_history_t.__len__(self) -> "size_t"

ida_hexrays.qvector_history_t.__ne__(self, r: "qvector_history_t") -> bool

ida_hexrays.qvector_history_t.__setitem__(self, i: "size_t", v: "history_item_t") -> None

ida_hexrays.qvector_history_t._del(self, x: "history_item_t") -> bool

ida_hexrays.qvector_history_t.add_unique(self, x: "history_item_t") -> bool

ida_hexrays.qvector_history_t.append(self, x: "history_item_t") -> None

ida_hexrays.qvector_history_t.at(self, _idx: "size_t") -> "history_item_t const &"

ida_hexrays.qvector_history_t.begin(self, *args) -> "qvector< history_item_t >::const_iterator"

ida_hexrays.qvector_history_t.capacity(self) -> "size_t"

ida_hexrays.qvector_history_t.clear(self) -> None

ida_hexrays.qvector_history_t.empty(self) -> bool

ida_hexrays.qvector_history_t.end(self, *args) -> "qvector< history_item_t >::const_iterator"

ida_hexrays.qvector_history_t.erase(self, *args) -> "qvector< history_item_t >::iterator"

ida_hexrays.qvector_history_t.extend(self, x: "qvector_history_t") -> None

ida_hexrays.qvector_history_t.extract(self) -> "history_item_t *"

ida_hexrays.qvector_history_t.find(self, *args) -> "qvector< history_item_t >::const_iterator"

ida_hexrays.qvector_history_t.grow(self, *args) -> None

ida_hexrays.qvector_history_t.has(self, x: "history_item_t") -> bool

ida_hexrays.qvector_history_t.inject(self, s: "history_item_t", len: "size_t") -> None

ida_hexrays.qvector_history_t.insert(self, it: "history_item_t", x: "history_item_t") -> "qvector< history_item_t >::iterator"

ida_hexrays.qvector_history_t.pop_back(self) -> None

ida_hexrays.qvector_history_t.push_back(self, *args) -> "history_item_t &"

ida_hexrays.qvector_history_t.qclear(self) -> None

ida_hexrays.qvector_history_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.qvector_history_t.resize(self, *args) -> None

ida_hexrays.qvector_history_t.size(self) -> "size_t"

ida_hexrays.qvector_history_t.swap(self, r: "qvector_history_t") -> None

ida_hexrays.qvector_history_t.truncate(self) -> None

ida_hexrays.qvector_lvar_t

ida_hexrays.qvector_lvar_t.__eq__(self, r: "qvector_lvar_t") -> bool

ida_hexrays.qvector_lvar_t.__getitem__(self, i: "size_t") -> "lvar_t const &"

ida_hexrays.qvector_lvar_t.__init__(self, *args)

ida_hexrays.qvector_lvar_t.__len__(self) -> "size_t"

ida_hexrays.qvector_lvar_t.__ne__(self, r: "qvector_lvar_t") -> bool

ida_hexrays.qvector_lvar_t.__setitem__(self, i: "size_t", v: "lvar_t") -> None

ida_hexrays.qvector_lvar_t._del(self, x: "lvar_t") -> bool

ida_hexrays.qvector_lvar_t.add_unique(self, x: "lvar_t") -> bool

ida_hexrays.qvector_lvar_t.append(self, x: "lvar_t") -> None

ida_hexrays.qvector_lvar_t.at(self, _idx: "size_t") -> "lvar_t const &"

ida_hexrays.qvector_lvar_t.begin(self, *args) -> "qvector< lvar_t >::const_iterator"

ida_hexrays.qvector_lvar_t.capacity(self) -> "size_t"

ida_hexrays.qvector_lvar_t.clear(self) -> None

ida_hexrays.qvector_lvar_t.empty(self) -> bool

ida_hexrays.qvector_lvar_t.end(self, *args) -> "qvector< lvar_t >::const_iterator"

ida_hexrays.qvector_lvar_t.erase(self, *args) -> "qvector< lvar_t >::iterator"

ida_hexrays.qvector_lvar_t.extend(self, x: "qvector_lvar_t") -> None

ida_hexrays.qvector_lvar_t.extract(self) -> "lvar_t *"

ida_hexrays.qvector_lvar_t.find(self, *args) -> "qvector< lvar_t >::const_iterator"

ida_hexrays.qvector_lvar_t.grow(self, *args) -> None

ida_hexrays.qvector_lvar_t.has(self, x: "lvar_t") -> bool

ida_hexrays.qvector_lvar_t.inject(self, s: "lvar_t", len: "size_t") -> None

ida_hexrays.qvector_lvar_t.insert(self, it: "lvar_t", x: "lvar_t") -> "qvector< lvar_t >::iterator"

ida_hexrays.qvector_lvar_t.pop_back(self) -> None

ida_hexrays.qvector_lvar_t.push_back(self, *args) -> "lvar_t &"

ida_hexrays.qvector_lvar_t.qclear(self) -> None

ida_hexrays.qvector_lvar_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.qvector_lvar_t.resize(self, *args) -> None

ida_hexrays.qvector_lvar_t.size(self) -> "size_t"

ida_hexrays.qvector_lvar_t.swap(self, r: "qvector_lvar_t") -> None

ida_hexrays.qvector_lvar_t.truncate(self) -> None

ida_hexrays.reg2mreg(reg: int) -> "mreg_t"
    Map a processor register to a microregister. 
            
    @param reg: processor register number
    @returns microregister register id or mr_none

ida_hexrays.remitem(e: "citem_t") -> None

ida_hexrays.remove_hexrays_callback(callback)
    Uninstall handler for decompiler events. 
            
    @param callback: handler to uninstall
    @returns number of uninstalled handlers.

ida_hexrays.rename_lvar(func_ea: ida_idaapi.ea_t, oldname: str, newname: str) -> bool
    Rename a local variable. 
            
    @param func_ea: function start address
    @param oldname: old name of the variable
    @param newname: new name of the variable
    @returns success This is a convenience function. For bulk renaming consider using modify_user_lvars.

ida_hexrays.restore_user_cmts(func_ea: ida_idaapi.ea_t) -> "user_cmts_t *"
    Restore user defined comments from the database. 
            
    @param func_ea: the entry address of the function
    @returns collection of user defined comments. The returned object must be deleted by the caller using delete_user_cmts()

ida_hexrays.restore_user_defined_calls(udcalls: "udcall_map_t *", func_ea: ida_idaapi.ea_t) -> bool
    Restore user defined function calls from the database. 
            
    @param udcalls: ptr to output buffer
    @param func_ea: entry address of the function
    @returns success

ida_hexrays.restore_user_iflags(func_ea: ida_idaapi.ea_t) -> "user_iflags_t *"
    Restore user defined citem iflags from the database. 
            
    @param func_ea: the entry address of the function
    @returns collection of user defined iflags. The returned object must be deleted by the caller using delete_user_iflags()

ida_hexrays.restore_user_labels(func_ea: ida_idaapi.ea_t, func: "cfunc_t" = None) -> "user_labels_t *"
    Restore user defined labels from the database. 
            
    @param func_ea: the entry address of the function, ignored if FUNC != nullptr
    @param func: pointer to current function
    @returns collection of user defined labels. The returned object must be deleted by the caller using delete_user_labels()

ida_hexrays.restore_user_lvar_settings(lvinf: "lvar_uservec_t", func_ea: ida_idaapi.ea_t) -> bool
    Restore user defined local variable settings in the database. 
            
    @param lvinf: ptr to output buffer
    @param func_ea: entry address of the function
    @returns success

ida_hexrays.restore_user_numforms(func_ea: ida_idaapi.ea_t) -> "user_numforms_t *"
    Restore user defined number formats from the database. 
            
    @param func_ea: the entry address of the function
    @returns collection of user defined number formats. The returned object must be deleted by the caller using delete_user_numforms()

ida_hexrays.restore_user_unions(func_ea: ida_idaapi.ea_t) -> "user_unions_t *"
    Restore user defined union field selections from the database. 
            
    @param func_ea: the entry address of the function
    @returns collection of union field selections The returned object must be deleted by the caller using delete_user_unions()

ida_hexrays.rlist_t

ida_hexrays.rlist_t.__init__(self, *args)

ida_hexrays.rlist_t.dstr(self) -> str

ida_hexrays.save_user_cmts(func_ea: ida_idaapi.ea_t, user_cmts: "user_cmts_t") -> None
    Save user defined comments into the database. 
            
    @param func_ea: the entry address of the function
    @param user_cmts: collection of user defined comments

ida_hexrays.save_user_defined_calls(func_ea: ida_idaapi.ea_t, udcalls: "udcall_map_t const &") -> None
    Save user defined local function calls into the database. 
            
    @param func_ea: entry address of the function
    @param udcalls: user-specified info about user defined function calls

ida_hexrays.save_user_iflags(func_ea: ida_idaapi.ea_t, iflags: "user_iflags_t") -> None
    Save user defined citem iflags into the database. 
            
    @param func_ea: the entry address of the function
    @param iflags: collection of user defined citem iflags

ida_hexrays.save_user_labels(func_ea: ida_idaapi.ea_t, user_labels: "user_labels_t", func: "cfunc_t" = None) -> None
    Save user defined labels into the database. 
            
    @param func_ea: the entry address of the function, ignored if FUNC != nullptr
    @param user_labels: collection of user defined labels
    @param func: pointer to current function, if FUNC != nullptr, then save labels using a more stable method that preserves them even when the decompiler output drastically changes

ida_hexrays.save_user_lvar_settings(func_ea: ida_idaapi.ea_t, lvinf: "lvar_uservec_t") -> None
    Save user defined local variable settings into the database. 
            
    @param func_ea: entry address of the function
    @param lvinf: user-specified info about local variables

ida_hexrays.save_user_numforms(func_ea: ida_idaapi.ea_t, numforms: "user_numforms_t") -> None
    Save user defined number formats into the database. 
            
    @param func_ea: the entry address of the function
    @param numforms: collection of user defined comments

ida_hexrays.save_user_unions(func_ea: ida_idaapi.ea_t, unions: "user_unions_t") -> None
    Save user defined union field selections into the database. 
            
    @param func_ea: the entry address of the function
    @param unions: collection of union field selections

ida_hexrays.scif_t

ida_hexrays.scif_t.__init__(self, _mba: "mba_t", tif: "tinfo_t", n: str = None)

ida_hexrays.scif_t.mba
    Pointer to the parent mba_t object. Some operations may convert a scattered operand into something simpler, (a stack operand, for example). We will need to create stkvar_ref_t at that moment, this is why we need this pointer. See notes for lvar_ref_t::mba. 
            

ida_hexrays.scif_t.name
    Usually scattered operands are created from a function prototype, which has the name information. We preserve it and use it to name the corresponding local variable. 
            

ida_hexrays.scif_t.type
    Scattered operands always have type info assigned to them because without it we won't be able to manipulte them. 
            

ida_hexrays.scif_visitor_t

ida_hexrays.scif_visitor_t.__disown__(self)

ida_hexrays.scif_visitor_t.__init__(self)

ida_hexrays.scif_visitor_t.visit_scif_mop(self, r: "mop_t", off: int) -> int

ida_hexrays.select_udt_by_offset(udts: "qvector< tinfo_t > const *", ops: "ui_stroff_ops_t", applicator: "ui_stroff_applicator_t") -> int
    Select UDT 
            
    @param udts: list of UDT tinfo_t for the selection, if nullptr or empty then UDTs from the "Local types" will be used
    @param ops: operands
    @param applicator: callback will be called to apply the selection for every operand

ida_hexrays.send_database(err: "hexrays_failure_t", silent: bool) -> None
    Send the database to Hex-Rays. This function sends the current database to the Hex-Rays server. The database is sent in the compressed form over an encrypted (SSL) connection. 
            
    @param err: failure description object. Empty hexrays_failure_t object can be used if error information is not available.
    @param silent: if false, a dialog box will be displayed before sending the database.

ida_hexrays.set2jcnd(code: "mcode_t") -> "mcode_t"

ida_hexrays.set_type(id: int, tif: "tinfo_t", source: "type_source_t", force: bool = False) -> bool
    Set a global type. 
            
    @param id: address or id of the object
    @param tif: new type info
    @param source: where the type comes from
    @param force: true means to set the type as is, false means to merge the new type with the possibly existing old type info.
    @returns success

ida_hexrays.simple_graph_t

ida_hexrays.simple_graph_t.__init__(self, *args, **kwargs)

ida_hexrays.simple_graph_t.begin(self) -> "simple_graph_t::iterator"

ida_hexrays.simple_graph_t.compute_dominators(self, domin: "array_of_node_bitset_t", post: bool = False) -> None

ida_hexrays.simple_graph_t.compute_immediate_dominators(self, domin: "array_of_node_bitset_t", idomin: "intvec_t", post: bool = False) -> None

ida_hexrays.simple_graph_t.depth_first_postorder(self, post: "node_ordering_t") -> int

ida_hexrays.simple_graph_t.depth_first_preorder(self, pre: "node_ordering_t") -> int

ida_hexrays.simple_graph_t.end(self) -> "simple_graph_t::iterator"

ida_hexrays.simple_graph_t.front(self) -> int

ida_hexrays.simple_graph_t.goup(self, node: int) -> int

ida_hexrays.simple_graph_t.inc(self, p: "simple_graph_t::iterator &", n: int = 1) -> None

ida_hexrays.stkvar_ref_t

ida_hexrays.stkvar_ref_t.__eq__(self, r: "stkvar_ref_t") -> bool

ida_hexrays.stkvar_ref_t.__ge__(self, r: "stkvar_ref_t") -> bool

ida_hexrays.stkvar_ref_t.__gt__(self, r: "stkvar_ref_t") -> bool

ida_hexrays.stkvar_ref_t.__init__(self, m: "mba_t", o: int)

ida_hexrays.stkvar_ref_t.__le__(self, r: "stkvar_ref_t") -> bool

ida_hexrays.stkvar_ref_t.__lt__(self, r: "stkvar_ref_t") -> bool

ida_hexrays.stkvar_ref_t.__ne__(self, r: "stkvar_ref_t") -> bool

ida_hexrays.stkvar_ref_t.compare(self, r: "stkvar_ref_t") -> int

ida_hexrays.stkvar_ref_t.get_stkvar(self, udm: "udm_t" = None, p_idaoff: "uval_t *" = None) -> "ssize_t"
    Retrieve the referenced stack variable. 
            
    @param udm: stkvar, may be nullptr
    @param p_idaoff: if specified, will hold IDA stkoff after the call.
    @returns index of stkvar in the frame or -1

ida_hexrays.stkvar_ref_t.mba
    Pointer to the parent mba_t object. We need it in order to retrieve the referenced stack variable. See notes for lvar_ref_t::mba. 
            

ida_hexrays.stkvar_ref_t.off
    Offset to the stack variable from the bottom of the stack frame. It is called 'decompiler stkoff' and it is different from IDA stkoff. See a note and a picture about 'decompiler stkoff' below. 
            

ida_hexrays.stkvar_ref_t.swap(self, r: "stkvar_ref_t") -> None

ida_hexrays.swap_mcode_relation(code: "mcode_t") -> "mcode_t"

ida_hexrays.swapped_relation(op: "ctype_t") -> "ctype_t"
    Swap a comparison operator. For example, cot_sge becomes cot_sle.

ida_hexrays.term_hexrays_plugin() -> None
    Stop working with hex-rays decompiler.

ida_hexrays.treeloc_t

ida_hexrays.treeloc_t.__eq__(self, r: "treeloc_t") -> bool

ida_hexrays.treeloc_t.__init__(self)

ida_hexrays.treeloc_t.__lt__(self, r: "treeloc_t") -> bool

ida_hexrays.udc_filter_t

ida_hexrays.udc_filter_t.__disown__(self)

ida_hexrays.udc_filter_t.__init__(self)

ida_hexrays.udc_filter_t.apply(self, cdg: "codegen_t") -> "merror_t"
    generate microcode for an instruction 
            
    @returns MERR_... code: MERR_OK - user-defined microcode generated, go to the next instruction MERR_INSN - not generated - the caller should try the standard way else - error

ida_hexrays.udc_filter_t.cleanup(self) -> None
    Cleanup the filter This function properly clears type information associated to this filter. 
            

ida_hexrays.udc_filter_t.empty(self) -> bool

ida_hexrays.udc_filter_t.init(self, decl: str) -> bool

ida_hexrays.udc_filter_t.install(self) -> None

ida_hexrays.udc_filter_t.match(self, cdg: "codegen_t") -> bool
    return true if the filter object should be applied to given instruction

ida_hexrays.udc_filter_t.remove(self) -> bool

ida_hexrays.udcall_map_begin(map: "udcall_map_t const *") -> "udcall_map_iterator_t"
    Get iterator pointing to the beginning of udcall_map_t.

ida_hexrays.udcall_map_clear(map: "udcall_map_t *") -> None
    Clear udcall_map_t.

ida_hexrays.udcall_map_end(map: "udcall_map_t const *") -> "udcall_map_iterator_t"
    Get iterator pointing to the end of udcall_map_t.

ida_hexrays.udcall_map_erase(map: "udcall_map_t *", p: "udcall_map_iterator_t") -> None
    Erase current element from udcall_map_t.

ida_hexrays.udcall_map_find(map: "udcall_map_t const *", key: "ea_t const &") -> "udcall_map_iterator_t"
    Find the specified key in udcall_map_t.

ida_hexrays.udcall_map_first(p: "udcall_map_iterator_t") -> "ea_t const &"
    Get reference to the current map key.

ida_hexrays.udcall_map_free(map: "udcall_map_t *") -> None
    Delete udcall_map_t instance.

ida_hexrays.udcall_map_insert(map: "udcall_map_t *", key: "ea_t const &", val: "udcall_t") -> "udcall_map_iterator_t"
    Insert new (ea_t, udcall_t) pair into udcall_map_t.

ida_hexrays.udcall_map_iterator_t

ida_hexrays.udcall_map_iterator_t.__eq__(self, p: "udcall_map_iterator_t") -> bool

ida_hexrays.udcall_map_iterator_t.__init__(self)

ida_hexrays.udcall_map_iterator_t.__ne__(self, p: "udcall_map_iterator_t") -> bool

ida_hexrays.udcall_map_new() -> "udcall_map_t *"
    Create a new udcall_map_t instance.

ida_hexrays.udcall_map_next(p: "udcall_map_iterator_t") -> "udcall_map_iterator_t"
    Move to the next element.

ida_hexrays.udcall_map_prev(p: "udcall_map_iterator_t") -> "udcall_map_iterator_t"
    Move to the previous element.

ida_hexrays.udcall_map_second(p: "udcall_map_iterator_t") -> "udcall_t &"
    Get reference to the current map value.

ida_hexrays.udcall_map_size(map: "udcall_map_t *") -> "size_t"
    Get size of udcall_map_t.

ida_hexrays.udcall_t

ida_hexrays.udcall_t.__eq__(self, r: "udcall_t") -> bool

ida_hexrays.udcall_t.__ge__(self, r: "udcall_t") -> bool

ida_hexrays.udcall_t.__gt__(self, r: "udcall_t") -> bool

ida_hexrays.udcall_t.__init__(self)

ida_hexrays.udcall_t.__le__(self, r: "udcall_t") -> bool

ida_hexrays.udcall_t.__lt__(self, r: "udcall_t") -> bool

ida_hexrays.udcall_t.__ne__(self, r: "udcall_t") -> bool

ida_hexrays.udcall_t.compare(self, r: "udcall_t") -> int

ida_hexrays.udcall_t.empty(self) -> bool

ida_hexrays.ui_stroff_applicator_t

ida_hexrays.ui_stroff_applicator_t.__disown__(self)

ida_hexrays.ui_stroff_applicator_t.__init__(self)

ida_hexrays.ui_stroff_applicator_t.apply(self, opnum: "size_t", path: "intvec_t", top_tif: "tinfo_t", spath: str) -> bool
    @param opnum: operand ordinal number, see below
    @param path: path describing the union selection, maybe empty
    @param top_tif: tinfo_t of the selected toplevel UDT
    @param spath: selected path

ida_hexrays.ui_stroff_op_t

ida_hexrays.ui_stroff_op_t.__eq__(self, r: "ui_stroff_op_t") -> bool

ida_hexrays.ui_stroff_op_t.__init__(self)

ida_hexrays.ui_stroff_op_t.__ne__(self, r: "ui_stroff_op_t") -> bool

ida_hexrays.ui_stroff_op_t.offset
    operand offset, will be used when calculating the UDT path

ida_hexrays.ui_stroff_op_t.text
    any text for the column "Operand" of widget

ida_hexrays.ui_stroff_ops_t

ida_hexrays.ui_stroff_ops_t.__eq__(self, r: "ui_stroff_ops_t") -> bool

ida_hexrays.ui_stroff_ops_t.__getitem__(self, i: "size_t") -> "ui_stroff_op_t const &"

ida_hexrays.ui_stroff_ops_t.__init__(self, *args)

ida_hexrays.ui_stroff_ops_t.__len__(self) -> "size_t"

ida_hexrays.ui_stroff_ops_t.__ne__(self, r: "ui_stroff_ops_t") -> bool

ida_hexrays.ui_stroff_ops_t.__setitem__(self, i: "size_t", v: "ui_stroff_op_t") -> None

ida_hexrays.ui_stroff_ops_t._del(self, x: "ui_stroff_op_t") -> bool

ida_hexrays.ui_stroff_ops_t.add_unique(self, x: "ui_stroff_op_t") -> bool

ida_hexrays.ui_stroff_ops_t.append(self, x: "ui_stroff_op_t") -> None

ida_hexrays.ui_stroff_ops_t.at(self, _idx: "size_t") -> "ui_stroff_op_t const &"

ida_hexrays.ui_stroff_ops_t.begin(self, *args) -> "qvector< ui_stroff_op_t >::const_iterator"

ida_hexrays.ui_stroff_ops_t.capacity(self) -> "size_t"

ida_hexrays.ui_stroff_ops_t.clear(self) -> None

ida_hexrays.ui_stroff_ops_t.empty(self) -> bool

ida_hexrays.ui_stroff_ops_t.end(self, *args) -> "qvector< ui_stroff_op_t >::const_iterator"

ida_hexrays.ui_stroff_ops_t.erase(self, *args) -> "qvector< ui_stroff_op_t >::iterator"

ida_hexrays.ui_stroff_ops_t.extend(self, x: "ui_stroff_ops_t") -> None

ida_hexrays.ui_stroff_ops_t.extract(self) -> "ui_stroff_op_t *"

ida_hexrays.ui_stroff_ops_t.find(self, *args) -> "qvector< ui_stroff_op_t >::const_iterator"

ida_hexrays.ui_stroff_ops_t.grow(self, *args) -> None

ida_hexrays.ui_stroff_ops_t.has(self, x: "ui_stroff_op_t") -> bool

ida_hexrays.ui_stroff_ops_t.inject(self, s: "ui_stroff_op_t", len: "size_t") -> None

ida_hexrays.ui_stroff_ops_t.insert(self, it: "ui_stroff_op_t", x: "ui_stroff_op_t") -> "qvector< ui_stroff_op_t >::iterator"

ida_hexrays.ui_stroff_ops_t.pop_back(self) -> None

ida_hexrays.ui_stroff_ops_t.push_back(self, *args) -> "ui_stroff_op_t &"

ida_hexrays.ui_stroff_ops_t.qclear(self) -> None

ida_hexrays.ui_stroff_ops_t.reserve(self, cnt: "size_t") -> None

ida_hexrays.ui_stroff_ops_t.resize(self, *args) -> None

ida_hexrays.ui_stroff_ops_t.size(self) -> "size_t"

ida_hexrays.ui_stroff_ops_t.swap(self, r: "ui_stroff_ops_t") -> None

ida_hexrays.ui_stroff_ops_t.truncate(self) -> None

ida_hexrays.user_cmts_begin(map: "user_cmts_t") -> "user_cmts_iterator_t"
    Get iterator pointing to the beginning of user_cmts_t.

ida_hexrays.user_cmts_clear(map: "user_cmts_t") -> None
    Clear user_cmts_t.

ida_hexrays.user_cmts_end(map: "user_cmts_t") -> "user_cmts_iterator_t"
    Get iterator pointing to the end of user_cmts_t.

ida_hexrays.user_cmts_erase(map: "user_cmts_t", p: "user_cmts_iterator_t") -> None
    Erase current element from user_cmts_t.

ida_hexrays.user_cmts_find(map: "user_cmts_t", key: "treeloc_t") -> "user_cmts_iterator_t"
    Find the specified key in user_cmts_t.

ida_hexrays.user_cmts_first(p: "user_cmts_iterator_t") -> "treeloc_t const &"
    Get reference to the current map key.

ida_hexrays.user_cmts_free(map: "user_cmts_t") -> None
    Delete user_cmts_t instance.

ida_hexrays.user_cmts_insert(map: "user_cmts_t", key: "treeloc_t", val: "citem_cmt_t") -> "user_cmts_iterator_t"
    Insert new (treeloc_t, citem_cmt_t) pair into user_cmts_t.

ida_hexrays.user_cmts_iterator_t

ida_hexrays.user_cmts_iterator_t.__eq__(self, p: "user_cmts_iterator_t") -> bool

ida_hexrays.user_cmts_iterator_t.__init__(self)

ida_hexrays.user_cmts_iterator_t.__ne__(self, p: "user_cmts_iterator_t") -> bool

ida_hexrays.user_cmts_new() -> "user_cmts_t *"
    Create a new user_cmts_t instance.

ida_hexrays.user_cmts_next(p: "user_cmts_iterator_t") -> "user_cmts_iterator_t"
    Move to the next element.

ida_hexrays.user_cmts_prev(p: "user_cmts_iterator_t") -> "user_cmts_iterator_t"
    Move to the previous element.

ida_hexrays.user_cmts_second(p: "user_cmts_iterator_t") -> "citem_cmt_t &"
    Get reference to the current map value.

ida_hexrays.user_cmts_size(map: "user_cmts_t") -> "size_t"
    Get size of user_cmts_t.

ida_hexrays.user_cmts_t

ida_hexrays.user_cmts_t.__init__(self)

ida_hexrays.user_cmts_t.at(self, _Keyval: "treeloc_t") -> "citem_cmt_t &"

ida_hexrays.user_cmts_t.size(self) -> "size_t"

ida_hexrays.user_iflags_begin(map: "user_iflags_t") -> "user_iflags_iterator_t"
    Get iterator pointing to the beginning of user_iflags_t.

ida_hexrays.user_iflags_clear(map: "user_iflags_t") -> None
    Clear user_iflags_t.

ida_hexrays.user_iflags_end(map: "user_iflags_t") -> "user_iflags_iterator_t"
    Get iterator pointing to the end of user_iflags_t.

ida_hexrays.user_iflags_erase(map: "user_iflags_t", p: "user_iflags_iterator_t") -> None
    Erase current element from user_iflags_t.

ida_hexrays.user_iflags_find(map: "user_iflags_t", key: "citem_locator_t") -> "user_iflags_iterator_t"
    Find the specified key in user_iflags_t.

ida_hexrays.user_iflags_first(p: "user_iflags_iterator_t") -> "citem_locator_t const &"
    Get reference to the current map key.

ida_hexrays.user_iflags_free(map: "user_iflags_t") -> None
    Delete user_iflags_t instance.

ida_hexrays.user_iflags_insert(map: "user_iflags_t", key: "citem_locator_t", val: "int32 const &") -> "user_iflags_iterator_t"
    Insert new (citem_locator_t, int32) pair into user_iflags_t.

ida_hexrays.user_iflags_iterator_t

ida_hexrays.user_iflags_iterator_t.__eq__(self, p: "user_iflags_iterator_t") -> bool

ida_hexrays.user_iflags_iterator_t.__init__(self)

ida_hexrays.user_iflags_iterator_t.__ne__(self, p: "user_iflags_iterator_t") -> bool

ida_hexrays.user_iflags_new() -> "user_iflags_t *"
    Create a new user_iflags_t instance.

ida_hexrays.user_iflags_next(p: "user_iflags_iterator_t") -> "user_iflags_iterator_t"
    Move to the next element.

ida_hexrays.user_iflags_prev(p: "user_iflags_iterator_t") -> "user_iflags_iterator_t"
    Move to the previous element.

ida_hexrays.user_iflags_second(p: "user_iflags_iterator_t") -> "int32 const &"
    Get reference to the current map value.

ida_hexrays.user_iflags_size(map: "user_iflags_t") -> "size_t"
    Get size of user_iflags_t.

ida_hexrays.user_iflags_t

ida_hexrays.user_iflags_t.__init__(self)

ida_hexrays.user_iflags_t.at(self, _Keyval: "citem_locator_t") -> "int &"

ida_hexrays.user_iflags_t.size(self) -> "size_t"

ida_hexrays.user_labels_begin(map: "user_labels_t") -> "user_labels_iterator_t"
    Get iterator pointing to the beginning of user_labels_t.

ida_hexrays.user_labels_clear(map: "user_labels_t") -> None
    Clear user_labels_t.

ida_hexrays.user_labels_end(map: "user_labels_t") -> "user_labels_iterator_t"
    Get iterator pointing to the end of user_labels_t.

ida_hexrays.user_labels_erase(map: "user_labels_t", p: "user_labels_iterator_t") -> None
    Erase current element from user_labels_t.

ida_hexrays.user_labels_find(map: "user_labels_t", key: "int const &") -> "user_labels_iterator_t"
    Find the specified key in user_labels_t.

ida_hexrays.user_labels_first(p: "user_labels_iterator_t") -> "int const &"
    Get reference to the current map key.

ida_hexrays.user_labels_free(map: "user_labels_t") -> None
    Delete user_labels_t instance.

ida_hexrays.user_labels_insert(map: "user_labels_t", key: "int const &", val: str) -> "user_labels_iterator_t"
    Insert new (int, qstring) pair into user_labels_t.

ida_hexrays.user_labels_iterator_t

ida_hexrays.user_labels_iterator_t.__eq__(self, p: "user_labels_iterator_t") -> bool

ida_hexrays.user_labels_iterator_t.__init__(self)

ida_hexrays.user_labels_iterator_t.__ne__(self, p: "user_labels_iterator_t") -> bool

ida_hexrays.user_labels_new() -> "user_labels_t *"
    Create a new user_labels_t instance.

ida_hexrays.user_labels_next(p: "user_labels_iterator_t") -> "user_labels_iterator_t"
    Move to the next element.

ida_hexrays.user_labels_prev(p: "user_labels_iterator_t") -> "user_labels_iterator_t"
    Move to the previous element.

ida_hexrays.user_labels_second(p: "user_labels_iterator_t") -> str
    Get reference to the current map value.

ida_hexrays.user_labels_size(map: "user_labels_t") -> "size_t"
    Get size of user_labels_t.

ida_hexrays.user_labels_t

ida_hexrays.user_labels_t.__init__(self)

ida_hexrays.user_labels_t.at(self, _Keyval: "int const &") -> "_qstring< char > &"

ida_hexrays.user_labels_t.size(self) -> "size_t"

ida_hexrays.user_lvar_modifier_t

ida_hexrays.user_lvar_modifier_t.__disown__(self)

ida_hexrays.user_lvar_modifier_t.__init__(self)

ida_hexrays.user_lvar_modifier_t.modify_lvars(self, lvinf: "lvar_uservec_t") -> bool
    Modify lvar settings. Returns: true-modified 
            

ida_hexrays.user_numforms_begin(map: "user_numforms_t") -> "user_numforms_iterator_t"
    Get iterator pointing to the beginning of user_numforms_t.

ida_hexrays.user_numforms_clear(map: "user_numforms_t") -> None
    Clear user_numforms_t.

ida_hexrays.user_numforms_end(map: "user_numforms_t") -> "user_numforms_iterator_t"
    Get iterator pointing to the end of user_numforms_t.

ida_hexrays.user_numforms_erase(map: "user_numforms_t", p: "user_numforms_iterator_t") -> None
    Erase current element from user_numforms_t.

ida_hexrays.user_numforms_find(map: "user_numforms_t", key: "operand_locator_t") -> "user_numforms_iterator_t"
    Find the specified key in user_numforms_t.

ida_hexrays.user_numforms_first(p: "user_numforms_iterator_t") -> "operand_locator_t const &"
    Get reference to the current map key.

ida_hexrays.user_numforms_free(map: "user_numforms_t") -> None
    Delete user_numforms_t instance.

ida_hexrays.user_numforms_insert(map: "user_numforms_t", key: "operand_locator_t", val: "number_format_t") -> "user_numforms_iterator_t"
    Insert new (operand_locator_t, number_format_t) pair into user_numforms_t.

ida_hexrays.user_numforms_iterator_t

ida_hexrays.user_numforms_iterator_t.__eq__(self, p: "user_numforms_iterator_t") -> bool

ida_hexrays.user_numforms_iterator_t.__init__(self)

ida_hexrays.user_numforms_iterator_t.__ne__(self, p: "user_numforms_iterator_t") -> bool

ida_hexrays.user_numforms_new() -> "user_numforms_t *"
    Create a new user_numforms_t instance.

ida_hexrays.user_numforms_next(p: "user_numforms_iterator_t") -> "user_numforms_iterator_t"
    Move to the next element.

ida_hexrays.user_numforms_prev(p: "user_numforms_iterator_t") -> "user_numforms_iterator_t"
    Move to the previous element.

ida_hexrays.user_numforms_second(p: "user_numforms_iterator_t") -> "number_format_t &"
    Get reference to the current map value.

ida_hexrays.user_numforms_size(map: "user_numforms_t") -> "size_t"
    Get size of user_numforms_t.

ida_hexrays.user_numforms_t

ida_hexrays.user_numforms_t.__init__(self)

ida_hexrays.user_numforms_t.at(self, _Keyval: "operand_locator_t") -> "number_format_t &"

ida_hexrays.user_numforms_t.size(self) -> "size_t"

ida_hexrays.user_unions_begin(map: "user_unions_t") -> "user_unions_iterator_t"
    Get iterator pointing to the beginning of user_unions_t.

ida_hexrays.user_unions_clear(map: "user_unions_t") -> None
    Clear user_unions_t.

ida_hexrays.user_unions_end(map: "user_unions_t") -> "user_unions_iterator_t"
    Get iterator pointing to the end of user_unions_t.

ida_hexrays.user_unions_erase(map: "user_unions_t", p: "user_unions_iterator_t") -> None
    Erase current element from user_unions_t.

ida_hexrays.user_unions_find(map: "user_unions_t", key: "ea_t const &") -> "user_unions_iterator_t"
    Find the specified key in user_unions_t.

ida_hexrays.user_unions_first(p: "user_unions_iterator_t") -> "ea_t const &"
    Get reference to the current map key.

ida_hexrays.user_unions_free(map: "user_unions_t") -> None
    Delete user_unions_t instance.

ida_hexrays.user_unions_insert(map: "user_unions_t", key: "ea_t const &", val: "intvec_t") -> "user_unions_iterator_t"
    Insert new (ea_t, intvec_t) pair into user_unions_t.

ida_hexrays.user_unions_iterator_t

ida_hexrays.user_unions_iterator_t.__eq__(self, p: "user_unions_iterator_t") -> bool

ida_hexrays.user_unions_iterator_t.__init__(self)

ida_hexrays.user_unions_iterator_t.__ne__(self, p: "user_unions_iterator_t") -> bool

ida_hexrays.user_unions_new() -> "user_unions_t *"
    Create a new user_unions_t instance.

ida_hexrays.user_unions_next(p: "user_unions_iterator_t") -> "user_unions_iterator_t"
    Move to the next element.

ida_hexrays.user_unions_prev(p: "user_unions_iterator_t") -> "user_unions_iterator_t"
    Move to the previous element.

ida_hexrays.user_unions_second(p: "user_unions_iterator_t") -> "intvec_t &"
    Get reference to the current map value.

ida_hexrays.user_unions_size(map: "user_unions_t") -> "size_t"
    Get size of user_unions_t.

ida_hexrays.user_unions_t

ida_hexrays.user_unions_t.__init__(self)

ida_hexrays.user_unions_t.at(self, _Keyval: "unsigned long long const &") -> "qvector< int > &"

ida_hexrays.user_unions_t.size(self) -> "size_t"

ida_hexrays.uval_ivl_ivlset_t

ida_hexrays.uval_ivl_ivlset_t.__eq__(self, v: "ivl_t") -> bool

ida_hexrays.uval_ivl_ivlset_t.__init__(self, *args)

ida_hexrays.uval_ivl_ivlset_t.__ne__(self, v: "ivl_t") -> bool

ida_hexrays.uval_ivl_ivlset_t.all_values(self) -> bool

ida_hexrays.uval_ivl_ivlset_t.begin(self, *args) -> "ivlset_tpl< ivl_t,unsigned long long >::iterator"

ida_hexrays.uval_ivl_ivlset_t.clear(self) -> None

ida_hexrays.uval_ivl_ivlset_t.empty(self) -> bool

ida_hexrays.uval_ivl_ivlset_t.end(self, *args) -> "ivlset_tpl< ivl_t,unsigned long long >::iterator"

ida_hexrays.uval_ivl_ivlset_t.getivl(self, idx: int) -> "ivl_t const &"

ida_hexrays.uval_ivl_ivlset_t.lastivl(self) -> "ivl_t const &"

ida_hexrays.uval_ivl_ivlset_t.nivls(self) -> "size_t"

ida_hexrays.uval_ivl_ivlset_t.qclear(self) -> None

ida_hexrays.uval_ivl_ivlset_t.set_all_values(self) -> None

ida_hexrays.uval_ivl_ivlset_t.single_value(self, *args) -> bool

ida_hexrays.uval_ivl_ivlset_t.swap(self, r: "uval_ivl_ivlset_t") -> None

ida_hexrays.uval_ivl_t

ida_hexrays.uval_ivl_t.__init__(self, _off: "unsigned long long", _size: "unsigned long long")

ida_hexrays.uval_ivl_t.end(self) -> "unsigned long long"

ida_hexrays.uval_ivl_t.last(self) -> "unsigned long long"

ida_hexrays.uval_ivl_t.valid(self) -> bool

ida_hexrays.valrng_t

ida_hexrays.valrng_t.__eq__(self, r: "valrng_t") -> bool

ida_hexrays.valrng_t.__ge__(self, r: "valrng_t") -> bool

ida_hexrays.valrng_t.__gt__(self, r: "valrng_t") -> bool

ida_hexrays.valrng_t.__init__(self, *args)

ida_hexrays.valrng_t.__le__(self, r: "valrng_t") -> bool

ida_hexrays.valrng_t.__lt__(self, r: "valrng_t") -> bool

ida_hexrays.valrng_t.__ne__(self, r: "valrng_t") -> bool

ida_hexrays.valrng_t._deregister(self) -> None

ida_hexrays.valrng_t._print(self) -> None

ida_hexrays.valrng_t._register(self) -> None

ida_hexrays.valrng_t.all_values(self) -> bool

ida_hexrays.valrng_t.compare(self, r: "valrng_t") -> int

ida_hexrays.valrng_t.cvt_to_cmp(self) -> bool

ida_hexrays.valrng_t.cvt_to_single_value(self) -> bool

ida_hexrays.valrng_t.dstr(self) -> str

ida_hexrays.valrng_t.empty(self) -> bool

ida_hexrays.valrng_t.get_size(self) -> int

ida_hexrays.valrng_t.has(self, v: "uvlr_t") -> bool

ida_hexrays.valrng_t.intersect_with(self, r: "valrng_t") -> bool

ida_hexrays.valrng_t.inverse(self) -> None

ida_hexrays.valrng_t.is_unknown(self) -> bool

ida_hexrays.valrng_t.max_svalue(self) -> "uvlr_t"

ida_hexrays.valrng_t.max_value(self) -> "uvlr_t"

ida_hexrays.valrng_t.min_svalue(self) -> "uvlr_t"

ida_hexrays.valrng_t.reduce_size(self, new_size: int) -> bool

ida_hexrays.valrng_t.set_all(self) -> None

ida_hexrays.valrng_t.set_cmp(self, cmp: "cmpop_t", _value: "uvlr_t") -> None

ida_hexrays.valrng_t.set_eq(self, v: "uvlr_t") -> None

ida_hexrays.valrng_t.set_none(self) -> None

ida_hexrays.valrng_t.set_unk(self) -> None

ida_hexrays.valrng_t.swap(self, r: "valrng_t") -> None

ida_hexrays.valrng_t.unite_with(self, r: "valrng_t") -> bool

ida_hexrays.var_ref_t

ida_hexrays.var_ref_t.__eq__(self, r: "var_ref_t") -> bool

ida_hexrays.var_ref_t.__ge__(self, r: "var_ref_t") -> bool

ida_hexrays.var_ref_t.__gt__(self, r: "var_ref_t") -> bool

ida_hexrays.var_ref_t.__init__(self)

ida_hexrays.var_ref_t.__le__(self, r: "var_ref_t") -> bool

ida_hexrays.var_ref_t.__lt__(self, r: "var_ref_t") -> bool

ida_hexrays.var_ref_t.__ne__(self, r: "var_ref_t") -> bool

ida_hexrays.var_ref_t.compare(self, r: "var_ref_t") -> int

ida_hexrays.var_ref_t.getv(self) -> "lvar_t &"

ida_hexrays.var_ref_t.idx
    index into lvars_t

ida_hexrays.var_ref_t.mba
    pointer to the underlying micro array

ida_hexrays.vc_printer_t

ida_hexrays.vc_printer_t.__disown__(self)

ida_hexrays.vc_printer_t.__init__(self, f: "cfunc_t")

ida_hexrays.vc_printer_t.func
    cfunc_t to generate text for

ida_hexrays.vc_printer_t.lastchar
    internal: last printed character 
            

ida_hexrays.vc_printer_t.oneliner(self) -> bool
    Are we generating one-line text representation? 
            
    @returns `true` if the output will occupy one line without line breaks

ida_hexrays.vd_failure_t

ida_hexrays.vd_failure_t.__init__(self, *args)

ida_hexrays.vd_failure_t.desc(self) -> str

ida_hexrays.vd_interr_t

ida_hexrays.vd_interr_t.__init__(self, ea: ida_idaapi.ea_t, buf: str)

ida_hexrays.vd_printer_t

ida_hexrays.vd_printer_t.__disown__(self)

ida_hexrays.vd_printer_t.__init__(self)

ida_hexrays.vd_printer_t._print(self, indent: int, format: str) -> int

ida_hexrays.vd_printer_t.hdrlines
    number of header lines (prototype+typedef+lvars) valid at the end of print process 
            

ida_hexrays.vdloc_t

ida_hexrays.vdloc_t.__eq__(self, r: "vdloc_t") -> bool

ida_hexrays.vdloc_t.__ge__(self, r: "vdloc_t") -> bool

ida_hexrays.vdloc_t.__gt__(self, r: "vdloc_t") -> bool

ida_hexrays.vdloc_t.__init__(self)

ida_hexrays.vdloc_t.__le__(self, r: "vdloc_t") -> bool

ida_hexrays.vdloc_t.__lt__(self, r: "vdloc_t") -> bool

ida_hexrays.vdloc_t.__ne__(self, r: "vdloc_t") -> bool

ida_hexrays.vdloc_t._set_reg1(self, r1: int) -> None

ida_hexrays.vdloc_t.compare(self, r: "vdloc_t") -> int

ida_hexrays.vdloc_t.is_aliasable(self, mb: "mba_t", size: int) -> bool

ida_hexrays.vdloc_t.reg1(self) -> int

ida_hexrays.vdloc_t.set_reg1(self, r1: int) -> None

ida_hexrays.vdui_t

ida_hexrays.vdui_t.__init__(self, *args, **kwargs)

ida_hexrays.vdui_t.calc_cmt_type(self, lnnum: "size_t", cmttype: "cmt_type_t") -> "cmt_type_t"
    Check if the specified line can have a comment. Due to the coordinate system for comments: ([https://www.hex-rays.com/blog/coordinate-system-for-hex-rays](https://www.hex-rays.com/blog/coordinate-system-for-hex-rays)) some function lines cannot have comments. This function checks if a comment can be attached to the specified line. 
            
    @param lnnum: line number (0 based)
    @param cmttype: comment types to check
    @returns possible comment types

ida_hexrays.vdui_t.cfunc
    pointer to function object

ida_hexrays.vdui_t.clear(self) -> None
    Clear the pseudocode window. It deletes the current function and microcode. 
            

ida_hexrays.vdui_t.collapse_item(self, hide: bool) -> bool
    Collapse/uncollapse item. This function collapses the current item. 
            
    @returns false if failed.

ida_hexrays.vdui_t.collapse_lvars(self, hide: bool) -> bool
    Collapse/uncollapse local variable declarations. 
            
    @returns false if failed.

ida_hexrays.vdui_t.cpos
    Current ctext position.

ida_hexrays.vdui_t.ct
    pseudocode view

ida_hexrays.vdui_t.ctree_to_disasm(self) -> bool
    Jump to disassembly. This function jumps to the address in the disassembly window which corresponds to the current item. The current item is determined based on the current keyboard cursor position. 
            
    @returns false if failed

ida_hexrays.vdui_t.del_orphan_cmts(self) -> bool
    Delete all orphan comments. Delete all orphan comments and refresh the screen. 
            
    @returns true

ida_hexrays.vdui_t.edit_cmt(self, loc: "treeloc_t") -> bool
    Edit an indented comment. This function displays a dialog box and allows the user to edit the comment for the specified ctree location. 
            
    @param loc: comment location
    @returns false if failed or cancelled

ida_hexrays.vdui_t.edit_func_cmt(self) -> bool
    Edit a function comment. This function displays a dialog box and allows the user to edit the function comment. 
            
    @returns false if failed or cancelled

ida_hexrays.vdui_t.flags
    Properties of pseudocode window 
            

ida_hexrays.vdui_t.get_current_item(self, idv: "input_device_t") -> bool
    Get current item. This function refreshes the cpos, item, tail fields. 
            
    @param idv: keyboard or mouse
    @returns false if failed

ida_hexrays.vdui_t.get_current_label(self) -> int
    Get current label. If there is a label under the cursor, return its number. 
            
    @returns -1 if there is no label under the cursor. prereq: get_current_item() has been called

ida_hexrays.vdui_t.get_number(self) -> "cnumber_t *"
    Get current number. If the current item is a number, return pointer to it. 
            
    @returns nullptr if the current item is not a number This function returns non-null for the cases of a 'switch' statement Also, if the current item is a casted number, then this function will succeed.

ida_hexrays.vdui_t.head
    First ctree item on the current line (for block comments)

ida_hexrays.vdui_t.in_ctree(self) -> bool
    Is the current item a statement?
    
    @returns false if the cursor is in the local variable/type declaration area
     true if the cursor is in the statement area

ida_hexrays.vdui_t.invert_bits(self) -> bool
    Bitwise negate a number. This function inverts all bits of the current number. 
            
    @returns false if failed.

ida_hexrays.vdui_t.invert_sign(self) -> bool
    Negate a number. This function negates the current number. 
            
    @returns false if failed.

ida_hexrays.vdui_t.item
    Current ctree item.

ida_hexrays.vdui_t.jump_enter(self, idv: "input_device_t", omflags: int) -> bool
    Process the Enter key. This function jumps to the definition of the item under the cursor. If the current item is a function, it will be decompiled. If the current item is a global data, its disassemly text will be displayed. 
            
    @param idv: what cursor must be used, the keyboard or the mouse
    @param omflags: OM_NEWWIN: new pseudocode window will open, 0: reuse the existing window
    @returns false if failed

ida_hexrays.vdui_t.last_code
    result of the last user action. See Microcode error codes

ida_hexrays.vdui_t.locked(self) -> bool
    Does the pseudocode window contain valid code? We lock windows before modifying them, to avoid recursion due to the events generated by the IDA kernel. 
            
    @retval true: The window is locked and may have stale info

ida_hexrays.vdui_t.map_lvar(self, frm: "lvar_t", to: "lvar_t") -> bool
    Map a local variable to another. This function permanently maps one lvar to another. All occurrences of the mapped variable are replaced by the new variable 
            
    @param to: the variable to map to. if nullptr, unmaps the variable
    @returns false if failed

ida_hexrays.vdui_t.mba
    pointer to underlying microcode

ida_hexrays.vdui_t.refresh_cpos(self, idv: "input_device_t") -> bool
    Refresh the current position. This function refreshes the cpos field. 
            
    @param idv: keyboard or mouse
    @returns false if failed

ida_hexrays.vdui_t.refresh_ctext(self, activate: bool = True) -> None
    Refresh pseudocode window. This function refreshes the pseudocode window by regenerating its text from cfunc_t. Instead of this function use refresh_func_ctext(), which refreshes all pseudocode windows for the function. 
            

ida_hexrays.vdui_t.refresh_view(self, redo_mba: bool) -> None
    Refresh pseudocode window. This is the highest level refresh function. It causes the most profound refresh possible and can lead to redecompilation of the current function. Please consider using refresh_ctext() if you need a more superficial refresh. 
            
    @param redo_mba: true means to redecompile the current function
     false means to rebuild ctree without regenerating microcode

ida_hexrays.vdui_t.rename_global(self, ea: ida_idaapi.ea_t) -> bool
    Rename global item. This function displays a dialog box and allows the user to rename a global item (data or function). 
            
    @param ea: address of the global item
    @returns false if failed or cancelled

ida_hexrays.vdui_t.rename_label(self, label: int) -> bool
    Rename a label. This function displays a dialog box and allows the user to rename a statement label. 
            
    @param label: label number
    @returns false if failed or cancelled

ida_hexrays.vdui_t.rename_lvar(self, v: "lvar_t", name: str, is_user_name: bool) -> bool
    Rename local variable. This function permanently renames a local variable. 
            
    @param v: pointer to local variable
    @param name: new variable name
    @param is_user_name: use true to save the new name into the database. use false to delete the saved name.
    @returns false if failed

ida_hexrays.vdui_t.rename_udm(self, udt_type: "tinfo_t", udm_idx: int) -> bool
    Rename structure field. This function displays a dialog box and allows the user to rename a structure field. 
            
    @param udt_type: structure/union type
    @param udm_idx: index of the structure/union member
    @returns false if failed or cancelled

ida_hexrays.vdui_t.set_global_type(self, ea: ida_idaapi.ea_t) -> bool
    Set global item type. This function displays a dialog box and allows the user to change the type of a global item (data or function). 
            
    @param ea: address of the global item
    @returns false if failed or cancelled

ida_hexrays.vdui_t.set_locked(self, v: bool) -> bool

ida_hexrays.vdui_t.set_lvar_cmt(self, v: "lvar_t", cmt: str) -> bool
    Set local variable comment. This function permanently sets a variable comment. 
            
    @param v: pointer to local variable
    @param cmt: new comment
    @returns false if failed

ida_hexrays.vdui_t.set_lvar_type(self, v: "lvar_t", type: "tinfo_t") -> bool
    Set local variable type. This function permanently sets a local variable type and clears NOPTR flag if it was set before by function 'set_noptr_lvar' 
            
    @param v: pointer to local variable
    @param type: new variable type
    @returns false if failed

ida_hexrays.vdui_t.set_noptr_lvar(self, v: "lvar_t") -> bool
    Inform that local variable should have a non-pointer type This function permanently sets a corresponding variable flag (NOPTR) and removes type if it was set before by function 'set_lvar_type' 
            
    @param v: pointer to local variable
    @returns false if failed

ida_hexrays.vdui_t.set_num_enum(self) -> bool
    Convert number to symbolic constant. This function displays a dialog box and allows the user to select a symbolic constant to represent the number. 
            
    @returns false if failed or cancelled

ida_hexrays.vdui_t.set_num_radix(self, base: int) -> bool
    Change number base. This function changes the current number representation. 
            
    @param base: number radix (10 or 16)
     0 means a character constant
    @returns false if failed

ida_hexrays.vdui_t.set_num_stroff(self) -> bool
    Convert number to structure field offset. Currently not implemented. 
            
    @returns false if failed or cancelled

ida_hexrays.vdui_t.set_udm_type(self, udt_type: "tinfo_t", udm_idx: int) -> bool
    Set structure field type. This function displays a dialog box and allows the user to change the type of a structure field. 
            
    @param udt_type: structure/union type
    @param udm_idx: index of the structure/union member
    @returns false if failed or cancelled

ida_hexrays.vdui_t.set_valid(self, v: bool) -> None

ida_hexrays.vdui_t.set_visible(self, v: bool) -> None

ida_hexrays.vdui_t.split_item(self, split: bool) -> bool
    Split/unsplit item. This function splits the current assignment expression. 
            
    @returns false if failed.

ida_hexrays.vdui_t.switch_to(self, f: "cfuncptr_t", activate: bool) -> None
    Display the specified pseudocode. This function replaces the pseudocode window contents with the specified cfunc_t. 
            
    @param f: pointer to the function to display.
    @param activate: should the pseudocode window get focus?

ida_hexrays.vdui_t.tail
    Tail ctree item on the current line (for indented comments)

ida_hexrays.vdui_t.ui_edit_lvar_cmt(self, v: "lvar_t") -> bool
    Set local variable comment. This function displays a dialog box and allows the user to edit the comment of a local variable. 
            
    @param v: pointer to local variable
    @returns false if failed or cancelled

ida_hexrays.vdui_t.ui_map_lvar(self, v: "lvar_t") -> bool
    Map a local variable to another. This function displays a variable list and allows the user to select mapping. 
            
    @param v: pointer to local variable
    @returns false if failed or cancelled

ida_hexrays.vdui_t.ui_rename_lvar(self, v: "lvar_t") -> bool
    Rename local variable. This function displays a dialog box and allows the user to rename a local variable. 
            
    @param v: pointer to local variable
    @returns false if failed or cancelled

ida_hexrays.vdui_t.ui_set_call_type(self, e: "cexpr_t") -> bool
    Set type of a function call This function displays a dialog box and allows the user to change the type of a function call 
            
    @param e: pointer to call expression
    @returns false if failed or cancelled

ida_hexrays.vdui_t.ui_set_lvar_type(self, v: "lvar_t") -> bool
    Set local variable type. This function displays a dialog box and allows the user to change the type of a local variable. 
            
    @param v: pointer to local variable
    @returns false if failed or cancelled

ida_hexrays.vdui_t.ui_unmap_lvar(self, v: "lvar_t") -> bool
    Unmap a local variable. This function displays list of variables mapped to the specified variable and allows the user to select a variable to unmap. 
            
    @param v: pointer to local variable
    @returns false if failed or cancelled

ida_hexrays.vdui_t.valid(self) -> bool
    Does the pseudocode window contain valid code? It can become invalid if the function type gets changed in IDA. 
            

ida_hexrays.vdui_t.view_idx
    pseudocode window index (0..)

ida_hexrays.vdui_t.visible(self) -> bool
    Is the pseudocode window visible? if not, it might be invisible or destroyed 
            

ida_hexrays.vivl_t

ida_hexrays.vivl_t.__eq__(self, *args) -> bool

ida_hexrays.vivl_t.__ge__(self, r: "vivl_t") -> bool

ida_hexrays.vivl_t.__gt__(self, r: "vivl_t") -> bool

ida_hexrays.vivl_t.__init__(self, *args)

ida_hexrays.vivl_t.__le__(self, r: "vivl_t") -> bool

ida_hexrays.vivl_t.__lt__(self, r: "vivl_t") -> bool

ida_hexrays.vivl_t.__ne__(self, r: "vivl_t") -> bool

ida_hexrays.vivl_t._print(self) -> None

ida_hexrays.vivl_t.compare(self, r: "vivl_t") -> int

ida_hexrays.vivl_t.contains(self, voff2: "voff_t") -> bool
    Does our value interval contain the specified value offset?

ida_hexrays.vivl_t.dstr(self) -> str

ida_hexrays.vivl_t.extend_to_cover(self, r: "vivl_t") -> bool
    Extend a value interval using another value interval of the same type 
            
    @returns success

ida_hexrays.vivl_t.includes(self, r: "vivl_t") -> bool
    Does our value interval include another?

ida_hexrays.vivl_t.intersect(self, r: "vivl_t") -> int
    Intersect value intervals the same type 
            
    @returns size of the resulting intersection

ida_hexrays.vivl_t.overlap(self, r: "vivl_t") -> bool
    Do two value intervals overlap?

ida_hexrays.vivl_t.set(self, *args) -> None
    This function has the following signatures:
    
        0. set(_type: mopt_t, _off: int, _size: int=0) -> None
        1. set(voff: const voff_t &, _size: int) -> None
    
    # 0: set(_type: mopt_t, _off: int, _size: int=0) -> None
    
    
    # 1: set(voff: const voff_t &, _size: int) -> None

ida_hexrays.vivl_t.set_reg(self, mreg: "mreg_t", sz: int = 0) -> None

ida_hexrays.vivl_t.set_stkoff(self, stkoff: int, sz: int = 0) -> None

ida_hexrays.vivl_t.size
    Interval size in bytes.

ida_hexrays.voff_t

ida_hexrays.voff_t.__eq__(self, r: "voff_t") -> bool

ida_hexrays.voff_t.__ge__(self, r: "voff_t") -> bool

ida_hexrays.voff_t.__gt__(self, r: "voff_t") -> bool

ida_hexrays.voff_t.__init__(self, *args)

ida_hexrays.voff_t.__le__(self, r: "voff_t") -> bool

ida_hexrays.voff_t.__lt__(self, r: "voff_t") -> bool

ida_hexrays.voff_t.__ne__(self, r: "voff_t") -> bool

ida_hexrays.voff_t.add(self, width: int) -> "voff_t"

ida_hexrays.voff_t.compare(self, r: "voff_t") -> int

ida_hexrays.voff_t.defined(self) -> bool

ida_hexrays.voff_t.diff(self, r: "voff_t") -> int

ida_hexrays.voff_t.get_reg(self) -> "mreg_t"

ida_hexrays.voff_t.get_stkoff(self) -> int

ida_hexrays.voff_t.inc(self, delta: int) -> None

ida_hexrays.voff_t.is_reg(self) -> bool

ida_hexrays.voff_t.is_stkoff(self) -> bool

ida_hexrays.voff_t.off
    register number or stack offset

ida_hexrays.voff_t.set(self, _type: "mopt_t", _off: int) -> None

ida_hexrays.voff_t.set_reg(self, mreg: "mreg_t") -> None

ida_hexrays.voff_t.set_stkoff(self, stkoff: int) -> None

ida_hexrays.voff_t.type
    mop_r - register, mop_S - stack, mop_z - undefined

ida_hexrays.voff_t.undef(self) -> None

ida_allins

ida_auto
    Functions that work with the autoanalyzer queue.
    
    The autoanalyzer works when IDA is not busy processing the user keystrokes. It has several queues, each queue having its own priority. The analyzer stops when all queues are empty.
    A queue contains addresses or address ranges. The addresses are kept sorted by their values. The analyzer will process all addresses from the first queue, then switch to the second queue and so on. There are no limitations on the size of the queues.
    This file also contains functions that deal with the IDA status indicator and the autoanalysis indicator. You may use these functions to change the indicator value. 
        

ida_auto.AU_CHLB
    12: load signature file (file name is kept separately)

ida_auto.AU_CODE
    1: convert to instruction

ida_auto.AU_FCHUNK
    5: find func chunks

ida_auto.AU_FINAL
    13: final pass

ida_auto.AU_LBF2
    10: the same, second pass

ida_auto.AU_LBF3
    11: the same, third pass

ida_auto.AU_LIBF
    9: apply signature to address

ida_auto.AU_NONE
    placeholder, not used

ida_auto.AU_PROC
    3: convert to procedure start

ida_auto.AU_TAIL
    4: add a procedure tail

ida_auto.AU_TYPE
    8: apply type information

ida_auto.AU_UNK
    0: convert to unexplored

ida_auto.AU_USD2
    7: reanalyze, second pass

ida_auto.AU_USED
    6: reanalyze

ida_auto.AU_WEAK
    2: convert to instruction (ida decision)

ida_auto.auto_apply_tail(tail_ea: ida_idaapi.ea_t, parent_ea: ida_idaapi.ea_t) -> None
    Plan to apply the tail_ea chunk to the parent 
            
    @param tail_ea: linear address of start of tail
    @param parent_ea: linear address within parent. If BADADDR, automatically try to find parent via xrefs.

ida_auto.auto_apply_type(caller: ida_idaapi.ea_t, callee: ida_idaapi.ea_t) -> None
    Plan to apply the callee's type to the calling point.

ida_auto.auto_cancel(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None
    Remove an address range (ea1..ea2) from queues AU_CODE, AU_PROC, AU_USED. To remove an address range from other queues use auto_unmark() function. 'ea1' may be higher than 'ea2', the kernel will swap them in this case. 'ea2' doesn't belong to the range. 
            

ida_auto.auto_display_t

ida_auto.auto_display_t.__init__(self)

ida_auto.auto_get(type: "atype_t *", lowEA: ida_idaapi.ea_t, highEA: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Retrieve an address from queues regarding their priority. Returns BADADDR if no addresses not lower than 'lowEA' and less than 'highEA' are found in the queues. Otherwise *type will have queue type. 
            

ida_auto.auto_is_ok() -> bool
    Are all queues empty? (i.e. has autoanalysis finished?). 
            

ida_auto.auto_make_code(ea: ida_idaapi.ea_t) -> None
    Plan to make code.

ida_auto.auto_make_proc(ea: ida_idaapi.ea_t) -> None
    Plan to make code&function.

ida_auto.auto_make_step(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool
    Analyze one address in the specified range and return true. 
            
    @returns if processed anything. false means that there is nothing to process in the specified range.

ida_auto.auto_mark(ea: ida_idaapi.ea_t, type: "atype_t") -> None
    Put single address into a queue. Queues keep addresses sorted.

ida_auto.auto_mark_range(start: ida_idaapi.ea_t, end: ida_idaapi.ea_t, type: "atype_t") -> None
    Put range of addresses into a queue. 'start' may be higher than 'end', the kernel will swap them in this case. 'end' doesn't belong to the range. 
            

ida_auto.auto_postpone_analysis(ea: ida_idaapi.ea_t) -> bool
    Plan to reanalyze on the second pass The typical usage of this function in emu.cpp is: if ( !auto_postpone_analysis(ea) ) op_offset(ea, 0, ...); (we make an offset only on the second pass) 
            

ida_auto.auto_recreate_insn(ea: ida_idaapi.ea_t) -> int
    Try to create instruction 
            
    @param ea: linear address of callee
    @returns the length of the instruction or 0

ida_auto.auto_unmark(start: ida_idaapi.ea_t, end: ida_idaapi.ea_t, type: "atype_t") -> None
    Remove range of addresses from a queue. 'start' may be higher than 'end', the kernel will swap them in this case. 'end' doesn't belong to the range. 
            

ida_auto.auto_wait() -> bool
    Process everything in the queues and return true. 
            
    @returns false if the user clicked cancel. (the wait box must be displayed by the caller if desired)

ida_auto.auto_wait_range(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> "ssize_t"
    Process everything in the specified range and return true. 
            
    @returns number of autoanalysis steps made. -1 if the user clicked cancel. (the wait box must be displayed by the caller if desired)

ida_auto.enable_auto(enable: bool) -> bool
    Temporarily enable/disable autoanalyzer. Not user-facing, but rather because IDA sometimes need to turn AA on/off regardless of inf.s_genflags:INFFL_AUTO 
            
    @returns old state

ida_auto.get_auto_display(auto_display: "auto_display_t") -> bool
    Get structure which holds the autoanalysis indicator contents.

ida_auto.get_auto_state() -> "atype_t"
    Get current state of autoanalyzer. If auto_state == AU_NONE, IDA is currently not running the analysis (it could be temporarily interrupted to perform the user's requests, for example). 
            

ida_auto.is_auto_enabled() -> bool
    Get autoanalyzer state.

ida_auto.may_create_stkvars() -> bool
    Is it allowed to create stack variables automatically?. This function should be used by IDP modules before creating stack vars. 
            

ida_auto.may_trace_sp() -> bool
    Is it allowed to trace stack pointer automatically?. This function should be used by IDP modules before tracing sp. 
            

ida_auto.peek_auto_queue(low_ea: ida_idaapi.ea_t, type: "atype_t") -> ida_idaapi.ea_t
    Peek into a queue 'type' for an address not lower than 'low_ea'. Do not remove address from the queue. 
            
    @returns the address or BADADDR

ida_auto.plan_and_wait(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, final_pass: bool = True) -> int
    Analyze the specified range. Try to create instructions where possible. Make the final pass over the specified range if specified. This function doesn't return until the range is analyzed. 
            
    @retval 1: ok
    @retval 0: Ctrl-Break was pressed

ida_auto.plan_ea(ea: ida_idaapi.ea_t) -> None
    Plan to perform reanalysis.

ida_auto.plan_range(sEA: ida_idaapi.ea_t, eEA: ida_idaapi.ea_t) -> None
    Plan to perform reanalysis.

ida_auto.reanalyze_callers(ea: ida_idaapi.ea_t, noret: bool) -> None
    Plan to reanalyze callers of the specified address. This function will add to AU_USED queue all instructions that call (not jump to) the specified address. 
            
    @param ea: linear address of callee
    @param noret: !=0: the callee doesn't return, mark to undefine subsequent instructions in the caller. 0: do nothing.

ida_auto.revert_ida_decisions(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None
    Delete all analysis info that IDA generated for for the given range.

ida_auto.set_auto_state(new_state: "atype_t") -> "atype_t"
    Set current state of autoanalyzer. 
            
    @param new_state: new state of autoanalyzer
    @returns previous state

ida_auto.set_ida_state(st: "idastate_t") -> "idastate_t"
    Change IDA status indicator value 
            
    @param st: - new indicator status
    @returns old indicator status

ida_auto.show_addr(ea: ida_idaapi.ea_t) -> None
    Show an address on the autoanalysis indicator. The address is displayed in the form " @:12345678". 
            
    @param ea: - linear address to display

ida_auto.show_auto(*args) -> None
    Change autoanalysis indicator value. 
            
    @param ea: linear address being analyzed
    @param type: autoanalysis type (see Autoanalysis queues)

ida_auto.st_Ready
    READY: IDA is doing nothing.

ida_auto.st_Think
    THINKING: Autoanalysis on, the user may press keys.

ida_auto.st_Waiting
    WAITING: Waiting for the user input.

ida_auto.st_Work
    BUSY: IDA is busy.

ida_bitrange
    Definition of the bitrange_t class.

ida_bitrange.bitrange_t

ida_bitrange.bitrange_t.__eq__(self, r: "bitrange_t") -> bool

ida_bitrange.bitrange_t.__ge__(self, r: "bitrange_t") -> bool

ida_bitrange.bitrange_t.__gt__(self, r: "bitrange_t") -> bool

ida_bitrange.bitrange_t.__init__(self, bit_ofs: "uint16" = 0, size_in_bits: "uint16" = 0)

ida_bitrange.bitrange_t.__le__(self, r: "bitrange_t") -> bool

ida_bitrange.bitrange_t.__lt__(self, r: "bitrange_t") -> bool

ida_bitrange.bitrange_t.__ne__(self, r: "bitrange_t") -> bool

ida_bitrange.bitrange_t.__repr__(self)

ida_bitrange.bitrange_t.__str__(self) -> str

ida_bitrange.bitrange_t.apply_mask(self, subrange: "bitrange_t") -> bool
    Apply mask to a bitrange 
            
    @param subrange: range *inside* the main bitrange to keep After this operation the main bitrange will be truncated to have only the bits that are specified by subrange. Example: [off=8,nbits=4], subrange[off=1,nbits=2] => [off=9,nbits=2]
    @returns success

ida_bitrange.bitrange_t.bitoff(self) -> "uint"
    Get offset of 1st bit.

ida_bitrange.bitrange_t.bitsize(self) -> "uint"
    Get size of the value in bits.

ida_bitrange.bitrange_t.bytesize(self) -> "uint"
    Size of the value in bytes.

ida_bitrange.bitrange_t.compare(self, r: "bitrange_t") -> int

ida_bitrange.bitrange_t.create_union(self, r: "bitrange_t") -> None
    Create union of 2 ranges including the hole between them.

ida_bitrange.bitrange_t.empty(self) -> bool
    Is the bitrange empty?

ida_bitrange.bitrange_t.extract(self, src: "void const *", is_mf: bool) -> bool

ida_bitrange.bitrange_t.has_common(self, r: "bitrange_t") -> bool
    Does have common bits with another bitrange?

ida_bitrange.bitrange_t.init(self, bit_ofs: "uint16", size_in_bits: "uint16") -> None
    Initialize offset and size to given values.

ida_bitrange.bitrange_t.inject(self, dst: "void *", src: "bytevec_t const &", is_mf: bool) -> bool

ida_bitrange.bitrange_t.intersect(self, r: "bitrange_t") -> None
    Intersect two ranges.

ida_bitrange.bitrange_t.mask64(self) -> "uint64"
    Convert to mask of 64 bits.

ida_bitrange.bitrange_t.reset(self) -> None
    Make the bitrange empty.

ida_bitrange.bitrange_t.shift_down(self, cnt: "uint") -> None
    Shift range down (left)

ida_bitrange.bitrange_t.shift_up(self, cnt: "uint") -> None
    Shift range up (right)

ida_bitrange.bitrange_t.sub(self, r: "bitrange_t") -> bool
    Subtract a bitrange.

ida_bytes
    Contains functions that deal with individual byte characteristics.
    
    Each byte of the disassembled program is represented by a 32-bit value. We will call this value 'flags'. The structure of the flags is here.
    You are not allowed to inspect individual bits of flags and modify them directly. Use special functions to inspect and/or modify flags.
    Flags are kept in a virtual array file (*.id1). Addresses (ea) are all 32-bit (or 64-bit) quantities. 
        

ida_bytes.ALOPT_APPEND
    if an existing strlit is encountered, then append it to the string. 
            

ida_bytes.ALOPT_IGNCLT
    if set, don't stop at codepoints that are not part of the current 'culture'; accept all those that are graphical (this is typically used used by user-initiated actions creating string literals.) 
            

ida_bytes.ALOPT_IGNHEADS
    don't stop if another data item is encountered. only the byte values will be used to determine the string length. if not set, a defined data item or instruction will truncate the string 
            

ida_bytes.ALOPT_IGNPRINT
    if set, don't stop at non-printable codepoints, but only at the terminating character (or not unicode-mapped character (e.g., 0x8f in CP1252)) 
            

ida_bytes.ALOPT_MAX4K
    if string length is more than 4K, return the accumulated length 
            

ida_bytes.ALOPT_ONLYTERM
    only the termination characters can be at the string end. Without this option illegal characters also terminate the string. 
            

ida_bytes.BIN_SEARCH_BACKWARD
    search backward for bytes

ida_bytes.BIN_SEARCH_BITMASK
    searching using strict bit mask

ida_bytes.BIN_SEARCH_CASE
    case sensitive

ida_bytes.BIN_SEARCH_FORWARD
    search forward for bytes

ida_bytes.BIN_SEARCH_INITED
    find_byte, find_byter: any initilized value

ida_bytes.BIN_SEARCH_NOBREAK
    don't check for Ctrl-Break

ida_bytes.BIN_SEARCH_NOCASE
    case insensitive

ida_bytes.BIN_SEARCH_NOSHOW
    don't show search progress or update screen

ida_bytes.DELIT_DELNAMES
    delete any names at the specified address range (except for the starting address). this bit is valid if nbytes > 1 
            

ida_bytes.DELIT_EXPAND
    propagate undefined items; for example if removing an instruction removes all references to the next instruction, then plan to convert to unexplored the next instruction too. 
            

ida_bytes.DELIT_KEEPFUNC
    do not undefine the function start. Just delete xrefs, ops e.t.c. 
            

ida_bytes.DELIT_NOCMT
    reject to delete if a comment is in address range (except for the starting address). this bit is valid if nbytes > 1 
            

ida_bytes.DELIT_NOTRUNC
    don't truncate the current function even if AF_TRFUNC is set 
            

ida_bytes.DELIT_NOUNAME
    reject to delete if a user name is in address range (except for the starting address). this bit is valid if nbytes > 1 
            

ida_bytes.DELIT_SIMPLE
    simply undefine the specified item(s)

ida_bytes.DTP_NODUP
    do not use dup construct

ida_bytes.DTP_NODUP
    do not use dup construct

ida_bytes.DT_TYPE
    Mask for DATA typing.

ida_bytes.FF_ALIGN
    alignment directive

ida_bytes.FF_ANYNAME
    Has name or dummy name?

ida_bytes.FF_BNOT
    Bitwise negation of operands.

ida_bytes.FF_BYTE
    byte

ida_bytes.FF_CODE
    Code ?

ida_bytes.FF_COMM
    Has comment ?

ida_bytes.FF_CUSTOM
    custom data type

ida_bytes.FF_DATA
    Data ?

ida_bytes.FF_DOUBLE
    double

ida_bytes.FF_DWORD
    double word

ida_bytes.FF_FLOAT
    float

ida_bytes.FF_FLOW
    Exec flow from prev instruction.

ida_bytes.FF_FUNC
    function start?

ida_bytes.FF_IMMD
    Has Immediate value ?

ida_bytes.FF_IVL
    Byte has value ?

ida_bytes.FF_JUMP
    Has jump table or switch_info?

ida_bytes.FF_LABL
    Has dummy name?

ida_bytes.FF_LINE
    Has next or prev lines ?

ida_bytes.FF_NAME
    Has name ?

ida_bytes.FF_N_CHAR
    Char ('x')?

ida_bytes.FF_N_CUST
    Custom representation?

ida_bytes.FF_N_ENUM
    Enumeration?

ida_bytes.FF_N_FLT
    Floating point number?

ida_bytes.FF_N_FOP
    Forced operand?

ida_bytes.FF_N_NUMB
    Binary number?

ida_bytes.FF_N_NUMD
    Decimal number?

ida_bytes.FF_N_NUMH
    Hexadecimal number?

ida_bytes.FF_N_NUMO
    Octal number?

ida_bytes.FF_N_OFF
    Offset?

ida_bytes.FF_N_SEG
    Segment?

ida_bytes.FF_N_STK
    Stack variable?

ida_bytes.FF_N_STRO
    Struct offset?

ida_bytes.FF_N_VOID
    Void (unknown)?

ida_bytes.FF_OWORD
    octaword/xmm word (16 bytes/128 bits)

ida_bytes.FF_PACKREAL
    packed decimal real

ida_bytes.FF_QWORD
    quadro word

ida_bytes.FF_REF
    has references

ida_bytes.FF_SIGN
    Inverted sign of operands.

ida_bytes.FF_STRLIT
    string literal

ida_bytes.FF_STRUCT
    struct variable

ida_bytes.FF_TAIL
    Tail ?

ida_bytes.FF_TBYTE
    tbyte

ida_bytes.FF_UNK
    Unknown ?

ida_bytes.FF_UNUSED
    unused bit (was used for variable bytes)

ida_bytes.FF_WORD
    word

ida_bytes.FF_YWORD
    ymm word (32 bytes/256 bits)

ida_bytes.FF_ZWORD
    zmm word (64 bytes/512 bits)

ida_bytes.GFE_IDB_VALUE
    get flags with FF_IVL & MS_VAL. but never use the debugger memory. 
            

ida_bytes.GFE_VALUE
    get flags with FF_IVL & MS_VAL. It is much slower under remote debugging because the kernel needs to read the process memory. 
            

ida_bytes.GMB_READALL
    try to read all bytes; if this bit is not set, fail at first uninited byte 
            

ida_bytes.GMB_WAITBOX
    show wait box (may return -1 in this case)

ida_bytes.ITEM_END_CANCEL
    stop when operation cancelled, it is the responsibility of the caller to show the wait dialog 
            

ida_bytes.ITEM_END_FIXUP
    stop at the first fixup

ida_bytes.ITEM_END_INITED
    stop when initialization changes i.e.
    * if is_loaded(ea): stop if uninitialized byte is encountered
    * if !is_loaded(ea): stop if initialized byte is encountered 
    
    
            

ida_bytes.ITEM_END_NAME
    stop at the first named location

ida_bytes.ITEM_END_XREF
    stop at the first referenced location

ida_bytes.MS_CLS
    Mask for typing.

ida_bytes.MS_CODE
    Mask for code bits.

ida_bytes.MS_COMM
    Mask of common bits.

ida_bytes.MS_N_TYPE
    Mask for nth arg (a 64-bit constant)

ida_bytes.MS_VAL
    Mask for byte value.

ida_bytes.OPND_ALL
    all operands

ida_bytes.OPND_MASK
    mask for operand number

ida_bytes.OPND_OUTER
    outer offset base (combined with operand number). used only in set, get, del_offset() functions 
            

ida_bytes.PBSENC_ALL
    Use all IDB encodings.

ida_bytes.PBSENC_DEF1BPU
    Use the default 1 byte-per-unit IDB encoding.

ida_bytes.PSTF_ATTRIB
    generate for type attribute usage

ida_bytes.PSTF_ENC
    if encoding is specified, append it

ida_bytes.PSTF_HOTKEY
    have hotkey markers part of the name

ida_bytes.PSTF_ONLY_ENC
    generate only the encoding name

ida_bytes.PSTF_TBRIEF
    use brief name (e.g., in the 'Strings' window)

ida_bytes.PSTF_TINLIN
    use 'inline' name (e.g., in the structures comments)

ida_bytes.PSTF_TMASK
    type mask

ida_bytes.PSTF_TNORM
    use normal name

ida_bytes.STRCONV_ESCAPE
    convert non-printable characters to C escapes (
    , \xNN, \uNNNN)

ida_bytes.STRCONV_INCLLEN
    for Pascal-style strings, include the prefixing length byte(s) as C-escaped sequence

ida_bytes.STRCONV_REPLCHAR
    convert non-printable characters to the Unicode replacement character (U+FFFD)

ida_bytes.__to_bytevec(_in: "bytevec_t const &") -> "bytevec_t"

ida_bytes.__walk_types_and_formats(formats, type_action, format_action, installing)

ida_bytes.add_byte(ea: ida_idaapi.ea_t, value: int) -> None
    Add a value to one byte of the program. This function works for wide byte processors too. 
            
    @param ea: linear address
    @param value: byte value

ida_bytes.add_dword(ea: ida_idaapi.ea_t, value: "uint64") -> None
    Add a value to one dword of the program. This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            
    @param ea: linear address
    @param value: byte value

ida_bytes.add_hidden_range(*args) -> bool
    Mark a range of addresses as hidden. The range will be created in the invisible state with the default color 
            
    @param ea1: linear address of start of the address range
    @param ea2: linear address of end of the address range
    @param description: range parameters
    @param header: range parameters
    @param footer: range parameters
    @param color: the range color
    @returns success

ida_bytes.add_mapping(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, size: "asize_t") -> bool
    IDA supports memory mapping. References to the addresses from the mapped range use data and meta-data from the mapping range. 
            
    @param to: start of the mapping range (existent address)
    @param size: size of the range
    @returns success

ida_bytes.add_qword(ea: ida_idaapi.ea_t, value: "uint64") -> None
    Add a value to one qword of the program. This function does not work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() 
            
    @param ea: linear address
    @param value: byte value

ida_bytes.add_word(ea: ida_idaapi.ea_t, value: "uint64") -> None
    Add a value to one word of the program. This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            
    @param ea: linear address
    @param value: byte value

ida_bytes.align_flag() -> "flags64_t"
    Get a flags64_t representing an alignment directive.

ida_bytes.append_cmt(ea: ida_idaapi.ea_t, str: str, rptble: bool) -> bool
    Append to an indented comment. Creates a new comment if none exists. Appends a newline character and the specified string otherwise. 
            
    @param ea: linear address
    @param str: comment string to append
    @param rptble: append to repeatable comment?
    @returns success

ida_bytes.attach_custom_data_format(dtid: int, dfid: int) -> bool
    Attach the data format to the data type. 
            
    @param dtid: data type id that can use the data format. 0 means all standard data types. Such data formats can be applied to any data item or instruction operands. For instruction operands, the data_format_t::value_size check is not performed by the kernel.
    @param dfid: data format id
    @retval true: ok
    @retval false: no such `dtid`, or no such `dfid', or the data format has already been attached to the data type

ida_bytes.bin_flag() -> "flags64_t"
    Get number flag of the base, regardless of current processor - better to use num_flag()

ida_bytes.bin_search(*args)
    Search for a set of bytes in the program
    
    This function has the following signatures:
    
        1. bin_search(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, data: compiled_binpat_vec_t, flags: int) -> Tuple[ida_idaapi.ea_t, int]
        2. bin_search(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, image: bytes, mask: bytes, len: int, flags: int) -> ida_idaapi.ea_t
    
    The return value type will differ depending on the form:
    
        1. a tuple `(matched-address, index-in-compiled_binpat_vec_t)` (1st form)
        2. the address of a match, or ida_idaapi.BADADDR if not found (2nd form)
    
    This is a low-level function; more user-friendly alternatives
    are available. Please see 'find_bytes' and 'find_string'.
    
    @param start_ea: linear address, start of range to search
    @param end_ea: linear address, end of range to search (exclusive)
    @param data: (1st form) the prepared data to search for (see parse_binpat_str())
    @param bytes: (2nd form) a set of bytes to match
    @param mask: (2nd form) a mask to apply to the set of bytes
    @param flags: combination of BIN_SEARCH_* flags
    @return: either a tuple holding both the address of the match and the index of the compiled pattern that matched, or the address of a match (ida_idaapi.BADADDR if not found)

ida_bytes.byte_flag() -> "flags64_t"
    Get a flags64_t representing a byte.

ida_bytes.bytesize(ea: ida_idaapi.ea_t) -> int
    Get number of bytes required to store a byte at the given address.

ida_bytes.calc_def_align(ea: ida_idaapi.ea_t, mina: int, maxa: int) -> int
    Calculate the default alignment exponent. 
            
    @param ea: linear address
    @param mina: minimal possible alignment exponent.
    @param maxa: minimal possible alignment exponent.

ida_bytes.calc_dflags(f: "flags64_t", force: bool) -> "flags64_t"

ida_bytes.calc_max_align(endea: ida_idaapi.ea_t) -> int
    Calculate the maximal possible alignment exponent. 
            
    @param endea: end address of the alignment item.
    @returns a value in the 0..32 range

ida_bytes.calc_max_item_end(ea: ida_idaapi.ea_t, how: int = 15) -> ida_idaapi.ea_t
    Calculate maximal reasonable end address of a new item. This function will limit the item with the current segment bounds. 
            
    @param ea: linear address
    @param how: when to stop the search. A combination of Item end search flags
    @returns end of new item. If it is not possible to create an item, it will return 'ea'. If operation was cancelled by user, it will return 'ea'

ida_bytes.calc_min_align(length: "asize_t") -> int
    Calculate the minimal possible alignment exponent. 
            
    @param length: size of the item in bytes.
    @returns a value in the 1..32 range

ida_bytes.can_define_item(ea: ida_idaapi.ea_t, length: "asize_t", flags: "flags64_t") -> bool
    Can define item (instruction/data) of the specified 'length', starting at 'ea'? 
    * a new item would cross segment boundaries
    * a new item would overlap with existing items (except items specified by 'flags') 
    
    
            
    @param ea: start of the range for the new item
    @param length: length of the new item in bytes
    @param flags: if not 0, then the kernel will ignore the data types specified by the flags and destroy them. For example: 
                     1000 dw 5
                     1002 db 5 ; undef
                     1003 db 5 ; undef
                     1004 dw 5
                     1006 dd 5
                      can_define_item(1000, 6, 0) - false because of dw at 1004 
     can_define_item(1000, 6, word_flag()) - true, word at 1004 is destroyed
    @returns 1-yes, 0-no

ida_bytes.change_storage_type(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, stt: "storage_type_t") -> "error_t"
    Change flag storage type for address range. 
            
    @param start_ea: should be lower than end_ea.
    @param end_ea: does not belong to the range.
    @param stt: storage_type_t
    @returns error code

ida_bytes.char_flag() -> "flags64_t"
    see FF_opbits

ida_bytes.chunk_size(ea: ida_idaapi.ea_t) -> "asize_t"
    Get size of the contiguous address block containing 'ea'. 
            
    @returns 0 if 'ea' doesn't belong to the program.

ida_bytes.chunk_start(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get start of the contiguous address block containing 'ea'. 
            
    @returns BADADDR if 'ea' doesn't belong to the program.

ida_bytes.clr_lzero(ea: ida_idaapi.ea_t, n: int) -> bool
    Clear toggle lzero bit. This function reset the display of leading zeroes for the specified operand to the default. If the default is not to display leading zeroes, leading zeroes will not be displayed, as vice versa. 
            
    @param ea: the item (insn/data) address
    @param n: the operand number (0-first operand, 1-other operands)
    @returns success

ida_bytes.clr_op_type(ea: ida_idaapi.ea_t, n: int) -> bool
    Remove operand representation information. (set operand representation to be 'undefined') 
            
    @param ea: linear address
    @param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @returns success

ida_bytes.code_flag() -> "flags64_t"
    FF_CODE

ida_bytes.combine_flags(F: "flags64_t") -> "flags64_t"

ida_bytes.compiled_binpat_t

ida_bytes.compiled_binpat_t.__eq__(self, r: "compiled_binpat_t") -> bool

ida_bytes.compiled_binpat_t.__init__(self)

ida_bytes.compiled_binpat_t.__ne__(self, r: "compiled_binpat_t") -> bool

ida_bytes.compiled_binpat_t.all_bytes_defined(self) -> bool

ida_bytes.compiled_binpat_t.qclear(self) -> None

ida_bytes.compiled_binpat_vec_t

ida_bytes.compiled_binpat_vec_t.__eq__(self, r: "compiled_binpat_vec_t") -> bool

ida_bytes.compiled_binpat_vec_t.__getitem__(self, i: "size_t") -> "compiled_binpat_t const &"

ida_bytes.compiled_binpat_vec_t.__init__(self, *args)

ida_bytes.compiled_binpat_vec_t.__len__(self) -> "size_t"

ida_bytes.compiled_binpat_vec_t.__ne__(self, r: "compiled_binpat_vec_t") -> bool

ida_bytes.compiled_binpat_vec_t.__setitem__(self, i: "size_t", v: "compiled_binpat_t") -> None

ida_bytes.compiled_binpat_vec_t._del(self, x: "compiled_binpat_t") -> bool

ida_bytes.compiled_binpat_vec_t.add_unique(self, x: "compiled_binpat_t") -> bool

ida_bytes.compiled_binpat_vec_t.append(self, x: "compiled_binpat_t") -> None

ida_bytes.compiled_binpat_vec_t.at(self, _idx: "size_t") -> "compiled_binpat_t const &"

ida_bytes.compiled_binpat_vec_t.begin(self, *args) -> "qvector< compiled_binpat_t >::const_iterator"

ida_bytes.compiled_binpat_vec_t.capacity(self) -> "size_t"

ida_bytes.compiled_binpat_vec_t.clear(self) -> None

ida_bytes.compiled_binpat_vec_t.empty(self) -> bool

ida_bytes.compiled_binpat_vec_t.end(self, *args) -> "qvector< compiled_binpat_t >::const_iterator"

ida_bytes.compiled_binpat_vec_t.erase(self, *args) -> "qvector< compiled_binpat_t >::iterator"

ida_bytes.compiled_binpat_vec_t.extend(self, x: "compiled_binpat_vec_t") -> None

ida_bytes.compiled_binpat_vec_t.extract(self) -> "compiled_binpat_t *"

ida_bytes.compiled_binpat_vec_t.find(self, *args) -> "qvector< compiled_binpat_t >::const_iterator"

ida_bytes.compiled_binpat_vec_t.grow(self, *args) -> None

ida_bytes.compiled_binpat_vec_t.has(self, x: "compiled_binpat_t") -> bool

ida_bytes.compiled_binpat_vec_t.inject(self, s: "compiled_binpat_t", len: "size_t") -> None

ida_bytes.compiled_binpat_vec_t.insert(self, it: "compiled_binpat_t", x: "compiled_binpat_t") -> "qvector< compiled_binpat_t >::iterator"

ida_bytes.compiled_binpat_vec_t.pop_back(self) -> None

ida_bytes.compiled_binpat_vec_t.push_back(self, *args) -> "compiled_binpat_t &"

ida_bytes.compiled_binpat_vec_t.qclear(self) -> None

ida_bytes.compiled_binpat_vec_t.reserve(self, cnt: "size_t") -> None

ida_bytes.compiled_binpat_vec_t.resize(self, *args) -> None

ida_bytes.compiled_binpat_vec_t.size(self) -> "size_t"

ida_bytes.compiled_binpat_vec_t.swap(self, r: "compiled_binpat_vec_t") -> None

ida_bytes.compiled_binpat_vec_t.truncate(self) -> None

ida_bytes.create_16bit_data(ea: ida_idaapi.ea_t, length: "asize_t") -> bool
    Convert to 16-bit quantity (take the byte size into account)

ida_bytes.create_32bit_data(ea: ida_idaapi.ea_t, length: "asize_t") -> bool
    Convert to 32-bit quantity (take the byte size into account)

ida_bytes.create_align(ea: ida_idaapi.ea_t, length: "asize_t", alignment: int) -> bool
    Create an alignment item. 
            
    @param ea: linear address
    @param length: size of the item in bytes. 0 means to infer from ALIGNMENT
    @param alignment: alignment exponent. Example: 3 means align to 8 bytes. 0 means to infer from LENGTH It is forbidden to specify both LENGTH and ALIGNMENT as 0.
    @returns success

ida_bytes.create_byte(ea: ida_idaapi.ea_t, length: "asize_t", force: bool = False) -> bool
    Convert to byte.

ida_bytes.create_custdata(ea: ida_idaapi.ea_t, length: "asize_t", dtid: int, fid: int, force: bool = False) -> bool
    Convert to custom data type.

ida_bytes.create_data(ea: ida_idaapi.ea_t, dataflag: "flags64_t", size: "asize_t", tid: "tid_t") -> bool
    Convert to data (byte, word, dword, etc). This function may be used to create arrays. 
            
    @param ea: linear address
    @param dataflag: type of data. Value of function byte_flag(), word_flag(), etc.
    @param size: size of array in bytes. should be divisible by the size of one item of the specified type. for variable sized items it can be specified as 0, and the kernel will try to calculate the size.
    @param tid: type id. If the specified type is a structure, then tid is structure id. Otherwise should be BADNODE.
    @returns success

ida_bytes.create_double(ea: ida_idaapi.ea_t, length: "asize_t", force: bool = False) -> bool
    Convert to double.

ida_bytes.create_dword(ea: ida_idaapi.ea_t, length: "asize_t", force: bool = False) -> bool
    Convert to dword.

ida_bytes.create_float(ea: ida_idaapi.ea_t, length: "asize_t", force: bool = False) -> bool
    Convert to float.

ida_bytes.create_oword(ea: ida_idaapi.ea_t, length: "asize_t", force: bool = False) -> bool
    Convert to octaword/xmm word.

ida_bytes.create_packed_real(ea: ida_idaapi.ea_t, length: "asize_t", force: bool = False) -> bool
    Convert to packed decimal real.

ida_bytes.create_qword(ea: ida_idaapi.ea_t, length: "asize_t", force: bool = False) -> bool
    Convert to quadword.

ida_bytes.create_strlit(start: ida_idaapi.ea_t, len: "size_t", strtype: int) -> bool
    Convert to string literal and give a meaningful name. 'start' may be higher than 'end', the kernel will swap them in this case 
            
    @param start: starting address
    @param len: length of the string in bytes. if 0, then get_max_strlit_length() will be used to determine the length
    @param strtype: string type. one of String type codes
    @returns success

ida_bytes.create_struct(ea: ida_idaapi.ea_t, length: "asize_t", tid: "tid_t", force: bool = False) -> bool
    Convert to struct.

ida_bytes.create_tbyte(ea: ida_idaapi.ea_t, length: "asize_t", force: bool = False) -> bool
    Convert to tbyte.

ida_bytes.create_word(ea: ida_idaapi.ea_t, length: "asize_t", force: bool = False) -> bool
    Convert to word.

ida_bytes.create_yword(ea: ida_idaapi.ea_t, length: "asize_t", force: bool = False) -> bool
    Convert to ymm word.

ida_bytes.create_zword(ea: ida_idaapi.ea_t, length: "asize_t", force: bool = False) -> bool
    Convert to zmm word.

ida_bytes.cust_flag() -> "flags64_t"
    Get a flags64_t representing custom type data.

ida_bytes.custfmt_flag() -> "flags64_t"
    see FF_opbits

ida_bytes.data_format_t
    Information about a data format

ida_bytes.data_format_t.__get_id(self) -> int

ida_bytes.data_format_t.__init__(self, _self: "PyObject *", name: str, value_size: "asize_t" = 0, menu_name: str = None, props: int = 0, hotkey: str = None, text_width: int = 0)

ida_bytes.data_format_t.__init__(self, *args)

ida_bytes.data_format_t.hotkey
    Hotkey for the corresponding menu item if nullptr, no hotkey will be associated with the menu item 
            

ida_bytes.data_format_t.is_present_in_menus(self) -> bool
    Should this format be shown in UI menus 
            
    @returns success

ida_bytes.data_format_t.menu_name
    Visible format name to use in menus if nullptr, no menu item will be created 
            

ida_bytes.data_format_t.name
    Format name, must be unique.

ida_bytes.data_format_t.props
    properties (currently 0)

ida_bytes.data_format_t.text_width
    Usual width of the text representation This value is used to calculate the width of the control to display values of this type 
            

ida_bytes.data_format_t.value_size
    size of the value in bytes 0 means any size is ok data formats that are registered for standard types (dtid 0) may be called with any value_size (instruction operands only) 
            

ida_bytes.data_type_t
    Information about a data type

ida_bytes.data_type_t.__get_id(self) -> int

ida_bytes.data_type_t.__init__(self, _self: "PyObject *", name: str, value_size: "asize_t" = 0, menu_name: str = None, hotkey: str = None, asm_keyword: str = None, props: int = 0)

ida_bytes.data_type_t.__init__(self, *args)

ida_bytes.data_type_t.asm_keyword
    keyword to use for this type in the assembly if nullptr, the data type cannot be used in the listing it can still be used in cpuregs window 
            

ida_bytes.data_type_t.hotkey
    Hotkey for the corresponding menu item if nullptr, no hotkey will be associated with the menu item 
            

ida_bytes.data_type_t.is_present_in_menus(self) -> bool
    Should this type be shown in UI menus 
            
    @returns success

ida_bytes.data_type_t.menu_name
    Visible data type name to use in menus if nullptr, no menu item will be created 
            

ida_bytes.data_type_t.name
    name of the data type. must be unique

ida_bytes.data_type_t.props
    properties

ida_bytes.data_type_t.value_size
    size of the value in bytes

ida_bytes.dec_flag() -> "flags64_t"
    Get number flag of the base, regardless of current processor - better to use num_flag()

ida_bytes.del_hidden_range(ea: ida_idaapi.ea_t) -> bool
    Delete hidden range. 
            
    @param ea: any address in the hidden range
    @returns success

ida_bytes.del_items(ea: ida_idaapi.ea_t, flags: int = 0, nbytes: "asize_t" = 1, may_destroy: "may_destroy_cb_t *" = None) -> bool
    Convert item (instruction/data) to unexplored bytes. The whole item (including the head and tail bytes) will be destroyed. It is allowed to pass any address in the item to this function 
            
    @param ea: any address within the first item to delete
    @param flags: combination of Unexplored byte conversion flags
    @param nbytes: number of bytes in the range to be undefined
    @param may_destroy: optional routine invoked before deleting a head item. If callback returns false then item is not to be deleted and operation fails
    @returns true on sucessful operation, otherwise false

ida_bytes.del_mapping(ea: ida_idaapi.ea_t) -> None
    Delete memory mapping range. 
            
    @param ea: any address in the mapped range

ida_bytes.del_value(ea: ida_idaapi.ea_t) -> None
    Delete byte value from flags. The corresponding byte becomes uninitialized. 
            

ida_bytes.detach_custom_data_format(dtid: int, dfid: int) -> bool
    Detach the data format from the data type. Unregistering a custom data type detaches all attached data formats, no need to detach them explicitly. You still need unregister them. Unregistering a custom data format detaches it from all attached data types. 
            
    @param dtid: data type id to detach data format from
    @param dfid: data format id to detach
    @retval true: ok
    @retval false: no such `dtid`, or no such `dfid', or the data format was not attached to the data type

ida_bytes.disable_flags(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t) -> "error_t"
    Deallocate flags for address range. Exit with an error message if not enough disk space (this may occur too). 
            
    @param start_ea: should be lower than end_ea.
    @param end_ea: does not belong to the range.
    @returns 0 if ok, otherwise return error code

ida_bytes.double_flag() -> "flags64_t"
    Get a flags64_t representing a double.

ida_bytes.dword_flag() -> "flags64_t"
    Get a flags64_t representing a double word.

ida_bytes.enable_flags(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, stt: "storage_type_t") -> "error_t"
    Allocate flags for address range. This function does not change the storage type of existing ranges. Exit with an error message if not enough disk space. 
            
    @param start_ea: should be lower than end_ea.
    @param end_ea: does not belong to the range.
    @param stt: storage_type_t
    @returns 0 if ok, otherwise an error code

ida_bytes.enum_flag() -> "flags64_t"
    see FF_opbits

ida_bytes.equal_bytes(ea: ida_idaapi.ea_t, image: "uchar const *", mask: "uchar const *", len: "size_t", bin_search_flags: int) -> bool
    Compare 'len' bytes of the program starting from 'ea' with 'image'. 
            
    @param ea: linear address
    @param image: bytes to compare with
    @param mask: array of mask bytes, it's length is 'len'. if the flag BIN_SEARCH_BITMASK is passsed, 'bitwise AND' is used to compare. if not; 1 means to perform the comparison of the corresponding byte. 0 means not to perform. if mask == nullptr, then all bytes of 'image' will be compared. if mask == SKIP_FF_MASK then 0xFF bytes will be skipped
    @param len: length of block to compare in bytes.
    @param bin_search_flags: combination of Search flags
    @retval 1: equal
    @retval 0: not equal

ida_bytes.f_has_cmt(f: "flags64_t", arg2: "void *") -> bool

ida_bytes.f_has_dummy_name(f: "flags64_t", arg2: "void *") -> bool
    Does the current byte have dummy (auto-generated, with special prefix) name?

ida_bytes.f_has_extra_cmts(f: "flags64_t", arg2: "void *") -> bool

ida_bytes.f_has_name(f: "flags64_t", arg2: "void *") -> bool
    Does the current byte have non-trivial (non-dummy) name?

ida_bytes.f_has_user_name(F: "flags64_t", arg2: "void *") -> bool
    Does the current byte have user-specified name?

ida_bytes.f_has_xref(f: "flags64_t", arg2: "void *") -> bool
    Does the current byte have cross-references to it?

ida_bytes.f_is_align(F: "flags64_t", arg2: "void *") -> bool
    See is_align()

ida_bytes.f_is_byte(F: "flags64_t", arg2: "void *") -> bool
    See is_byte()

ida_bytes.f_is_code(F: "flags64_t", arg2: "void *") -> bool
    Does flag denote start of an instruction?

ida_bytes.f_is_custom(F: "flags64_t", arg2: "void *") -> bool
    See is_custom()

ida_bytes.f_is_data(F: "flags64_t", arg2: "void *") -> bool
    Does flag denote start of data?

ida_bytes.f_is_double(F: "flags64_t", arg2: "void *") -> bool
    See is_double()

ida_bytes.f_is_dword(F: "flags64_t", arg2: "void *") -> bool
    See is_dword()

ida_bytes.f_is_float(F: "flags64_t", arg2: "void *") -> bool
    See is_float()

ida_bytes.f_is_head(F: "flags64_t", arg2: "void *") -> bool
    Does flag denote start of instruction OR data?

ida_bytes.f_is_not_tail(F: "flags64_t", arg2: "void *") -> bool
    Does flag denote tail byte?

ida_bytes.f_is_oword(F: "flags64_t", arg2: "void *") -> bool
    See is_oword()

ida_bytes.f_is_pack_real(F: "flags64_t", arg2: "void *") -> bool
    See is_pack_real()

ida_bytes.f_is_qword(F: "flags64_t", arg2: "void *") -> bool
    See is_qword()

ida_bytes.f_is_strlit(F: "flags64_t", arg2: "void *") -> bool
    See is_strlit()

ida_bytes.f_is_struct(F: "flags64_t", arg2: "void *") -> bool
    See is_struct()

ida_bytes.f_is_tail(F: "flags64_t", arg2: "void *") -> bool
    Does flag denote tail byte?

ida_bytes.f_is_tbyte(F: "flags64_t", arg2: "void *") -> bool
    See is_tbyte()

ida_bytes.f_is_word(F: "flags64_t", arg2: "void *") -> bool
    See is_word()

ida_bytes.f_is_yword(F: "flags64_t", arg2: "void *") -> bool
    See is_yword()

ida_bytes.find_byte(sEA: ida_idaapi.ea_t, size: "asize_t", value: "uchar", bin_search_flags: int) -> ida_idaapi.ea_t
    Find forward a byte with the specified value (only 8-bit value from the database). example: ea=4 size=3 will inspect addresses 4, 5, and 6 
            
    @param sEA: linear address
    @param size: number of bytes to inspect
    @param value: value to find
    @param bin_search_flags: combination of Search flags
    @returns address of byte or BADADDR

ida_bytes.find_byter(sEA: ida_idaapi.ea_t, size: "asize_t", value: "uchar", bin_search_flags: int) -> ida_idaapi.ea_t
    Find reverse a byte with the specified value (only 8-bit value from the database). example: ea=4 size=3 will inspect addresses 6, 5, and 4 
            
    @param sEA: the lower address of the search range
    @param size: number of bytes to inspect
    @param value: value to find
    @param bin_search_flags: combination of Search flags
    @returns address of byte or BADADDR

ida_bytes.find_bytes(bs: typing.Union[bytes, bytearray, str], range_start: int, range_size: typing.Optional[int] = None, range_end: typing.Optional[int] = ida_idaapi.BADADDR, mask: typing.Optional[typing.Union[bytes, bytearray]] = None, flags: typing.Optional[int] = BIN_SEARCH_FORWARD|BIN_SEARCH_NOSHOW, radix: typing.Optional[int] = 16, strlit_encoding: typing.Optional[typing.Union[int, str]] = PBSENC_DEF1BPU) -> int

ida_bytes.find_custom_data_format(name: str) -> int
    Get id of a custom data format. 
            
    @param name: name of the custom data format
    @returns id or -1

ida_bytes.find_custom_data_type(name: str) -> int
    Get id of a custom data type. 
            
    @param name: name of the custom data type
    @returns id or -1

ida_bytes.find_free_chunk(start: ida_idaapi.ea_t, size: "asize_t", alignment: "asize_t") -> ida_idaapi.ea_t
    Search for a hole in the addressing space of the program. 
            
    @param start: Address to start searching from
    @param size: Size of the desired empty range
    @param alignment: Alignment bitmask, must be a pow2-1. (for example, 0xF would align the returned range to 16 bytes).
    @returns Start of the found empty range or BADADDR

ida_bytes.find_string(_str: str, range_start: int, range_end: typing.Optional[int] = ida_idaapi.BADADDR, range_size: typing.Optional[int] = None, strlit_encoding: typing.Optional[typing.Union[int, str]] = PBSENC_DEF1BPU, flags: typing.Optional[int] = BIN_SEARCH_FORWARD|BIN_SEARCH_NOSHOW) -> int

ida_bytes.float_flag() -> "flags64_t"
    Get a flags64_t representing a float.

ida_bytes.flt_flag() -> "flags64_t"
    see FF_opbits

ida_bytes.get_16bit(ea: ida_idaapi.ea_t) -> int
    Get 16bits of the program at 'ea'. 
            
    @returns 1 byte (getFullByte()) if the current processor has 16-bit byte, otherwise return get_word()

ida_bytes.get_32bit(ea: ida_idaapi.ea_t) -> int
    Get not more than 32bits of the program at 'ea'. 
            
    @returns 32 bit value, depending on processor_t::nbits:
    * if ( nbits <= 8 ) return get_dword(ea);
    * if ( nbits <= 16) return get_wide_word(ea);
    * return get_wide_byte(ea);

ida_bytes.get_64bit(ea: ida_idaapi.ea_t) -> "uint64"
    Get not more than 64bits of the program at 'ea'. 
            
    @returns 64 bit value, depending on processor_t::nbits:
    * if ( nbits <= 8 ) return get_qword(ea);
    * if ( nbits <= 16) return get_wide_dword(ea);
    * return get_wide_byte(ea);

ida_bytes.get_byte(ea: ida_idaapi.ea_t) -> "uchar"
    Get one byte (8-bit) of the program at 'ea'. This function works only for 8bit byte processors. 
            

ida_bytes.get_bytes(ea: ida_idaapi.ea_t, size: int, gmb_flags: int = GMB_READALL)
    Get the specified number of bytes of the program.
    
    @param ea: program address
    @param size: number of bytes to return
    @param gmb_flags: OR'ed combination of GMB_* values (defaults to GMB_READALL)
    @return: the bytes (as bytes object), or None in case of failure

ida_bytes.get_bytes_and_mask(ea: ida_idaapi.ea_t, size: int, gmb_flags: int = GMB_READALL)
    Get the specified number of bytes of the program, and a bitmask
    specifying what bytes are defined and what bytes are not.
    
    @param ea: program address
    @param size: number of bytes to return
    @param gmb_flags: OR'ed combination of GMB_* values (defaults to GMB_READALL)
    @return: a tuple (bytes, mask), or None in case of failure.
             Both 'bytes' and 'mask' are 'str' instances.

ida_bytes.get_cmt(ea: ida_idaapi.ea_t, rptble: bool) -> str
    Get an indented comment. 
            
    @param ea: linear address. may point to tail byte, the function will find start of the item
    @param rptble: get repeatable comment?
    @returns size of comment or -1

ida_bytes.get_custom_data_format(dfid: int) -> "data_format_t const *"
    Get definition of a registered custom data format. 
            
    @param dfid: data format id
    @returns data format definition or nullptr

ida_bytes.get_custom_data_formats(out: "intvec_t *", dtid: int) -> int
    Get list of attached custom data formats for the specified data type. 
            
    @param out: buffer for the output. may be nullptr
    @param dtid: data type id
    @returns number of returned custom data formats. if error, returns -1

ida_bytes.get_custom_data_type(dtid: int) -> "data_type_t const *"
    Get definition of a registered custom data type. 
            
    @param dtid: data type id
    @returns data type definition or nullptr

ida_bytes.get_custom_data_types(*args) -> int
    Get list of registered custom data type ids. 
            
    @param out: buffer for the output. may be nullptr
    @param min_size: minimum value size
    @param max_size: maximum value size
    @returns number of custom data types with the specified size limits

ida_bytes.get_data_elsize(ea: ida_idaapi.ea_t, F: "flags64_t", ti: "opinfo_t" = None) -> "asize_t"
    Get size of data type specified in flags 'F'. 
            
    @param ea: linear address of the item
    @param F: flags
    @param ti: additional information about the data type. For example, if the current item is a structure instance, then ti->tid is structure id. Otherwise is ignored (may be nullptr). If specified as nullptr, will be automatically retrieved from the database
    @returns * byte : 1
    * word : 2
    * etc...

ida_bytes.get_data_value(v: "uval_t *", ea: ida_idaapi.ea_t, size: "asize_t") -> bool
    Get the value at of the item at 'ea'. This function works with entities up to sizeof(ea_t) (bytes, word, etc) 
            
    @param v: pointer to the result. may be nullptr
    @param ea: linear address
    @param size: size of data to read. If 0, then the item type at 'ea' will be used
    @returns success

ida_bytes.get_db_byte(ea: ida_idaapi.ea_t) -> "uchar"
    Get one byte (8-bit) of the program at 'ea' from the database. Works even if the debugger is active. See also get_dbg_byte() to read the process memory directly. This function works only for 8bit byte processors. 
            

ida_bytes.get_default_radix() -> int
    Get default base of number for the current processor. 
            
    @returns 2, 8, 10, 16

ida_bytes.get_dword(ea: ida_idaapi.ea_t) -> int
    Get one dword (32-bit) of the program at 'ea'. This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. 
            

ida_bytes.get_enum_id(ea: ida_idaapi.ea_t, n: int) -> "uchar *"
    Get enum id of 'enum' operand. 
            
    @param ea: linear address
    @param n: 0..UA_MAXOP-1 operand number, OPND_ALL one of the operands
    @returns id of enum or BADNODE

ida_bytes.get_first_hidden_range() -> "hidden_range_t *"
    Get pointer to the first hidden range. 
            
    @returns ptr to hidden range or nullptr

ida_bytes.get_flags(ea: ida_idaapi.ea_t) -> "flags64_t"
    get flags with FF_IVL & MS_VAL. It is much slower under remote debugging because the kernel needs to read the process memory. 
            

ida_bytes.get_flags_by_size(size: "size_t") -> "flags64_t"
    Get flags from size (in bytes). Supported sizes: 1, 2, 4, 8, 16, 32. For other sizes returns 0 
            

ida_bytes.get_flags_ex(ea: ida_idaapi.ea_t, how: int) -> "flags64_t"
    Get flags for the specified address, extended form.

ida_bytes.get_forced_operand(ea: ida_idaapi.ea_t, n: int) -> str
    Get forced operand. 
            
    @param ea: linear address
    @param n: 0..UA_MAXOP-1 operand number
    @returns size of forced operand or -1

ida_bytes.get_full_data_elsize(ea: ida_idaapi.ea_t, F: "flags64_t", ti: "opinfo_t" = None) -> "asize_t"
    Get full size of data type specified in flags 'F'. takes into account processors with wide bytes e.g. returns 2 for a byte element with 16-bit bytes 
            

ida_bytes.get_full_flags(ea: ida_idaapi.ea_t) -> "flags64_t"
    Get flags value for address 'ea'. 
            
    @returns 0 if address is not present in the program

ida_bytes.get_hidden_range(ea: ida_idaapi.ea_t) -> "hidden_range_t *"
    Get pointer to hidden range structure, in: linear address. 
            
    @param ea: any address in the hidden range

ida_bytes.get_hidden_range_num(ea: ida_idaapi.ea_t) -> int
    Get number of a hidden range. 
            
    @param ea: any address in the hidden range
    @returns number of hidden range (0..get_hidden_range_qty()-1)

ida_bytes.get_hidden_range_qty() -> int
    Get number of hidden ranges.

ida_bytes.get_item_end(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get the end address of the item at 'ea'. The returned address doesn't belong to the current item. Unexplored bytes are counted as 1 byte entities. 
            

ida_bytes.get_item_flag(_from: ida_idaapi.ea_t, n: int, ea: ida_idaapi.ea_t, appzero: bool) -> "flags64_t"
    Get flag of the item at 'ea' even if it is a tail byte of some array or structure. This function is used to get flags of structure members or array elements. 
            
    @param n: operand number which refers to 'ea' or OPND_ALL for one of the operands
    @param ea: the referenced address
    @param appzero: append a struct field name if the field offset is zero? meaningful only if the name refers to a structure.
    @returns flags or 0 (if failed)

ida_bytes.get_item_head(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get the start address of the item at 'ea'. If there is no current item, then 'ea' will be returned (see definition at the end of bytes.hpp source) 
            

ida_bytes.get_item_refinfo(ri: "refinfo_t", ea: ida_idaapi.ea_t, n: int) -> bool
    Get refinfo of the item at 'ea'. This function works for a regular offset operand as well as for a tail byte of a structure variable (in this case refinfo to corresponding structure member will be returned) 
            
    @param ri: refinfo holder
    @param ea: the item address
    @param n: operand number which refers to 'ea' or OPND_ALL for one of the operands
    @returns success

ida_bytes.get_item_size(ea: ida_idaapi.ea_t) -> "asize_t"
    Get size of item (instruction/data) in bytes. Unexplored bytes have length of 1 byte. This function returns 0 only for BADADDR. 
            

ida_bytes.get_last_hidden_range() -> "hidden_range_t *"
    Get pointer to the last hidden range. 
            
    @returns ptr to hidden range or nullptr

ida_bytes.get_manual_insn(ea: ida_idaapi.ea_t) -> str
    Retrieve the user-specified string for the manual instruction. 
            
    @param ea: linear address of the instruction or data item
    @returns size of manual instruction or -1

ida_bytes.get_mapping(n: "size_t") -> "ea_t *, ea_t *, asize_t *"
    Get memory mapping range by its number. 
            
    @param n: number of mapping range (0..get_mappings_qty()-1)
    @returns false if the specified range doesn't exist, otherwise returns `from`, `to`, `size`

ida_bytes.get_mappings_qty() -> "size_t"
    Get number of mappings.

ida_bytes.get_max_strlit_length(ea: ida_idaapi.ea_t, strtype: int, options: int = 0) -> "size_t"
    Determine maximum length of string literal.
    If the string literal has a length prefix (e.g., STRTYPE_LEN2 has a two-byte length prefix), the length of that prefix (i.e., 2) will be part of the returned value.
    
    @param ea: starting address
    @param strtype: string type. one of String type codes
    @param options: combination of string literal length options
    @returns length of the string in octets (octet==8bit)

ida_bytes.get_next_hidden_range(ea: ida_idaapi.ea_t) -> "hidden_range_t *"
    Get pointer to next hidden range. 
            
    @param ea: any address in the program
    @returns ptr to hidden range or nullptr if next hidden range doesn't exist

ida_bytes.get_octet(ogen: "octet_generator_t") -> "uchar *"

ida_bytes.get_operand_flag(typebits: "uint8", n: int) -> "flags64_t"
    Place operand `n`'s type flag in the right nibble of a 64-bit flags set.
    
    @param typebits: the type bits (one of `FF_N_`)
    @param n: the operand number
    @returns the shift to the nibble

ida_bytes.get_operand_type_shift(n: int) -> int
    Get the shift in `flags64_t` for the nibble representing operand `n`'s type
    Note: n must be < UA_MAXOP, and is not checked
    
    @param n: the operand number
    @returns the shift to the nibble

ida_bytes.get_opinfo(buf: "opinfo_t", ea: ida_idaapi.ea_t, n: int, flags: "flags64_t") -> "opinfo_t *"
    Get additional information about an operand representation. 
            
    @param buf: buffer to receive the result. may not be nullptr
    @param ea: linear address of item
    @param n: number of operand, 0 or 1
    @param flags: flags of the item
    @returns nullptr if no additional representation information

ida_bytes.get_optype_flags0(F: "flags64_t") -> "flags64_t"
    Get flags for first operand.

ida_bytes.get_optype_flags1(F: "flags64_t") -> "flags64_t"
    Get flags for second operand.

ida_bytes.get_original_byte(ea: ida_idaapi.ea_t) -> "uint64"
    Get original byte value (that was before patching). This function works for wide byte processors too. 
            

ida_bytes.get_original_dword(ea: ida_idaapi.ea_t) -> "uint64"
    Get original dword (that was before patching) This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            

ida_bytes.get_original_qword(ea: ida_idaapi.ea_t) -> "uint64"
    Get original qword value (that was before patching) This function DOESN'T work for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            

ida_bytes.get_original_word(ea: ida_idaapi.ea_t) -> "uint64"
    Get original word value (that was before patching). This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            

ida_bytes.get_possible_item_varsize(ea: ida_idaapi.ea_t, tif: "tinfo_t") -> "asize_t"
    Return the possible size of the item at EA of type TIF if TIF is the variable structure. 
            
    @param ea: the linear address of the item
    @param tif: the item type
    @returns the possible size
    @retval asize_t(-1): TIF is not a variable structure

ida_bytes.get_predef_insn_cmt(ins: "insn_t const &") -> str
    Get predefined comment. 
            
    @param ins: current instruction information
    @returns size of comment or -1

ida_bytes.get_prev_hidden_range(ea: ida_idaapi.ea_t) -> "hidden_range_t *"
    Get pointer to previous hidden range. 
            
    @param ea: any address in the program
    @returns ptr to hidden range or nullptr if previous hidden range doesn't exist

ida_bytes.get_qword(ea: ida_idaapi.ea_t) -> "uint64"
    Get one qword (64-bit) of the program at 'ea'. This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. 
            

ida_bytes.get_radix(F: "flags64_t", n: int) -> int
    Get radix of the operand, in: flags. If the operand is not a number, returns get_default_radix() 
            
    @param F: flags
    @param n: number of operand (0, 1, -1)
    @returns 2, 8, 10, 16

ida_bytes.get_strlit_contents(ea: ida_idaapi.ea_t, len: int, type: int, flags: int = 0)
    Get contents of string literal, as UTF-8-encoded codepoints.
    It works even if the string has not been created in the database yet.
    
    Note that the returned value will be of type 'bytes'; if
    you want auto-conversion to unicode strings (that is: real Python
    strings), you should probably be using the idautils.Strings class.
    
    @param ea: linear address of the string
    @param len: length of the string in bytes (including terminating 0)
    @param type: type of the string. Represents both the character encoding,
                 <u>and</u> the 'type' of string at the given location.
    @param flags: combination of STRCONV_..., to perform output conversion.
    @return: a bytes-filled str object.

ida_bytes.get_stroff_path(*args)
    Get the structure offset path for operand `n`, at the
    specified address.
    
    This function has the following signatures:
    
        1. get_stroff_path(ea: ida_idaapi.ea_t, n : int) -> Tuple[List[int], int]
        2. get_stroff_path(path: tid_array, delta: sval_pointer, ea: ida_idaapi.ea_t, n : int) (backward-compatibility only)
    
    @param ea address where the operand holds a path to a structure offset (1st form)
    @param n operand number (1st form)
    @return a tuple holding a (list_of_tid_t's, delta_within_the_last_type), or (None, None)

ida_bytes.get_wide_byte(ea: ida_idaapi.ea_t) -> "uint64"
    Get one wide byte of the program at 'ea'. Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. 
            

ida_bytes.get_wide_dword(ea: ida_idaapi.ea_t) -> "uint64"
    Get two wide words (4 'bytes') of the program at 'ea'. Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. This function takes into account order of bytes specified in idainfo::is_be() 
            

ida_bytes.get_wide_word(ea: ida_idaapi.ea_t) -> "uint64"
    Get one wide word (2 'byte') of the program at 'ea'. Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. This function takes into account order of bytes specified in idainfo::is_be() 
            

ida_bytes.get_word(ea: ida_idaapi.ea_t) -> "ushort"
    Get one word (16-bit) of the program at 'ea'. This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. 
            

ida_bytes.get_zero_ranges(zranges: "rangeset_t", range: "range_t") -> bool
    Return set of ranges with zero initialized bytes. The returned set includes only big zero initialized ranges (at least >1KB). Some zero initialized byte ranges may be not included. Only zero bytes that use the sparse storage method (STT_MM) are reported. 
            
    @param zranges: pointer to the return value. cannot be nullptr
    @param range: the range of addresses to verify. can be nullptr - means all ranges
    @returns true if the result is a non-empty set

ida_bytes.getn_hidden_range(n: int) -> "hidden_range_t *"
    Get pointer to hidden range structure, in: number of hidden range. 
            
    @param n: number of hidden range, is in range 0..get_hidden_range_qty()-1

ida_bytes.has_any_name(F: "flags64_t") -> bool
    Does the current byte have any name?

ida_bytes.has_auto_name(F: "flags64_t") -> bool
    Does the current byte have auto-generated (no special prefix) name?

ida_bytes.has_cmt(F: "flags64_t") -> bool
    Does the current byte have an indented comment?

ida_bytes.has_dummy_name(F: "flags64_t") -> bool
    Does the current byte have dummy (auto-generated, with special prefix) name?

ida_bytes.has_extra_cmts(F: "flags64_t") -> bool
    Does the current byte have additional anterior or posterior lines?

ida_bytes.has_immd(F: "flags64_t") -> bool
    Has immediate value?

ida_bytes.has_name(F: "flags64_t") -> bool
    Does the current byte have non-trivial (non-dummy) name?

ida_bytes.has_user_name(F: "flags64_t") -> bool
    Does the current byte have user-specified name?

ida_bytes.has_value(F: "flags64_t") -> bool
    Do flags contain byte value?

ida_bytes.has_xref(F: "flags64_t") -> bool
    Does the current byte have cross-references to it?

ida_bytes.hex_flag() -> "flags64_t"
    Get number flag of the base, regardless of current processor - better to use num_flag()

ida_bytes.hidden_range_t

ida_bytes.hidden_range_t.__init__(self)

ida_bytes.hidden_range_t.color
    range color

ida_bytes.hidden_range_t.description
    description to display if the range is collapsed

ida_bytes.hidden_range_t.footer
    footer lines to display if the range is expanded

ida_bytes.hidden_range_t.header
    header lines to display if the range is expanded

ida_bytes.hidden_range_t.visible
    the range state

ida_bytes.is_align(F: "flags64_t") -> bool
    FF_ALIGN

ida_bytes.is_attached_custom_data_format(dtid: int, dfid: int) -> bool
    Is the custom data format attached to the custom data type? 
            
    @param dtid: data type id
    @param dfid: data format id
    @returns true or false

ida_bytes.is_bnot(ea: ida_idaapi.ea_t, F: "flags64_t", n: int) -> bool
    Should we negate the operand?. asm_t::a_bnot should be defined in the idp module in order to work with this function 
            

ida_bytes.is_byte(F: "flags64_t") -> bool
    FF_BYTE

ida_bytes.is_char(F: "flags64_t", n: int) -> bool
    is character constant?

ida_bytes.is_char0(F: "flags64_t") -> bool
    Is the first operand character constant? (example: push 'a')

ida_bytes.is_char1(F: "flags64_t") -> bool
    Is the second operand character constant? (example: mov al, 'a')

ida_bytes.is_code(F: "flags64_t") -> bool
    Does flag denote start of an instruction?

ida_bytes.is_custfmt(F: "flags64_t", n: int) -> bool
    is custom data format?

ida_bytes.is_custfmt0(F: "flags64_t") -> bool
    Does the first operand use a custom data representation?

ida_bytes.is_custfmt1(F: "flags64_t") -> bool
    Does the second operand use a custom data representation?

ida_bytes.is_custom(F: "flags64_t") -> bool
    FF_CUSTOM

ida_bytes.is_data(F: "flags64_t") -> bool
    Does flag denote start of data?

ida_bytes.is_defarg(F: "flags64_t", n: int) -> bool
    is defined?

ida_bytes.is_defarg0(F: "flags64_t") -> bool
    Is the first operand defined? Initially operand has no defined representation.

ida_bytes.is_defarg1(F: "flags64_t") -> bool
    Is the second operand defined? Initially operand has no defined representation.

ida_bytes.is_double(F: "flags64_t") -> bool
    FF_DOUBLE

ida_bytes.is_dword(F: "flags64_t") -> bool
    FF_DWORD

ida_bytes.is_enum(F: "flags64_t", n: int) -> bool
    is enum?

ida_bytes.is_enum0(F: "flags64_t") -> bool
    Is the first operand a symbolic constant (enum member)?

ida_bytes.is_enum1(F: "flags64_t") -> bool
    Is the second operand a symbolic constant (enum member)?

ida_bytes.is_flag_for_operand(F: "flags64_t", typebits: "uint8", n: int) -> bool
    Check that the 64-bit flags set has the expected type for operand `n`.
    
    @param F: the flags
    @param typebits: the type bits (one of `FF_N_`)
    @param n: the operand number
    @returns success

ida_bytes.is_float(F: "flags64_t") -> bool
    FF_FLOAT

ida_bytes.is_float0(F: "flags64_t") -> bool
    Is the first operand a floating point number?

ida_bytes.is_float1(F: "flags64_t") -> bool
    Is the second operand a floating point number?

ida_bytes.is_flow(F: "flags64_t") -> bool
    Does the previous instruction exist and pass execution flow to the current byte?

ida_bytes.is_fltnum(F: "flags64_t", n: int) -> bool
    is floating point number?

ida_bytes.is_forced_operand(ea: ida_idaapi.ea_t, n: int) -> bool
    Is operand manually defined?. 
            
    @param ea: linear address
    @param n: 0..UA_MAXOP-1 operand number

ida_bytes.is_func(F: "flags64_t") -> bool
    Is function start?

ida_bytes.is_head(F: "flags64_t") -> bool
    Does flag denote start of instruction OR data?

ida_bytes.is_invsign(ea: ida_idaapi.ea_t, F: "flags64_t", n: int) -> bool
    Should sign of n-th operand inverted during output?. allowed values of n: 0-first operand, 1-other operands 
            

ida_bytes.is_loaded(ea: ida_idaapi.ea_t) -> bool
    Does the specified address have a byte value (is initialized?)

ida_bytes.is_lzero(ea: ida_idaapi.ea_t, n: int) -> bool
    Display leading zeroes? Display leading zeroes in operands. The global switch for the leading zeroes is in idainfo::s_genflags Note: the leading zeroes doesn't work if for the target assembler octal numbers start with 0. 
            
    @param ea: the item (insn/data) address
    @param n: the operand number (0-first operand, 1-other operands)
    @returns success

ida_bytes.is_manual(F: "flags64_t", n: int) -> bool
    is forced operand? (use is_forced_operand())

ida_bytes.is_manual_insn(ea: ida_idaapi.ea_t) -> bool
    Is the instruction overridden? 
            
    @param ea: linear address of the instruction or data item

ida_bytes.is_mapped(ea: ida_idaapi.ea_t) -> bool
    Is the specified address 'ea' present in the program?

ida_bytes.is_not_tail(F: "flags64_t") -> bool
    Does flag denote tail byte?

ida_bytes.is_numop(F: "flags64_t", n: int) -> bool
    is number (bin, oct, dec, hex)?

ida_bytes.is_numop0(F: "flags64_t") -> bool
    Is the first operand a number (i.e. binary, octal, decimal or hex?)

ida_bytes.is_numop1(F: "flags64_t") -> bool
    Is the second operand a number (i.e. binary, octal, decimal or hex?)

ida_bytes.is_off(F: "flags64_t", n: int) -> bool
    is offset?

ida_bytes.is_off0(F: "flags64_t") -> bool
    Is the first operand offset? (example: push offset xxx)

ida_bytes.is_off1(F: "flags64_t") -> bool
    Is the second operand offset? (example: mov ax, offset xxx)

ida_bytes.is_oword(F: "flags64_t") -> bool
    FF_OWORD

ida_bytes.is_pack_real(F: "flags64_t") -> bool
    FF_PACKREAL

ida_bytes.is_qword(F: "flags64_t") -> bool
    FF_QWORD

ida_bytes.is_same_data_type(F1: "flags64_t", F2: "flags64_t") -> bool
    Do the given flags specify the same data type?

ida_bytes.is_seg(F: "flags64_t", n: int) -> bool
    is segment?

ida_bytes.is_seg0(F: "flags64_t") -> bool
    Is the first operand segment selector? (example: push seg seg001)

ida_bytes.is_seg1(F: "flags64_t") -> bool
    Is the second operand segment selector? (example: mov dx, seg dseg)

ida_bytes.is_stkvar(F: "flags64_t", n: int) -> bool
    is stack variable?

ida_bytes.is_stkvar0(F: "flags64_t") -> bool
    Is the first operand a stack variable?

ida_bytes.is_stkvar1(F: "flags64_t") -> bool
    Is the second operand a stack variable?

ida_bytes.is_strlit(F: "flags64_t") -> bool
    FF_STRLIT

ida_bytes.is_stroff(F: "flags64_t", n: int) -> bool
    is struct offset?

ida_bytes.is_stroff0(F: "flags64_t") -> bool
    Is the first operand an offset within a struct?

ida_bytes.is_stroff1(F: "flags64_t") -> bool
    Is the second operand an offset within a struct?

ida_bytes.is_struct(F: "flags64_t") -> bool
    FF_STRUCT

ida_bytes.is_suspop(ea: ida_idaapi.ea_t, F: "flags64_t", n: int) -> bool
    is suspicious operand?

ida_bytes.is_tail(F: "flags64_t") -> bool
    Does flag denote tail byte?

ida_bytes.is_tbyte(F: "flags64_t") -> bool
    FF_TBYTE

ida_bytes.is_unknown(F: "flags64_t") -> bool
    Does flag denote unexplored byte?

ida_bytes.is_varsize_item(ea: ida_idaapi.ea_t, F: "flags64_t", ti: "opinfo_t" = None, itemsize: "asize_t *" = None) -> int
    Is the item at 'ea' variable size?. 
            
    @param ea: linear address of the item
    @param F: flags
    @param ti: additional information about the data type. For example, if the current item is a structure instance, then ti->tid is structure id. Otherwise is ignored (may be nullptr). If specified as nullptr, will be automatically retrieved from the database
    @param itemsize: if not nullptr and the item is varsize, itemsize will contain the calculated item size (for struct types, the minimal size is returned)
    @retval 1: varsize item
    @retval 0: fixed item
    @retval -1: error (bad data definition)

ida_bytes.is_word(F: "flags64_t") -> bool
    FF_WORD

ida_bytes.is_yword(F: "flags64_t") -> bool
    FF_YWORD

ida_bytes.is_zword(F: "flags64_t") -> bool
    FF_ZWORD

ida_bytes.leading_zero_important(ea: ida_idaapi.ea_t, n: int) -> bool
    Check if leading zeroes are important.

ida_bytes.nbits(ea: ida_idaapi.ea_t) -> int
    Get number of bits in a byte at the given address. 
            
    @returns processor_t::dnbits() if the address doesn't belong to a segment, otherwise the result depends on the segment type

ida_bytes.next_addr(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get next address in the program (i.e. next address which has flags). 
            
    @returns BADADDR if no such address exist.

ida_bytes.next_chunk(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get the first address of next contiguous chunk in the program. 
            
    @returns BADADDR if next chunk doesn't exist.

ida_bytes.next_head(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get start of next defined item. 
            
    @param ea: begin search at this address
    @param maxea: not included in the search range
    @returns BADADDR if none exists.

ida_bytes.next_inited(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Find the next initialized address.

ida_bytes.next_not_tail(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get address of next non-tail byte. 
            
    @returns BADADDR if none exists.

ida_bytes.next_that(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t, testf: "testf_t *") -> ida_idaapi.ea_t
    Find next address with a flag satisfying the function 'testf'. 
            
    @param ea: start searching at this address + 1
    @param maxea: not included in the search range.
    @param testf: test function to find next address
    @returns the found address or BADADDR.

ida_bytes.next_unknown(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Similar to next_that(), but will find the next address that is unexplored.

ida_bytes.next_visea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get next visible address. 
            
    @returns BADADDR if none exists.

ida_bytes.num_flag() -> "flags64_t"
    Get number of default base (bin, oct, dec, hex) 
            

ida_bytes.oct_flag() -> "flags64_t"
    Get number flag of the base, regardless of current processor - better to use num_flag()

ida_bytes.octet_generator_t

ida_bytes.octet_generator_t.__init__(self, _ea: ida_idaapi.ea_t)

ida_bytes.octet_generator_t.invert_byte_order(self) -> None

ida_bytes.off_flag() -> "flags64_t"
    see FF_opbits

ida_bytes.op_adds_xrefs(F: "flags64_t", n: int) -> bool
    Should processor module create xrefs from the operand?. Currently 'offset' and 'structure offset' operands create xrefs 
            

ida_bytes.op_based_stroff(insn: "insn_t const &", n: int, opval: "adiff_t", base: ida_idaapi.ea_t) -> bool
    Set operand representation to be 'struct offset' if the operand likely points to a structure member. For example, let's there is a structure at 1000 1000 stru_1000 Elf32_Sym <...> the operand #8 will be represented as '#Elf32_Sym.st_size' after the call of 'op_based_stroff(..., 8, 0x1000)' By the way, after the call of 'op_plain_offset(..., 0x1000)' it will be represented as '#(stru_1000.st_size - 0x1000)' 
            
    @param insn: the instruction
    @param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @param opval: operand value (usually op_t::value or op_t::addr)
    @param base: base reference
    @returns success

ida_bytes.op_bin(ea: ida_idaapi.ea_t, n: int) -> bool
    set op type to bin_flag()

ida_bytes.op_chr(ea: ida_idaapi.ea_t, n: int) -> bool
    set op type to char_flag()

ida_bytes.op_custfmt(ea: ida_idaapi.ea_t, n: int, fid: int) -> bool
    Set custom data format for operand (fid-custom data format id)

ida_bytes.op_dec(ea: ida_idaapi.ea_t, n: int) -> bool
    set op type to dec_flag()

ida_bytes.op_enum(ea: ida_idaapi.ea_t, n: int, id: "tid_t", serial: "uchar" = 0) -> bool
    Set operand representation to be enum type If applied to unexplored bytes, converts them to 16/32bit word data 
            
    @param ea: linear address
    @param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @param id: id of enum
    @param serial: the serial number of the constant in the enumeration, usually 0. the serial numbers are used if the enumeration contains several constants with the same value
    @returns success

ida_bytes.op_flt(ea: ida_idaapi.ea_t, n: int) -> bool
    set op type to flt_flag()

ida_bytes.op_hex(ea: ida_idaapi.ea_t, n: int) -> bool
    set op type to hex_flag()

ida_bytes.op_num(ea: ida_idaapi.ea_t, n: int) -> bool
    set op type to num_flag()

ida_bytes.op_oct(ea: ida_idaapi.ea_t, n: int) -> bool
    set op type to oct_flag()

ida_bytes.op_seg(ea: ida_idaapi.ea_t, n: int) -> bool
    Set operand representation to be 'segment'. If applied to unexplored bytes, converts them to 16/32bit word data 
            
    @param ea: linear address
    @param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @returns success

ida_bytes.op_stkvar(ea: ida_idaapi.ea_t, n: int) -> bool
    Set operand representation to be 'stack variable'. Should be applied to an instruction within a function. Should be applied after creating a stack var using insn_t::create_stkvar(). 
            
    @param ea: linear address
    @param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @returns success

ida_bytes.op_stroff(*args) -> bool
    Set operand representation to be 'struct offset'.
    
    This function has the following signatures:
    
        1. op_stroff(ins: ida_ua.insn_t, n: int, path: List[int], delta: int)
        2. op_stroff(ins: ida_ua.insn_t, n: int, path: ida_pro.tid_array, path_len: int, delta: int) (backward-compatibility only)
    
    Here is an example using this function:
    
        ins = ida_ua.insn_t()
        if ida_ua.decode_insn(ins, some_address):
            operand = 0
            path = [ida_typeinf.get_named_type_tid("my_stucture_t")] # a one-element path
            ida_bytes.op_stroff(ins, operand, path, 0)

ida_bytes.oword_flag() -> "flags64_t"
    Get a flags64_t representing a octaword.

ida_bytes.packreal_flag() -> "flags64_t"
    Get a flags64_t representing a packed decimal real.

ida_bytes.parse_binpat_str(out: "compiled_binpat_vec_t", ea: ida_idaapi.ea_t, _in: str, radix: int, strlits_encoding: int = 0) -> bool
    Convert user-specified binary string to internal representation. The 'in' parameter contains space-separated tokens: 
         numbers (numeric base is determined by 'radix')
            - if value of number fits a byte, it is considered as a byte
            - if value of number fits a word, it is considered as 2 bytes
            - if value of number fits a dword,it is considered as 4 bytes
         "..." string constants
         'x'  single-character constants
         ?    variable bytes
    
    
    Note that string constants are surrounded with double quotes.
    Here are a few examples (assuming base 16): 
         21          - bytes 0xCD, 0x21
                   - bytes 0xCD, 0x21 (little endian ) or 0x21, 0xCD (big-endian)
         0     - the null terminated string "Hello"
               - 'H', 0, 'e', 0, 'l', 0, 'l', 0, 'o', 0
         ? ? ? ? 90  - byte 0xB8, 4 bytes with any value, byte 0x90
    
    
            
    @param out: a vector of compiled binary patterns, for use with bin_search()
    @param ea: linear address to convert for (the conversion depends on the address, because the number of bits in a byte depend on the segment type)
    @param radix: numeric base of numbers (8,10,16)
    @param strlits_encoding: the target encoding into which the string literals present in 'in', should be encoded. Can be any from [1, get_encoding_qty()), or the special values PBSENC_*
    @returns false either in case of parsing error, or if at least one requested target encoding couldn't encode the string literals present in "in".

ida_bytes.patch_byte(ea: ida_idaapi.ea_t, x: "uint64") -> bool
    Patch a byte of the program. The original value of the byte is saved and can be obtained by get_original_byte(). This function works for wide byte processors too. 
            
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.

ida_bytes.patch_bytes(ea: ida_idaapi.ea_t, buf: "void const *") -> None
    Patch the specified number of bytes of the program. Original values of bytes are saved and are available with get_original...() functions. See also put_bytes(). 
            
    @param ea: linear address
    @param buf: buffer with new values of bytes

ida_bytes.patch_dword(ea: ida_idaapi.ea_t, x: "uint64") -> bool
    Patch a dword of the program. The original value of the dword is saved and can be obtained by get_original_dword(). This function DOESN'T work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() 
            
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.

ida_bytes.patch_qword(ea: ida_idaapi.ea_t, x: "uint64") -> bool
    Patch a qword of the program. The original value of the qword is saved and can be obtained by get_original_qword(). This function DOESN'T work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() 
            
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.

ida_bytes.patch_word(ea: ida_idaapi.ea_t, x: "uint64") -> bool
    Patch a word of the program. The original value of the word is saved and can be obtained by get_original_word(). This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.

ida_bytes.prev_addr(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get previous address in the program. 
            
    @returns BADADDR if no such address exist.

ida_bytes.prev_chunk(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get the last address of previous contiguous chunk in the program. 
            
    @returns BADADDR if previous chunk doesn't exist.

ida_bytes.prev_head(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get start of previous defined item. 
            
    @param ea: begin search at this address
    @param minea: included in the search range
    @returns BADADDR if none exists.

ida_bytes.prev_inited(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Find the previous initialized address.

ida_bytes.prev_not_tail(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get address of previous non-tail byte. 
            
    @returns BADADDR if none exists.

ida_bytes.prev_that(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t, testf: "testf_t *") -> ida_idaapi.ea_t
    Find previous address with a flag satisfying the function 'testf'. 
            
    @param ea: start searching from this address - 1.
    @param minea: included in the search range.
    @param testf: test function to find previous address
    @returns the found address or BADADDR.

ida_bytes.prev_unknown(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Similar to prev_that(), but will find the previous address that is unexplored.

ida_bytes.prev_visea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get previous visible address. 
            
    @returns BADADDR if none exists.

ida_bytes.print_strlit_type(strtype: int, flags: int = 0) -> "PyObject *"
    Get string type information: the string type name (possibly decorated with hotkey markers), and the tooltip.
    
    @param strtype: the string type
    @param flags: or'ed PSTF_* constants
    @returns length of generated text

ida_bytes.put_byte(ea: ida_idaapi.ea_t, x: "uint64") -> bool
    Set value of one byte of the program. This function modifies the database. If the debugger is active then the debugged process memory is patched too. 
            
    @param ea: linear address
    @param x: byte value
    @returns true if the database has been modified

ida_bytes.put_bytes(ea: ida_idaapi.ea_t, buf: "void const *") -> None
    Modify the specified number of bytes of the program. This function does not save the original values of bytes. See also patch_bytes(). 
            
    @param ea: linear address
    @param buf: buffer with new values of bytes

ida_bytes.put_dword(ea: ida_idaapi.ea_t, x: "uint64") -> None
    Set value of one dword of the program. This function takes into account order of bytes specified in idainfo::is_be() This function works for wide byte processors too. 
            
    @param ea: linear address
    @param x: dword value

ida_bytes.put_qword(ea: ida_idaapi.ea_t, x: "uint64") -> None
    Set value of one qword (8 bytes) of the program. This function takes into account order of bytes specified in idainfo::is_be() This function DOESN'T works for wide byte processors. 
            
    @param ea: linear address
    @param x: qword value

ida_bytes.put_word(ea: ida_idaapi.ea_t, x: "uint64") -> None
    Set value of one word of the program. This function takes into account order of bytes specified in idainfo::is_be() This function works for wide byte processors too. 
            

ida_bytes.qword_flag() -> "flags64_t"
    Get a flags64_t representing a quad word.

ida_bytes.register_custom_data_format(df)
    Registers a custom data format with a given data type.
    
    @param df: an instance of data_format_t
    @return:
        < 0 if failed to register
        > 0 data format id

ida_bytes.register_custom_data_type(dt)
    Registers a custom data type.
    
    @param dt: an instance of the data_type_t class
    @return:
        < 0 if failed to register
        > 0 data type id

ida_bytes.register_data_types_and_formats(formats)
    Registers multiple data types and formats at once.
    To register one type/format at a time use register_custom_data_type/register_custom_data_format
    
    It employs a special table of types and formats described below:
    
    The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
    If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
    many_formats = [
      (pascal_data_type(), pascal_data_format()),
      (simplevm_data_type(), simplevm_data_format()),
      (makedword_data_format(),),
      (simplevm_data_format(),)
    ]
    The first two tuples describe data types and their associated formats.
    The last two tuples describe two data formats to be used with built-in data types.
    The data format may be attached to several data types. The id of the
    data format is stored in the first data_format_t object. For example:
    assert many_formats[1][1] != -1
    assert many_formats[2][0] != -1
    assert many_formats[3][0] == -1

ida_bytes.register_data_types_and_formats.__reg_format(df, dtid)

ida_bytes.register_data_types_and_formats.__reg_type(dt)

ida_bytes.revert_byte(ea: ida_idaapi.ea_t) -> bool
    Revert patched byte 
            
    @retval true: byte was patched before and reverted now

ida_bytes.seg_flag() -> "flags64_t"
    see FF_opbits

ida_bytes.set_cmt(ea: ida_idaapi.ea_t, comm: str, rptble: bool) -> bool
    Set an indented comment. 
            
    @param ea: linear address
    @param comm: comment string
    * nullptr: do nothing (return 0)
    * "" : delete comment
    @param rptble: is repeatable?
    @returns success

ida_bytes.set_forced_operand(ea: ida_idaapi.ea_t, n: int, op: str) -> bool
    Set forced operand. 
            
    @param ea: linear address
    @param n: 0..UA_MAXOP-1 operand number
    @param op: text of operand
    * nullptr: do nothing (return 0)
    * "" : delete forced operand
    @returns success

ida_bytes.set_immd(ea: ida_idaapi.ea_t) -> bool
    Set 'has immediate operand' flag. Returns true if the FF_IMMD bit was not set and now is set 
            

ida_bytes.set_lzero(ea: ida_idaapi.ea_t, n: int) -> bool
    Set toggle lzero bit. This function changes the display of leading zeroes for the specified operand. If the default is not to display leading zeroes, this function will display them and vice versa. 
            
    @param ea: the item (insn/data) address
    @param n: the operand number (0-first operand, 1-other operands)
    @returns success

ida_bytes.set_manual_insn(ea: ida_idaapi.ea_t, manual_insn: str) -> None
    Set manual instruction string. 
            
    @param ea: linear address of the instruction or data item
    @param manual_insn: "" - delete manual string. nullptr - do nothing

ida_bytes.set_op_type(ea: ida_idaapi.ea_t, type: "flags64_t", n: int) -> bool
    (internal function) change representation of operand(s). 
            
    @param ea: linear address
    @param type: new flag value (should be obtained from char_flag(), num_flag() and similar functions)
    @param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    @retval 1: ok
    @retval 0: failed (applied to a tail byte)

ida_bytes.set_opinfo(ea: ida_idaapi.ea_t, n: int, flag: "flags64_t", ti: "opinfo_t", suppress_events: bool = False) -> bool
    Set additional information about an operand representation. This function is a low level one. Only the kernel should use it. 
            
    @param ea: linear address of the item
    @param n: number of operand, 0 or 1 (see the note below)
    @param flag: flags of the item
    @param ti: additional representation information
    @param suppress_events: do not generate changing_op_type and op_type_changed events
    @returns success

ida_bytes.stkvar_flag() -> "flags64_t"
    see FF_opbits

ida_bytes.strlit_flag() -> "flags64_t"
    Get a flags64_t representing a string literal.

ida_bytes.stroff_flag() -> "flags64_t"
    see FF_opbits

ida_bytes.stru_flag() -> "flags64_t"
    Get a flags64_t representing a struct.

ida_bytes.tbyte_flag() -> "flags64_t"
    Get a flags64_t representing a tbyte.

ida_bytes.toggle_bnot(ea: ida_idaapi.ea_t, n: int) -> bool
    Toggle binary negation of operand. also see is_bnot()

ida_bytes.toggle_lzero(ea: ida_idaapi.ea_t, n: int) -> bool
    Toggle lzero bit. 
            
    @param ea: the item (insn/data) address
    @param n: the operand number (0-first operand, 1-other operands)
    @returns success

ida_bytes.toggle_sign(ea: ida_idaapi.ea_t, n: int) -> bool
    Toggle sign of n-th operand. allowed values of n: 0-first operand, 1-other operands 
            

ida_bytes.unregister_custom_data_format(dfid)
    Unregisters a custom data format
    
    @param dfid: data format id
    @return: Boolean

ida_bytes.unregister_custom_data_type(dtid)
    Unregisters a custom data type.
    
    @param dtid: the data type id
    @return: Boolean

ida_bytes.unregister_data_types_and_formats(formats)
    As opposed to register_data_types_and_formats(), this function
    unregisters multiple data types and formats at once.

ida_bytes.unregister_data_types_and_formats.__unreg_format(df, dtid)

ida_bytes.unregister_data_types_and_formats.__unreg_type(dt)

ida_bytes.update_hidden_range(ha: "hidden_range_t") -> bool
    Update hidden range information in the database. You cannot use this function to change the range boundaries 
            
    @param ha: range to update
    @returns success

ida_bytes.use_mapping(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Translate address according to current mappings. 
            
    @param ea: address to translate
    @returns translated address

ida_bytes.visit_patched_bytes(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, callable)
    Enumerates patched bytes in the given range and invokes a callable
    
    @param ea1: start address
    @param ea2: end address
    @param callable: a Python callable with the following prototype:
                     callable(ea, fpos, org_val, patch_val).
                     If the callable returns non-zero then that value will be
                     returned to the caller and the enumeration will be
                     interrupted.
    @return: Zero if the enumeration was successful or the return
             value of the callback if enumeration was interrupted.

ida_bytes.word_flag() -> "flags64_t"
    Get a flags64_t representing a word.

ida_bytes.yword_flag() -> "flags64_t"
    Get a flags64_t representing a ymm word.

ida_bytes.zword_flag() -> "flags64_t"
    Get a flags64_t representing a zmm word.

ida_dbg
    Contains functions to control the debugging of a process.
    
    See Debugger functions for a complete explanation of these functions.
    These functions are inlined for the kernel. They are not inlined for the user-interfaces. 
        

ida_dbg.BKPT_ACTIVE
    active?

ida_dbg.BKPT_BADBPT
    failed to write the bpt to the process memory (at least one location)

ida_dbg.BKPT_CNDREADY
    condition has been compiled

ida_dbg.BKPT_FAKEPEND
    fake pending bpt: it is inactive but another bpt of the same type is active at the same address(es) 
            

ida_dbg.BKPT_LISTBPT
    include in bpt list (user-defined bpt)

ida_dbg.BKPT_PAGE
    written to the process as a page bpt. Available only after writing the bpt to the process. 
            

ida_dbg.BKPT_PARTIAL
    partially active? (some locations were not written yet)

ida_dbg.BKPT_TRACE
    trace bpt; should not be deleted when the process gets suspended

ida_dbg.BPLT_ABS
    absolute address: ea

ida_dbg.BPLT_REL
    relative address: module_path, offset

ida_dbg.BPLT_SRC
    source level: filename, lineno

ida_dbg.BPLT_SYM
    symbolic: symbol_name, offset

ida_dbg.BPTCK_ACT
    breakpoint is active (written to the process)

ida_dbg.BPTCK_NO
    breakpoint is disabled

ida_dbg.BPTCK_NONE
    breakpoint does not exist

ida_dbg.BPTCK_YES
    breakpoint is enabled

ida_dbg.BPTEV_ADDED
    Breakpoint has been added.

ida_dbg.BPTEV_CHANGED
    Breakpoint has been modified.

ida_dbg.BPTEV_REMOVED
    Breakpoint has been removed.

ida_dbg.BPT_BRK
    suspend execution upon hit

ida_dbg.BPT_ELANG_SHIFT
    index of the extlang (scripting language) of the condition

ida_dbg.BPT_ENABLED
    enabled?

ida_dbg.BPT_LOWCND
    condition is calculated at low level (on the server side)

ida_dbg.BPT_TRACE
    add trace information upon hit

ida_dbg.BPT_TRACEON
    enable tracing when the breakpoint is reached

ida_dbg.BPT_TRACE_BBLK
    basic block tracing

ida_dbg.BPT_TRACE_FUNC
    function tracing

ida_dbg.BPT_TRACE_INSN
    instruction tracing

ida_dbg.BPT_TRACE_TYPES
    trace insns, functions, and basic blocks. if any of BPT_TRACE_TYPES bits are set but BPT_TRACEON is clear, then turn off tracing for the specified trace types 
            

ida_dbg.BPT_UPDMEM
    refresh the memory layout and contents before evaluating bpt condition

ida_dbg.BT_LOG_INSTS
    specific options for basic block tracing (see set_bblk_trace_options())
    
    log all instructions in the current basic block 
            

ida_dbg.DBGINV_ALL
    invalidate everything

ida_dbg.DBGINV_MEMCFG
    invalidate cached process segmentation

ida_dbg.DBGINV_MEMORY
    invalidate cached memory contents

ida_dbg.DBGINV_NONE
    invalidate nothing

ida_dbg.DBGINV_REDRAW
    refresh the screen

ida_dbg.DBGINV_REGS
    invalidate cached register values

ida_dbg.DBG_Hooks

ida_dbg.DBG_Hooks.__disown__(self)

ida_dbg.DBG_Hooks.__init__(self, _flags: int = 0, _hkcb_flags: int = 1)

ida_dbg.DBG_Hooks.dbg_bpt(self, tid: "thid_t", bptea: ida_idaapi.ea_t) -> int
    A user defined breakpoint was reached. 
              
    @param tid: (thid_t)
    @param bptea: (::ea_t)

ida_dbg.DBG_Hooks.dbg_bpt_changed(self, bptev_code: int, bpt: "bpt_t") -> None
    Breakpoint has been changed. 
              
    @param bptev_code: (int) Breakpoint modification events
    @param bpt: (bpt_t *)

ida_dbg.DBG_Hooks.dbg_exception(self, pid: "pid_t", tid: "thid_t", ea: ida_idaapi.ea_t, exc_code: int, exc_can_cont: bool, exc_ea: ida_idaapi.ea_t, exc_info: str) -> int

ida_dbg.DBG_Hooks.dbg_finished_loading_bpts(self) -> None
    Finished loading breakpoint info from idb.

ida_dbg.DBG_Hooks.dbg_information(self, pid: "pid_t", tid: "thid_t", ea: ida_idaapi.ea_t, info: str) -> None

ida_dbg.DBG_Hooks.dbg_library_load(self, pid: "pid_t", tid: "thid_t", ea: ida_idaapi.ea_t, modinfo_name: str, modinfo_base: ida_idaapi.ea_t, modinfo_size: "asize_t") -> None

ida_dbg.DBG_Hooks.dbg_library_unload(self, pid: "pid_t", tid: "thid_t", ea: ida_idaapi.ea_t, info: str) -> None

ida_dbg.DBG_Hooks.dbg_process_attach(self, pid: "pid_t", tid: "thid_t", ea: ida_idaapi.ea_t, modinfo_name: str, modinfo_base: ida_idaapi.ea_t, modinfo_size: "asize_t") -> None

ida_dbg.DBG_Hooks.dbg_process_detach(self, pid: "pid_t", tid: "thid_t", ea: ida_idaapi.ea_t) -> None

ida_dbg.DBG_Hooks.dbg_process_exit(self, pid: "pid_t", tid: "thid_t", ea: ida_idaapi.ea_t, exit_code: int) -> None

ida_dbg.DBG_Hooks.dbg_process_start(self, pid: "pid_t", tid: "thid_t", ea: ida_idaapi.ea_t, modinfo_name: str, modinfo_base: ida_idaapi.ea_t, modinfo_size: "asize_t") -> None

ida_dbg.DBG_Hooks.dbg_request_error(self, failed_command: int, failed_dbg_notification: int) -> None
    An error occurred during the processing of a request. 
              
    @param failed_command: (ui_notification_t)
    @param failed_dbg_notification: (dbg_notification_t)

ida_dbg.DBG_Hooks.dbg_run_to(self, pid: "pid_t", tid: "thid_t", ea: ida_idaapi.ea_t) -> None

ida_dbg.DBG_Hooks.dbg_started_loading_bpts(self) -> None
    Started loading breakpoint info from idb.

ida_dbg.DBG_Hooks.dbg_step_into(self) -> None

ida_dbg.DBG_Hooks.dbg_step_over(self) -> None

ida_dbg.DBG_Hooks.dbg_step_until_ret(self) -> None

ida_dbg.DBG_Hooks.dbg_suspend_process(self) -> None
    The process is now suspended. 
              

ida_dbg.DBG_Hooks.dbg_thread_exit(self, pid: "pid_t", tid: "thid_t", ea: ida_idaapi.ea_t, exit_code: int) -> None

ida_dbg.DBG_Hooks.dbg_thread_start(self, pid: "pid_t", tid: "thid_t", ea: ida_idaapi.ea_t) -> None

ida_dbg.DBG_Hooks.dbg_trace(self, tid: "thid_t", ip: ida_idaapi.ea_t) -> int
    A step occurred (one instruction was executed). This event notification is only generated if step tracing is enabled. 
              
    @param tid: (thid_t) thread ID
    @param ip: (::ea_t) current instruction pointer. usually points after the executed instruction
    @retval 1: do not log this trace event
    @retval 0: log it

ida_dbg.DBG_Hooks.hook(self) -> bool

ida_dbg.DBG_Hooks.unhook(self) -> bool

ida_dbg.DEC_ERROR
    error

ida_dbg.DEC_NOTASK
    process does not exist

ida_dbg.DEC_TIMEOUT
    timeout

ida_dbg.DOPT_BPT_MSGS
    log breakpoints

ida_dbg.DOPT_DISABLE_ASLR
    disable ASLR

ida_dbg.DOPT_END_BPT
    evaluate event condition on process end

ida_dbg.DOPT_ENTRY_BPT
    break on program entry point

ida_dbg.DOPT_EXCDLG
    exception dialogs:

ida_dbg.DOPT_FAST_STEP
    prevent debugger memory refreshes when single-stepping

ida_dbg.DOPT_INFO_BPT
    break on debugging information

ida_dbg.DOPT_INFO_MSGS
    log debugging info events

ida_dbg.DOPT_LIB_BPT
    break on library load/unload

ida_dbg.DOPT_LIB_MSGS
    log library loads/unloads

ida_dbg.DOPT_LOAD_DINFO
    automatically load debug files (pdb)

ida_dbg.DOPT_REAL_MEMORY
    do not hide breakpoint instructions

ida_dbg.DOPT_REDO_STACK
    reconstruct the stack

ida_dbg.DOPT_SEGM_MSGS
    log debugger segments modifications

ida_dbg.DOPT_START_BPT
    break on process start

ida_dbg.DOPT_TEMP_HWBPT
    when possible use hardware bpts for temp bpts

ida_dbg.DOPT_THREAD_BPT
    break on thread start/exit

ida_dbg.DOPT_THREAD_MSGS
    log thread starts/exits

ida_dbg.DSTATE_NOTASK
    no process is currently debugged

ida_dbg.DSTATE_RUN
    process is running

ida_dbg.DSTATE_SUSP
    process is suspended and will not continue

ida_dbg.EXCDLG_ALWAYS
    always display

ida_dbg.EXCDLG_NEVER
    never display exception dialogs

ida_dbg.EXCDLG_UNKNOWN
    display for unknown exceptions

ida_dbg.FT_LOG_RET
    specific options for function tracing (see set_func_trace_options())
    
    function tracing will log returning instructions 
            

ida_dbg.IT_LOG_SAME_IP
    specific options for instruction tracing (see set_insn_trace_options())
    
    instruction tracing will log new instructions even when IP doesn't change 
            

ida_dbg.MOVBPT_BAD_TYPE
    BPLT_ABS is not supported.

ida_dbg.MOVBPT_DEST_BUSY
    destination location is busy (we already have such a bpt)

ida_dbg.MOVBPT_NOT_FOUND
    source bpt not found

ida_dbg.MOVBPT_OK
    moved ok

ida_dbg.SRCIT_EXPR
    an expression (a+b*c)

ida_dbg.SRCIT_FUNC
    function

ida_dbg.SRCIT_LOCVAR
    a stack, register, or register-relative local variable or parameter

ida_dbg.SRCIT_MODULE
    module

ida_dbg.SRCIT_NONE
    unknown

ida_dbg.SRCIT_STMT
    a statement (if/while/for...)

ida_dbg.SRCIT_STTVAR
    static variable/code

ida_dbg.ST_ALREADY_LOGGED
    step tracing will be disabled when IP is already logged

ida_dbg.ST_DIFFERENTIAL
    tracing: log only new instructions (not previously logged) 
            

ida_dbg.ST_OPTIONS_MASK
    mask of available options, to ensure compatibility with newer IDA versions

ida_dbg.ST_OVER_DEBUG_SEG
    step tracing will be disabled when IP is in a debugger segment

ida_dbg.ST_OVER_LIB_FUNC
    step tracing will be disabled when IP is in a library function

ida_dbg.ST_SKIP_LOOPS
    step tracing will try to skip loops already recorded

ida_dbg.WFNE_ANY
    return the first event (even if it doesn't suspend the process)

ida_dbg.WFNE_CONT
    continue from the suspended state

ida_dbg.WFNE_NOWAIT
    do not wait for any event, immediately return DEC_TIMEOUT (to be used with WFNE_CONT) 
            

ida_dbg.WFNE_SILENT
    1: be silent, 0:display modal boxes if necessary

ida_dbg.WFNE_SUSP
    wait until the process gets suspended

ida_dbg.WFNE_USEC
    timeout is specified in microseconds (minimum non-zero timeout is 40000us) 
            

ida_dbg.add_bpt(*args) -> bool
    This function has the following signatures:
    
        0. add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool
        1. add_bpt(bpt: const bpt_t &) -> bool
    
    # 0: add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool
    
    Add a new breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    
    # 1: add_bpt(bpt: const bpt_t &) -> bool
    
    Add a new breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            

ida_dbg.add_path_mapping(src: str, dst: str) -> None

ida_dbg.add_virt_module(mod: "modinfo_t") -> bool

ida_dbg.attach_process(*args) -> int
    Attach the debugger to a running process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_attach} 
            
    @param pid: PID of the process to attach to. If NO_PROCESS, a dialog box will interactively ask the user for the process to attach to.
    @param event_id: event to trigger upon attaching
    @retval -4: debugger was not inited
    @retval -3: the attaching is not supported
    @retval -2: impossible to find a compatible process
    @retval -1: impossible to attach to the given process (process died, privilege needed, not supported by the debugger plugin, ...)
    @retval 0: the user cancelled the attaching to the process
    @retval 1: the debugger properly attached to the process

ida_dbg.bpt_location_t

ida_dbg.bpt_location_t.__eq__(self, r: "bpt_location_t") -> bool

ida_dbg.bpt_location_t.__ge__(self, r: "bpt_location_t") -> bool

ida_dbg.bpt_location_t.__gt__(self, r: "bpt_location_t") -> bool

ida_dbg.bpt_location_t.__init__(self)

ida_dbg.bpt_location_t.__le__(self, r: "bpt_location_t") -> bool

ida_dbg.bpt_location_t.__lt__(self, r: "bpt_location_t") -> bool

ida_dbg.bpt_location_t.__ne__(self, r: "bpt_location_t") -> bool

ida_dbg.bpt_location_t.compare(self, r: "bpt_location_t") -> int
    Lexically compare two breakpoint locations. Bpt locations are first compared based on type (i.e. BPLT_ABS < BPLT_REL). BPLT_ABS locations are compared based on their ea values. For all other location types, locations are first compared based on their string (path/filename/symbol), then their offset/lineno. 
            

ida_dbg.bpt_location_t.ea(self) -> ida_idaapi.ea_t
    Get address (BPLT_ABS)

ida_dbg.bpt_location_t.is_empty_path(self) -> bool
    No path/filename specified? (BPLT_REL, BPLT_SRC)

ida_dbg.bpt_location_t.lineno(self) -> int
    Get line number (BPLT_SRC)

ida_dbg.bpt_location_t.offset(self) -> int
    Get offset (BPLT_REL, BPLT_SYM)

ida_dbg.bpt_location_t.path(self) -> str
    Get path/filename (BPLT_REL, BPLT_SRC)

ida_dbg.bpt_location_t.set_abs_bpt(self, a: ida_idaapi.ea_t) -> None
    Specify an absolute address location.

ida_dbg.bpt_location_t.set_rel_bpt(self, mod: str, _offset: int) -> None
    Specify a relative address location.

ida_dbg.bpt_location_t.set_src_bpt(self, fn: str, _lineno: int) -> None
    Specify a source level location.

ida_dbg.bpt_location_t.set_sym_bpt(self, _symbol: str, _offset: int = 0) -> None
    Specify a symbolic location.

ida_dbg.bpt_location_t.symbol(self) -> str
    Get symbol name (BPLT_SYM)

ida_dbg.bpt_location_t.type(self) -> "bpt_loctype_t"
    Get bpt type.

ida_dbg.bpt_t

ida_dbg.bpt_t.__init__(self)

ida_dbg.bpt_t.badbpt(self) -> bool
    Failed to write bpt to process memory?

ida_dbg.bpt_t.bptid
    Internal breakpoint id.

ida_dbg.bpt_t.cb
    size of this structure

ida_dbg.bpt_t.cndidx
    Internal number of the condition (<0-none)

ida_dbg.bpt_t.ea
    Address, if known. For BPLT_SRC, index into an internal data struct.

ida_dbg.bpt_t.enabled(self) -> bool
    Is breakpoint enabled?

ida_dbg.bpt_t.flags
    Breakpoint property bits 
            

ida_dbg.bpt_t.get_cnd_elang_idx(self) -> "size_t"

ida_dbg.bpt_t.get_size(self) -> int
    Get bpt size.

ida_dbg.bpt_t.is_absbpt(self) -> bool
    Is absolute address breakpoint?

ida_dbg.bpt_t.is_active(self) -> bool
    Written completely to process?

ida_dbg.bpt_t.is_compiled(self) -> bool
    Condition has been compiled? 
            

ida_dbg.bpt_t.is_hwbpt(self) -> bool
    Is hardware breakpoint?

ida_dbg.bpt_t.is_inactive(self) -> bool
    Not written to process at all?

ida_dbg.bpt_t.is_low_level(self) -> bool
    Is bpt condition calculated at low level?

ida_dbg.bpt_t.is_page_bpt(self) -> bool
    Page breakpoint?

ida_dbg.bpt_t.is_partially_active(self) -> bool
    Written partially to process?

ida_dbg.bpt_t.is_relbpt(self) -> bool
    Is relative address breakpoint?

ida_dbg.bpt_t.is_srcbpt(self) -> bool
    Is source level breakpoint?

ida_dbg.bpt_t.is_symbpt(self) -> bool
    Is symbolic breakpoint?

ida_dbg.bpt_t.is_tracemodebpt(self) -> bool
    Does breakpoint trace anything?

ida_dbg.bpt_t.is_traceoffbpt(self) -> bool
    Is this a tracing breakpoint, and is tracing disabled?

ida_dbg.bpt_t.is_traceonbpt(self) -> bool
    Is this a tracing breakpoint, and is tracing enabled?

ida_dbg.bpt_t.listbpt(self) -> bool
    Include in the bpt list?

ida_dbg.bpt_t.loc
    Location.

ida_dbg.bpt_t.pass_count
    Number of times the breakpoint is hit before stopping (default is 0: stop always) 
            

ida_dbg.bpt_t.pid
    breakpoint process id

ida_dbg.bpt_t.props
    Internal breakpoint properties 
            

ida_dbg.bpt_t.set_abs_bpt(self, a: ida_idaapi.ea_t) -> None
    Set bpt location to an absolute address.

ida_dbg.bpt_t.set_rel_bpt(self, mod: str, o: int) -> None
    Set bpt location to a relative address.

ida_dbg.bpt_t.set_src_bpt(self, fn: str, lineno: int) -> None
    Set bpt location to a source line.

ida_dbg.bpt_t.set_sym_bpt(self, sym: str, o: int) -> None
    Set bpt location to a symbol.

ida_dbg.bpt_t.set_trace_action(self, enable: bool, trace_types: int) -> bool
    Configure tracing options.

ida_dbg.bpt_t.size
    Size of the breakpoint (0 for software breakpoints)

ida_dbg.bpt_t.tid
    breakpoint thread id

ida_dbg.bpt_t.type
    Breakpoint type.

ida_dbg.bpt_vec_t

ida_dbg.bpt_vec_t.__getitem__(self, i: "size_t") -> "bpt_t const &"

ida_dbg.bpt_vec_t.__init__(self, *args)

ida_dbg.bpt_vec_t.__len__(self) -> "size_t"

ida_dbg.bpt_vec_t.__setitem__(self, i: "size_t", v: "bpt_t") -> None

ida_dbg.bpt_vec_t.append(self, x: "bpt_t") -> None

ida_dbg.bpt_vec_t.at(self, _idx: "size_t") -> "bpt_t const &"

ida_dbg.bpt_vec_t.begin(self, *args) -> "qvector< bpt_t >::const_iterator"

ida_dbg.bpt_vec_t.capacity(self) -> "size_t"

ida_dbg.bpt_vec_t.clear(self) -> None

ida_dbg.bpt_vec_t.empty(self) -> bool

ida_dbg.bpt_vec_t.end(self, *args) -> "qvector< bpt_t >::const_iterator"

ida_dbg.bpt_vec_t.erase(self, *args) -> "qvector< bpt_t >::iterator"

ida_dbg.bpt_vec_t.extend(self, x: "bpt_vec_t") -> None

ida_dbg.bpt_vec_t.extract(self) -> "bpt_t *"

ida_dbg.bpt_vec_t.grow(self, *args) -> None

ida_dbg.bpt_vec_t.inject(self, s: "bpt_t", len: "size_t") -> None

ida_dbg.bpt_vec_t.insert(self, it: "bpt_t", x: "bpt_t") -> "qvector< bpt_t >::iterator"

ida_dbg.bpt_vec_t.pop_back(self) -> None

ida_dbg.bpt_vec_t.push_back(self, *args) -> "bpt_t &"

ida_dbg.bpt_vec_t.qclear(self) -> None

ida_dbg.bpt_vec_t.reserve(self, cnt: "size_t") -> None

ida_dbg.bpt_vec_t.resize(self, *args) -> None

ida_dbg.bpt_vec_t.size(self) -> "size_t"

ida_dbg.bpt_vec_t.swap(self, r: "bpt_vec_t") -> None

ida_dbg.bpt_vec_t.truncate(self) -> None

ida_dbg.bptaddrs_t

ida_dbg.bptaddrs_t.__init__(self)

ida_dbg.bring_debugger_to_front() -> None

ida_dbg.check_bpt(ea: ida_idaapi.ea_t) -> int
    Check the breakpoint at the specified address. 
            
    @returns one of Breakpoint status codes

ida_dbg.choose_trace_file() -> str
    Show the choose trace dialog.

ida_dbg.clear_requests_queue() -> None
    Clear the queue of waiting requests. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.clear_trace() -> None
    Clear all events in the trace buffer. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            

ida_dbg.collect_stack_trace(tid: "thid_t", trace: "call_stack_t") -> bool

ida_dbg.continue_backwards() -> bool
    Continue the execution of the process in the debugger backwards. Can only be used with debuggers that support time-travel debugging. \sq{Type, Synchronous function - available as Request, Notification, none (synchronous function)} 
            

ida_dbg.continue_process() -> bool
    Continue the execution of the process in the debugger. \sq{Type, Synchronous function - available as Request, Notification, none (synchronous function)} 
            

ida_dbg.create_source_viewer(out_ccv: "TWidget **", parent: "TWidget *", custview: "TWidget *", sf: "source_file_ptr", lines: "strvec_t *", lnnum: int, colnum: int, flags: int) -> "source_view_t *"
    Create a source code view.

ida_dbg.dbg_add_bpt_tev(tid: "thid_t", ea: ida_idaapi.ea_t, bp: ida_idaapi.ea_t) -> bool
    Add a new breakpoint trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @returns false if the operation failed, true otherwise

ida_dbg.dbg_add_call_tev(tid: "thid_t", caller: ida_idaapi.ea_t, callee: ida_idaapi.ea_t) -> None
    Add a new call trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.dbg_add_debug_event(event: "debug_event_t") -> None
    Add a new debug event to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.dbg_add_insn_tev(tid: "thid_t", ea: ida_idaapi.ea_t, save: "save_reg_values_t" = SAVE_DIFF) -> bool
    Add a new instruction trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @returns false if the operation failed, true otherwise

ida_dbg.dbg_add_many_tevs(new_tevs: "tevinforeg_vec_t") -> bool
    Add many new trace elements to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @returns false if the operation failed for any tev_info_t object

ida_dbg.dbg_add_ret_tev(tid: "thid_t", ret_insn: ida_idaapi.ea_t, return_to: ida_idaapi.ea_t) -> None
    Add a new return trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.dbg_add_tev(type: "tev_type_t", tid: "thid_t", address: ida_idaapi.ea_t) -> None
    Add a new trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.dbg_add_thread(tid: "thid_t") -> None
    Add a thread to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.dbg_bin_search(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, data: "compiled_binpat_vec_t const &", srch_flags: int) -> str

ida_dbg.dbg_bpt
    A user defined breakpoint was reached. 
              

ida_dbg.dbg_bpt_changed
    Breakpoint has been changed. 
              

ida_dbg.dbg_can_query()
    This function can be used to check if the debugger can be queried:
      - debugger is loaded
      - process is suspended
      - process is not suspended but can take requests. In this case some requests like
        memory read/write, bpt management succeed and register querying will fail.
        Check if idaapi.get_process_state() < 0 to tell if the process is suspended
    
    @return: Boolean

ida_dbg.dbg_del_thread(tid: "thid_t") -> None
    Delete a thread from the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.dbg_finished_loading_bpts
    Finished loading breakpoint info from idb.

ida_dbg.dbg_is_loaded()
    Checks if a debugger is loaded
    
    @return: Boolean

ida_dbg.dbg_last
    The last debugger notification code.

ida_dbg.dbg_request_error
    An error occurred during the processing of a request. 
              

ida_dbg.dbg_started_loading_bpts
    Started loading breakpoint info from idb.

ida_dbg.dbg_suspend_process
    The process is now suspended. 
              

ida_dbg.dbg_trace
    A step occurred (one instruction was executed). This event notification is only generated if step tracing is enabled. 
              

ida_dbg.define_exception(code: "uint", name: str, desc: str, flags: int) -> str
    Convenience function: define new exception code. 
            
    @param code: exception code (cannot be 0)
    @param name: exception name (cannot be empty or nullptr)
    @param desc: exception description (maybe nullptr)
    @param flags: combination of Exception info flags
    @returns failure message or nullptr. You must call store_exceptions() if this function succeeds

ida_dbg.del_bpt(*args) -> bool
    This function has the following signatures:
    
        0. del_bpt(ea: ida_idaapi.ea_t) -> bool
        1. del_bpt(bptloc: const bpt_location_t &) -> bool
    
    # 0: del_bpt(ea: ida_idaapi.ea_t) -> bool
    
    Delete an existing breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    
    # 1: del_bpt(bptloc: const bpt_location_t &) -> bool
    
    Delete an existing breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            

ida_dbg.del_bptgrp(name: str) -> bool
    Delete a folder, bpt that were part of this folder are moved to the root folder \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param name: full path to the folder to be deleted
    @returns success

ida_dbg.del_virt_module(base: "ea_t const") -> bool

ida_dbg.detach_process() -> bool
    Detach the debugger from the debugged process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_detach} 
            

ida_dbg.diff_trace_file(NONNULL_filename: str) -> bool
    Show difference between the current trace and the one from 'filename'.

ida_dbg.disable_bblk_trace() -> bool

ida_dbg.disable_bpt(*args) -> bool

ida_dbg.disable_func_trace() -> bool

ida_dbg.disable_insn_trace() -> bool

ida_dbg.disable_step_trace() -> bool

ida_dbg.edit_manual_regions() -> None

ida_dbg.enable_bblk_trace(enable: bool = True) -> bool

ida_dbg.enable_bpt(*args) -> bool

ida_dbg.enable_bptgrp(bptgrp_name: str, enable: bool = True) -> int
    Enable (or disable) all bpts in a folder \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param bptgrp_name: absolute path to the folder
    @param enable: by default true, enable bpts, false disable bpts
    @retval -1: an error occured
    @retval 0: no changes
    @retval >0: nubmers of bpts udpated

ida_dbg.enable_func_trace(enable: bool = True) -> bool

ida_dbg.enable_insn_trace(enable: bool = True) -> bool

ida_dbg.enable_manual_regions(enable: bool) -> None

ida_dbg.enable_step_trace(enable: int = 1) -> bool

ida_dbg.eval_ctx_t

ida_dbg.eval_ctx_t.__init__(self, _ea: ida_idaapi.ea_t)

ida_dbg.exist_bpt(ea: ida_idaapi.ea_t) -> bool
    Does a breakpoint exist at the given location?

ida_dbg.exit_process() -> bool
    Terminate the debugging of the current process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_exit} 
            

ida_dbg.find_bpt(bptloc: "bpt_location_t", bpt: "bpt_t") -> bool
    Find a breakpoint by location. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    @param bptloc: Breakpoint location
    @param bpt: bpt is filled if the breakpoint was found

ida_dbg.get_bblk_trace_options() -> int
    Get current basic block tracing options. Also see BT_LOG_INSTS \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.get_bpt(ea: ida_idaapi.ea_t, bpt: "bpt_t") -> bool
    Get the characteristics of a breakpoint. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param ea: any address in the breakpoint range
    @param bpt: if not nullptr, is filled with the characteristics.
    @returns false if no breakpoint exists

ida_dbg.get_bpt_group(bptloc: "bpt_location_t") -> str
    Retrieve the absolute path to the folder of the bpt based on the bpt_location find_bpt is called to retrieve the bpt \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param bptloc: bptlocation of the bpt
    @returns success
    @retval true: breakpoint correclty moved to the directory

ida_dbg.get_bpt_qty() -> int
    Get number of breakpoints. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.get_bpt_tev_ea(n: int) -> ida_idaapi.ea_t
    Get the address associated to a read, read/write or execution trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    @returns BADADDR if not a read, read/write or execution trace event.

ida_dbg.get_bptloc_string(i: int) -> str

ida_dbg.get_call_tev_callee(n: int) -> ida_idaapi.ea_t
    Get the called function from a function call trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    @returns BADADDR if not a function call event.

ida_dbg.get_current_source_file() -> str

ida_dbg.get_current_source_line() -> int

ida_dbg.get_current_thread() -> "thid_t"
    Get current thread ID. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.get_dbg_byte(ea: ida_idaapi.ea_t) -> "uint32 *"
    Get one byte of the debugged process memory. 
            
    @param ea: linear address
    @returns success
    @retval true: success
    @retval false: address inaccessible or debugger not running

ida_dbg.get_dbg_memory_info(ranges: "meminfo_vec_t") -> int

ida_dbg.get_dbg_reg_info(regname: str, ri: "register_info_t") -> bool
    Get register information \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.get_debug_event() -> "debug_event_t const *"
    Get the current debugger event.

ida_dbg.get_debugger_event_cond() -> str

ida_dbg.get_first_module(modinfo: "modinfo_t") -> bool

ida_dbg.get_func_trace_options() -> int
    Get current function tracing options. Also see FT_LOG_RET \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.get_global_var(prov: "srcinfo_provider_t *", ea: ida_idaapi.ea_t, name: str, out: "source_item_ptr *") -> bool

ida_dbg.get_grp_bpts(bpts: "bpt_vec_t", grp_name: str) -> "ssize_t"
    Retrieve a copy the bpts stored in a folder \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param bpts: : pointer to a vector where the copy of bpts are stored
    @param grp_name: absolute path to the folder
    @returns number of bpts present in the vector

ida_dbg.get_insn_tev_reg_mem(n: int, memmap: "memreg_infos_t") -> bool
    Read the memory pointed by register values from an instruction trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    @param memmap: result
    @returns false if not an instruction event or no memory is available

ida_dbg.get_insn_tev_reg_result(n: int, regname: str, regval: "regval_t") -> bool
    Read the resulting register value from an instruction trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    @param regname: name of desired register
    @param regval: result
    @returns false if not an instruction trace event or register wasn't modified.

ida_dbg.get_insn_tev_reg_val(n: int, regname: str, regval: "regval_t") -> bool
    Read a register value from an instruction trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    @param regname: name of desired register
    @param regval: result
    @returns false if not an instruction event.

ida_dbg.get_insn_trace_options() -> int
    Get current instruction tracing options. Also see IT_LOG_SAME_IP \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.get_ip_val() -> "uint64 *"
    Get value of the IP (program counter) register for the current thread. Requires a suspended debugger. 
            

ida_dbg.get_local_var(prov: "srcinfo_provider_t *", ea: ida_idaapi.ea_t, name: str, out: "source_item_ptr *") -> bool

ida_dbg.get_local_vars(prov: "srcinfo_provider_t *", ea: ida_idaapi.ea_t, out: "source_items_t *") -> bool

ida_dbg.get_manual_regions(*args)
    Returns the manual memory regions
    
    This function has the following signatures:
    
        1. get_manual_regions() -> List[Tuple(ida_idaapi.ea_t, ida_idaapi.ea_t, str, str, ida_idaapi.ea_t, int, int)]
           Where each tuple holds (start_ea, end_ea, name, sclass, sbase, bitness, perm)
        2. get_manual_regions(storage: meminfo_vec_t) -> None

ida_dbg.get_module_info(ea: ida_idaapi.ea_t, modinfo: "modinfo_t") -> bool

ida_dbg.get_next_module(modinfo: "modinfo_t") -> bool

ida_dbg.get_process_options() -> "qstring *, qstring *, qstring *, qstring *, qstring *, int *"
    Get process options. Any of the arguments may be nullptr 
            

ida_dbg.get_process_options2() -> "qstring *, qstring *, launch_env_t *, qstring *, qstring *, qstring *, int *"

ida_dbg.get_process_state() -> int
    Return the state of the currently debugged process. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @returns one of Debugged process states

ida_dbg.get_processes(proclist: "procinfo_vec_t") -> "ssize_t"
    Take a snapshot of running processes and return their description. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param proclist: array with information about each running process
    @returns number of processes or -1 on error

ida_dbg.get_reg_val(*args)
    Get a register value.
    
    This function has the following signatures:
    
        1. get_reg_val(name: str) -> Union[int, float, bytes]
        2. get_reg_val(name: str, regval: regval_t) -> bool
    
    The first (and most user-friendly) form will return
    a value whose type is related to the register type.
    I.e., either an integer, a float or, in the case of large
    vector registers, a bytes sequence.
    
    @param name the register name
    @return the register value (1st form)

ida_dbg.get_reg_vals(tid: int, clsmask: int = -1) -> "ida_idd.regvals_t"
    Fetch live registers values for the thread
    
    @param tid The ID of the thread to read registers for
    @param clsmask An OR'ed mask of register classes to
           read values for (can be used to speed up the
           retrieval process)
    
    @return: a list of register values (empty if an error occurs)

ida_dbg.get_ret_tev_return(n: int) -> ida_idaapi.ea_t
    Get the return address from a function return trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    @returns BADADDR if not a function return event.

ida_dbg.get_running_notification() -> "dbg_notification_t"
    Get the notification associated (if any) with the current running request. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @returns dbg_null if no running request

ida_dbg.get_running_request() -> "ui_notification_t"
    Get the current running request. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @returns ui_null if no running request

ida_dbg.get_sp_val() -> "uint64 *"
    Get value of the SP register for the current thread. Requires a suspended debugger. 
            

ida_dbg.get_srcinfo_provider(name: str) -> "srcinfo_provider_t *"

ida_dbg.get_step_trace_options() -> int
    Get current step tracing options. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @returns Step trace options

ida_dbg.get_tev_ea(n: int) -> ida_idaapi.ea_t

ida_dbg.get_tev_event(n: int, d: "debug_event_t") -> bool
    Get the corresponding debug event, if any, for the specified tev object. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    @param d: result
    @returns false if the tev_t object doesn't have any associated debug event, true otherwise, with the debug event in "d".

ida_dbg.get_tev_info(n: int, tev_info: "tev_info_t") -> bool
    Get main information about a trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    @param tev_info: result
    @returns success

ida_dbg.get_tev_memory_info(n: int, mi: "meminfo_vec_t") -> bool
    Get the memory layout, if any, for the specified tev object. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    @param mi: result
    @returns false if the tev_t object is not of type tev_mem, true otherwise, with the new memory layout in "mi".

ida_dbg.get_tev_qty() -> int
    Get number of trace events available in trace buffer. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.get_tev_reg_mem(tev, idx)

ida_dbg.get_tev_reg_mem_ea(tev, idx)

ida_dbg.get_tev_reg_mem_qty(tev)

ida_dbg.get_tev_reg_val(tev, reg)

ida_dbg.get_tev_tid(n: int) -> int

ida_dbg.get_tev_type(n: int) -> int

ida_dbg.get_thread_qty() -> int
    Get number of threads. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.get_trace_base_address() -> ida_idaapi.ea_t
    Get the base address of the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @returns the base address of the currently loaded trace

ida_dbg.get_trace_dynamic_register_set(idaregs: "dynamic_register_set_t *") -> None
    Get dynamic register set of current trace.

ida_dbg.get_trace_file_desc(filename: str) -> str
    Get the file header of the specified trace file.

ida_dbg.get_trace_platform() -> str
    Get platform name of current trace.

ida_dbg.getn_bpt(n: int, bpt: "bpt_t") -> bool
    Get the characteristics of a breakpoint. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of breakpoint, is in range 0..get_bpt_qty()-1
    @param bpt: filled with the characteristics.
    @returns false if no breakpoint exists

ida_dbg.getn_thread(n: int) -> "thid_t"
    Get the ID of a thread. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of thread, is in range 0..get_thread_qty()-1
    @returns NO_THREAD if the thread doesn't exist.

ida_dbg.getn_thread_name(n: int) -> str
    Get the NAME of a thread \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param n: number of thread, is in range 0..get_thread_qty()-1 or -1 for the current thread
    @returns thread name or nullptr if the thread doesn't exist.

ida_dbg.graph_trace() -> bool
    Show the trace callgraph.

ida_dbg.handle_debug_event(ev: "debug_event_t", rqflags: int) -> int

ida_dbg.hide_all_bpts() -> int

ida_dbg.internal_get_sreg_base(tid: int, sreg_value: int)
    Get the sreg base, for the given thread.
    
    @param tid: the thread ID
    @param sreg_value: the sreg value
    @return: The sreg base, or BADADDR on failure.

ida_dbg.internal_ioctl(fn: int, buf: "void const *", poutbuf: "void **", poutsize: "ssize_t *") -> int

ida_dbg.invalidate_dbg_state(dbginv: int) -> int
    Invalidate cached debugger information. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param dbginv: Debugged process invalidation options
    @returns current debugger state (one of Debugged process states)

ida_dbg.invalidate_dbgmem_config() -> None
    Invalidate the debugged process memory configuration. Call this function if the debugged process might have changed its memory layout (allocated more memory, for example) 
            

ida_dbg.invalidate_dbgmem_contents(ea: ida_idaapi.ea_t, size: "asize_t") -> None
    Invalidate the debugged process memory contents. Call this function each time the process has been stopped or the process memory is modified. If ea == BADADDR, then the whole memory contents will be invalidated 
            

ida_dbg.is_bblk_trace_enabled() -> bool

ida_dbg.is_debugger_busy() -> bool
    Is the debugger busy?. Some debuggers do not accept any commands while the debugged application is running. For such a debugger, it is unsafe to do anything with the database (even simple queries like get_byte may lead to undesired consequences). Returns: true if the debugged application is running under such a debugger 
            

ida_dbg.is_debugger_memory(ea: ida_idaapi.ea_t) -> bool
    Is the address mapped to debugger memory?

ida_dbg.is_debugger_on() -> bool
    Is the debugger currently running?

ida_dbg.is_func_trace_enabled() -> bool
    Get current state of functions tracing. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.is_insn_trace_enabled() -> bool
    Get current state of instruction tracing. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.is_reg_custom(regname: str) -> bool
    Does a register contain a value of a custom data type? \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.is_reg_float(regname: str) -> bool
    Does a register contain a floating point value? \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.is_reg_integer(regname: str) -> bool
    Does a register contain an integer value? \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.is_request_running() -> bool
    Is a request currently running?

ida_dbg.is_step_trace_enabled() -> bool
    Get current state of step tracing. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.is_valid_dstate(state: int) -> bool

ida_dbg.is_valid_trace_file(filename: str) -> bool
    Is the specified file a valid trace file for the current database?

ida_dbg.list_bptgrps() -> List[str]
    Retrieve the list of absolute path of all folders of bpt dirtree.
    Synchronous function, Notification, none (synchronous function)

ida_dbg.load_debugger(dbgname: str, use_remote: bool) -> bool

ida_dbg.load_trace_file(filename: str) -> str
    Load a recorded trace file in the 'Tracing' window. If the call succeeds and 'buf' is not null, the description of the trace stored in the binary trace file will be returned in 'buf' 
            

ida_dbg.memreg_info_t

ida_dbg.memreg_info_t.__init__(self)

ida_dbg.memreg_info_t.get_bytes(self) -> "PyObject *"

ida_dbg.memreg_infos_t

ida_dbg.memreg_infos_t.__getitem__(self, i: "size_t") -> "memreg_info_t const &"

ida_dbg.memreg_infos_t.__init__(self, *args)

ida_dbg.memreg_infos_t.__len__(self) -> "size_t"

ida_dbg.memreg_infos_t.__setitem__(self, i: "size_t", v: "memreg_info_t") -> None

ida_dbg.memreg_infos_t.append(self, x: "memreg_info_t") -> None

ida_dbg.memreg_infos_t.at(self, _idx: "size_t") -> "memreg_info_t const &"

ida_dbg.memreg_infos_t.begin(self, *args) -> "qvector< memreg_info_t >::const_iterator"

ida_dbg.memreg_infos_t.capacity(self) -> "size_t"

ida_dbg.memreg_infos_t.clear(self) -> None

ida_dbg.memreg_infos_t.empty(self) -> bool

ida_dbg.memreg_infos_t.end(self, *args) -> "qvector< memreg_info_t >::const_iterator"

ida_dbg.memreg_infos_t.erase(self, *args) -> "qvector< memreg_info_t >::iterator"

ida_dbg.memreg_infos_t.extend(self, x: "memreg_infos_t") -> None

ida_dbg.memreg_infos_t.extract(self) -> "memreg_info_t *"

ida_dbg.memreg_infos_t.grow(self, *args) -> None

ida_dbg.memreg_infos_t.inject(self, s: "memreg_info_t", len: "size_t") -> None

ida_dbg.memreg_infos_t.insert(self, it: "memreg_info_t", x: "memreg_info_t") -> "qvector< memreg_info_t >::iterator"

ida_dbg.memreg_infos_t.pop_back(self) -> None

ida_dbg.memreg_infos_t.push_back(self, *args) -> "memreg_info_t &"

ida_dbg.memreg_infos_t.qclear(self) -> None

ida_dbg.memreg_infos_t.reserve(self, cnt: "size_t") -> None

ida_dbg.memreg_infos_t.resize(self, *args) -> None

ida_dbg.memreg_infos_t.size(self) -> "size_t"

ida_dbg.memreg_infos_t.swap(self, r: "memreg_infos_t") -> None

ida_dbg.memreg_infos_t.truncate(self) -> None

ida_dbg.put_dbg_byte(ea: ida_idaapi.ea_t, x: int) -> bool
    Change one byte of the debugged process memory. 
            
    @param ea: linear address
    @param x: byte value
    @returns true if the process memory has been modified

ida_dbg.read_dbg_memory(ea: ida_idaapi.ea_t, buffer: "void *", size: "size_t") -> "ssize_t"

ida_dbg.refresh_debugger_memory()
    Refreshes the debugger memory
    
    @return: Nothing

ida_dbg.rename_bptgrp(old_name: str, new_name: str) -> bool
    Rename a folder of bpt dirtree \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param old_name: absolute path to the folder to be renamed
    @param new_name: absolute path of the new folder name
    @returns success

ida_dbg.request_add_bpt(*args) -> bool
    This function has the following signatures:
    
        0. request_add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool
        1. request_add_bpt(bpt: const bpt_t &) -> bool
    
    # 0: request_add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool
    
    Post an add_bpt(ea_t, asize_t, bpttype_t) request.
    
    
    # 1: request_add_bpt(bpt: const bpt_t &) -> bool
    
    Post an add_bpt(const bpt_t &) request.

ida_dbg.request_attach_process(pid: "pid_t", event_id: int) -> int
    Post an attach_process() request.

ida_dbg.request_clear_trace() -> None
    Post a clear_trace() request.

ida_dbg.request_continue_backwards() -> bool
    Post a continue_backwards() request. 
            

ida_dbg.request_continue_process() -> bool
    Post a continue_process() request. 
            

ida_dbg.request_del_bpt(*args) -> bool
    This function has the following signatures:
    
        0. request_del_bpt(ea: ida_idaapi.ea_t) -> bool
        1. request_del_bpt(bptloc: const bpt_location_t &) -> bool
    
    # 0: request_del_bpt(ea: ida_idaapi.ea_t) -> bool
    
    Post a del_bpt(ea_t) request.
    
    
    # 1: request_del_bpt(bptloc: const bpt_location_t &) -> bool
    
    Post a del_bpt(const bpt_location_t &) request.

ida_dbg.request_detach_process() -> bool
    Post a detach_process() request.

ida_dbg.request_disable_bblk_trace() -> bool

ida_dbg.request_disable_bpt(*args) -> bool

ida_dbg.request_disable_func_trace() -> bool

ida_dbg.request_disable_insn_trace() -> bool

ida_dbg.request_disable_step_trace() -> bool

ida_dbg.request_enable_bblk_trace(enable: bool = True) -> bool

ida_dbg.request_enable_bpt(*args) -> bool

ida_dbg.request_enable_func_trace(enable: bool = True) -> bool

ida_dbg.request_enable_insn_trace(enable: bool = True) -> bool

ida_dbg.request_enable_step_trace(enable: int = 1) -> bool

ida_dbg.request_exit_process() -> bool
    Post an exit_process() request.

ida_dbg.request_resume_thread(tid: "thid_t") -> int
    Post a resume_thread() request.

ida_dbg.request_run_to(*args) -> bool
    Post a run_to() request.

ida_dbg.request_run_to_backwards(*args) -> bool
    Post a run_to_backwards() request.

ida_dbg.request_select_thread(tid: "thid_t") -> bool
    Post a select_thread() request.

ida_dbg.request_set_bblk_trace_options(options: int) -> None
    Post a set_bblk_trace_options() request.

ida_dbg.request_set_func_trace_options(options: int) -> None
    Post a set_func_trace_options() request.

ida_dbg.request_set_insn_trace_options(options: int) -> None
    Post a set_insn_trace_options() request.

ida_dbg.request_set_reg_val(regname: str, o: "PyObject *") -> "PyObject *"
    Post a set_reg_val() request.

ida_dbg.request_set_resume_mode(tid: "thid_t", mode: "resume_mode_t") -> bool
    Post a set_resume_mode() request.

ida_dbg.request_set_step_trace_options(options: int) -> None
    Post a set_step_trace_options() request.

ida_dbg.request_start_process(path: str = None, args: str = None, sdir: str = None) -> int
    Post a start_process() request.

ida_dbg.request_step_into() -> bool
    Post a step_into() request.

ida_dbg.request_step_into_backwards() -> bool
    Post a step_into_backwards() request.

ida_dbg.request_step_over() -> bool
    Post a step_over() request.

ida_dbg.request_step_over_backwards() -> bool
    Post a step_over_backwards() request.

ida_dbg.request_step_until_ret() -> bool
    Post a step_until_ret() request.

ida_dbg.request_suspend_process() -> bool
    Post a suspend_process() request.

ida_dbg.request_suspend_thread(tid: "thid_t") -> int
    Post a suspend_thread() request.

ida_dbg.resume_thread(tid: "thid_t") -> int
    Resume thread. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    @param tid: thread id
    @retval -1: network error
    @retval 0: failed
    @retval 1: ok

ida_dbg.retrieve_exceptions() -> "excvec_t *"
    Retrieve the exception information. You may freely modify the returned vector and add/edit/delete exceptions You must call store_exceptions() after any modifications Note: exceptions with code zero, multiple exception codes or names are prohibited 
            

ida_dbg.run_requests() -> bool
    Execute requests until all requests are processed or an asynchronous function is called. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @returns false if not all requests could be processed (indicates an asynchronous function was started)

ida_dbg.run_to(*args) -> bool
    Execute the process until the given address is reached. If no process is active, a new process is started. Technically, the debugger sets up a temporary breakpoint at the given address, and continues (or starts) the execution of the whole process. So, all threads continue their execution! \sq{Type, Asynchronous function - available as Request, Notification, dbg_run_to} 
            
    @param ea: target address
    @param pid: not used yet. please do not specify this parameter.
    @param tid: not used yet. please do not specify this parameter.

ida_dbg.run_to_backwards(*args) -> bool
    Execute the process backwards until the given address is reached. Technically, the debugger sets up a temporary breakpoint at the given address, and continues (or starts) the execution of the whole process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_run_to} 
            
    @param ea: target address
    @param pid: not used yet. please do not specify this parameter.
    @param tid: not used yet. please do not specify this parameter.

ida_dbg.save_trace_file(filename: str, description: str) -> bool
    Save the current trace in the specified file.

ida_dbg.select_thread(tid: "thid_t") -> bool
    Select the given thread as the current debugged thread. All thread related execution functions will work on this thread. The process must be suspended to select a new thread. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    @param tid: ID of the thread to select
    @returns false if the thread doesn't exist.

ida_dbg.send_dbg_command(command)
    Send a direct command to the debugger backend, and
    retrieve the result as a string.
    
    Note: any double-quotes in 'command' must be backslash-escaped.
    Note: this only works with some debugger backends: Bochs, WinDbg, GDB.
    
    Returns: (True, <result string>) on success, or (False, <Error message string>) on failure

ida_dbg.set_bblk_trace_options(options: int) -> None
    Modify basic block tracing options (see BT_LOG_INSTS)

ida_dbg.set_bpt_group(bpt: "bpt_t", grp_name: str) -> bool
    Move a bpt into a folder in the breakpoint dirtree if the folder didn't exists, it will be created \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param bpt: bpt that will be moved
    @param grp_name: absolute path to the breakpoint dirtree folder
    @returns success

ida_dbg.set_bptloc_group(bptloc: "bpt_location_t", grp_name: str) -> bool
    Move a bpt into a folder in the breakpoint dirtree based on the bpt_location find_bpt is called to retrieve the bpt and then set_bpt_group if the folder didn't exists, it will be created \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param bptloc: bptlocation of the bpt that will be moved
    @param grp_name: absolute path to the breakpoint dirtree folder
    @returns success

ida_dbg.set_bptloc_string(s: str) -> int

ida_dbg.set_debugger_event_cond(NONNULL_evcond: str) -> None

ida_dbg.set_debugger_options(options: "uint") -> "uint"
    Set debugger options. Replaces debugger options with the specification combination Debugger options 
            
    @returns the old debugger options

ida_dbg.set_func_trace_options(options: int) -> None
    Modify function tracing options. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            

ida_dbg.set_highlight_trace_options(hilight: bool, color: "bgcolor_t", diff: "bgcolor_t") -> None
    Set highlight trace parameters.

ida_dbg.set_insn_trace_options(options: int) -> None
    Modify instruction tracing options. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            

ida_dbg.set_manual_regions(ranges: "meminfo_vec_t") -> None

ida_dbg.set_process_options(*args) -> None
    Set process options. Any of the arguments may be nullptr, which means 'do not modify' 
            

ida_dbg.set_process_state(newstate: int, p_thid: "thid_t *", dbginv: int) -> int
    Set new state for the debugged process. Notifies the IDA kernel about the change of the debugged process state. For example, a debugger module could call this function when it knows that the process is suspended for a short period of time. Some IDA API calls can be made only when the process is suspended. The process state is usually restored before returning control to the caller. You must know that it is ok to change the process state, doing it at arbitrary moments may crash the application or IDA. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param newstate: new process state (one of Debugged process states) if DSTATE_NOTASK is passed then the state is not changed
    @param p_thid: ptr to new thread id. may be nullptr or pointer to NO_THREAD. the pointed variable will contain the old thread id upon return
    @param dbginv: Debugged process invalidation options
    @returns old debugger state (one of Debugged process states)

ida_dbg.set_reg_val(*args) -> bool
    Set a register value by name
    
    This function has the following signatures:
        1. set_reg_val(name: str, value: Union[int, float, bytes]) -> bool
        1. set_reg_val(tid: int, regidx: int, value: Union[int, float, bytes]) -> bool
    
    Depending on the register type, this will expect
    either an integer, a float or, in the case of large
    vector registers, a bytes sequence.
    
    @param name (1st form) the register name
    @param tid (2nd form) the thread ID
    @param regidx (2nd form) the register index
    @param value the register value
    @return success

ida_dbg.set_remote_debugger(host: str, _pass: str, port: int = -1) -> None
    Set remote debugging options. Should be used before starting the debugger. 
            
    @param host: If empty, IDA will use local debugger. If nullptr, the host will not be set.
    @param port: If -1, the default port number will be used

ida_dbg.set_resume_mode(tid: "thid_t", mode: "resume_mode_t") -> bool
    How to resume the application. Set resume mode but do not resume process. 
            

ida_dbg.set_step_trace_options(options: int) -> None
    Modify step tracing options. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            

ida_dbg.set_trace_base_address(ea: ida_idaapi.ea_t) -> None
    Set the base address of the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.set_trace_dynamic_register_set(idaregs: "dynamic_register_set_t &") -> None
    Set dynamic register set of current trace.

ida_dbg.set_trace_file_desc(filename: str, description: str) -> bool
    Change the description of the specified trace file.

ida_dbg.set_trace_platform(platform: str) -> None
    Set platform name of current trace.

ida_dbg.set_trace_size(size: int) -> bool
    Specify the new size of the circular buffer. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    @param size: if 0, buffer isn't circular and events are never removed. If the new size is smaller than the existing number of trace events, a corresponding number of trace events are removed.

ida_dbg.srcdbg_request_step_into() -> bool

ida_dbg.srcdbg_request_step_over() -> bool

ida_dbg.srcdbg_request_step_until_ret() -> bool

ida_dbg.srcdbg_step_into() -> bool

ida_dbg.srcdbg_step_over() -> bool

ida_dbg.srcdbg_step_until_ret() -> bool

ida_dbg.start_process(path: str = None, args: str = None, sdir: str = None) -> int
    Start a process in the debugger. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_start} 
            
    @param path: path to the executable to start
    @param args: arguments to pass to process
    @param sdir: starting directory for the process
    @retval -1: impossible to create the process
    @retval 0: the starting of the process was cancelled by the user
    @retval 1: the process was properly started

ida_dbg.step_into() -> bool
    Execute one instruction in the current thread. Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_into} 
            

ida_dbg.step_into_backwards() -> bool
    Execute one instruction backwards in the current thread. Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_into} 
            

ida_dbg.step_over() -> bool
    Execute one instruction in the current thread, but without entering into functions. Others threads keep suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_over} 
            

ida_dbg.step_over_backwards() -> bool
    Execute one instruction backwards in the current thread, but without entering into functions. Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_over} 
            

ida_dbg.step_until_ret() -> bool
    Execute instructions in the current thread until a function return instruction is executed (aka "step out"). Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_until_ret} 
            

ida_dbg.store_exceptions() -> bool
    Update the exception information stored in the debugger module by invoking its dbg->set_exception_info callback 
            

ida_dbg.suspend_process() -> bool
    Suspend the process in the debugger. \sq{ Type,
    * Synchronous function (if in a notification handler)
    * Asynchronous function (everywhere else)
    * available as Request, Notification,
    * none (if in a notification handler)
    * dbg_suspend_process (everywhere else) }

ida_dbg.suspend_thread(tid: "thid_t") -> int
    Suspend thread. Suspending a thread may deadlock the whole application if the suspended was owning some synchronization objects. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    @param tid: thread id
    @retval -1: network error
    @retval 0: failed
    @retval 1: ok

ida_dbg.tev_bpt
    write, read/write, execution trace

ida_dbg.tev_call
    a function call trace

ida_dbg.tev_event
    debug event occurred

ida_dbg.tev_info_reg_t

ida_dbg.tev_info_reg_t.__init__(self)

ida_dbg.tev_info_t

ida_dbg.tev_info_t.__init__(self)

ida_dbg.tev_info_t.ea
    address where the event occurred

ida_dbg.tev_info_t.tid
    thread where the event was recorded

ida_dbg.tev_info_t.type
    trace event type

ida_dbg.tev_insn
    an instruction trace

ida_dbg.tev_max
    first unused event type

ida_dbg.tev_mem
    memory layout changed

ida_dbg.tev_none
    no event

ida_dbg.tev_reg_value_t

ida_dbg.tev_reg_value_t.__init__(self, *args)

ida_dbg.tev_reg_values_t

ida_dbg.tev_reg_values_t.__getitem__(self, i: "size_t") -> "tev_reg_value_t const &"

ida_dbg.tev_reg_values_t.__init__(self, *args)

ida_dbg.tev_reg_values_t.__len__(self) -> "size_t"

ida_dbg.tev_reg_values_t.__setitem__(self, i: "size_t", v: "tev_reg_value_t") -> None

ida_dbg.tev_reg_values_t.append(self, x: "tev_reg_value_t") -> None

ida_dbg.tev_reg_values_t.at(self, _idx: "size_t") -> "tev_reg_value_t const &"

ida_dbg.tev_reg_values_t.begin(self, *args) -> "qvector< tev_reg_value_t >::const_iterator"

ida_dbg.tev_reg_values_t.capacity(self) -> "size_t"

ida_dbg.tev_reg_values_t.clear(self) -> None

ida_dbg.tev_reg_values_t.empty(self) -> bool

ida_dbg.tev_reg_values_t.end(self, *args) -> "qvector< tev_reg_value_t >::const_iterator"

ida_dbg.tev_reg_values_t.erase(self, *args) -> "qvector< tev_reg_value_t >::iterator"

ida_dbg.tev_reg_values_t.extend(self, x: "tev_reg_values_t") -> None

ida_dbg.tev_reg_values_t.extract(self) -> "tev_reg_value_t *"

ida_dbg.tev_reg_values_t.grow(self, *args) -> None

ida_dbg.tev_reg_values_t.inject(self, s: "tev_reg_value_t", len: "size_t") -> None

ida_dbg.tev_reg_values_t.insert(self, it: "tev_reg_value_t", x: "tev_reg_value_t") -> "qvector< tev_reg_value_t >::iterator"

ida_dbg.tev_reg_values_t.pop_back(self) -> None

ida_dbg.tev_reg_values_t.push_back(self, *args) -> "tev_reg_value_t &"

ida_dbg.tev_reg_values_t.qclear(self) -> None

ida_dbg.tev_reg_values_t.reserve(self, cnt: "size_t") -> None

ida_dbg.tev_reg_values_t.resize(self, *args) -> None

ida_dbg.tev_reg_values_t.size(self) -> "size_t"

ida_dbg.tev_reg_values_t.swap(self, r: "tev_reg_values_t") -> None

ida_dbg.tev_reg_values_t.truncate(self) -> None

ida_dbg.tev_ret
    a function return trace

ida_dbg.tevinforeg_vec_t

ida_dbg.tevinforeg_vec_t.__getitem__(self, i: "size_t") -> "tev_info_reg_t const &"

ida_dbg.tevinforeg_vec_t.__init__(self, *args)

ida_dbg.tevinforeg_vec_t.__len__(self) -> "size_t"

ida_dbg.tevinforeg_vec_t.__setitem__(self, i: "size_t", v: "tev_info_reg_t") -> None

ida_dbg.tevinforeg_vec_t.append(self, x: "tev_info_reg_t") -> None

ida_dbg.tevinforeg_vec_t.at(self, _idx: "size_t") -> "tev_info_reg_t const &"

ida_dbg.tevinforeg_vec_t.begin(self, *args) -> "qvector< tev_info_reg_t >::const_iterator"

ida_dbg.tevinforeg_vec_t.capacity(self) -> "size_t"

ida_dbg.tevinforeg_vec_t.clear(self) -> None

ida_dbg.tevinforeg_vec_t.empty(self) -> bool

ida_dbg.tevinforeg_vec_t.end(self, *args) -> "qvector< tev_info_reg_t >::const_iterator"

ida_dbg.tevinforeg_vec_t.erase(self, *args) -> "qvector< tev_info_reg_t >::iterator"

ida_dbg.tevinforeg_vec_t.extend(self, x: "tevinforeg_vec_t") -> None

ida_dbg.tevinforeg_vec_t.extract(self) -> "tev_info_reg_t *"

ida_dbg.tevinforeg_vec_t.grow(self, *args) -> None

ida_dbg.tevinforeg_vec_t.inject(self, s: "tev_info_reg_t", len: "size_t") -> None

ida_dbg.tevinforeg_vec_t.insert(self, it: "tev_info_reg_t", x: "tev_info_reg_t") -> "qvector< tev_info_reg_t >::iterator"

ida_dbg.tevinforeg_vec_t.pop_back(self) -> None

ida_dbg.tevinforeg_vec_t.push_back(self, *args) -> "tev_info_reg_t &"

ida_dbg.tevinforeg_vec_t.qclear(self) -> None

ida_dbg.tevinforeg_vec_t.reserve(self, cnt: "size_t") -> None

ida_dbg.tevinforeg_vec_t.resize(self, *args) -> None

ida_dbg.tevinforeg_vec_t.size(self) -> "size_t"

ida_dbg.tevinforeg_vec_t.swap(self, r: "tevinforeg_vec_t") -> None

ida_dbg.tevinforeg_vec_t.truncate(self) -> None

ida_dbg.update_bpt(bpt: "bpt_t") -> bool
    Update modifiable characteristics of an existing breakpoint. To update the breakpoint location, use change_bptlocs() \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            

ida_dbg.wait_for_next_event(wfne: int, timeout: int) -> "dbg_event_code_t"
    Wait for the next event.
    This function (optionally) resumes the process execution, and waits for a debugger event until a possible timeout occurs.
    
    @param wfne: combination of Wait for debugger event flags constants
    @param timeout: number of seconds to wait, -1-infinity
    @returns either an event_id_t (if > 0), or a dbg_event_code_t (if <= 0)

ida_dbg.write_dbg_memory(*args) -> "ssize_t"

ida_diskio
    File I/O functions for IDA.
    
    You should not use standard C file I/O functions in modules. Use functions from this header, pro.h and fpro.h instead.
    This file also declares a call_system() function. 
        

ida_diskio.IDA_SUBDIR_IDADIR_FIRST
    $IDADIR/subdir will be first, not last

ida_diskio.IDA_SUBDIR_IDP
    append the processor name as a subdirectory

ida_diskio.IDA_SUBDIR_ONLY_EXISTING
    only existing directories will be present

ida_diskio.LOC_CLOSE
    close the inner linput

ida_diskio.LOC_KEEP
    do nothing

ida_diskio.LOC_UNMAKE
    unmake the inner linput

ida_diskio.VAULT_CACHE_FNAME
    to store file caches

ida_diskio.VAULT_CACHE_SUBDIR
    subdir name for cached deltas and old files

ida_diskio.choose_ioport_device2(_device: str, file: str, parse_params: "choose_ioport_parser_t") -> bool

ida_diskio.choose_ioport_parser_t

ida_diskio.choose_ioport_parser_t.__disown__(self)

ida_diskio.choose_ioport_parser_t.__init__(self)

ida_diskio.choose_ioport_parser_t.parse(self, param: str, line: str) -> bool
    @retval true: and fill PARAM with a displayed string
    @retval false: and empty PARAM to skip the current device
    @retval false: and fill PARAM with an error message

ida_diskio.close_linput(li: "linput_t *") -> None

ida_diskio.create_bytearray_linput(s: str) -> "linput_t *"

ida_diskio.create_generic_linput(gl: "generic_linput_t") -> "linput_t *"

ida_diskio.create_memory_linput(start: ida_idaapi.ea_t, size: "asize_t") -> "linput_t *"

ida_diskio.enumerate_files(path, fname, callback)
    Enumerate files in the specified directory while the callback returns 0.
    
    @param path: directory to enumerate files in
    @param fname: mask of file names to enumerate
    @param callback: a callable object that takes the filename as
                     its first argument and it returns 0 to continue
                     enumeration or non-zero to stop enumeration.
    @return:
        None in case of script errors
        tuple(code, fname) : If the callback returns non-zero

ida_diskio.file_enumerator_t

ida_diskio.file_enumerator_t.__disown__(self)

ida_diskio.file_enumerator_t.__init__(self)

ida_diskio.file_enumerator_t.visit_file(self, file: str) -> int

ida_diskio.fopenA(file: str) -> "FILE *"

ida_diskio.fopenM(file: str) -> "FILE *"

ida_diskio.fopenRB(file: str) -> "FILE *"

ida_diskio.fopenRT(file: str) -> "FILE *"

ida_diskio.fopenWB(file: str) -> "FILE *"

ida_diskio.fopenWT(file: str) -> "FILE *"

ida_diskio.generic_linput_t

ida_diskio.generic_linput_t.__init__(self, *args, **kwargs)

ida_diskio.generic_linput_t.read(self, off: "qoff64_t", buffer: "void *", nbytes: "size_t") -> "ssize_t"

ida_diskio.get_ida_subdirs(subdir: str, flags: int = 0) -> "qstrvec_t *"
    Get list of directories in which to find a specific IDA resource (see IDA subdirectories). The order of the resulting list is as follows: 
         [$IDAUSR/subdir (0..N entries)]
         $IDADIR/subdir
    
    
            
    @param subdir: name of the resource to list (can be nullptr)
    @param flags: Subdirectory modification flags bits
    @returns number of directories appended to 'dirs'

ida_diskio.get_linput_type(li: "linput_t *") -> "linput_type_t"

ida_diskio.get_special_folder(csidl: int) -> str
    Get a folder location by CSIDL (see Common CSIDLs). Path should be of at least MAX_PATH size 
            

ida_diskio.get_user_idadir() -> str
    Get user ida related directory. 
    if $IDAUSR is defined:
       - the first element in $IDAUSR
    else
       - default user directory ($HOME/.idapro or %APPDATA%Hex-Rays/IDA Pro)
    
    
       

ida_diskio.getsysfile(filename: str, subdir: str) -> str
    Search for IDA system file. This function searches for a file in:
    0. each directory specified by IDAUSR%
    1. ida directory [+ subdir]
    
    
    and returns the first match. 
            
    @param filename: name of file to search
    @param subdir: if specified, the file is looked for in the specified subdirectory of the ida directory first (see IDA subdirectories)
    @returns nullptr if not found, otherwise a pointer to full file name.

ida_diskio.idadir(subdir: str) -> str
    Get IDA directory (if subdir==nullptr) or the specified subdirectory (see IDA subdirectories) 
            

ida_diskio.ioports_fallback_t

ida_diskio.ioports_fallback_t.__disown__(self)

ida_diskio.ioports_fallback_t.__init__(self)

ida_diskio.ioports_fallback_t.handle(self, ports: "ioports_t const &", line: str) -> bool
    @param ports: i/o port definitions
    @param line: input line to parse
    @returns success or fills ERRBUF with an error message

ida_diskio.open_linput(file: str, remote: bool) -> "linput_t *"

ida_diskio.qlgetz(li: "linput_t *", fpos: "int64") -> str

ida_diskio.read_ioports(ports: "ioports_t *", device: str, file: str, callback: "ioports_fallback_t" = None) -> "ssize_t"

ida_dirtree
    Types involved in grouping of item into folders.
    
    The dirtree_t class is used to organize a directory tree on top of any collection that allows for accessing its elements by an id (inode).
    No requirements are imposed on the inodes apart from the forbidden value -1 (used to denote a bad inode).
    The dirspec_t class is used to specialize the dirtree. It can be used to introduce a directory structure for:
    * local types
    * structs
    * enums
    * functions
    * names
    * etc

ida_dirtree.DTE_ALREADY_EXISTS
    item already exists

ida_dirtree.DTE_BAD_PATH
    invalid path

ida_dirtree.DTE_CANT_RENAME
    failed to rename an item

ida_dirtree.DTE_MAX_DIR
    maximum directory count achieved

ida_dirtree.DTE_NOT_DIRECTORY
    item is not a directory

ida_dirtree.DTE_NOT_EMPTY
    directory is not empty

ida_dirtree.DTE_NOT_FOUND
    item not found

ida_dirtree.DTE_OK
    ok

ida_dirtree.DTE_OWN_CHILD
    moving inside subdirectory of itself

ida_dirtree.DTN_DISPLAY_NAME
    use short, displayable form of the entry name. for example, 'std::string' instead of 'std::basic_string<char, ...>'. Note that more than one "full name" can have the same displayable name. 
              

ida_dirtree.DTN_FULL_NAME
    use long form of the entry name. That name is unique. 
              

ida_dirtree.direntry_t

ida_dirtree.direntry_t.__eq__(self, r: "direntry_t") -> bool

ida_dirtree.direntry_t.__init__(self, *args)

ida_dirtree.direntry_t.__lt__(self, r: "direntry_t") -> bool

ida_dirtree.direntry_t.__ne__(self, r: "direntry_t") -> bool

ida_dirtree.direntry_t.idx
    diridx_t or inode_t

ida_dirtree.direntry_t.isdir
    is 'idx' a diridx_t, or an inode_t

ida_dirtree.direntry_t.valid(self) -> bool

ida_dirtree.direntry_vec_t

ida_dirtree.direntry_vec_t.__eq__(self, r: "direntry_vec_t") -> bool

ida_dirtree.direntry_vec_t.__getitem__(self, i: "size_t") -> "direntry_t const &"

ida_dirtree.direntry_vec_t.__init__(self, *args)

ida_dirtree.direntry_vec_t.__len__(self) -> "size_t"

ida_dirtree.direntry_vec_t.__ne__(self, r: "direntry_vec_t") -> bool

ida_dirtree.direntry_vec_t.__setitem__(self, i: "size_t", v: "direntry_t") -> None

ida_dirtree.direntry_vec_t._del(self, x: "direntry_t") -> bool

ida_dirtree.direntry_vec_t.add_unique(self, x: "direntry_t") -> bool

ida_dirtree.direntry_vec_t.append(self, x: "direntry_t") -> None

ida_dirtree.direntry_vec_t.at(self, _idx: "size_t") -> "direntry_t const &"

ida_dirtree.direntry_vec_t.begin(self, *args) -> "qvector< direntry_t >::const_iterator"

ida_dirtree.direntry_vec_t.capacity(self) -> "size_t"

ida_dirtree.direntry_vec_t.clear(self) -> None

ida_dirtree.direntry_vec_t.empty(self) -> bool

ida_dirtree.direntry_vec_t.end(self, *args) -> "qvector< direntry_t >::const_iterator"

ida_dirtree.direntry_vec_t.erase(self, *args) -> "qvector< direntry_t >::iterator"

ida_dirtree.direntry_vec_t.extend(self, x: "direntry_vec_t") -> None

ida_dirtree.direntry_vec_t.extract(self) -> "direntry_t *"

ida_dirtree.direntry_vec_t.find(self, *args) -> "qvector< direntry_t >::const_iterator"

ida_dirtree.direntry_vec_t.grow(self, *args) -> None

ida_dirtree.direntry_vec_t.has(self, x: "direntry_t") -> bool

ida_dirtree.direntry_vec_t.inject(self, s: "direntry_t", len: "size_t") -> None

ida_dirtree.direntry_vec_t.insert(self, it: "direntry_t", x: "direntry_t") -> "qvector< direntry_t >::iterator"

ida_dirtree.direntry_vec_t.pop_back(self) -> None

ida_dirtree.direntry_vec_t.push_back(self, *args) -> "direntry_t &"

ida_dirtree.direntry_vec_t.qclear(self) -> None

ida_dirtree.direntry_vec_t.reserve(self, cnt: "size_t") -> None

ida_dirtree.direntry_vec_t.resize(self, *args) -> None

ida_dirtree.direntry_vec_t.size(self) -> "size_t"

ida_dirtree.direntry_vec_t.swap(self, r: "direntry_vec_t") -> None

ida_dirtree.direntry_vec_t.truncate(self) -> None

ida_dirtree.dirspec_t

ida_dirtree.dirspec_t.__disown__(self)

ida_dirtree.dirspec_t.__init__(self, nm: str = None, f: int = 0)

ida_dirtree.dirspec_t.get_attrs(self, inode: "inode_t") -> str

ida_dirtree.dirspec_t.get_inode(self, dirpath: str, name: str) -> "inode_t"
    get the entry inode in the specified directory 
            
    @param dirpath: the absolute directory path with trailing slash
    @param name: the entry name in the directory
    @returns the entry inode

ida_dirtree.dirspec_t.get_name(self, inode: "inode_t", name_flags: int = DTN_FULL_NAME) -> bool
    get the entry name. for example, the structure name 
            
    @param inode: inode number of the entry
    @param name_flags: how exactly the name should be retrieved. combination of bits for get_...name() methods bits
    @returns false if the entry does not exist.

ida_dirtree.dirspec_t.is_orderable(self) -> bool

ida_dirtree.dirspec_t.rename_inode(self, inode: "inode_t", newname: str) -> bool
    rename the entry 
            
    @returns success

ida_dirtree.dirspec_t.unlink_inode(self, inode: "inode_t") -> None
    event: unlinked an inode 
            

ida_dirtree.dirtree_cursor_t

ida_dirtree.dirtree_cursor_t.__eq__(self, r: "dirtree_cursor_t") -> bool

ida_dirtree.dirtree_cursor_t.__ge__(self, r: "dirtree_cursor_t") -> bool

ida_dirtree.dirtree_cursor_t.__gt__(self, r: "dirtree_cursor_t") -> bool

ida_dirtree.dirtree_cursor_t.__init__(self, *args)

ida_dirtree.dirtree_cursor_t.__le__(self, r: "dirtree_cursor_t") -> bool

ida_dirtree.dirtree_cursor_t.__lt__(self, r: "dirtree_cursor_t") -> bool

ida_dirtree.dirtree_cursor_t.__ne__(self, r: "dirtree_cursor_t") -> bool

ida_dirtree.dirtree_cursor_t.compare(self, r: "dirtree_cursor_t") -> int

ida_dirtree.dirtree_cursor_t.is_root_cursor(self) -> bool

ida_dirtree.dirtree_cursor_t.parent
    the parent directory

ida_dirtree.dirtree_cursor_t.rank
    the index into the parent directory

ida_dirtree.dirtree_cursor_t.root_cursor() -> "dirtree_cursor_t"

ida_dirtree.dirtree_cursor_t.set_root_cursor(self) -> None

ida_dirtree.dirtree_cursor_t.valid(self) -> bool

ida_dirtree.dirtree_cursor_vec_t

ida_dirtree.dirtree_cursor_vec_t.__eq__(self, r: "dirtree_cursor_vec_t") -> bool

ida_dirtree.dirtree_cursor_vec_t.__getitem__(self, i: "size_t") -> "dirtree_cursor_t const &"

ida_dirtree.dirtree_cursor_vec_t.__init__(self, *args)

ida_dirtree.dirtree_cursor_vec_t.__len__(self) -> "size_t"

ida_dirtree.dirtree_cursor_vec_t.__ne__(self, r: "dirtree_cursor_vec_t") -> bool

ida_dirtree.dirtree_cursor_vec_t.__setitem__(self, i: "size_t", v: "dirtree_cursor_t") -> None

ida_dirtree.dirtree_cursor_vec_t._del(self, x: "dirtree_cursor_t") -> bool

ida_dirtree.dirtree_cursor_vec_t.add_unique(self, x: "dirtree_cursor_t") -> bool

ida_dirtree.dirtree_cursor_vec_t.append(self, x: "dirtree_cursor_t") -> None

ida_dirtree.dirtree_cursor_vec_t.at(self, _idx: "size_t") -> "dirtree_cursor_t const &"

ida_dirtree.dirtree_cursor_vec_t.begin(self, *args) -> "qvector< dirtree_cursor_t >::const_iterator"

ida_dirtree.dirtree_cursor_vec_t.capacity(self) -> "size_t"

ida_dirtree.dirtree_cursor_vec_t.clear(self) -> None

ida_dirtree.dirtree_cursor_vec_t.empty(self) -> bool

ida_dirtree.dirtree_cursor_vec_t.end(self, *args) -> "qvector< dirtree_cursor_t >::const_iterator"

ida_dirtree.dirtree_cursor_vec_t.erase(self, *args) -> "qvector< dirtree_cursor_t >::iterator"

ida_dirtree.dirtree_cursor_vec_t.extend(self, x: "dirtree_cursor_vec_t") -> None

ida_dirtree.dirtree_cursor_vec_t.extract(self) -> "dirtree_cursor_t *"

ida_dirtree.dirtree_cursor_vec_t.find(self, *args) -> "qvector< dirtree_cursor_t >::const_iterator"

ida_dirtree.dirtree_cursor_vec_t.grow(self, *args) -> None

ida_dirtree.dirtree_cursor_vec_t.has(self, x: "dirtree_cursor_t") -> bool

ida_dirtree.dirtree_cursor_vec_t.inject(self, s: "dirtree_cursor_t", len: "size_t") -> None

ida_dirtree.dirtree_cursor_vec_t.insert(self, it: "dirtree_cursor_t", x: "dirtree_cursor_t") -> "qvector< dirtree_cursor_t >::iterator"

ida_dirtree.dirtree_cursor_vec_t.pop_back(self) -> None

ida_dirtree.dirtree_cursor_vec_t.push_back(self, *args) -> "dirtree_cursor_t &"

ida_dirtree.dirtree_cursor_vec_t.qclear(self) -> None

ida_dirtree.dirtree_cursor_vec_t.reserve(self, cnt: "size_t") -> None

ida_dirtree.dirtree_cursor_vec_t.resize(self, *args) -> None

ida_dirtree.dirtree_cursor_vec_t.size(self) -> "size_t"

ida_dirtree.dirtree_cursor_vec_t.swap(self, r: "dirtree_cursor_vec_t") -> None

ida_dirtree.dirtree_cursor_vec_t.truncate(self) -> None

ida_dirtree.dirtree_iterator_t

ida_dirtree.dirtree_iterator_t.__init__(self)

ida_dirtree.dirtree_selection_t

ida_dirtree.dirtree_selection_t.__init__(self)

ida_dirtree.dirtree_t

ida_dirtree.dirtree_t.__init__(self, ds: "dirspec_t")

ida_dirtree.dirtree_t.change_rank(self, path: str, rank_delta: "ssize_t") -> "dterr_t"
    Change ordering rank of an item. 
            
    @param path: path to the item
    @param rank_delta: the amount of the change. positive numbers mean to move down in the list; negative numbers mean to move up.
    @returns dterr_t error code

ida_dirtree.dirtree_t.chdir(self, path: str) -> "dterr_t"
    Change current directory 
            
    @param path: new current directory
    @returns dterr_t error code

ida_dirtree.dirtree_t.errstr(err: "dterr_t") -> str
    Get textual representation of the error code.

ida_dirtree.dirtree_t.find_entry(self, de: "direntry_t") -> "dirtree_cursor_t"
    Find the cursor corresponding to an entry of a directory 
            
    @param de: directory entry
    @returns cursor corresponding to the directory entry

ida_dirtree.dirtree_t.findfirst(self, ff: "dirtree_iterator_t", pattern: str) -> bool
    Start iterating over files in a directory 
            
    @param ff: directory iterator. it will be initialized by the function
    @param pattern: pattern to search for
    @returns success

ida_dirtree.dirtree_t.findnext(self, ff: "dirtree_iterator_t") -> bool
    Continue iterating over files in a directory 
            
    @param ff: directory iterator
    @returns success

ida_dirtree.dirtree_t.get_abspath(self, *args) -> str
    This function has the following signatures:
    
        0. get_abspath(cursor: const dirtree_cursor_t &, name_flags: int=DTN_FULL_NAME) -> str
        1. get_abspath(relpath: str) -> str
    
    # 0: get_abspath(cursor: const dirtree_cursor_t &, name_flags: int=DTN_FULL_NAME) -> str
    
    Get absolute path pointed by the cursor 
            
    @returns path; empty string if error
    
    # 1: get_abspath(relpath: str) -> str
    
    Construct an absolute path from the specified relative path. This function verifies the directory part of the specified path. The last component of the specified path is not verified. 
            
    @returns path. empty path means wrong directory part of RELPATH

ida_dirtree.dirtree_t.get_dir_size(self, diridx: "diridx_t") -> "ssize_t"
    Get dir size 
            
    @param diridx: directory index
    @returns number of entries under this directory; if error, return -1

ida_dirtree.dirtree_t.get_entry_attrs(self, de: "direntry_t") -> str
    Get entry attributes 
            
    @param de: directory entry
    @returns name

ida_dirtree.dirtree_t.get_entry_name(self, de: "direntry_t", name_flags: int = DTN_FULL_NAME) -> str
    Get entry name 
            
    @param de: directory entry
    @param name_flags: how exactly the name should be retrieved. combination of bits for get_...name() methods bits
    @returns name

ida_dirtree.dirtree_t.get_id(self) -> str
    netnode name

ida_dirtree.dirtree_t.get_parent_cursor(self, cursor: "dirtree_cursor_t") -> "dirtree_cursor_t"
    Get parent cursor. 
            
    @param cursor: a valid ditree cursor
    @returns cursor's parent

ida_dirtree.dirtree_t.get_rank(self, diridx: "diridx_t", de: "direntry_t") -> "ssize_t"
    Get ordering rank of an item. 
            
    @param diridx: index of the parent directory
    @param de: directory entry
    @returns number in a range of [0..n) where n is the number of entries in the parent directory. -1 if error

ida_dirtree.dirtree_t.getcwd(self) -> str
    Get current directory 
            
    @returns the current working directory

ida_dirtree.dirtree_t.is_dir_ordered(self, diridx: "diridx_t") -> bool
    Is dir ordered? 
            
    @returns true if the dirtree has natural ordering

ida_dirtree.dirtree_t.is_orderable(self) -> bool
    Is dirtree orderable? 
            
    @returns true if the dirtree is orderable

ida_dirtree.dirtree_t.isdir(self, *args) -> bool
    This function has the following signatures:
    
        0. isdir(path: str) -> bool
        1. isdir(de: const direntry_t &) -> bool
    
    # 0: isdir(path: str) -> bool
    
    Is a directory? 
            
    @returns true if the specified path is a directory
    
    # 1: isdir(de: const direntry_t &) -> bool

ida_dirtree.dirtree_t.isfile(self, *args) -> bool
    This function has the following signatures:
    
        0. isfile(path: str) -> bool
        1. isfile(de: const direntry_t &) -> bool
    
    # 0: isfile(path: str) -> bool
    
    Is a file? 
            
    @returns true if the specified path is a file
    
    # 1: isfile(de: const direntry_t &) -> bool

ida_dirtree.dirtree_t.link(self, *args) -> "dterr_t"
    This function has the following signatures:
    
        0. link(path: str) -> dterr_t
        1. link(inode: inode_t) -> dterr_t
    
    # 0: link(path: str) -> dterr_t
    
    Add a file item into a directory. 
            
    @returns dterr_t error code
    
    # 1: link(inode: inode_t) -> dterr_t
    
    Add an inode into the current directory 
            
    @returns dterr_t error code

ida_dirtree.dirtree_t.load(self) -> bool
    Load the tree structure from the netnode. If dirspec_t::id is empty, the operation will be considered a success. In addition, calling load() more than once will not do anything, and will be considered a success. 
            
    @returns success

ida_dirtree.dirtree_t.mkdir(self, path: str) -> "dterr_t"
    Create a directory. 
            
    @param path: directory to create
    @returns dterr_t error code

ida_dirtree.dirtree_t.notify_dirtree(self, added: bool, inode: "inode_t") -> None
    Notify dirtree about a change of an inode. 
            
    @param added: are we adding or deleting an inode?
    @param inode: inode in question

ida_dirtree.dirtree_t.rename(self, _from: str, to: str) -> "dterr_t"
    Rename a directory entry. 
            
    @param to: destination path
    @returns dterr_t error code

ida_dirtree.dirtree_t.resolve_cursor(self, cursor: "dirtree_cursor_t") -> "direntry_t"
    Resolve cursor 
            
    @param cursor: to analyze
    @returns directory entry; if the cursor is bad, the resolved entry will be invalid.

ida_dirtree.dirtree_t.resolve_path(self, path: str) -> "direntry_t"
    Resolve path 
            
    @param path: to analyze
    @returns directory entry

ida_dirtree.dirtree_t.rmdir(self, path: str) -> "dterr_t"
    Remove a directory. 
            
    @param path: directory to delete
    @returns dterr_t error code

ida_dirtree.dirtree_t.save(self) -> bool
    Save the tree structure to the netnode. 
            
    @returns success

ida_dirtree.dirtree_t.set_id(self, nm: str) -> None

ida_dirtree.dirtree_t.set_natural_order(self, diridx: "diridx_t", enable: bool) -> bool
    Enable/disable natural inode order in a directory. 
            
    @param diridx: directory index
    @param enable: action to do TRUE - enable ordering: re-order existing entries so that all subdirs are at the to beginning of the list, file entries are sorted and placed after the subdirs FALSE - disable ordering, no changes to existing entries
    @returns SUCCESS

ida_dirtree.dirtree_t.traverse(self, v: "dirtree_visitor_t") -> "ssize_t"
    Traverse dirtree, and be notified at each entry If the the visitor returns anything other than 0, iteration will stop, and that value returned. The tree is traversed using a depth-first algorithm. It is forbidden to modify the dirtree_t during traversal; doing so will result in undefined behavior. 
            
    @param v: the callback
    @returns 0, or whatever the visitor returned

ida_dirtree.dirtree_t.unlink(self, *args) -> "dterr_t"
    This function has the following signatures:
    
        0. unlink(path: str) -> dterr_t
        1. unlink(inode: inode_t) -> dterr_t
    
    # 0: unlink(path: str) -> dterr_t
    
    Remove a file item from a directory. 
            
    @returns dterr_t error code
    
    # 1: unlink(inode: inode_t) -> dterr_t
    
    Remove an inode from the current directory 
            
    @returns dterr_t error code

ida_dirtree.dirtree_visitor_t

ida_dirtree.dirtree_visitor_t.__disown__(self)

ida_dirtree.dirtree_visitor_t.__init__(self)

ida_dirtree.dirtree_visitor_t.visit(self, c: "dirtree_cursor_t", de: "direntry_t") -> "ssize_t"
    Will be called for each entry in the dirtree_t If something other than 0 is returned, iteration will stop. 
            
    @param c: the current cursor
    @param de: the current entry
    @returns 0 to keep iterating, or anything else to stop

ida_dirtree.get_std_dirtree(id: "dirtree_id_t") -> "dirtree_t *"

ida_entry
    Functions that deal with entry points.
    
    Exported functions are considered as entry points as well.
    IDA maintains list of entry points to the program. Each entry point:
    * has an address
    * has a name
    * may have an ordinal number 
    
    
        

ida_entry.AEF_IDBENC
    the name is given in the IDB encoding; non-ASCII bytes will be decoded accordingly. Specifying AEF_IDBENC also implies AEF_NODUMMY 
            

ida_entry.AEF_NODUMMY
    automatically prepend the name with '_' if it begins with a dummy suffix. See also AEF_IDBENC 
            

ida_entry.AEF_UTF8
    the name is given in UTF-8 (default)

ida_entry.add_entry(ord: int, ea: ida_idaapi.ea_t, name: str, makecode: bool, flags: int = 0) -> bool
    Add an entry point to the list of entry points. 
            
    @param ord: ordinal number if ordinal number is equal to 'ea' then ordinal is not used
    @param ea: linear address
    @param name: name of entry point. If the specified location already has a name, the old name will be appended to the regular comment. If name == nullptr, then the old name will be retained.
    @param makecode: should the kernel convert bytes at the entry point to instruction(s)
    @param flags: See AEF_*
    @returns success (currently always true)

ida_entry.get_entry(ord: int) -> ida_idaapi.ea_t
    Get entry point address by its ordinal 
            
    @param ord: ordinal number of entry point
    @returns address or BADADDR

ida_entry.get_entry_forwarder(ord: int) -> str
    Get forwarder name for the entry point by its ordinal. 
            
    @param ord: ordinal number of entry point
    @returns size of entry forwarder name or -1

ida_entry.get_entry_name(ord: int) -> str
    Get name of the entry point by its ordinal. 
            
    @param ord: ordinal number of entry point
    @returns size of entry name or -1

ida_entry.get_entry_ordinal(idx: "size_t") -> int
    Get ordinal number of an entry point. 
            
    @param idx: internal number of entry point. Should be in the range 0..get_entry_qty()-1
    @returns ordinal number or 0.

ida_entry.get_entry_qty() -> "size_t"
    Get number of entry points.

ida_entry.rename_entry(ord: int, name: str, flags: int = 0) -> bool
    Rename entry point. 
            
    @param ord: ordinal number of the entry point
    @param name: name of entry point. If the specified location already has a name, the old name will be appended to a repeatable comment.
    @param flags: See AEF_*
    @returns success

ida_entry.set_entry_forwarder(ord: int, name: str, flags: int = 0) -> bool
    Set forwarder name for ordinal. 
            
    @param ord: ordinal number of the entry point
    @param name: forwarder name for entry point.
    @param flags: See AEF_*
    @returns success

ida_expr
    thread safe function. may be called

ida_expr.CPL_DEL_MACROS
    delete macros at the end of compilation

ida_expr.CPL_ONLY_SAFE
    allow calls of only thread-safe functions

ida_expr.CPL_USE_LABELS
    allow program labels in the script

ida_expr.EXTFUN_BASE
    requires open database.

ida_expr.EXTFUN_NORET
    does not return. the interpreter may clean up its state before calling it. 
            

ida_expr.EXTFUN_SAFE
    thread safe function. may be called from any thread. 
            

ida_expr.IDC_LANG_EXT
    IDC script extension.

ida_expr.VARSLICE_SINGLE
    return single index (i2 is ignored)

ida_expr.VREF_COPY
    copy the result to the input var (v)

ida_expr.VREF_LOOP
    dereference until we get a non VT_REF

ida_expr.VREF_ONCE
    dereference only once, do not loop

ida_expr.VT_FLOAT
    Floating point (see idc_value_t::e)

ida_expr.VT_FUNC
    Function (see idc_value_t::funcidx)

ida_expr.VT_INT64
    i64

ida_expr.VT_LONG
    Integer (see idc_value_t::num)

ida_expr.VT_OBJ
    Object (see idc_value_t::obj)

ida_expr.VT_PVOID
    void *

ida_expr.VT_REF
    Reference.

ida_expr.VT_STR
    String (see qstr() and similar functions)

ida_expr.VT_WILD
    Function with arbitrary number of arguments. The actual number of arguments will be passed in idc_value_t::num. This value should not be used for idc_value_t. 
            

ida_expr._IdcFunction
    Internal class that calls pyw_call_idc_func() with a context

ida_expr._IdcFunction.__call__(self, args, res)

ida_expr._IdcFunction.__init__(self, ctxptr)

ida_expr.add_idc_class(name: str, super: "idc_class_t const *" = None) -> "idc_class_t *"
    Create a new IDC class. 
            
    @param name: name of the new class
    @param super: the base class for the new class. if the new class is not based on any other class, pass nullptr
    @returns pointer to the created class. If such a class already exists, a pointer to it will be returned. Pointers to other existing classes may be invalidated by this call.

ida_expr.add_idc_func(name, fp, args, defvals = , flags = 0)
    Add an IDC function. This function does not modify the predefined kernel functions. Example: 
         error_t idaapi myfunc5(idc_value_t *argv, idc_value_t *res)
        
          msg("myfunc is called with arg0=%a and arg1=%s\n", argv[0].num, argv[1].str);
          res->num = 5;     // let's return 5
          return eOk;
        
         const char myfunc5_args[] = { VT_LONG, VT_STR, 0 };
         const ext_idcfunc_t myfunc_desc = { "MyFunc5", myfunc5, myfunc5_args, nullptr, 0, EXTFUN_BASE };
        
         after this:
        
        
         there is a new IDC function which can be called like this:
         "test");
    
    
            
    @returns success

ida_expr.add_idc_gvar(name: str) -> "idc_value_t *"
    Add global IDC variable. 
            
    @param name: name of the global variable
    @returns pointer to the created variable or existing variable. NB: the returned pointer is valid until a new global var is added.

ida_expr.call_idc_func__(*args)

ida_expr.compile_idc_file(nonnul_line: str) -> str

ida_expr.compile_idc_snippet(func: str, text: str, resolver: "idc_resolver_t *" = None, only_safe_funcs: bool = False) -> str
    Compile text with IDC statements. 
            
    @param func: name of the function to create out of the snippet
    @param text: text to compile
    @param resolver: callback object to get values of undefined variables This object will be called if IDC function contains references to undefined variables. May be nullptr.
    @param only_safe_funcs: if true, any calls to functions without EXTFUN_SAFE flag will lead to a compilation error.
    @retval true: ok
    @retval false: error, see errbuf

ida_expr.compile_idc_text(nonnul_line: str) -> str

ida_expr.copy_idcv(dst: "idc_value_t", src: "idc_value_t") -> "error_t"
    Copy 'src' to 'dst'. For idc objects only a reference is copied. 
            

ida_expr.create_idcv_ref(ref: "idc_value_t", v: "idc_value_t") -> bool
    Create a variable reference. Currently only references to global variables can be created. 
            
    @param ref: ptr to the result
    @param v: variable to reference
    @returns success

ida_expr.deep_copy_idcv(dst: "idc_value_t", src: "idc_value_t") -> "error_t"
    Deep copy an IDC object. This function performs deep copy of idc objects. If 'src' is not an object, copy_idcv() will be called 
            

ida_expr.del_idc_func(name)
    Delete an IDC function 
            

ida_expr.del_idcv_attr(obj: "idc_value_t", attr: str) -> "error_t"
    Delete an object attribute. 
            
    @param obj: variable that holds an object reference
    @param attr: attribute name
    @returns error code, eOk on success

ida_expr.deref_idcv(v: "idc_value_t", vref_flags: int) -> "idc_value_t *"
    Dereference a VT_REF variable. 
            
    @param v: variable to dereference
    @param vref_flags: Dereference IDC variable flags
    @returns pointer to the dereference result or nullptr. If returns nullptr, qerrno is set to eExecBadRef "Illegal variable reference"

ida_expr.eExecThrow
    See return value of idc_func_t.

ida_expr.eval_expr(rv: "idc_value_t", where: ida_idaapi.ea_t, line: str) -> str
    Compile and calculate an expression. 
            
    @param rv: pointer to the result
    @param where: the current linear address in the addressing space of the program being disassembled. If will be used to resolve names of local variables etc. if not applicable, then should be BADADDR.
    @param line: the expression to evaluate
    @retval true: ok
    @retval false: error, see errbuf

ida_expr.eval_idc_expr(rv: "idc_value_t", where: ida_idaapi.ea_t, line: str) -> str
    Same as eval_expr(), but will always use the IDC interpreter regardless of the currently installed extlang. 
            

ida_expr.exec_idc_script(result: "idc_value_t", path: str, func: str, args: "idc_value_t", argsnum: "size_t") -> str
    Compile and execute IDC function(s) from file. 
            
    @param result: ptr to idc_value_t to hold result of the function. If execution fails, this variable will contain the exception information. You may pass nullptr if you are not interested in the returned value.
    @param path: text file containing text of IDC functions
    @param func: function name to execute
    @param args: array of parameters
    @param argsnum: number of parameters to pass to 'fname' This number should be equal to number of parameters the function expects.
    @retval true: ok
    @retval false: error, see errbuf

ida_expr.exec_system_script(file: str, complain_if_no_file: bool = True) -> bool
    Compile and execute "main" function from system file. 
            
    @param file: file name with IDC function(s). The file will be searched using get_idc_filename().
    @param complain_if_no_file: * 1: display warning if the file is not found
    * 0: don't complain if file doesn't exist
    @retval 1: ok, file is compiled and executed
    @retval 0: failure, compilation or execution error, warning is displayed

ida_expr.find_idc_class(name: str) -> "idc_class_t *"
    Find an existing IDC class by its name. 
            
    @param name: name of the class
    @returns pointer to the class or nullptr. The returned pointer is valid until a new call to add_idc_class()

ida_expr.find_idc_func(prefix: str, n: int = 0) -> str

ida_expr.find_idc_gvar(name: str) -> "idc_value_t *"
    Find an existing global IDC variable by its name. 
            
    @param name: name of the global variable
    @returns pointer to the variable or nullptr. NB: the returned pointer is valid until a new global var is added. FIXME: it is difficult to use this function in a thread safe manner

ida_expr.first_idcv_attr(obj: "idc_value_t") -> str

ida_expr.free_idcv(v: "idc_value_t") -> None
    Free storage used by VT_STR/VT_OBJ IDC variables. After this call the variable has a numeric value 0 
            

ida_expr.get_idc_filename(file: str) -> str
    Get full name of IDC file name. Search for file in list of include directories, IDCPATH directory and system directories. 
            
    @param file: file name without full path
    @returns nullptr is file not found. otherwise returns pointer to buf

ida_expr.get_idcv_attr(res: "idc_value_t", obj: "idc_value_t", attr: str, may_use_getattr: bool = False) -> "error_t"
    Get an object attribute. 
            
    @param res: buffer for the attribute value
    @param obj: variable that holds an object reference. if obj is nullptr it searches global variables, then user functions
    @param attr: attribute name
    @param may_use_getattr: may call getattr functions to calculate the attribute if it does not exist
    @returns error code, eOk on success

ida_expr.get_idcv_class_name(obj: "idc_value_t") -> str
    Retrieves the IDC object class name. 
            
    @param obj: class instance variable
    @returns error code, eOk on success

ida_expr.get_idcv_slice(res: "idc_value_t", v: "idc_value_t", i1: int, i2: int, flags: int = 0) -> "error_t"
    Get slice. 
            
    @param res: output variable that will contain the slice
    @param v: input variable (string or object)
    @param i1: slice start index
    @param i2: slice end index (excluded)
    @param flags: IDC variable slice flags or 0
    @returns eOk if success

ida_expr.highlighter_cbs_t

ida_expr.highlighter_cbs_t.__disown__(self)

ida_expr.highlighter_cbs_t.__init__(self)

ida_expr.highlighter_cbs_t.cur_block_state(self) -> int

ida_expr.highlighter_cbs_t.prev_block_state(self) -> int

ida_expr.highlighter_cbs_t.set_block_state(self, arg0: int) -> None

ida_expr.highlighter_cbs_t.set_style(self, arg0: int, arg1: int, arg2: "syntax_highlight_style") -> None

ida_expr.idc_global_t

ida_expr.idc_global_t.__init__(self, *args)

ida_expr.idc_value_t

ida_expr.idc_value_t.__init__(self, *args)

ida_expr.idc_value_t._create_empty_string(self) -> None

ida_expr.idc_value_t.c_str(self) -> str
    VT_STR

ida_expr.idc_value_t.clear(self) -> None
    See free_idcv()

ida_expr.idc_value_t.create_empty_string(self) -> None

ida_expr.idc_value_t.e
    VT_FLOAT

ida_expr.idc_value_t.funcidx
    VT_FUNC

ida_expr.idc_value_t.i64
    VT_INT64

ida_expr.idc_value_t.is_convertible(self) -> bool
    Convertible types are VT_LONG, VT_FLOAT, VT_INT64, and VT_STR.

ida_expr.idc_value_t.is_integral(self) -> bool
    Does value represent a whole number? 
            

ida_expr.idc_value_t.is_zero(self) -> bool
    Does value represent the integer 0?

ida_expr.idc_value_t.num
    VT_LONG

ida_expr.idc_value_t.pvoid
    VT_PVOID

ida_expr.idc_value_t.qstr(self) -> str
    VT_STR

ida_expr.idc_value_t.reserve
    VT_STR.

ida_expr.idc_value_t.set_float(self, f: "fpvalue_t const &") -> None

ida_expr.idc_value_t.set_int64(self, v: "int64") -> None

ida_expr.idc_value_t.set_long(self, v: int) -> None

ida_expr.idc_value_t.set_pvoid(self, p: "void *") -> None

ida_expr.idc_value_t.set_string(self, *args) -> None

ida_expr.idc_value_t.swap(self, v: "idc_value_t") -> None
    Set this = r and v = this.

ida_expr.idc_value_t.u_str(self) -> "uchar const *"
    VT_STR

ida_expr.idc_value_t.vtype
    IDC value types

ida_expr.idc_values_t

ida_expr.idc_values_t.__getitem__(self, i: "size_t") -> "idc_value_t const &"

ida_expr.idc_values_t.__init__(self, *args)

ida_expr.idc_values_t.__len__(self) -> "size_t"

ida_expr.idc_values_t.__setitem__(self, i: "size_t", v: "idc_value_t") -> None

ida_expr.idc_values_t.append(self, x: "idc_value_t") -> None

ida_expr.idc_values_t.at(self, _idx: "size_t") -> "idc_value_t const &"

ida_expr.idc_values_t.begin(self, *args) -> "qvector< idc_value_t >::const_iterator"

ida_expr.idc_values_t.capacity(self) -> "size_t"

ida_expr.idc_values_t.clear(self) -> None

ida_expr.idc_values_t.empty(self) -> bool

ida_expr.idc_values_t.end(self, *args) -> "qvector< idc_value_t >::const_iterator"

ida_expr.idc_values_t.erase(self, *args) -> "qvector< idc_value_t >::iterator"

ida_expr.idc_values_t.extend(self, x: "idc_values_t") -> None

ida_expr.idc_values_t.extract(self) -> "idc_value_t *"

ida_expr.idc_values_t.grow(self, *args) -> None

ida_expr.idc_values_t.inject(self, s: "idc_value_t", len: "size_t") -> None

ida_expr.idc_values_t.insert(self, it: "idc_value_t", x: "idc_value_t") -> "qvector< idc_value_t >::iterator"

ida_expr.idc_values_t.pop_back(self) -> None

ida_expr.idc_values_t.push_back(self, *args) -> "idc_value_t &"

ida_expr.idc_values_t.qclear(self) -> None

ida_expr.idc_values_t.reserve(self, cnt: "size_t") -> None

ida_expr.idc_values_t.resize(self, *args) -> None

ida_expr.idc_values_t.size(self) -> "size_t"

ida_expr.idc_values_t.swap(self, r: "idc_values_t") -> None

ida_expr.idc_values_t.truncate(self) -> None

ida_expr.idcv_float(v: "idc_value_t") -> "error_t"
    Convert IDC variable to a floating point.

ida_expr.idcv_int64(v: "idc_value_t") -> "error_t"
    Convert IDC variable to a 64bit number. 
            
    @returns v = 0 if impossible to convert to int64

ida_expr.idcv_long(v: "idc_value_t") -> "error_t"
    Convert IDC variable to a long (32/64bit) number. 
            
    @returns v = 0 if impossible to convert to long

ida_expr.idcv_num(v: "idc_value_t") -> "error_t"
    Convert IDC variable to a long number. 
            
    @returns * v = 0 if IDC variable = "false" string
    * v = 1 if IDC variable = "true" string
    * v = number if IDC variable is number or string containing a number
    * eTypeConflict if IDC variable = empty string

ida_expr.idcv_object(v: "idc_value_t", icls: "idc_class_t const *" = None) -> "error_t"
    Create an IDC object. The original value of 'v' is discarded (freed). 
            
    @param v: variable to hold the object. any previous value will be cleaned
    @param icls: ptr to the desired class. nullptr means "object" class this ptr must be returned by add_idc_class() or find_idc_class()
    @returns always eOk

ida_expr.idcv_string(v: "idc_value_t") -> "error_t"
    Convert IDC variable to a text string.

ida_expr.last_idcv_attr(obj: "idc_value_t") -> str

ida_expr.move_idcv(dst: "idc_value_t", src: "idc_value_t") -> "error_t"
    Move 'src' to 'dst'. This function is more effective than copy_idcv since it never copies big amounts of data. 
            

ida_expr.next_idcv_attr(obj: "idc_value_t", attr: str) -> str

ida_expr.prev_idcv_attr(obj: "idc_value_t", attr: str) -> str

ida_expr.print_idcv(v: "idc_value_t", name: str = None, indent: int = 0) -> str
    Get text representation of idc_value_t.

ida_expr.py_add_idc_func(name: str, fp_ptr: "size_t", args: str, defvals: "idc_values_t", flags: int) -> bool

ida_expr.py_get_call_idc_func() -> "size_t"

ida_expr.pyw_convert_defvals(out: "idc_values_t", py_seq: "PyObject *") -> bool

ida_expr.pyw_register_idc_func(name: str, args: str, py_fp: "PyObject *") -> "size_t"

ida_expr.pyw_unregister_idc_func(ctxptr: "size_t") -> bool

ida_expr.set_header_path(path: str, add: bool) -> bool
    Set or append a header path. IDA looks for the include files in the appended header paths, then in the ida executable directory. 
            
    @param path: list of directories to add (separated by ';') may be nullptr, in this case nothing is added
    @param add: true: append. false: remove old paths.
    @retval true: success
    @retval false: no memory

ida_expr.set_idcv_attr(obj: "idc_value_t", attr: str, value: "idc_value_t", may_use_setattr: bool = False) -> "error_t"
    Set an object attribute. 
            
    @param obj: variable that holds an object reference. if obj is nullptr then it tries to modify a global variable with the attribute name
    @param attr: attribute name
    @param value: new attribute value
    @param may_use_setattr: may call setattr functions for the class
    @returns error code, eOk on success

ida_expr.set_idcv_slice(v: "idc_value_t", i1: int, i2: int, _in: "idc_value_t", flags: int = 0) -> "error_t"
    Set slice. 
            
    @param v: variable to modify (string or object)
    @param i1: slice start index
    @param i2: slice end index (excluded)
    @param flags: IDC variable slice flags or 0
    @returns eOk on success

ida_expr.swap_idcvs(v1: "idc_value_t", v2: "idc_value_t") -> None
    Swap 2 variables.

ida_expr.throw_idc_exception(r: "idc_value_t", desc: str) -> "error_t"
    Create an idc execution exception object. This helper function can be used to return an exception from C++ code to IDC. In other words this function can be called from idc_func_t() callbacks. Sample usage: if ( !ok ) return throw_idc_exception(r, "detailed error msg"); 
            
    @param r: object to hold the exception object
    @param desc: exception description
    @returns eExecThrow

ida_fixup
    Functions that deal with fixup information.
    
    A loader should setup fixup information using set_fixup(). 
        

ida_fixup.FIXUPF_CREATED
    fixup was not present in the input file

ida_fixup.FIXUPF_EXTDEF
    target is a location (otherwise - segment). Use this bit if the target is a symbol rather than an offset from the beginning of a segment. 
            

ida_fixup.FIXUPF_LOADER_MASK
    additional flags. The bits from this mask are not stored in the database and can be used by the loader at its discretion. 
            

ida_fixup.FIXUPF_REL
    fixup is relative to the linear address `base`. Otherwise fixup is relative to the start of the segment with `sel` selector. 
            

ida_fixup.FIXUPF_UNUSED
    fixup is ignored by IDA
    * disallows the kernel to convert operands
    * this fixup is not used during output 
    
    
            

ida_fixup.FIXUP_CUSTOM
    start of the custom types range

ida_fixup.FIXUP_HI16
    high 16 bits of 32bit offset

ida_fixup.FIXUP_HI8
    high 8 bits of 16bit offset

ida_fixup.FIXUP_LOW16
    low 16 bits of 32bit offset

ida_fixup.FIXUP_LOW8
    low 8 bits of 16bit offset

ida_fixup.FIXUP_OFF16
    16-bit offset

ida_fixup.FIXUP_OFF16S
    16-bit signed offset

ida_fixup.FIXUP_OFF32
    32-bit offset

ida_fixup.FIXUP_OFF32S
    32-bit signed offset

ida_fixup.FIXUP_OFF64
    64-bit offset

ida_fixup.FIXUP_OFF8
    8-bit offset

ida_fixup.FIXUP_OFF8S
    8-bit signed offset

ida_fixup.FIXUP_PTR16
    32-bit long pointer (16-bit base:16-bit offset) 
            

ida_fixup.FIXUP_PTR32
    48-bit pointer (16-bit base:32-bit offset)

ida_fixup.FIXUP_SEG16
    16-bit base-logical segment base (selector)

ida_fixup.V695_FIXUP_VHIGH
    obsolete

ida_fixup.V695_FIXUP_VLOW
    obsolete

ida_fixup.calc_fixup_size(type: "fixup_type_t") -> int
    Calculate size of fixup in bytes (the number of bytes the fixup patches) 
            
    @retval -1: means error

ida_fixup.contains_fixups(ea: ida_idaapi.ea_t, size: "asize_t") -> bool
    Does the specified address range contain any fixup information?

ida_fixup.del_fixup(source: ida_idaapi.ea_t) -> None
    Delete fixup information.

ida_fixup.exists_fixup(source: ida_idaapi.ea_t) -> bool
    Check that a fixup exists at the given address.

ida_fixup.find_custom_fixup(name: str) -> "fixup_type_t"

ida_fixup.fixup_data_t

ida_fixup.fixup_data_t.__init__(self, *args)

ida_fixup.fixup_data_t.calc_size(self) -> int
    calc_fixup_size()

ida_fixup.fixup_data_t.clr_extdef(self) -> None

ida_fixup.fixup_data_t.clr_unused(self) -> None

ida_fixup.fixup_data_t.displacement
    displacement (offset from the target)

ida_fixup.fixup_data_t.get(self, source: ida_idaapi.ea_t) -> bool
    get_fixup()

ida_fixup.fixup_data_t.get_base(self) -> ida_idaapi.ea_t
    Get base of fixup. 
            

ida_fixup.fixup_data_t.get_desc(self, source: ida_idaapi.ea_t) -> str
    get_fixup_desc()

ida_fixup.fixup_data_t.get_flags(self) -> int
    Fixup flags Fixup flags.

ida_fixup.fixup_data_t.get_handler(self) -> "fixup_handler_t const *"
    get_fixup_handler()

ida_fixup.fixup_data_t.get_type(self) -> "fixup_type_t"
    Fixup type Types of fixups.

ida_fixup.fixup_data_t.get_value(self, ea: ida_idaapi.ea_t) -> int
    get_fixup_value()

ida_fixup.fixup_data_t.has_base(self) -> bool
    Is fixup relative?

ida_fixup.fixup_data_t.is_custom(self) -> bool
    is_fixup_custom()

ida_fixup.fixup_data_t.is_extdef(self) -> bool

ida_fixup.fixup_data_t.is_unused(self) -> bool

ida_fixup.fixup_data_t.off
    target offset 
            

ida_fixup.fixup_data_t.patch_value(self, ea: ida_idaapi.ea_t) -> bool
    patch_fixup_value()

ida_fixup.fixup_data_t.sel
    selector of the target segment. BADSEL means an absolute (zero based) target. 
            

ida_fixup.fixup_data_t.set(self, source: ida_idaapi.ea_t) -> None
    set_fixup()

ida_fixup.fixup_data_t.set_base(self, new_base: ida_idaapi.ea_t) -> None
    Set base of fixup. The target should be set before a call of this function. 
            

ida_fixup.fixup_data_t.set_extdef(self) -> None

ida_fixup.fixup_data_t.set_sel(self, seg: "segment_t const *") -> None

ida_fixup.fixup_data_t.set_target_sel(self) -> None
    Set selector of fixup to the target. The target should be set before a call of this function. 
            

ida_fixup.fixup_data_t.set_type(self, type_: "fixup_type_t") -> None

ida_fixup.fixup_data_t.set_type_and_flags(self, type_: "fixup_type_t", flags_: int = 0) -> None

ida_fixup.fixup_data_t.set_unused(self) -> None

ida_fixup.fixup_data_t.was_created(self) -> bool
    Is fixup artificial?

ida_fixup.fixup_info_t

ida_fixup.fixup_info_t.__init__(self)

ida_fixup.gen_fix_fixups(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, size: "asize_t") -> None
    Relocate the bytes with fixup information once more (generic function). This function may be called from loader_t::move_segm() if it suits the goal. If loader_t::move_segm is not defined then this function will be called automatically when moving segments or rebasing the entire program. Special parameter values (from = BADADDR, size = 0, to = delta) are used when the function is called from rebase_program(delta). 
            

ida_fixup.get_first_fixup_ea() -> ida_idaapi.ea_t

ida_fixup.get_fixup(fd: "fixup_data_t", source: ida_idaapi.ea_t) -> bool
    Get fixup information.

ida_fixup.get_fixup_desc(source: ida_idaapi.ea_t, fd: "fixup_data_t") -> str
    Get FIXUP description comment.

ida_fixup.get_fixup_handler(type: "fixup_type_t") -> "fixup_handler_t const *"
    Get handler of standard or custom fixup.

ida_fixup.get_fixup_value(ea: ida_idaapi.ea_t, type: "fixup_type_t") -> int
    Get the operand value. This function get fixup bytes from data or an instruction at `ea` and convert them to the operand value (maybe partially). It is opposite in meaning to the `patch_fixup_value()`. For example, FIXUP_HI8 read a byte at `ea` and shifts it left by 8 bits, or AArch64's custom fixup BRANCH26 get low 26 bits of the insn at `ea` and shifts it left by 2 bits. This function is mainly used to get a relocation addend. 
            
    @param ea: address to get fixup bytes from, the size of the fixup bytes depends on the fixup type.
    @param type: fixup type
    @retval operand: value

ida_fixup.get_fixups(out: "fixups_t *", ea: ida_idaapi.ea_t, size: "asize_t") -> bool

ida_fixup.get_next_fixup_ea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_fixup.get_prev_fixup_ea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_fixup.handle_fixups_in_macro(ri: "refinfo_t", ea: ida_idaapi.ea_t, other: "fixup_type_t", macro_reft_and_flags: int) -> bool
    Handle two fixups in a macro. We often combine two instruction that load parts of a value into one macro instruction. For example: 
           ADRP  X0, #var@PAGE
               ADD   X0, X0, #var@PAGEOFF  --> ADRL X0, var
          lui   $v0, %hi(var)
               addiu $v0, $v0, %lo(var)    --> la   $v0, var
    
    
            
    @returns success ('false' means that RI was not changed)

ida_fixup.is_fixup_custom(type: "fixup_type_t") -> bool
    Is fixup processed by processor module?

ida_fixup.patch_fixup_value(ea: ida_idaapi.ea_t, fd: "fixup_data_t") -> bool
    Patch the fixup bytes. This function updates data or an instruction at `ea` to the fixup bytes. For example, FIXUP_HI8 updates a byte at `ea` to the high byte of `fd->off`, or AArch64's custom fixup BRANCH26 updates low 26 bits of the insn at `ea` to the value of `fd->off` shifted right by 2. 
            
    @param ea: address where data are changed, the size of the changed data depends on the fixup type.
    @param fd: fixup data
    @retval false: the fixup bytes do not fit (e.g. `fd->off` is greater than 0xFFFFFFC for BRANCH26). The database is changed even in this case.

ida_fixup.set_fixup(source: ida_idaapi.ea_t, fd: "fixup_data_t") -> None
    Set fixup information. You should fill fixup_data_t and call this function and the kernel will remember information in the database. 
            
    @param source: the fixup source address, i.e. the address modified by the fixup
    @param fd: fixup data

ida_fpro
    System independent counterparts of FILE* related functions from Clib.
    
    You should not use C standard I/O functions in your modules. The reason: Each module compiled with Borland (and statically linked to Borland's library) will host a copy of the FILE * information.
    So, if you open a file in the plugin and pass the handle to the kernel, the kernel will not be able to use it.
    If you really need to use the standard functions, define USE_STANDARD_FILE_FUNCTIONS. In this case do not mix them with q... functions. 
        

ida_fpro.qfclose(fp: "FILE *") -> int

ida_fpro.qfile_t
    A helper class to work with FILE related functions.

ida_fpro.qfile_t.__init__(self, *args)

ida_fpro.qfile_t.close(self)
    Closes the file

ida_fpro.qfile_t.filename(self) -> "PyObject *"

ida_fpro.qfile_t.flush(self)

ida_fpro.qfile_t.from_capsule(pycapsule: "PyObject *") -> "qfile_t *"

ida_fpro.qfile_t.from_fp(fp: "FILE *") -> "qfile_t *"

ida_fpro.qfile_t.get_byte(self)
    Reads a single byte from the file. Returns None if EOF or the read byte

ida_fpro.qfile_t.get_fp(self) -> "FILE *"

ida_fpro.qfile_t.gets(self, len)
    Reads a line from the input file. Returns the read line or None
    
    @param len: the maximum line length

ida_fpro.qfile_t.open(self, filename, mode)
    Opens a file
    
    @param filename: the file name
    @param mode: The mode string, ala fopen() style
    @return: Boolean

ida_fpro.qfile_t.opened(self)
    Checks if the file is opened or not

ida_fpro.qfile_t.put_byte(self)
    Writes a single byte to the file
    
    @param chr: the byte value

ida_fpro.qfile_t.puts(self, str: str) -> int

ida_fpro.qfile_t.read(self, size)
    Reads from the file. Returns the buffer or None
    
    @param size: the maximum number of bytes to read
    @return: a str, or None

ida_fpro.qfile_t.readbytes(self, size, big_endian)
    Similar to read() but it respect the endianness
    
    @param size: the maximum number of bytes to read
    @param big_endian: endianness
    @return a str, or None

ida_fpro.qfile_t.seek(self, offset, whence = ida_idaapi.SEEK_SET)
    Set input source position
    
    @param offset: the seek offset
    @param whence: the position to seek from
    @return: the new position (not 0 as fseek!)

ida_fpro.qfile_t.size(self) -> "int64"

ida_fpro.qfile_t.tell(self)
    Returns the current position

ida_fpro.qfile_t.tmpfile()
    A static method to construct an instance using a temporary file

ida_fpro.qfile_t.write(self, buf)
    Writes to the file. Returns 0 or the number of bytes written
    
    @param buf: the str to write
    @return: result code

ida_fpro.qfile_t.writebytes(self, size, big_endian)
    Similar to write() but it respect the endianness
    
    @param buf: the str to write
    @param big_endian: endianness
    @return: result code

ida_frame
    Routines to manipulate function stack frames, stack variables, register variables and local labels.
    
    The frame is represented as a structure: 
      +------------------------------------------------+
      | function arguments                             |
      +------------------------------------------------+
      | return address (isn't stored in func_t)        |
      +------------------------------------------------+
      | saved registers (SI, DI, etc - func_t::frregs) |
      +------------------------------------------------+ <- typical BP
      |                                                |  |
      |                                                |  | func_t::fpd
      |                                                |  |
      |                                                | <- real BP
      | local variables (func_t::frsize)               |
      |                                                |
      |                                                |
      +------------------------------------------------+ <- SP
    
    To access the structure of a function frame and stack variables, use:
    * tinfo_t::get_func_frame(const func_t *pfn) (the preferred way)
    * get_func_frame(tinfo_t *out, const func_t *pfn)
    * tinfo_t::get_udt_details() gives info about stack variables: their type, names, offset, etc 
    
    
        

ida_frame.REGVAR_ERROR_ARG
    function arguments are bad

ida_frame.REGVAR_ERROR_NAME
    the provided name(s) can't be accepted

ida_frame.REGVAR_ERROR_OK
    all ok

ida_frame.REGVAR_ERROR_RANGE
    the definition range is bad

ida_frame.STKVAR_VALID_SIZE
    x.dtyp contains correct variable type (for insns like 'lea' this bit must be off). In general, dr_O references do not allow to determine the variable size 
            

ida_frame.add_auto_stkpnt(pfn: "func_t *", ea: ida_idaapi.ea_t, delta: int) -> bool
    Add automatic SP register change point. 
            
    @param pfn: pointer to the function. may be nullptr.
    @param ea: linear address where SP changes. usually this is the end of the instruction which modifies the stack pointer ( insn_t::ea+ insn_t::size)
    @param delta: difference between old and new values of SP
    @returns success

ida_frame.add_frame(pfn: "func_t *", frsize: int, frregs: "ushort", argsize: "asize_t") -> bool
    Add function frame. 
            
    @param pfn: pointer to function structure
    @param frsize: size of function local variables
    @param frregs: size of saved registers
    @param argsize: size of function arguments range which will be purged upon return. this parameter is used for __stdcall and __pascal calling conventions. for other calling conventions please pass 0.
    @retval 1: ok
    @retval 0: failed (no function, frame already exists)

ida_frame.add_frame_member(pfn: "func_t const *", name: str, offset: int, tif: "tinfo_t", repr: "value_repr_t" = None, etf_flags: "uint" = 0) -> bool
    Add member to the frame type 
            
    @param pfn: pointer to function
    @param name: variable name, nullptr means autogenerate a name
    @param offset: member offset in the frame structure, in bytes
    @param tif: variable type
    @param repr: variable representation
    @returns success

ida_frame.add_regvar(pfn: "func_t *", ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str, user: str, cmt: str) -> int
    Define a register variable. 
            
    @param pfn: function in which the definition will be created
    @param ea1: range of addresses within the function where the definition will be used
    @param ea2: range of addresses within the function where the definition will be used
    @param canon: name of a general register
    @param user: user-defined name for the register
    @param cmt: comment for the definition
    @returns Register variable error codes

ida_frame.add_user_stkpnt(ea: ida_idaapi.ea_t, delta: int) -> bool
    Add user-defined SP register change point. 
            
    @param ea: linear address where SP changes
    @param delta: difference between old and new values of SP
    @returns success

ida_frame.build_stkvar_name(pfn: "func_t const *", v: int) -> str
    Build automatic stack variable name. 
            
    @param pfn: pointer to function (can't be nullptr!)
    @param v: value of variable offset
    @returns length of stack variable name or -1

ida_frame.build_stkvar_xrefs(out: "xreflist_t", pfn: "func_t *", start_offset: int, end_offset: int) -> None
    Fill 'out' with a list of all the xrefs made from function 'pfn' to specified range of the pfn's stack frame. 
            
    @param out: the list of xrefs to fill.
    @param pfn: the function to scan.
    @param start_offset: start frame structure offset, in bytes
    @param end_offset: end frame structure offset, in bytes

ida_frame.calc_frame_offset(pfn: "func_t *", off: int, insn: "insn_t const *" = None, op: "op_t const *" = None) -> int
    Calculate the offset of stack variable in the frame. 
            
    @param pfn: pointer to function (cannot be nullptr)
    @param off: the offset relative to stack pointer or frame pointer
    @param insn: the instruction
    @param op: the operand
    @returns the offset in the frame

ida_frame.calc_stkvar_struc_offset(pfn: "func_t *", insn: "insn_t const &", n: int) -> ida_idaapi.ea_t
    Calculate offset of stack variable in the frame structure. 
            
    @param pfn: pointer to function (cannot be nullptr)
    @param insn: the instruction
    @param n: 0..UA_MAXOP-1 operand number -1 if error, return BADADDR
    @returns BADADDR if some error (issue a warning if stack frame is bad)

ida_frame.define_stkvar(pfn: "func_t *", name: str, off: int, tif: "tinfo_t", repr: "value_repr_t" = None) -> bool
    Define/redefine a stack variable. 
            
    @param pfn: pointer to function
    @param name: variable name, nullptr means autogenerate a name
    @param off: offset of the stack variable in the frame. negative values denote local variables, positive - function arguments.
    @param tif: variable type
    @param repr: variable representation
    @returns success

ida_frame.del_frame(pfn: "func_t *") -> bool
    Delete a function frame. 
            
    @param pfn: pointer to function structure
    @returns success

ida_frame.del_regvar(pfn: "func_t *", ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str) -> int
    Delete a register variable definition. 
            
    @param pfn: function in question
    @param ea1: range of addresses within the function where the definition holds
    @param ea2: range of addresses within the function where the definition holds
    @param canon: name of a general register
    @returns Register variable error codes

ida_frame.del_stkpnt(pfn: "func_t *", ea: ida_idaapi.ea_t) -> bool
    Delete SP register change point. 
            
    @param pfn: pointer to the function. may be nullptr.
    @param ea: linear address
    @returns success

ida_frame.delete_frame_members(pfn: "func_t const *", start_offset: int, end_offset: int) -> bool
    Delete frame members 
            
    @param pfn: pointer to function
    @param start_offset: member offset to start deletion from, in bytes
    @param end_offset: member offset which not included in the deletion, in bytes
    @returns success

ida_frame.find_regvar(*args) -> "regvar_t *"
    This function has the following signatures:
    
        0. find_regvar(pfn: func_t *, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str, user: str) -> regvar_t *
        1. find_regvar(pfn: func_t *, ea: ida_idaapi.ea_t, canon: str) -> regvar_t *
    
    # 0: find_regvar(pfn: func_t *, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str, user: str) -> regvar_t *
    
    Find a register variable definition (powerful version). One of 'canon' and 'user' should be nullptr. If both 'canon' and 'user' are nullptr it returns the first regvar definition in the range. 
            
    @returns nullptr-not found, otherwise ptr to regvar_t
    
    # 1: find_regvar(pfn: func_t *, ea: ida_idaapi.ea_t, canon: str) -> regvar_t *
    
    Find a register variable definition. 
            
    @returns nullptr-not found, otherwise ptr to regvar_t

ida_frame.frame_off_args(pfn: "func_t const *") -> ida_idaapi.ea_t
    Get starting address of arguments section.

ida_frame.frame_off_lvars(pfn: "func_t const *") -> ida_idaapi.ea_t
    Get start address of local variables section.

ida_frame.frame_off_retaddr(pfn: "func_t const *") -> ida_idaapi.ea_t
    Get starting address of return address section.

ida_frame.frame_off_savregs(pfn: "func_t const *") -> ida_idaapi.ea_t
    Get starting address of saved registers section.

ida_frame.free_regvar(v: "regvar_t") -> None

ida_frame.get_effective_spd(pfn: "func_t *", ea: ida_idaapi.ea_t) -> int
    Get effective difference between the initial and current values of ESP. This function returns the sp-diff used by the instruction. The difference between get_spd() and get_effective_spd() is present only for instructions like "pop [esp+N]": they modify sp and use the modified value. 
            
    @param pfn: pointer to the function. may be nullptr.
    @param ea: linear address
    @returns 0 or the difference, usually a negative number

ida_frame.get_frame_part(range: "range_t", pfn: "func_t const *", part: "frame_part_t") -> None
    Get offsets of the frame part in the frame. 
            
    @param range: pointer to the output buffer with the frame part start/end(exclusive) offsets, can't be nullptr
    @param pfn: pointer to function structure, can't be nullptr
    @param part: frame part

ida_frame.get_frame_retsize(pfn: "func_t const *") -> int
    Get size of function return address. 
            
    @param pfn: pointer to function structure, can't be nullptr

ida_frame.get_frame_size(pfn: "func_t const *") -> "asize_t"
    Get full size of a function frame. This function takes into account size of local variables + size of saved registers + size of return address + number of purged bytes. The purged bytes correspond to the arguments of the functions with __stdcall and __fastcall calling conventions. 
            
    @param pfn: pointer to function structure, may be nullptr
    @returns size of frame in bytes or zero

ida_frame.get_func_frame(out: "tinfo_t", pfn: "func_t const *") -> bool
    Get type of function frame 
            
    @param out: type info
    @param pfn: pointer to function structure
    @returns success

ida_frame.get_sp_delta(pfn: "func_t *", ea: ida_idaapi.ea_t) -> int
    Get modification of SP made at the specified location 
            
    @param pfn: pointer to the function. may be nullptr.
    @param ea: linear address
    @returns 0 if the specified location doesn't contain a SP change point. otherwise return delta of SP modification.

ida_frame.get_spd(pfn: "func_t *", ea: ida_idaapi.ea_t) -> int
    Get difference between the initial and current values of ESP. 
            
    @param pfn: pointer to the function. may be nullptr.
    @param ea: linear address of the instruction
    @returns 0 or the difference, usually a negative number. returns the sp-diff before executing the instruction.

ida_frame.has_regvar(pfn: "func_t *", ea: ida_idaapi.ea_t) -> bool
    Is there a register variable definition? 
            
    @param pfn: function in question
    @param ea: current address

ida_frame.is_anonymous_member_name(name: str) -> bool
    Is member name prefixed with "anonymous"?

ida_frame.is_dummy_member_name(name: str) -> bool
    Is member name an auto-generated name?

ida_frame.is_funcarg_off(pfn: "func_t const *", frameoff: int) -> bool

ida_frame.is_special_frame_member(tid: "tid_t") -> bool
    Is stkvar with TID the return address slot or the saved registers slot ? 
            
    @param tid: frame member type id return address or saved registers member?

ida_frame.lvar_off(pfn: "func_t const *", frameoff: int) -> int

ida_frame.recalc_spd(cur_ea: ida_idaapi.ea_t) -> bool
    Recalculate SP delta for an instruction that stops execution. The next instruction is not reached from the current instruction. We need to recalculate SP for the next instruction.
    This function will create a new automatic SP register change point if necessary. It should be called from the emulator (emu.cpp) when auto_state == AU_USED if the current instruction doesn't pass the execution flow to the next instruction. 
            
    @param cur_ea: linear address of the current instruction
    @retval 1: new stkpnt is added
    @retval 0: nothing is changed

ida_frame.recalc_spd_for_basic_block(pfn: "func_t *", cur_ea: ida_idaapi.ea_t) -> bool
    Recalculate SP delta for the current instruction. The typical code snippet to calculate SP delta in a proc module is:
    
    if ( may_trace_sp() && pfn != nullptr )
      if ( !recalc_spd_for_basic_block(pfn, insn.ea) )
        trace_sp(pfn, insn);
    
    where trace_sp() is a typical name for a function that emulates the SP change of an instruction.
    
    @param pfn: pointer to the function
    @param cur_ea: linear address of the current instruction
    @retval true: the cumulative SP delta is set
    @retval false: the instruction at CUR_EA passes flow to the next instruction. SP delta must be set as a result of emulating the current instruction.

ida_frame.regvar_t

ida_frame.regvar_t.__init__(self, *args)

ida_frame.regvar_t.canon
    canonical register name (case-insensitive)

ida_frame.regvar_t.cmt
    comment to appear near definition

ida_frame.regvar_t.swap(self, r: "regvar_t") -> None

ida_frame.regvar_t.user
    user-defined register name

ida_frame.rename_regvar(pfn: "func_t *", v: "regvar_t", user: str) -> int
    Rename a register variable. 
            
    @param pfn: function in question
    @param v: variable to rename
    @param user: new user-defined name for the register
    @returns Register variable error codes

ida_frame.set_auto_spd(pfn: "func_t *", ea: ida_idaapi.ea_t, new_spd: int) -> bool
    Add such an automatic SP register change point so that at EA the new cumulative SP delta (that is, the difference between the initial and current values of SP) would be equal to NEW_SPD. 
            
    @param pfn: pointer to the function. may be nullptr.
    @param ea: linear address of the instruction
    @param new_spd: new value of the cumulative SP delta
    @returns success

ida_frame.set_frame_member_type(pfn: "func_t const *", offset: int, tif: "tinfo_t", repr: "value_repr_t" = None, etf_flags: "uint" = 0) -> bool
    Change type of the frame member 
            
    @param pfn: pointer to function
    @param offset: member offset in the frame structure, in bytes
    @param tif: variable type
    @param repr: variable representation
    @returns success

ida_frame.set_frame_size(pfn: "func_t *", frsize: "asize_t", frregs: "ushort", argsize: "asize_t") -> bool
    Set size of function frame. Note: The returned size may not include all stack arguments. It does so only for __stdcall and __fastcall calling conventions. To get the entire frame size for all cases use frame.get_func_frame(pfn).get_size() 
            
    @param pfn: pointer to function structure
    @param frsize: size of function local variables
    @param frregs: size of saved registers
    @param argsize: size of function arguments that will be purged from the stack upon return
    @returns success

ida_frame.set_purged(ea: ida_idaapi.ea_t, nbytes: int, override_old_value: bool) -> bool
    Set the number of purged bytes for a function or data item (funcptr). This function will update the database and plan to reanalyze items referencing the specified address. It works only for processors with PR_PURGING bit in 16 and 32 bit modes. 
            
    @param ea: address of the function of item
    @param nbytes: number of purged bytes
    @param override_old_value: may overwrite old information about purged bytes
    @returns success

ida_frame.set_regvar_cmt(pfn: "func_t *", v: "regvar_t", cmt: str) -> int
    Set comment for a register variable. 
            
    @param pfn: function in question
    @param v: variable to rename
    @param cmt: new comment
    @returns Register variable error codes

ida_frame.soff_to_fpoff(pfn: "func_t *", soff: int) -> int
    Convert struct offsets into fp-relative offsets. This function converts the offsets inside the udt_type_data_t object into the frame pointer offsets (for example, EBP-relative). 
            

ida_frame.stkpnt_t

ida_frame.stkpnt_t.__eq__(self, r: "stkpnt_t") -> bool

ida_frame.stkpnt_t.__ge__(self, r: "stkpnt_t") -> bool

ida_frame.stkpnt_t.__gt__(self, r: "stkpnt_t") -> bool

ida_frame.stkpnt_t.__init__(self)

ida_frame.stkpnt_t.__le__(self, r: "stkpnt_t") -> bool

ida_frame.stkpnt_t.__lt__(self, r: "stkpnt_t") -> bool

ida_frame.stkpnt_t.__ne__(self, r: "stkpnt_t") -> bool

ida_frame.stkpnt_t.compare(self, r: "stkpnt_t") -> int

ida_frame.stkpnts_t

ida_frame.stkpnts_t.__eq__(self, r: "stkpnts_t") -> bool

ida_frame.stkpnts_t.__ge__(self, r: "stkpnts_t") -> bool

ida_frame.stkpnts_t.__gt__(self, r: "stkpnts_t") -> bool

ida_frame.stkpnts_t.__init__(self)

ida_frame.stkpnts_t.__le__(self, r: "stkpnts_t") -> bool

ida_frame.stkpnts_t.__lt__(self, r: "stkpnts_t") -> bool

ida_frame.stkpnts_t.__ne__(self, r: "stkpnts_t") -> bool

ida_frame.stkpnts_t.compare(self, r: "stkpnts_t") -> int

ida_frame.update_fpd(pfn: "func_t *", fpd: "asize_t") -> bool
    Update frame pointer delta. 
            
    @param pfn: pointer to function structure
    @param fpd: new fpd value. cannot be bigger than the local variable range size.
    @returns success

ida_frame.xreflist_entry_t

ida_frame.xreflist_entry_t.__eq__(self, r: "xreflist_entry_t") -> bool

ida_frame.xreflist_entry_t.__ge__(self, r: "xreflist_entry_t") -> bool

ida_frame.xreflist_entry_t.__gt__(self, r: "xreflist_entry_t") -> bool

ida_frame.xreflist_entry_t.__init__(self)

ida_frame.xreflist_entry_t.__le__(self, r: "xreflist_entry_t") -> bool

ida_frame.xreflist_entry_t.__lt__(self, r: "xreflist_entry_t") -> bool

ida_frame.xreflist_entry_t.__ne__(self, r: "xreflist_entry_t") -> bool

ida_frame.xreflist_entry_t.compare(self, r: "xreflist_entry_t") -> int

ida_frame.xreflist_entry_t.ea
    Location of the insn referencing the stack frame member.

ida_frame.xreflist_entry_t.opnum
    Number of the operand of that instruction.

ida_frame.xreflist_entry_t.type
    The type of xref (cref_t & dref_t)

ida_frame.xreflist_t

ida_frame.xreflist_t.__eq__(self, r: "xreflist_t") -> bool

ida_frame.xreflist_t.__getitem__(self, i: "size_t") -> "xreflist_entry_t const &"

ida_frame.xreflist_t.__init__(self, *args)

ida_frame.xreflist_t.__len__(self) -> "size_t"

ida_frame.xreflist_t.__ne__(self, r: "xreflist_t") -> bool

ida_frame.xreflist_t.__setitem__(self, i: "size_t", v: "xreflist_entry_t") -> None

ida_frame.xreflist_t._del(self, x: "xreflist_entry_t") -> bool

ida_frame.xreflist_t.add_unique(self, x: "xreflist_entry_t") -> bool

ida_frame.xreflist_t.append(self, x: "xreflist_entry_t") -> None

ida_frame.xreflist_t.at(self, _idx: "size_t") -> "xreflist_entry_t const &"

ida_frame.xreflist_t.begin(self, *args) -> "qvector< xreflist_entry_t >::const_iterator"

ida_frame.xreflist_t.capacity(self) -> "size_t"

ida_frame.xreflist_t.clear(self) -> None

ida_frame.xreflist_t.empty(self) -> bool

ida_frame.xreflist_t.end(self, *args) -> "qvector< xreflist_entry_t >::const_iterator"

ida_frame.xreflist_t.erase(self, *args) -> "qvector< xreflist_entry_t >::iterator"

ida_frame.xreflist_t.extend(self, x: "xreflist_t") -> None

ida_frame.xreflist_t.extract(self) -> "xreflist_entry_t *"

ida_frame.xreflist_t.find(self, *args) -> "qvector< xreflist_entry_t >::const_iterator"

ida_frame.xreflist_t.grow(self, *args) -> None

ida_frame.xreflist_t.has(self, x: "xreflist_entry_t") -> bool

ida_frame.xreflist_t.inject(self, s: "xreflist_entry_t", len: "size_t") -> None

ida_frame.xreflist_t.insert(self, it: "xreflist_entry_t", x: "xreflist_entry_t") -> "qvector< xreflist_entry_t >::iterator"

ida_frame.xreflist_t.pop_back(self) -> None

ida_frame.xreflist_t.push_back(self, *args) -> "xreflist_entry_t &"

ida_frame.xreflist_t.qclear(self) -> None

ida_frame.xreflist_t.reserve(self, cnt: "size_t") -> None

ida_frame.xreflist_t.resize(self, *args) -> None

ida_frame.xreflist_t.size(self) -> "size_t"

ida_frame.xreflist_t.swap(self, r: "xreflist_t") -> None

ida_frame.xreflist_t.truncate(self) -> None

ida_funcs
    Routines for working with functions within the disassembled program.
    
    This file also contains routines for working with library signatures (e.g. FLIRT).
    Each function consists of function chunks. At least one function chunk must be present in the function definition - the function entry chunk. Other chunks are called function tails. There may be several of them for a function.
    A function tail is a continuous range of addresses. It can be used in the definition of one or more functions. One function using the tail is singled out and called the tail owner. This function is considered as 'possessing' the tail. get_func() on a tail address will return the function possessing the tail. You can enumerate the functions using the tail by using func_parent_iterator_t.
    Each function chunk in the disassembly is represented as an "range" (a range of addresses, see range.hpp for details) with characteristics.
    A function entry must start with an instruction (code) byte. 
        

ida_funcs.FIND_FUNC_DEFINE
    create instruction if undefined byte is encountered

ida_funcs.FIND_FUNC_EXIST
    function exists already. its bounds are returned in 'nfn'. 
            

ida_funcs.FIND_FUNC_IGNOREFN
    ignore existing function boundaries. by default the function returns function boundaries if ea belongs to a function. 
            

ida_funcs.FIND_FUNC_KEEPBD
    do not modify incoming function boundaries, just create instructions inside the boundaries. 
            

ida_funcs.FIND_FUNC_NORMAL
    stop processing if undefined byte is encountered

ida_funcs.FIND_FUNC_OK
    ok, 'nfn' is ready for add_func()

ida_funcs.FIND_FUNC_UNDEF
    function has instructions that pass execution flow to unexplored bytes. nfn->end_ea will have the address of the unexplored byte. 
            

ida_funcs.FUNC_BOTTOMBP
    BP points to the bottom of the stack frame.

ida_funcs.FUNC_CATCH
    function is an exception catch handler

ida_funcs.FUNC_FAR
    Far function.

ida_funcs.FUNC_FRAME
    Function uses frame pointer (BP)

ida_funcs.FUNC_FUZZY_SP
    Function changes SP in untraceable way, for example: and esp, 0FFFFFFF0h 
            

ida_funcs.FUNC_HIDDEN
    A hidden function chunk.

ida_funcs.FUNC_LIB
    Library function.

ida_funcs.FUNC_LUMINA
    Function info is provided by Lumina.

ida_funcs.FUNC_NORET
    Function doesn't return.

ida_funcs.FUNC_NORET_PENDING
    Function 'non-return' analysis must be performed. This flag is verified upon func_does_return() 
            

ida_funcs.FUNC_OUTLINE
    Outlined code, not a real function.

ida_funcs.FUNC_PROLOG_OK
    Prolog analysis has been performed by last SP-analysis 
            

ida_funcs.FUNC_PURGED_OK
    'argsize' field has been validated. If this bit is clear and 'argsize' is 0, then we do not known the real number of bytes removed from the stack. This bit is handled by the processor module. 
            

ida_funcs.FUNC_REANALYZE
    Function frame changed, request to reanalyze the function after the last insn is analyzed. 
            

ida_funcs.FUNC_SP_READY
    SP-analysis has been performed. If this flag is on, the stack change points should not be not modified anymore. Currently this analysis is performed only for PC 
            

ida_funcs.FUNC_STATICDEF
    Static function.

ida_funcs.FUNC_TAIL
    This is a function tail. Other bits must be clear (except FUNC_HIDDEN). 
            

ida_funcs.FUNC_THUNK
    Thunk (jump) function.

ida_funcs.FUNC_UNWIND
    function is an exception unwind handler

ida_funcs.FUNC_USERFAR
    User has specified far-ness of the function 
            

ida_funcs.IDASGN_APPLIED
    signature is already applied

ida_funcs.IDASGN_BADARG
    bad number of signature

ida_funcs.IDASGN_CURRENT
    signature is currently being applied

ida_funcs.IDASGN_OK
    ok

ida_funcs.IDASGN_PLANNED
    signature is planned to be applied

ida_funcs.LIBFUNC_DELAY
    no decision because of lack of information

ida_funcs.LIBFUNC_FOUND
    ok, library function is found

ida_funcs.LIBFUNC_NONE
    no, this is not a library function

ida_funcs.MOVE_FUNC_BADSTART
    bad new start address

ida_funcs.MOVE_FUNC_NOCODE
    no instruction at 'newstart'

ida_funcs.MOVE_FUNC_NOFUNC
    no function at 'ea'

ida_funcs.MOVE_FUNC_OK
    ok

ida_funcs.MOVE_FUNC_REFUSED
    a plugin refused the action

ida_funcs.add_func(*args) -> bool
    Add a new function. If the function end address is BADADDR, then IDA will try to determine the function bounds by calling find_func_bounds(..., FIND_FUNC_DEFINE). 
            
    @param ea1: start address
    @param ea2: end address
    @returns success

ida_funcs.add_func_ex(pfn: "func_t") -> bool
    Add a new function. If the fn->end_ea is BADADDR, then IDA will try to determine the function bounds by calling find_func_bounds(..., FIND_FUNC_DEFINE). 
            
    @param pfn: ptr to filled function structure
    @returns success

ida_funcs.add_regarg(pfn: "func_t", reg: int, tif: "tinfo_t", name: str) -> None

ida_funcs.append_func_tail(pfn: "func_t", ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool
    Append a new tail chunk to the function definition. If the tail already exists, then it will simply be added to the function tail list Otherwise a new tail will be created and its owner will be set to be our function If a new tail cannot be created, then this function will fail. 
            
    @param pfn: pointer to the function
    @param ea1: start of the tail. If a tail already exists at the specified address it must start at 'ea1'
    @param ea2: end of the tail. If a tail already exists at the specified address it must end at 'ea2'. If specified as BADADDR, IDA will determine the end address itself.

ida_funcs.apply_idasgn_to(signame: str, ea: ida_idaapi.ea_t, is_startup: bool) -> int
    Apply a signature file to the specified address. 
            
    @param signame: short name of signature file (the file name without path)
    @param ea: address to apply the signature
    @param is_startup: if set, then the signature is treated as a startup one for startup signature ida doesn't rename the first function of the applied module.
    @returns Library function codes

ida_funcs.apply_startup_sig(ea: ida_idaapi.ea_t, startup: str) -> bool
    Apply a startup signature file to the specified address. 
            
    @param ea: address to apply the signature to; usually idainfo::start_ea
    @param startup: the name of the signature file without path and extension
    @returns true if successfully applied the signature

ida_funcs.calc_func_size(pfn: "func_t") -> "asize_t"
    Calculate function size. This function takes into account all fragments of the function. 
            
    @param pfn: ptr to function structure

ida_funcs.calc_idasgn_state(n: int) -> int
    Get state of a signature in the list of planned signatures 
            
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @returns state of signature or IDASGN_BADARG

ida_funcs.calc_thunk_func_target(pfn: "func_t") -> "ea_t *"
    Calculate target of a thunk function. 
            
    @param pfn: pointer to function (may not be nullptr)
    @returns the target function or BADADDR

ida_funcs.calc_thunk_func_target(*args)
    Calculate target of a thunk function. 
            
    @param pfn: pointer to function (may not be nullptr)
    @param fptr: out: will hold address of a function pointer (if indirect jump)
    @returns the target function or BADADDR

ida_funcs.del_func(ea: ida_idaapi.ea_t) -> bool
    Delete a function. 
            
    @param ea: any address in the function entry chunk
    @returns success

ida_funcs.del_idasgn(n: int) -> int
    Remove signature from the list of planned signatures. 
            
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @returns IDASGN_OK, IDASGN_BADARG, IDASGN_APPLIED

ida_funcs.dyn_ea_array

ida_funcs.dyn_ea_array.__getitem__(self, i: "size_t") -> "unsigned long long const &"

ida_funcs.dyn_ea_array.__init__(self, _data: "unsigned long long *", _count: "size_t")

ida_funcs.dyn_ea_array.__len__(self) -> "size_t"

ida_funcs.dyn_ea_array.__setitem__(self, i: "size_t", v: "unsigned long long const &") -> None

ida_funcs.dyn_range_array

ida_funcs.dyn_range_array.__getitem__(self, i: "size_t") -> "range_t const &"

ida_funcs.dyn_range_array.__init__(self, _data: "range_t", _count: "size_t")

ida_funcs.dyn_range_array.__len__(self) -> "size_t"

ida_funcs.dyn_range_array.__setitem__(self, i: "size_t", v: "range_t") -> None

ida_funcs.dyn_regarg_array

ida_funcs.dyn_regarg_array.__getitem__(self, i: "size_t") -> "regarg_t const &"

ida_funcs.dyn_regarg_array.__init__(self, _data: "regarg_t", _count: "size_t")

ida_funcs.dyn_regarg_array.__len__(self) -> "size_t"

ida_funcs.dyn_regarg_array.__setitem__(self, i: "size_t", v: "regarg_t") -> None

ida_funcs.dyn_regvar_array

ida_funcs.dyn_regvar_array.__getitem__(self, i: "size_t") -> "regvar_t const &"

ida_funcs.dyn_regvar_array.__init__(self, _data: "regvar_t *", _count: "size_t")

ida_funcs.dyn_regvar_array.__len__(self) -> "size_t"

ida_funcs.dyn_regvar_array.__setitem__(self, i: "size_t", v: "regvar_t const &") -> None

ida_funcs.dyn_stkpnt_array

ida_funcs.dyn_stkpnt_array.__getitem__(self, i: "size_t") -> "stkpnt_t const &"

ida_funcs.dyn_stkpnt_array.__init__(self, _data: "stkpnt_t *", _count: "size_t")

ida_funcs.dyn_stkpnt_array.__len__(self) -> "size_t"

ida_funcs.dyn_stkpnt_array.__setitem__(self, i: "size_t", v: "stkpnt_t const &") -> None

ida_funcs.f_any(arg1: "flags64_t", arg2: "void *") -> bool
    Helper function to accept any address.

ida_funcs.find_func_bounds(nfn: "func_t", flags: int) -> int
    Determine the boundaries of a new function. This function tries to find the start and end addresses of a new function. It calls the module with processor_t::func_bounds in order to fine tune the function boundaries. 
            
    @param nfn: structure to fill with information \ nfn->start_ea points to the start address of the new function.
    @param flags: Find function bounds flags
    @returns Find function bounds result codes

ida_funcs.free_regarg(v: "regarg_t") -> None

ida_funcs.func_contains(pfn: "func_t", ea: ida_idaapi.ea_t) -> bool
    Does the given function contain the given address?

ida_funcs.func_does_return(callee: ida_idaapi.ea_t) -> bool
    Does the function return?. To calculate the answer, FUNC_NORET flag and is_noret() are consulted The latter is required for imported functions in the .idata section. Since in .idata we have only function pointers but not functions, we have to introduce a special flag for them. 
            

ida_funcs.func_item_iterator_t

ida_funcs.func_item_iterator_t.__init__(self, *args)

ida_funcs.func_item_iterator_t.__iter__(self)
    Provide an iterator on code items

ida_funcs.func_item_iterator_t.__next__(self, func: "testf_t *") -> bool

ida_funcs.func_item_iterator_t.addresses(self)
    Provide an iterator on addresses contained within the function

ida_funcs.func_item_iterator_t.chunk(self) -> "range_t const &"

ida_funcs.func_item_iterator_t.code_items(self)
    Provide an iterator on code items contained within the function

ida_funcs.func_item_iterator_t.current(self) -> ida_idaapi.ea_t

ida_funcs.func_item_iterator_t.data_items(self)
    Provide an iterator on data items contained within the function

ida_funcs.func_item_iterator_t.decode_preceding_insn(self, visited: "eavec_t *", p_farref: "bool *", out: "insn_t *") -> bool

ida_funcs.func_item_iterator_t.decode_prev_insn(self, out: "insn_t *") -> bool

ida_funcs.func_item_iterator_t.first(self) -> bool

ida_funcs.func_item_iterator_t.head_items(self)
    Provide an iterator on item heads contained within the function

ida_funcs.func_item_iterator_t.last(self) -> bool

ida_funcs.func_item_iterator_t.next_addr(self) -> bool

ida_funcs.func_item_iterator_t.next_code(self) -> bool

ida_funcs.func_item_iterator_t.next_data(self) -> bool

ida_funcs.func_item_iterator_t.next_head(self) -> bool

ida_funcs.func_item_iterator_t.next_not_tail(self) -> bool

ida_funcs.func_item_iterator_t.not_tails(self)
    Provide an iterator on non-tail addresses contained within the function

ida_funcs.func_item_iterator_t.prev(self, func: "testf_t *") -> bool

ida_funcs.func_item_iterator_t.prev_addr(self) -> bool

ida_funcs.func_item_iterator_t.prev_code(self) -> bool

ida_funcs.func_item_iterator_t.prev_data(self) -> bool

ida_funcs.func_item_iterator_t.prev_head(self) -> bool

ida_funcs.func_item_iterator_t.prev_not_tail(self) -> bool

ida_funcs.func_item_iterator_t.set(self, *args) -> bool
    Set a function range. if pfn == nullptr then a segment range will be set.

ida_funcs.func_item_iterator_t.set_ea(self, _ea: ida_idaapi.ea_t) -> bool

ida_funcs.func_item_iterator_t.set_range(self, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool
    Set an arbitrary range.

ida_funcs.func_item_iterator_t.succ(self, func: "testf_t *") -> bool
    Similar to next(), but succ() iterates the chunks from low to high addresses, while next() iterates through chunks starting at the function entry chunk 
            

ida_funcs.func_item_iterator_t.succ_code(self) -> bool

ida_funcs.func_parent_iterator_set(fpi: "func_parent_iterator_t", pfn: "func_t") -> bool

ida_funcs.func_parent_iterator_t

ida_funcs.func_parent_iterator_t.__init__(self, *args)

ida_funcs.func_parent_iterator_t.__iter__(self)
    Provide an iterator on function parents

ida_funcs.func_parent_iterator_t.__next__(self) -> bool

ida_funcs.func_parent_iterator_t.first(self) -> bool

ida_funcs.func_parent_iterator_t.last(self) -> bool

ida_funcs.func_parent_iterator_t.parent(self) -> ida_idaapi.ea_t

ida_funcs.func_parent_iterator_t.prev(self) -> bool

ida_funcs.func_parent_iterator_t.reset_fnt(self, _fnt: "func_t") -> None

ida_funcs.func_parent_iterator_t.set(self, _fnt: "func_t") -> bool

ida_funcs.func_t

ida_funcs.func_t.__get_points__(self) -> "dynamic_wrapped_array_t< stkpnt_t >"

ida_funcs.func_t.__get_referers__(self) -> "dynamic_wrapped_array_t< ea_t >"

ida_funcs.func_t.__get_regargs__(self) -> "dynamic_wrapped_array_t< regarg_t >"

ida_funcs.func_t.__get_regvars__(self) -> "dynamic_wrapped_array_t< regvar_t >"

ida_funcs.func_t.__get_tails__(self) -> "dynamic_wrapped_array_t< range_t >"

ida_funcs.func_t.__init__(self, start: ida_idaapi.ea_t = 0, end: ida_idaapi.ea_t = 0, f: "flags64_t" = 0)

ida_funcs.func_t.__iter__(self)
    Alias for func_item_iterator_t(self).__iter__()

ida_funcs.func_t.addresses(self)
    Alias for func_item_iterator_t(self).addresses()

ida_funcs.func_t.analyzed_sp(self) -> bool
    Has SP-analysis been performed?

ida_funcs.func_t.argsize
    number of bytes purged from the stack upon returning 
            

ida_funcs.func_t.code_items(self)
    Alias for func_item_iterator_t(self).code_items()

ida_funcs.func_t.color
    user defined function color

ida_funcs.func_t.data_items(self)
    Alias for func_item_iterator_t(self).data_items()

ida_funcs.func_t.does_return(self) -> bool
    Does function return?

ida_funcs.func_t.flags
    Function flags 
            

ida_funcs.func_t.fpd
    frame pointer delta. (usually 0, i.e. realBP==typicalBP) use update_fpd() to modify it. 
            

ida_funcs.func_t.frame
    netnode id of frame structure - see frame.hpp

ida_funcs.func_t.frregs
    size of saved registers in frame. This range is immediately above the local variables range. 
            

ida_funcs.func_t.frsize
    size of local variables part of frame in bytes. If FUNC_FRAME is set and fpd==0, the frame pointer (EBP) is assumed to point to the top of the local variables range. 
            

ida_funcs.func_t.get_frame_object(self)
    Retrieve the function frame, in the form of a structure
    where frame offsets that are accessed by the program, as well
    as areas for "saved registers" and "return address", are
    represented by structure members.
    
    If the function has no associated frame, return None
    
    @return a ida_typeinf.tinfo_t object representing the frame, or None

ida_funcs.func_t.get_name(self)
    Get the function name
    
    @return the function name

ida_funcs.func_t.get_prototype(self)
    Retrieve the function prototype.
    
    Once you have obtained the prototype, you can:
    
    * retrieve the return type through ida_typeinf.tinfo_t.get_rettype()
    * iterate on the arguments using ida_typeinf.tinfo_t.iter_func()
    
    If the function has no associated prototype, return None
    
    @return a ida_typeinf.tinfo_t object representing the prototype, or None

ida_funcs.func_t.head_items(self)
    Alias for func_item_iterator_t(self).head_items()

ida_funcs.func_t.is_far(self) -> bool
    Is a far function?

ida_funcs.func_t.need_prolog_analysis(self) -> bool
    Needs prolog analysis?

ida_funcs.func_t.not_tails(self)
    Alias for func_item_iterator_t(self).not_tails()

ida_funcs.func_t.owner
    the address of the main function possessing this tail

ida_funcs.func_t.pntqty
    number of SP change points

ida_funcs.func_t.points
    array of SP change points. use ...stkpnt...() functions to access this array. 
            

ida_funcs.func_t.points
    array of SP change points. use ...stkpnt...() functions to access this array. 
            

ida_funcs.func_t.referers
    array of referers (function start addresses). use func_parent_iterator_t to access the referers. 
            

ida_funcs.func_t.referers
    array of referers (function start addresses). use func_parent_iterator_t to access the referers. 
            

ida_funcs.func_t.refqty
    number of referers

ida_funcs.func_t.regargqty
    number of register arguments. During analysis IDA tries to guess the register arguments. It stores store the guessing outcome in this field. As soon as it determines the final function prototype, regargqty is set to zero. 
            

ida_funcs.func_t.regargs
    unsorted array of register arguments. use ...regarg...() functions to access this array. regargs are destroyed when the full function type is determined. 
            

ida_funcs.func_t.regargs
    unsorted array of register arguments. use ...regarg...() functions to access this array. regargs are destroyed when the full function type is determined. 
            

ida_funcs.func_t.regvarqty
    number of register variables (-1-not read in yet) use find_regvar() to read register variables 
            

ida_funcs.func_t.regvars
    array of register variables. this array is sorted by: start_ea. use ...regvar...() functions to access this array. 
            

ida_funcs.func_t.regvars
    array of register variables. this array is sorted by: start_ea. use ...regvar...() functions to access this array. 
            

ida_funcs.func_t.tailqty
    number of function tails

ida_funcs.func_t.tails
    array of tails, sorted by ea. use func_tail_iterator_t to access function tails. 
            

ida_funcs.func_t.tails
    array of tails, sorted by ea. use func_tail_iterator_t to access function tails. 
            

ida_funcs.func_t__from_ptrval__(ptrval: "size_t") -> "func_t *"

ida_funcs.func_tail_iterator_set(fti: "func_tail_iterator_t", pfn: "func_t", ea: ida_idaapi.ea_t) -> bool

ida_funcs.func_tail_iterator_set_ea(fti: "func_tail_iterator_t", ea: ida_idaapi.ea_t) -> bool

ida_funcs.func_tail_iterator_t

ida_funcs.func_tail_iterator_t.__init__(self, *args)

ida_funcs.func_tail_iterator_t.__iter__(self)
    Provide an iterator on function tails

ida_funcs.func_tail_iterator_t.__next__(self) -> bool

ida_funcs.func_tail_iterator_t.chunk(self) -> "range_t const &"

ida_funcs.func_tail_iterator_t.first(self) -> bool

ida_funcs.func_tail_iterator_t.last(self) -> bool

ida_funcs.func_tail_iterator_t.main(self) -> bool

ida_funcs.func_tail_iterator_t.prev(self) -> bool

ida_funcs.func_tail_iterator_t.set(self, *args) -> bool

ida_funcs.func_tail_iterator_t.set_ea(self, ea: ida_idaapi.ea_t) -> bool

ida_funcs.func_tail_iterator_t.set_range(self, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool

ida_funcs.get_current_idasgn() -> int
    Get number of the the current signature. 
            
    @returns 0..n-1

ida_funcs.get_fchunk(ea: ida_idaapi.ea_t) -> "func_t *"
    Get pointer to function chunk structure by address. 
            
    @param ea: any address in a function chunk
    @returns ptr to a function chunk or nullptr. This function may return a function entry as well as a function tail.

ida_funcs.get_fchunk_num(ea: ida_idaapi.ea_t) -> int
    Get ordinal number of a function chunk in the global list of function chunks. 
            
    @param ea: any address in the function chunk
    @returns number of function chunk (0..get_fchunk_qty()-1). -1 means 'no function chunk at the specified address'.

ida_funcs.get_fchunk_qty() -> "size_t"
    Get total number of function chunks in the program.

ida_funcs.get_fchunk_referer(ea: int, idx)

ida_funcs.get_func(ea: ida_idaapi.ea_t) -> "func_t *"
    Get pointer to function structure by address. 
            
    @param ea: any address in a function
    @returns ptr to a function or nullptr. This function returns a function entry chunk.

ida_funcs.get_func_bitness(pfn: "func_t") -> int
    Get function bitness (which is equal to the function segment bitness). pfn==nullptr => returns 0 
            
    @retval 0: 16
    @retval 1: 32
    @retval 2: 64

ida_funcs.get_func_bits(pfn: "func_t") -> int
    Get number of bits in the function addressing.

ida_funcs.get_func_bytes(pfn: "func_t") -> int
    Get number of bytes in the function addressing.

ida_funcs.get_func_chunknum(pfn: "func_t", ea: ida_idaapi.ea_t) -> int
    Get the containing tail chunk of 'ea'. 
            
    @retval -1: means 'does not contain ea'
    @retval 0: means the 'pfn' itself contains ea
    @retval >0: the number of the containing function tail chunk

ida_funcs.get_func_cmt(pfn: "func_t", repeatable: bool) -> str
    Get function comment. 
            
    @param pfn: ptr to function structure
    @param repeatable: get repeatable comment?
    @returns size of comment or -1 In fact this function works with function chunks too.

ida_funcs.get_func_name(ea: ida_idaapi.ea_t) -> str
    Get function name. 
            
    @param ea: any address in the function
    @returns length of the function name

ida_funcs.get_func_num(ea: ida_idaapi.ea_t) -> int
    Get ordinal number of a function. 
            
    @param ea: any address in the function
    @returns number of function (0..get_func_qty()-1). -1 means 'no function at the specified address'.

ida_funcs.get_func_qty() -> "size_t"
    Get total number of functions in the program.

ida_funcs.get_func_ranges(ranges: "rangeset_t", pfn: "func_t") -> ida_idaapi.ea_t
    Get function ranges. 
            
    @param ranges: buffer to receive the range info
    @param pfn: ptr to function structure
    @returns end address of the last function range (BADADDR-error)

ida_funcs.get_idasgn_desc(n)
    Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries)
    
    See also: get_idasgn_desc_with_matches
    
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @return: None on failure or tuple(signame, optlibs)

ida_funcs.get_idasgn_desc_with_matches(n)
    Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries, number of matches)
    
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @return: None on failure or tuple(signame, optlibs, nmatches)

ida_funcs.get_idasgn_qty() -> int
    Get number of signatures in the list of planned and applied signatures. 
            
    @returns 0..n

ida_funcs.get_idasgn_title(name: str) -> str
    Get full description of the signature by its short name. 
            
    @param name: short name of a signature
    @returns size of signature description or -1

ida_funcs.get_next_fchunk(ea: ida_idaapi.ea_t) -> "func_t *"
    Get pointer to the next function chunk in the global list. 
            
    @param ea: any address in the program
    @returns ptr to function chunk or nullptr if next function chunk doesn't exist

ida_funcs.get_next_func(ea: ida_idaapi.ea_t) -> "func_t *"
    Get pointer to the next function. 
            
    @param ea: any address in the program
    @returns ptr to function or nullptr if next function doesn't exist

ida_funcs.get_next_func_addr(pfn: "func_t", ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_funcs.get_prev_fchunk(ea: ida_idaapi.ea_t) -> "func_t *"
    Get pointer to the previous function chunk in the global list. 
            
    @param ea: any address in the program
    @returns ptr to function chunk or nullptr if previous function chunk doesn't exist

ida_funcs.get_prev_func(ea: ida_idaapi.ea_t) -> "func_t *"
    Get pointer to the previous function. 
            
    @param ea: any address in the program
    @returns ptr to function or nullptr if previous function doesn't exist

ida_funcs.get_prev_func_addr(pfn: "func_t", ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_funcs.getn_fchunk(n: int) -> "func_t *"
    Get pointer to function chunk structure by number. 
            
    @param n: number of function chunk, is in range 0..get_fchunk_qty()-1
    @returns ptr to a function chunk or nullptr. This function may return a function entry as well as a function tail.

ida_funcs.getn_func(n: "size_t") -> "func_t *"
    Get pointer to function structure by number. 
            
    @param n: number of function, is in range 0..get_func_qty()-1
    @returns ptr to a function or nullptr. This function returns a function entry chunk.

ida_funcs.is_finally_visible_func(pfn: "func_t") -> bool
    Is the function visible (event after considering SCF_SHHID_FUNC)?

ida_funcs.is_func_entry(pfn: "func_t") -> bool
    Does function describe a function entry chunk?

ida_funcs.is_func_locked(pfn: "func_t") -> bool
    Is the function pointer locked?

ida_funcs.is_func_tail(pfn: "func_t") -> bool
    Does function describe a function tail chunk?

ida_funcs.is_same_func(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool
    Do two addresses belong to the same function?

ida_funcs.is_visible_func(pfn: "func_t") -> bool
    Is the function visible (not hidden)?

ida_funcs.lock_func

ida_funcs.lock_func.__init__(self, _pfn: "func_t")

ida_funcs.lock_func_range(pfn: "func_t", lock: bool) -> None
    Lock function pointer Locked pointers are guaranteed to remain valid until they are unlocked. Ranges with locked pointers cannot be deleted or moved. 
            

ida_funcs.lock_func_with_tails_t

ida_funcs.lock_func_with_tails_t.__init__(self, pfn: "func_t")

ida_funcs.plan_to_apply_idasgn(fname: str) -> int
    Add a signature file to the list of planned signature files. 
            
    @param fname: file name. should not contain directory part.
    @returns 0 if failed, otherwise number of planned (and applied) signatures

ida_funcs.read_regargs(pfn: "func_t") -> None

ida_funcs.reanalyze_function(*args) -> None
    Reanalyze a function. This function plans to analyzes all chunks of the given function. Optional parameters (ea1, ea2) may be used to narrow the analyzed range. 
            
    @param pfn: pointer to a function
    @param ea1: start of the range to analyze
    @param ea2: end of range to analyze
    @param analyze_parents: meaningful only if pfn points to a function tail. if true, all tail parents will be reanalyzed. if false, only the given tail will be reanalyzed.

ida_funcs.reanalyze_noret_flag(ea: ida_idaapi.ea_t) -> bool
    Plan to reanalyze noret flag. This function does not remove FUNC_NORET if it is already present. It just plans to reanalysis. 
            

ida_funcs.regarg_t

ida_funcs.regarg_t.__init__(self, *args)

ida_funcs.regarg_t.swap(self, r: "regarg_t") -> None

ida_funcs.remove_func_tail(pfn: "func_t", tail_ea: ida_idaapi.ea_t) -> bool
    Remove a function tail. If the tail belongs only to one function, it will be completely removed. Otherwise if the function was the tail owner, the first function using this tail becomes the owner of the tail. 
            
    @param pfn: pointer to the function
    @param tail_ea: any address inside the tail to remove

ida_funcs.set_func_cmt(pfn: "func_t", cmt: str, repeatable: bool) -> bool
    Set function comment. This function works with function chunks too. 
            
    @param pfn: ptr to function structure
    @param cmt: comment string, may be multiline (with '
    '). Use empty str ("") to delete comment
    @param repeatable: set repeatable comment?

ida_funcs.set_func_end(ea: ida_idaapi.ea_t, newend: ida_idaapi.ea_t) -> bool
    Move function chunk end address. 
            
    @param ea: any address in the function
    @param newend: new end address of the function
    @returns success

ida_funcs.set_func_name_if_jumpfunc(pfn: "func_t", oldname: str) -> int
    Give a meaningful name to function if it consists of only 'jump' instruction. 
            
    @param pfn: pointer to function (may be nullptr)
    @param oldname: old name of function. if old name was in "j_..." form, then we may discard it and set a new name. if oldname is not known, you may pass nullptr.
    @returns success

ida_funcs.set_func_start(ea: ida_idaapi.ea_t, newstart: ida_idaapi.ea_t) -> int
    Move function chunk start address. 
            
    @param ea: any address in the function
    @param newstart: new end address of the function
    @returns Function move result codes

ida_funcs.set_noret_insn(insn_ea: ida_idaapi.ea_t, noret: bool) -> bool
    Signal a non-returning instruction. This function can be used by the processor module to tell the kernel about non-returning instructions (like call exit). The kernel will perform the global function analysis and find out if the function returns at all. This analysis will be done at the first call to func_does_return() 
            
    @returns true if the instruction 'noret' flag has been changed

ida_funcs.set_tail_owner(fnt: "func_t", new_owner: ida_idaapi.ea_t) -> bool
    Set a new owner of a function tail. The new owner function must be already referring to the tail (after append_func_tail). 
            
    @param fnt: pointer to the function tail
    @param new_owner: the entry point of the new owner function

ida_funcs.set_visible_func(pfn: "func_t", visible: bool) -> None
    Set visibility of function.

ida_funcs.try_to_add_libfunc(ea: ida_idaapi.ea_t) -> int
    Apply the currently loaded signature file to the specified address. If a library function is found, then create a function and name it accordingly. 
            
    @param ea: any address in the program
    @returns Library function codes

ida_funcs.update_func(pfn: "func_t") -> bool
    Update information about a function in the database (func_t). You must not change the function start and end addresses using this function. Use set_func_start() and set_func_end() for it. 
            
    @param pfn: ptr to function structure
    @returns success

ida_gdl
    Low level graph drawing operations.

ida_gdl.BasicBlock
    Basic block class. It is returned by the Flowchart class

ida_gdl.BasicBlock.__init__(self, id, bb, fc)
    Block type (check fc_block_type_t enum)

ida_gdl.BasicBlock.preds(self)
    Iterates the predecessors list

ida_gdl.BasicBlock.succs(self)
    Iterates the successors list

ida_gdl.CHART_FOLLOW_DIRECTION
    analyze references to added blocks only in the direction of the reference who discovered the current block

ida_gdl.CHART_GEN_DOT
    generate .dot file (file extension is forced to .dot)

ida_gdl.CHART_GEN_GDL
    generate .gdl file (file extension is forced to .gdl)

ida_gdl.CHART_IGNORE_LIB_FROM
    ignore references from library functions

ida_gdl.CHART_IGNORE_LIB_TO
    ignore references to library functions

ida_gdl.CHART_NOLIBFUNCS
    don't include library functions in the graph

ida_gdl.CHART_PRINT_DOTS
    print dots if xrefs exist outside of the range recursion depth

ida_gdl.CHART_PRINT_NAMES
    print labels for each block?

ida_gdl.CHART_RECURSIVE
    analyze added blocks

ida_gdl.CHART_REFERENCED
    references from the addresses in the list

ida_gdl.CHART_REFERENCING
    references to the addresses in the list

ida_gdl.CHART_WINGRAPH
    call grapher to display the graph

ida_gdl.FC_APPND
    multirange flowchart (set by append_to_flowchart)

ida_gdl.FC_CALL_ENDS
    call instructions terminate basic blocks

ida_gdl.FC_CHKBREAK
    build_qflow_chart() may be aborted by user

ida_gdl.FC_NOEXT
    do not compute external blocks. Use this to prevent jumps leaving the function from appearing in the flow chart. Unless specified, the targets of those outgoing jumps will be present in the flow chart under the form of one-instruction blocks 
            

ida_gdl.FC_NOPREDS
    do not compute predecessor lists

ida_gdl.FC_OUTLINES
    include outlined code (with FUNC_OUTLINE)

ida_gdl.FC_PRINT
    print names (used only by display_flow_chart())

ida_gdl.FC_RESERVED
    former FC_PREDS

ida_gdl.FlowChart
    Flowchart class used to determine basic blocks.
    Check ex_gdl_qflow_chart.py for sample usage.

ida_gdl.FlowChart.__getitem__(self, index)
    Returns a basic block
    
    @return: BasicBlock

ida_gdl.FlowChart.__init__(self, f = None, bounds = None, flags = 0)
    Constructor
    @param f: A func_t type, use get_func(ea) to get a reference
    @param bounds: A tuple of the form (start, end). Used if "f" is None
    @param flags: one of the FC_xxxx flags.

ida_gdl.FlowChart.__iter__(self)

ida_gdl.FlowChart._getitem(self, index)

ida_gdl.FlowChart.refresh(self)
    Refreshes the flow chart

ida_gdl.FlowChart.size
    Number of blocks in the flow chart

ida_gdl.cancellable_graph_t

ida_gdl.cancellable_graph_t.__disown__(self)

ida_gdl.cancellable_graph_t.__init__(self)

ida_gdl.display_gdl(fname: str) -> int
    Display GDL file by calling wingraph32. The exact name of the grapher is taken from the configuration file and set up by setup_graph_subsystem(). The path should point to a temporary file: when wingraph32 succeeds showing the graph, the input file will be deleted. 
            
    @returns error code from os, 0 if ok

ida_gdl.edge_t

ida_gdl.edge_t.__eq__(self, y: "edge_t") -> bool

ida_gdl.edge_t.__init__(self, x: int = 0, y: int = 0)

ida_gdl.edge_t.__lt__(self, y: "edge_t") -> bool

ida_gdl.edge_t.__ne__(self, y: "edge_t") -> bool

ida_gdl.edge_t.dst
    destination node number

ida_gdl.edge_t.src
    source node number

ida_gdl.edgevec_t

ida_gdl.edgevec_t.__init__(self)

ida_gdl.fcb_cndret
    conditional return block

ida_gdl.fcb_enoret
    external noreturn block (does not belong to the function)

ida_gdl.fcb_error
    block passes execution past the function end

ida_gdl.fcb_extern
    external normal block

ida_gdl.fcb_indjump
    block ends with indirect jump

ida_gdl.fcb_noret
    noreturn block

ida_gdl.fcb_normal
    normal block

ida_gdl.fcb_ret
    return block

ida_gdl.gdl_graph_t

ida_gdl.gdl_graph_t.__disown__(self)

ida_gdl.gdl_graph_t.__init__(self)

ida_gdl.gdl_graph_t.begin(self) -> "node_iterator"

ida_gdl.gdl_graph_t.edge(self, node: int, i: int, ispred: bool) -> int

ida_gdl.gdl_graph_t.empty(self) -> bool

ida_gdl.gdl_graph_t.end(self) -> "node_iterator"

ida_gdl.gdl_graph_t.entry(self) -> int

ida_gdl.gdl_graph_t.exists(self, node: int) -> bool

ida_gdl.gdl_graph_t.exit(self) -> int

ida_gdl.gdl_graph_t.front(self) -> int

ida_gdl.gdl_graph_t.get_edge_color(self, i: int, j: int) -> "bgcolor_t"

ida_gdl.gdl_graph_t.get_node_color(self, n: int) -> "bgcolor_t"

ida_gdl.gdl_graph_t.get_node_label(self, n: int) -> "char *"

ida_gdl.gdl_graph_t.nedge(self, node: int, ispred: bool) -> "size_t"

ida_gdl.gdl_graph_t.node_qty(self) -> int

ida_gdl.gdl_graph_t.npred(self, node: int) -> int

ida_gdl.gdl_graph_t.nsucc(self, node: int) -> int

ida_gdl.gdl_graph_t.pred(self, node: int, i: int) -> int

ida_gdl.gdl_graph_t.print_edge(self, fp: "FILE *", i: int, j: int) -> bool

ida_gdl.gdl_graph_t.print_graph_attributes(self, fp: "FILE *") -> None

ida_gdl.gdl_graph_t.print_node(self, fp: "FILE *", n: int) -> bool

ida_gdl.gdl_graph_t.print_node_attributes(self, fp: "FILE *", n: int) -> None

ida_gdl.gdl_graph_t.size(self) -> int

ida_gdl.gdl_graph_t.succ(self, node: int, i: int) -> int

ida_gdl.gen_complex_call_chart(filename: str, wait: str, title: str, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, flags: int, recursion_depth: int = -1) -> bool
    Build and display a complex xref graph. 
            
    @param filename: output file name. the file extension is not used. maybe nullptr.
    @param wait: message to display during graph building
    @param title: graph title
    @param ea1: address range
    @param ea2: address range
    @param flags: combination of Call chart building flags and Flow graph building flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the function will return false.
    @param recursion_depth: optional limit of recursion
    @returns success. if fails, a warning message is displayed on the screen

ida_gdl.gen_flow_graph(filename: str, title: str, pfn: "func_t *", ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, gflags: int) -> bool
    Build and display a flow graph. 
            
    @param filename: output file name. the file extension is not used. maybe nullptr.
    @param title: graph title
    @param pfn: function to graph
    @param ea1: if pfn == nullptr, then the address range
    @param ea2: if pfn == nullptr, then the address range
    @param gflags: combination of Flow graph building flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the function will return false
    @returns success. if fails, a warning message is displayed on the screen

ida_gdl.gen_gdl(g: "gdl_graph_t", fname: str) -> None
    Create GDL file for graph.

ida_gdl.gen_simple_call_chart(filename: str, wait: str, title: str, gflags: int) -> bool
    Build and display a simple function call graph. 
            
    @param filename: output file name. the file extension is not used. maybe nullptr.
    @param wait: message to display during graph building
    @param title: graph title
    @param gflags: combination of CHART_NOLIBFUNCS and Flow graph building flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the function will return false.
    @returns success. if fails, a warning message is displayed on the screen

ida_gdl.is_noret_block(btype: "fc_block_type_t") -> bool
    Does this block never return?

ida_gdl.is_ret_block(btype: "fc_block_type_t") -> bool
    Does this block return?

ida_gdl.node_iterator

ida_gdl.node_iterator.__eq__(self, n: "node_iterator") -> bool

ida_gdl.node_iterator.__init__(self, _g: "gdl_graph_t", n: int)

ida_gdl.node_iterator.__ne__(self, n: "node_iterator") -> bool

ida_gdl.node_iterator.__ref__(self) -> int

ida_gdl.node_ordering_t

ida_gdl.node_ordering_t.__init__(self)

ida_gdl.node_ordering_t.clear(self) -> None

ida_gdl.node_ordering_t.clr(self, _node: int) -> bool

ida_gdl.node_ordering_t.node(self, _order: "size_t") -> int

ida_gdl.node_ordering_t.order(self, _node: int) -> int

ida_gdl.node_ordering_t.resize(self, n: int) -> None

ida_gdl.node_ordering_t.set(self, _node: int, num: int) -> None

ida_gdl.node_ordering_t.size(self) -> "size_t"

ida_gdl.qbasic_block_t

ida_gdl.qbasic_block_t.__init__(self)

ida_gdl.qflow_chart_t

ida_gdl.qflow_chart_t.__getitem__(self, n: int) -> "qbasic_block_t *"

ida_gdl.qflow_chart_t.__init__(self, *args)

ida_gdl.qflow_chart_t.append_to_flowchart(self, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None

ida_gdl.qflow_chart_t.bounds
    overall bounds of the qflow_chart_t instance

ida_gdl.qflow_chart_t.calc_block_type(self, blknum: "size_t") -> "fc_block_type_t"

ida_gdl.qflow_chart_t.create(self, *args) -> None
    This function has the following signatures:
    
        0. create(_title: str, _pfn: func_t *, _ea1: ida_idaapi.ea_t, _ea2: ida_idaapi.ea_t, _flags: int) -> None
        1. create(_title: str, ranges: const rangevec_t &, _flags: int) -> None
    
    # 0: create(_title: str, _pfn: func_t *, _ea1: ida_idaapi.ea_t, _ea2: ida_idaapi.ea_t, _flags: int) -> None
    
    
    # 1: create(_title: str, ranges: const rangevec_t &, _flags: int) -> None

ida_gdl.qflow_chart_t.flags
    flags. See Flow chart flags

ida_gdl.qflow_chart_t.get_node_label(self, *args) -> "char *"

ida_gdl.qflow_chart_t.is_noret_block(self, blknum: "size_t") -> bool

ida_gdl.qflow_chart_t.is_ret_block(self, blknum: "size_t") -> bool

ida_gdl.qflow_chart_t.npred(self, node: int) -> int

ida_gdl.qflow_chart_t.nproper
    number of basic blocks belonging to the specified range

ida_gdl.qflow_chart_t.nsucc(self, node: int) -> int

ida_gdl.qflow_chart_t.pfn
    the function this instance was built upon

ida_gdl.qflow_chart_t.pred(self, node: int, i: int) -> int

ida_gdl.qflow_chart_t.print_names(self) -> bool

ida_gdl.qflow_chart_t.print_node_attributes(self, fp: "FILE *", n: int) -> None

ida_gdl.qflow_chart_t.refresh(self) -> None

ida_gdl.qflow_chart_t.size(self) -> int

ida_gdl.qflow_chart_t.succ(self, node: int, i: int) -> int

ida_graph
    Graph view management.

ida_graph.GLICTL_CENTER
    the gli should be set/get as center

ida_graph.GraphViewer
    This class wraps the user graphing facility provided by the graph.hpp file

ida_graph.GraphViewer.AddCommand(self, title, shortcut)

ida_graph.GraphViewer.AddEdge(self, src_node, dest_node)
    Creates an edge between two given node ids

ida_graph.GraphViewer.AddNode(self, obj)
    Creates a node associated with the given object and returns the node id

ida_graph.GraphViewer.Clear(self)
    Clears all the nodes and edges

ida_graph.GraphViewer.Close(self)
    Closes the graph.
    It is possible to call Show() again (which will recreate the graph)

ida_graph.GraphViewer.Count(self)
    Returns the node count

ida_graph.GraphViewer.OnCommand(self, cmd_id)

ida_graph.GraphViewer.OnPopup(self, widget, popup_handle)

ida_graph.GraphViewer.OnRefresh(self)
    Event called when the graph is refreshed or first created.
    From this event you are supposed to create nodes and edges.
    This callback is mandatory.
    
    @note: ***It is important to clear previous nodes before adding nodes.***
    @return: Returning True tells the graph viewer to use the items. Otherwise old items will be used.

ida_graph.GraphViewer.Select(self, node_id)
    Selects a node on the graph

ida_graph.GraphViewer.Show(self)
    Shows an existing graph or creates a new one
    
    @return: Boolean

ida_graph.GraphViewer.UI_Hooks_Trampoline

ida_graph.GraphViewer.UI_Hooks_Trampoline.__init__(self, v)

ida_graph.GraphViewer.UI_Hooks_Trampoline.populating_widget_popup(self, w, popup_handle)

ida_graph.GraphViewer._OnBind(self, hook)

ida_graph.GraphViewer.__getitem__(self, idx)
    Returns a reference to the object associated with this node id

ida_graph.GraphViewer.__init__(self, title, close_open = False)
    Constructs the GraphView object.
    Please do not remove or rename the private fields
    
    @param title: The title of the graph window
    @param close_open: Should it attempt to close an existing graph (with same title) before creating this graph?

ida_graph.GraphViewer.__init__._qccb(ctx, cmd_id)

ida_graph.GraphViewer.__iter__(self)

ida_graph.MTG_DOT_NODE
    is dot node?

ida_graph.MTG_GROUP_NODE
    is group node?

ida_graph.MTG_NON_DISPLAYABLE_NODE
    for disassembly graphs - non-displayable nodes have a visible area that is too large to generate disassembly lines for without IDA slowing down significantly (see MAX_VISIBLE_NODE_AREA) 
            

ida_graph.NIF_BG_COLOR
    node_info_t::bg_color

ida_graph.NIF_EA
    node_info_t::ea

ida_graph.NIF_FLAGS
    node_info_t::flags

ida_graph.NIF_FRAME_COLOR
    node_info_t::frame_color

ida_graph.NIF_TEXT
    node_info_t::text

ida_graph.TPointDouble

ida_graph.TPointDouble.__eq__(self, r: "TPointDouble") -> bool

ida_graph.TPointDouble.__init__(self, *args)

ida_graph.TPointDouble.__ne__(self, r: "TPointDouble") -> bool

ida_graph.TPointDouble.add(self, r: "TPointDouble") -> None

ida_graph.TPointDouble.negate(self) -> None

ida_graph.TPointDouble.sub(self, r: "TPointDouble") -> None

ida_graph.calc_dist(p: "point_t", q: "point_t") -> "double"
    Calculate distance between p and q.

ida_graph.clr_node_info(gid: "graph_id_t", node: int, flags: int) -> None
    Clear node info for the given node. 
            
    @param gid: id of desired graph
    @param node: node number
    @param flags: combination of Node info flags, identifying which fields of node_info_t will be cleared

ida_graph.create_disasm_graph(*args) -> "interactive_graph_t *"
    This function has the following signatures:
    
        0. create_disasm_graph(ea: ida_idaapi.ea_t) -> interactive_graph_t *
        1. create_disasm_graph(ranges: const rangevec_t &) -> interactive_graph_t *
    
    # 0: create_disasm_graph(ea: ida_idaapi.ea_t) -> interactive_graph_t *
    
    Create a graph for the function that contains 'ea'.
    
    
    # 1: create_disasm_graph(ranges: const rangevec_t &) -> interactive_graph_t *
    
    Create a graph using an arbitrary set of ranges.

ida_graph.create_graph_viewer(title: str, id: int, callback: "hook_cb_t *", ud: "void *", title_height: int, parent: "TWidget *" = None) -> "graph_viewer_t *"
    Create a custom graph viewer. 
            
    @param title: the widget title
    @param id: graph id
    @param callback: callback to handle graph notifications (graph_notification_t)
    @param ud: user data passed to callback
    @param title_height: node title height
    @param parent: the parent widget of the graph viewer
    @returns new viewer

ida_graph.create_interactive_graph(id: int) -> "interactive_graph_t *"
    Create a new empty graph with given id.

ida_graph.create_user_graph_place(node: int, lnnum: int) -> "user_graph_place_t *"
    Get a copy of a user_graph_place_t (returns a pointer to static storage)

ida_graph.del_node_info(gid: "graph_id_t", node: int) -> None
    Delete the node_info_t for the given node.

ida_graph.delete_interactive_graph(g: "interactive_graph_t") -> None
    Delete graph object. 
            

ida_graph.drawable_graph_t

ida_graph.drawable_graph_t.__disown__(self)

ida_graph.drawable_graph_t.__init__(self)

ida_graph.drawable_graph_t.callback_ud
    user data for callback

ida_graph.drawable_graph_t.circle_center
    for layout_circle

ida_graph.drawable_graph_t.circle_radius
    for layout_circle

ida_graph.drawable_graph_t.create_circle_layout(self, p: "point_t", radius: int) -> bool

ida_graph.drawable_graph_t.create_tree_layout(self) -> bool

ida_graph.drawable_graph_t.current_layout
    see Proximity view layouts

ida_graph.drawable_graph_t.get_edge(self, e: "edge_t") -> "edge_info_t *"

ida_graph.drawable_graph_t.grcall(self, code: int) -> "ssize_t"

ida_graph.drawable_graph_t.nrect(self, n: int) -> "rect_t"

ida_graph.drawable_graph_t.rect_edges_made
    have create rectangular edges?

ida_graph.drawable_graph_t.set_callback(self, _callback: "hook_cb_t *", _ud: "void *") -> None

ida_graph.drawable_graph_t.title
    graph title

ida_graph.edge_info_t

ida_graph.edge_info_t.__init__(self)

ida_graph.edge_info_t.color
    edge color

ida_graph.edge_info_t.dstoff
    destination: edge port offset from the left

ida_graph.edge_info_t.layout
    describes geometry of edge

ida_graph.edge_info_t.reverse_layout(self) -> None

ida_graph.edge_info_t.srcoff
    source: edge port offset from the left

ida_graph.edge_info_t.width
    edge width

ida_graph.edge_infos_wrapper_t

ida_graph.edge_infos_wrapper_t.__init__(self, *args, **kwargs)

ida_graph.edge_infos_wrapper_t.clear(self) -> None

ida_graph.edge_layout_point_t

ida_graph.edge_layout_point_t.__eq__(self, r: "edge_layout_point_t") -> bool

ida_graph.edge_layout_point_t.__init__(self, *args)

ida_graph.edge_layout_point_t.__ne__(self, r: "edge_layout_point_t") -> bool

ida_graph.edge_layout_point_t.compare(self, r: "edge_layout_point_t") -> int

ida_graph.edge_layout_point_t.e
    parent edge

ida_graph.edge_layout_point_t.pidx
    index into edge_info_t::layout

ida_graph.edge_segment_t

ida_graph.edge_segment_t.__init__(self)

ida_graph.edge_segment_t.__lt__(self, r: "edge_segment_t") -> bool

ida_graph.edge_segment_t.length(self) -> "size_t"

ida_graph.edge_segment_t.toright(self) -> bool

ida_graph.get_graph_viewer(parent: "TWidget *") -> "graph_viewer_t *"
    Get custom graph viewer for given form.

ida_graph.get_node_info(out: "node_info_t", gid: "graph_id_t", node: int) -> bool
    Get node info. 
            
    @param out: result
    @param gid: id of desired graph
    @param node: node number
    @returns success

ida_graph.get_viewer_graph(gv: "graph_viewer_t *") -> "interactive_graph_t *"
    Get graph object for given custom graph viewer.

ida_graph.git_edge
    edge (graph_item_t::e, graph_item_t::n. n is farthest edge endpoint)

ida_graph.git_elp
    edge layout point (graph_item_t::elp)

ida_graph.git_node
    node title (graph_item_t::n)

ida_graph.git_none
    nothing

ida_graph.git_text
    node text (graph_item_t::n, graph_item_t::p)

ida_graph.git_tool
    node title button (graph_item_t::n, graph_item_t::b)

ida_graph.graph_item_t

ida_graph.graph_item_t.__init__(self)

ida_graph.graph_item_t.b
    button number

ida_graph.graph_item_t.e
    edge source and destination

ida_graph.graph_item_t.elp
    edge layout point

ida_graph.graph_item_t.is_edge(self) -> bool

ida_graph.graph_item_t.is_node(self) -> bool

ida_graph.graph_item_t.n
    node number

ida_graph.graph_item_t.p
    text coordinates in the node

ida_graph.graph_item_t.type
    type

ida_graph.graph_node_visitor_t

ida_graph.graph_node_visitor_t.__disown__(self)

ida_graph.graph_node_visitor_t.__init__(self)

ida_graph.graph_node_visitor_t.is_forbidden_edge(self, arg0: int, arg1: int) -> bool
    Should the edge between 'n' and 'm' be ignored?

ida_graph.graph_node_visitor_t.is_visited(self, n: int) -> bool
    Have we already visited the given node?

ida_graph.graph_node_visitor_t.reinit(self) -> None
    Reset visited nodes.

ida_graph.graph_node_visitor_t.set_visited(self, n: int) -> None
    Mark node as visited.

ida_graph.graph_node_visitor_t.visit_node(self, arg0: int) -> int
    Implements action to take when a node is visited.

ida_graph.graph_path_visitor_t

ida_graph.graph_path_visitor_t.__disown__(self)

ida_graph.graph_path_visitor_t.__init__(self)

ida_graph.graph_path_visitor_t.path
    current path

ida_graph.graph_path_visitor_t.prune
    walk_forward(): prune := true means to stop the current path 
            

ida_graph.graph_path_visitor_t.walk_backward(self, arg0: int) -> int

ida_graph.graph_path_visitor_t.walk_forward(self, arg0: int) -> int

ida_graph.graph_visitor_t

ida_graph.graph_visitor_t.__disown__(self)

ida_graph.graph_visitor_t.__init__(self)

ida_graph.graph_visitor_t.visit_edge(self, arg2: "edge_t", arg3: "edge_info_t") -> int

ida_graph.graph_visitor_t.visit_node(self, arg2: int, arg3: "rect_t") -> int

ida_graph.grcode_calculating_layout
    calculating user-defined graph layout. 
              

ida_graph.grcode_center_on
    use viewer_center_on()

ida_graph.grcode_change_group_visibility
    use interactive_graph_t::change_group_visibility()

ida_graph.grcode_changed_graph
    new graph has been set. 
              

ida_graph.grcode_clear
    use interactive_graph_t::clear()

ida_graph.grcode_clicked
    graph is being clicked. this callback allows you to ignore some clicks. it occurs too early, internal graph variables are not updated yet. current_item1, current_item2 point to the same thing. item2 has more information. see also: custom_viewer_click_t 
              

ida_graph.grcode_create_circle_layout
    use drawable_graph_t::create_circle_layout()

ida_graph.grcode_create_digraph_layout
    use interactive_graph_t::create_digraph_layout()

ida_graph.grcode_create_disasm_graph1
    use create_disasm_graph(ea_t ea)

ida_graph.grcode_create_disasm_graph2
    use create_disasm_graph(const rangevec_t &ranges)

ida_graph.grcode_create_graph_viewer
    use create_graph_viewer()

ida_graph.grcode_create_group
    use interactive_graph_t::create_group()

ida_graph.grcode_create_interactive_graph
    use create_interactive_graph()

ida_graph.grcode_create_tree_layout
    use drawable_graph_t::create_tree_layout()

ida_graph.grcode_create_user_graph_place
    use create_user_graph_place()

ida_graph.grcode_creating_group
    a group is being created. this provides an opportunity for the graph to forbid creation of the group. Note that groups management is done by the interactive_graph_t instance itself: there is no need to modify the graph in this callback. 
              

ida_graph.grcode_dblclicked
    a graph node has been double clicked. 
              

ida_graph.grcode_del_custom_layout
    use interactive_graph_t::del_custom_layout()

ida_graph.grcode_del_node_info
    use viewer_del_node_info()

ida_graph.grcode_delete_group
    use interactive_graph_t::delete_group()

ida_graph.grcode_delete_interactive_graph
    use delete_interactive_graph()

ida_graph.grcode_deleting_group
    a group is being deleted. this provides an opportunity for the graph to forbid deletion of the group. Note that groups management is done by the interactive_graph_t instance itself: there is no need to modify the graph in this callback. 
              

ida_graph.grcode_destroyed
    graph is being destroyed. Note that this doesn't mean the graph viewer is being destroyed; this only means that the graph that is being displayed by it is being destroyed, and that, e.g., any possibly cached data should be invalidated (this event can happen when, for example, the user decides to group nodes together: that operation will effectively create a new graph, that will replace the old one.) To be notified when the graph viewer itself is being destroyed, please see notification 'view_close', in kernwin.hpp 
              

ida_graph.grcode_edge_infos_wrapper_clear
    use edge_infos_wrapper_t::clear()

ida_graph.grcode_edge_infos_wrapper_copy
    use edge_infos_wrapper_t::operator=()

ida_graph.grcode_empty
    use interactive_graph_t::empty()

ida_graph.grcode_find_subgraph_node
    use interactive_graph_t::_find_subgraph_node()

ida_graph.grcode_fit_window
    use viewer_fit_window()

ida_graph.grcode_get_curnode
    use viewer_get_curnode()

ida_graph.grcode_get_custom_layout
    use interactive_graph_t::get_custom_layout()

ida_graph.grcode_get_gli
    use viewer_get_gli()

ida_graph.grcode_get_graph_groups
    use interactive_graph_t::get_graph_groups()

ida_graph.grcode_get_graph_viewer
    use get_graph_viewer()

ida_graph.grcode_get_node_info
    use viewer_get_node_info()

ida_graph.grcode_get_node_representative
    use interactive_graph_t::get_node_representative()

ida_graph.grcode_get_selection
    use viewer_get_selection()

ida_graph.grcode_get_viewer_graph
    use get_viewer_graph()

ida_graph.grcode_gotfocus
    a graph viewer got focus. 
              

ida_graph.grcode_group_visibility
    a group is being collapsed/uncollapsed this provides an opportunity for the graph to forbid changing the visibility of the group. Note that groups management is done by the interactive_graph_t instance itself: there is no need to modify the graph in this callback. 
              

ida_graph.grcode_is_visible_node
    use interactive_graph_t::is_visible_node()

ida_graph.grcode_layout_calculated
    graph layout calculated. 
              

ida_graph.grcode_lostfocus
    a graph viewer lost focus. 
              

ida_graph.grcode_node_qty
    use interactive_graph_t::node_qty()

ida_graph.grcode_nrect
    use interactive_graph_t::nrect()

ida_graph.grcode_refresh_viewer
    use refresh_viewer()

ida_graph.grcode_set_custom_layout
    use interactive_graph_t::set_custom_layout()

ida_graph.grcode_set_edge
    use interactive_graph_t::set_edge()

ida_graph.grcode_set_gli
    use viewer_set_gli()

ida_graph.grcode_set_graph_groups
    use interactive_graph_t::set_graph_groups()

ida_graph.grcode_set_node_info
    use viewer_set_node_info()

ida_graph.grcode_set_titlebar_height
    use viewer_set_titlebar_height()

ida_graph.grcode_set_viewer_graph
    use set_viewer_graph()

ida_graph.grcode_user_draw
    render node of a user-defined graph. NB: draw only on the specified DC and nowhere else! 
              

ida_graph.grcode_user_hint
    retrieve hint for the user-defined graph. 
              

ida_graph.grcode_user_refresh
    refresh user-defined graph nodes and edges This is called when the UI considers that it is necessary to recreate the graph layout, and thus has to ensure that the 'interactive_graph_t' instance it is using, is up-to-date. For example:
    * at graph creation-time
    * if a refresh_viewer() call was made

ida_graph.grcode_user_size
    calculate node size for user-defined graph. 
              

ida_graph.grcode_user_text
    retrieve text for user-defined graph node. NB: do not use anything calling GDI! 
              

ida_graph.grcode_user_title
    render node title of a user-defined graph. 
              

ida_graph.grcode_viewer_create_groups_vec
    use viewer_create_groups()

ida_graph.grcode_viewer_delete_groups_vec
    use viewer_delete_groups()

ida_graph.grcode_viewer_groups_visibility_vec
    use viewer_set_groups_visibility()

ida_graph.group_crinfo_t

ida_graph.group_crinfo_t.__init__(self)

ida_graph.interactive_graph_t

ida_graph.interactive_graph_t.__init__(self, *args, **kwargs)

ida_graph.interactive_graph_t.add_edge(self, i: int, j: int, ei: "edge_info_t") -> bool

ida_graph.interactive_graph_t.add_node(self, r: "rect_t") -> int
    Add a node, possibly with a specific geometry
    
    @param r: the node geometry (can be nullptr)
    @returns the new node

ida_graph.interactive_graph_t.belongs
    the subgraph the node belongs to INT_MAX means that the node doesn't exist sign bit means collapsed node 
            

ida_graph.interactive_graph_t.calc_group_ea(self, arg2: "intvec_t const &") -> ida_idaapi.ea_t

ida_graph.interactive_graph_t.change_group_visibility(self, group: int, expand: bool) -> bool
    Expand/collapse a group node
    
    @param group: the group node
    @param expand: whether to expand or collapse
    @returns success

ida_graph.interactive_graph_t.create_digraph_layout(self) -> bool

ida_graph.interactive_graph_t.create_group(self, nodes: "intvec_t const &") -> int
    Create a new group node, that will contain all the nodes in 'nodes'.
    
    @param nodes: the nodes that will be part of the group
    @returns the group node, or -1 in case of error

ida_graph.interactive_graph_t.del_custom_layout(self) -> None

ida_graph.interactive_graph_t.del_edge(self, i: int, j: int) -> bool

ida_graph.interactive_graph_t.del_node(self, n: int) -> "ssize_t"
    Delete a node
    
    @param n: the node to delete
    @returns the number of deleted edges

ida_graph.interactive_graph_t.delete_group(self, group: int) -> bool
    Delete a group node.
    This deletes the group node only; it does not delete nodes that are part of the group.
    
    @param group: the group node
    @returns success

ida_graph.interactive_graph_t.empty(self) -> bool
    Is the graph (visually) empty? 
            
    @returns true if there are no visible nodes

ida_graph.interactive_graph_t.exists(self, node: int) -> bool
    Is the node visible?
    
    @param node: the node number
    @returns success

ida_graph.interactive_graph_t.get_custom_layout(self) -> bool

ida_graph.interactive_graph_t.get_first_subgraph_node(self, group: int) -> int

ida_graph.interactive_graph_t.get_graph_groups(self) -> bool

ida_graph.interactive_graph_t.get_next_subgraph_node(self, group: int, current: int) -> int

ida_graph.interactive_graph_t.get_node_group(self, node: int) -> int

ida_graph.interactive_graph_t.get_node_representative(self, node: int) -> int
    Get the node that currently visually represents 'node'. This will find the "closest" parent group node that's visible, by attempting to walk up the group nodes that contain 'node', and will stop when it finds a node that is currently visible.
    See also get_group_node() 
            
    @param node: the node
    @returns the node that represents 'node', or 'node' if it's not part of any group

ida_graph.interactive_graph_t.gid
    graph id - unique for the database for flowcharts it is equal to the function start_ea 
            

ida_graph.interactive_graph_t.is_collapsed_node(self, node: int) -> bool

ida_graph.interactive_graph_t.is_deleted_node(self, node: int) -> bool

ida_graph.interactive_graph_t.is_displayable_node(self, node: int) -> bool

ida_graph.interactive_graph_t.is_dot_node(self, node: int) -> bool

ida_graph.interactive_graph_t.is_group_node(self, node: int) -> bool

ida_graph.interactive_graph_t.is_simple_node(self, node: int) -> bool

ida_graph.interactive_graph_t.is_subgraph_node(self, node: int) -> bool

ida_graph.interactive_graph_t.is_uncollapsed_node(self, node: int) -> bool

ida_graph.interactive_graph_t.is_user_graph(self) -> bool

ida_graph.interactive_graph_t.is_visible_node(self, node: int) -> bool
    Is the node currently visible?
    An invisible node is a node that's part of a group that's currently collapsed.
    
    @param node: the node
    @returns success

ida_graph.interactive_graph_t.node_flags
    node flags

ida_graph.interactive_graph_t.node_qty(self) -> int
    Get the number of visible nodes (the list can be retrieved using gdl.hpp's node_iterator)
    See also size()
    
    @returns the number of visible nodes

ida_graph.interactive_graph_t.npred(self, b: int) -> int

ida_graph.interactive_graph_t.nsucc(self, b: int) -> int

ida_graph.interactive_graph_t.pred(self, b: int, i: int) -> int

ida_graph.interactive_graph_t.predset(self, b: int) -> "intvec_t const &"

ida_graph.interactive_graph_t.redo_layout(self) -> bool
    Recompute the layout, according to the value of 'current_layout'.
    
    @returns success

ida_graph.interactive_graph_t.refresh(self) -> bool
    Refresh the graph
    A graph needs refreshing when it's "backing data". E.g., if the number (or contents) of the objects in the above example, change.
    Let's say the user's plugin ends up finding a 5th piece of scattered data. It should then add it to its internal list of known objects, and tell IDA that the graph needs to be refreshed, using refresh_viewer(). This will cause IDA to:
    * discard all its internal rendering information,
    * call interactive_graph_t::refresh() on the graph so that the user's plugin has a chance to "sync" the number of nodes & edges that this graph contains, to the information that the plugin has collected so far
    * re-create internal rendering information, and
    * repaint the view
    
    
    
    @returns success

ida_graph.interactive_graph_t.replace_edge(self, i: int, j: int, x: int, y: int) -> bool

ida_graph.interactive_graph_t.reset(self) -> None

ida_graph.interactive_graph_t.resize(self, n: int) -> None
    Resize the graph to 'n' nodes
    
    @param n: the new size

ida_graph.interactive_graph_t.set_custom_layout(self) -> None

ida_graph.interactive_graph_t.set_deleted_node(self, node: int) -> None

ida_graph.interactive_graph_t.set_edge(self, e: "edge_t", ei: "edge_info_t") -> bool

ida_graph.interactive_graph_t.set_graph_groups(self) -> None

ida_graph.interactive_graph_t.set_node_group(self, node: int, group: int) -> None

ida_graph.interactive_graph_t.set_nrect(self, n: int, r: "rect_t") -> bool

ida_graph.interactive_graph_t.size(self) -> int
    Get the total number of nodes (including group nodes, and including hidden nodes.)
    See also node_qty()
    
    @returns the total number of nodes in the graph

ida_graph.interactive_graph_t.succ(self, b: int, i: int) -> int

ida_graph.interactive_graph_t.succset(self, b: int) -> "intvec_t const &"

ida_graph.interval_t

ida_graph.interval_t.__eq__(self, r: "interval_t") -> bool

ida_graph.interval_t.__init__(self, *args)

ida_graph.interval_t.__ne__(self, r: "interval_t") -> bool

ida_graph.interval_t.contains(self, x: int) -> bool

ida_graph.interval_t.empty(self) -> bool

ida_graph.interval_t.intersect(self, r: "interval_t") -> None

ida_graph.interval_t.length(self) -> int

ida_graph.interval_t.make_union(self, r: "interval_t") -> None

ida_graph.interval_t.move_by(self, shift: int) -> None

ida_graph.node_info_t

ida_graph.node_info_t.__init__(self)

ida_graph.node_info_t.bg_color
    background color

ida_graph.node_info_t.ea
    address

ida_graph.node_info_t.flags
    flags

ida_graph.node_info_t.frame_color
    color of enclosing frame

ida_graph.node_info_t.get_flags_for_valid(self) -> int
    Get combination of Node info flags describing which attributes are valid.

ida_graph.node_info_t.text
    node contents

ida_graph.node_info_t.valid_bg_color(self) -> bool
    Has valid bg_color?

ida_graph.node_info_t.valid_ea(self) -> bool
    Has valid ea?

ida_graph.node_info_t.valid_flags(self) -> bool
    Has valid flags?

ida_graph.node_info_t.valid_frame_color(self) -> bool
    Has valid frame_color?

ida_graph.node_info_t.valid_text(self) -> bool
    Has non-empty text?

ida_graph.node_layout_t

ida_graph.node_layout_t.__eq__(self, r: "node_layout_t") -> bool

ida_graph.node_layout_t.__getitem__(self, i: "size_t") -> "rect_t const &"

ida_graph.node_layout_t.__init__(self, *args)

ida_graph.node_layout_t.__len__(self) -> "size_t"

ida_graph.node_layout_t.__ne__(self, r: "node_layout_t") -> bool

ida_graph.node_layout_t.__setitem__(self, i: "size_t", v: "rect_t") -> None

ida_graph.node_layout_t._del(self, x: "rect_t") -> bool

ida_graph.node_layout_t.add_unique(self, x: "rect_t") -> bool

ida_graph.node_layout_t.append(self, x: "rect_t") -> None

ida_graph.node_layout_t.at(self, _idx: "size_t") -> "rect_t const &"

ida_graph.node_layout_t.begin(self, *args) -> "qvector< rect_t >::const_iterator"

ida_graph.node_layout_t.capacity(self) -> "size_t"

ida_graph.node_layout_t.clear(self) -> None

ida_graph.node_layout_t.empty(self) -> bool

ida_graph.node_layout_t.end(self, *args) -> "qvector< rect_t >::const_iterator"

ida_graph.node_layout_t.erase(self, *args) -> "qvector< rect_t >::iterator"

ida_graph.node_layout_t.extend(self, x: "node_layout_t") -> None

ida_graph.node_layout_t.extract(self) -> "rect_t *"

ida_graph.node_layout_t.find(self, *args) -> "qvector< rect_t >::const_iterator"

ida_graph.node_layout_t.grow(self, *args) -> None

ida_graph.node_layout_t.has(self, x: "rect_t") -> bool

ida_graph.node_layout_t.inject(self, s: "rect_t", len: "size_t") -> None

ida_graph.node_layout_t.insert(self, it: "rect_t", x: "rect_t") -> "qvector< rect_t >::iterator"

ida_graph.node_layout_t.pop_back(self) -> None

ida_graph.node_layout_t.push_back(self, *args) -> "rect_t &"

ida_graph.node_layout_t.qclear(self) -> None

ida_graph.node_layout_t.reserve(self, cnt: "size_t") -> None

ida_graph.node_layout_t.resize(self, *args) -> None

ida_graph.node_layout_t.size(self) -> "size_t"

ida_graph.node_layout_t.swap(self, r: "node_layout_t") -> None

ida_graph.node_layout_t.truncate(self) -> None

ida_graph.point_t

ida_graph.point_t.__eq__(self, r: "point_t") -> bool

ida_graph.point_t.__init__(self, *args)

ida_graph.point_t.__ne__(self, r: "point_t") -> bool

ida_graph.point_t.add(self, r: "point_t") -> "point_t &"

ida_graph.point_t.negate(self) -> None

ida_graph.point_t.sub(self, r: "point_t") -> "point_t &"

ida_graph.pointseq_t

ida_graph.pointseq_t.__init__(self)

ida_graph.pointvec_t

ida_graph.pointvec_t.__eq__(self, r: "pointvec_t") -> bool

ida_graph.pointvec_t.__getitem__(self, i: "size_t") -> "point_t const &"

ida_graph.pointvec_t.__init__(self, *args)

ida_graph.pointvec_t.__len__(self) -> "size_t"

ida_graph.pointvec_t.__ne__(self, r: "pointvec_t") -> bool

ida_graph.pointvec_t.__setitem__(self, i: "size_t", v: "point_t") -> None

ida_graph.pointvec_t._del(self, x: "point_t") -> bool

ida_graph.pointvec_t.add_unique(self, x: "point_t") -> bool

ida_graph.pointvec_t.append(self, x: "point_t") -> None

ida_graph.pointvec_t.at(self, _idx: "size_t") -> "point_t const &"

ida_graph.pointvec_t.begin(self, *args) -> "qvector< point_t >::const_iterator"

ida_graph.pointvec_t.capacity(self) -> "size_t"

ida_graph.pointvec_t.clear(self) -> None

ida_graph.pointvec_t.empty(self) -> bool

ida_graph.pointvec_t.end(self, *args) -> "qvector< point_t >::const_iterator"

ida_graph.pointvec_t.erase(self, *args) -> "qvector< point_t >::iterator"

ida_graph.pointvec_t.extend(self, x: "pointvec_t") -> None

ida_graph.pointvec_t.extract(self) -> "point_t *"

ida_graph.pointvec_t.find(self, *args) -> "qvector< point_t >::const_iterator"

ida_graph.pointvec_t.grow(self, *args) -> None

ida_graph.pointvec_t.has(self, x: "point_t") -> bool

ida_graph.pointvec_t.inject(self, s: "point_t", len: "size_t") -> None

ida_graph.pointvec_t.insert(self, it: "point_t", x: "point_t") -> "qvector< point_t >::iterator"

ida_graph.pointvec_t.pop_back(self) -> None

ida_graph.pointvec_t.push_back(self, *args) -> "point_t &"

ida_graph.pointvec_t.qclear(self) -> None

ida_graph.pointvec_t.reserve(self, cnt: "size_t") -> None

ida_graph.pointvec_t.resize(self, *args) -> None

ida_graph.pointvec_t.size(self) -> "size_t"

ida_graph.pointvec_t.swap(self, r: "pointvec_t") -> None

ida_graph.pointvec_t.truncate(self) -> None

ida_graph.pyg_close(_self: "PyObject *") -> None

ida_graph.pyg_select_node(_self: "PyObject *", nid: int) -> None

ida_graph.pyg_show(_self: "PyObject *") -> bool

ida_graph.rect_t

ida_graph.rect_t.__eq__(self, r: "rect_t") -> bool

ida_graph.rect_t.__init__(self, *args)

ida_graph.rect_t.__ne__(self, r: "rect_t") -> bool

ida_graph.rect_t.area(self) -> int

ida_graph.rect_t.bottomright(self) -> "point_t"

ida_graph.rect_t.center(self) -> "point_t"

ida_graph.rect_t.contains(self, p: "point_t") -> bool

ida_graph.rect_t.empty(self) -> bool

ida_graph.rect_t.grow(self, delta: int) -> None

ida_graph.rect_t.height(self) -> int

ida_graph.rect_t.intersect(self, r: "rect_t") -> None

ida_graph.rect_t.is_intersection_empty(self, r: "rect_t") -> bool

ida_graph.rect_t.make_union(self, r: "rect_t") -> None

ida_graph.rect_t.move_by(self, p: "point_t") -> None

ida_graph.rect_t.move_to(self, p: "point_t") -> None

ida_graph.rect_t.topleft(self) -> "point_t"

ida_graph.rect_t.verify(self) -> None

ida_graph.rect_t.width(self) -> int

ida_graph.refresh_viewer(gv: "graph_viewer_t *") -> None
    Redraw the graph in the given view.

ida_graph.row_info_t

ida_graph.row_info_t.__init__(self)

ida_graph.row_info_t.bottom
    bottom y coord of the row

ida_graph.row_info_t.height(self) -> int

ida_graph.row_info_t.nodes
    list of nodes at the row

ida_graph.row_info_t.top
    top y coord of the row

ida_graph.screen_graph_selection_base_t

ida_graph.screen_graph_selection_base_t.__eq__(self, r: "screen_graph_selection_base_t") -> bool

ida_graph.screen_graph_selection_base_t.__getitem__(self, i: "size_t") -> "selection_item_t const &"

ida_graph.screen_graph_selection_base_t.__init__(self, *args)

ida_graph.screen_graph_selection_base_t.__len__(self) -> "size_t"

ida_graph.screen_graph_selection_base_t.__ne__(self, r: "screen_graph_selection_base_t") -> bool

ida_graph.screen_graph_selection_base_t.__setitem__(self, i: "size_t", v: "selection_item_t") -> None

ida_graph.screen_graph_selection_base_t._del(self, x: "selection_item_t") -> bool

ida_graph.screen_graph_selection_base_t.add_unique(self, x: "selection_item_t") -> bool

ida_graph.screen_graph_selection_base_t.append(self, x: "selection_item_t") -> None

ida_graph.screen_graph_selection_base_t.at(self, _idx: "size_t") -> "selection_item_t const &"

ida_graph.screen_graph_selection_base_t.begin(self, *args) -> "qvector< selection_item_t >::const_iterator"

ida_graph.screen_graph_selection_base_t.capacity(self) -> "size_t"

ida_graph.screen_graph_selection_base_t.clear(self) -> None

ida_graph.screen_graph_selection_base_t.empty(self) -> bool

ida_graph.screen_graph_selection_base_t.end(self, *args) -> "qvector< selection_item_t >::const_iterator"

ida_graph.screen_graph_selection_base_t.erase(self, *args) -> "qvector< selection_item_t >::iterator"

ida_graph.screen_graph_selection_base_t.extend(self, x: "screen_graph_selection_base_t") -> None

ida_graph.screen_graph_selection_base_t.extract(self) -> "selection_item_t *"

ida_graph.screen_graph_selection_base_t.find(self, *args) -> "qvector< selection_item_t >::const_iterator"

ida_graph.screen_graph_selection_base_t.grow(self, *args) -> None

ida_graph.screen_graph_selection_base_t.has(self, x: "selection_item_t") -> bool

ida_graph.screen_graph_selection_base_t.inject(self, s: "selection_item_t", len: "size_t") -> None

ida_graph.screen_graph_selection_base_t.insert(self, it: "selection_item_t", x: "selection_item_t") -> "qvector< selection_item_t >::iterator"

ida_graph.screen_graph_selection_base_t.pop_back(self) -> None

ida_graph.screen_graph_selection_base_t.push_back(self, *args) -> "selection_item_t &"

ida_graph.screen_graph_selection_base_t.qclear(self) -> None

ida_graph.screen_graph_selection_base_t.reserve(self, cnt: "size_t") -> None

ida_graph.screen_graph_selection_base_t.resize(self, *args) -> None

ida_graph.screen_graph_selection_base_t.size(self) -> "size_t"

ida_graph.screen_graph_selection_base_t.swap(self, r: "screen_graph_selection_base_t") -> None

ida_graph.screen_graph_selection_base_t.truncate(self) -> None

ida_graph.screen_graph_selection_t

ida_graph.screen_graph_selection_t.__init__(self)

ida_graph.screen_graph_selection_t.add(self, s: "screen_graph_selection_t") -> None

ida_graph.screen_graph_selection_t.add_node(self, node: int) -> None

ida_graph.screen_graph_selection_t.add_point(self, e: "edge_t", idx: int) -> None

ida_graph.screen_graph_selection_t.del_node(self, node: int) -> None

ida_graph.screen_graph_selection_t.del_point(self, e: "edge_t", idx: int) -> None

ida_graph.screen_graph_selection_t.has(self, item: "selection_item_t") -> bool

ida_graph.screen_graph_selection_t.items_count(self, look_for_nodes: bool) -> "size_t"

ida_graph.screen_graph_selection_t.nodes_count(self) -> "size_t"

ida_graph.screen_graph_selection_t.points_count(self) -> "size_t"

ida_graph.screen_graph_selection_t.sub(self, s: "screen_graph_selection_t") -> None

ida_graph.selection_item_t

ida_graph.selection_item_t.__eq__(self, r: "selection_item_t") -> bool

ida_graph.selection_item_t.__init__(self, *args)

ida_graph.selection_item_t.__lt__(self, r: "selection_item_t") -> bool

ida_graph.selection_item_t.__ne__(self, r: "selection_item_t") -> bool

ida_graph.selection_item_t.compare(self, r: "selection_item_t") -> int

ida_graph.selection_item_t.elp
    edge layout point (is_node = false)

ida_graph.selection_item_t.is_node
    represents a selected node?

ida_graph.selection_item_t.node
    node number (is_node = true)

ida_graph.set_node_info(gid: "graph_id_t", node: int, ni: "node_info_t", flags: int) -> None
    Set node info. 
            
    @param gid: id of desired graph
    @param node: node number
    @param ni: node info to use
    @param flags: combination of Node info flags, identifying which fields of 'ni' will be used

ida_graph.set_viewer_graph(gv: "graph_viewer_t *", g: "interactive_graph_t") -> None
    Set the underlying graph object for the given viewer.

ida_graph.user_graph_place_t

ida_graph.user_graph_place_t.__init__(self, *args, **kwargs)

ida_graph.viewer_attach_menu_item(g: "graph_viewer_t *", name: str) -> bool
    Attach a previously-registered action to the view's context menu. See kernwin.hpp for how to register actions. 
            
    @param g: graph viewer
    @param name: action name
    @returns success

ida_graph.viewer_center_on(gv: "graph_viewer_t *", node: int) -> None
    Center the graph view on the given node.

ida_graph.viewer_create_groups(gv: "graph_viewer_t *", out_group_nodes: "intvec_t *", gi: "groups_crinfos_t const &") -> bool
    This will perform an operation similar to what happens when a user manually selects a set of nodes, right-clicks and selects "Create group". This is a wrapper around interactive_graph_t::create_group that will, in essence:
    * clone the current graph
    * for each group_crinfo_t, attempt creating group in that new graph
    * if all were successful, animate to that new graph.

ida_graph.viewer_del_node_info(gv: "graph_viewer_t *", n: int) -> None
    Delete node info for node in given viewer (see del_node_info())

ida_graph.viewer_delete_groups(gv: "graph_viewer_t *", groups: "intvec_t const &", new_current: int = -1) -> bool
    Wrapper around interactive_graph_t::delete_group. This function will:
    * clone the current graph
    * attempt deleting the groups in that new graph
    * if successful, animate to that new graph. 
    
    
            

ida_graph.viewer_fit_window(gv: "graph_viewer_t *") -> None
    Fit graph viewer to its parent form.

ida_graph.viewer_get_curnode(gv: "graph_viewer_t *") -> int
    Get number of currently selected node (-1 if none)

ida_graph.viewer_get_gli(out: "graph_location_info_t *", gv: "graph_viewer_t *", flags: int = 0) -> bool
    Get location info for given graph view If flags contains GLICTL_CENTER, then the gli that will be retrieved, will be the one at the center of the view. Otherwise it will be the top-left. 
            

ida_graph.viewer_get_node_info(gv: "graph_viewer_t *", out: "node_info_t", n: int) -> bool
    Get node info for node in given viewer (see get_node_info())

ida_graph.viewer_get_selection(gv: "graph_viewer_t *", sgs: "screen_graph_selection_t") -> bool
    Get currently selected items for graph viewer.

ida_graph.viewer_set_gli(gv: "graph_viewer_t *", gli: "graph_location_info_t const *", flags: int = 0) -> None
    Set location info for given graph view If flags contains GLICTL_CENTER, then the gli will be set to be the center of the view. Otherwise it will be the top-left. 
            

ida_graph.viewer_set_groups_visibility(gv: "graph_viewer_t *", groups: "intvec_t const &", expand: bool, new_current: int = -1) -> bool
    Wrapper around interactive_graph_t::change_visibility. This function will:
    * clone the current graph
    * attempt changing visibility of the groups in that new graph
    * if successful, animate to that new graph. 
    
    
            

ida_graph.viewer_set_node_info(gv: "graph_viewer_t *", n: int, ni: "node_info_t", flags: int) -> None
    Set node info for node in given viewer (see set_node_info())

ida_graph.viewer_set_titlebar_height(gv: "graph_viewer_t *", height: int) -> int
    Set height of node title bars (grcode_set_titlebar_height)

ida_ida
    Contains the ::inf structure definition and some functions common to the whole IDA project.
    
    The ::inf structure is saved in the database and contains information specific to the current program being disassembled. Initially it is filled with values from ida.cfg.
    Although it is not a good idea to change values in ::inf structure (because you will overwrite values taken from ida.cfg), you are allowed to do it if you feel it necessary. 
        

ida_ida.ABI_8ALIGN4
    4 byte alignment for 8byte scalars (__int64/double) inside structures?

ida_ida.ABI_BIGARG_ALIGN
    use natural type alignment for argument if the alignment exceeds native word size. (e.g. __int64 argument should be 8byte aligned on some 32bit platforms) 
            

ida_ida.ABI_GCC_LAYOUT
    use gcc layout for udts (used for mingw)

ida_ida.ABI_HARD_FLOAT
    use the floating-point register set

ida_ida.ABI_HUGEARG_ALIGN
    use natural type alignment for an argument even if its alignment exceeds double native word size (the default is to use double word max). e.g. if this bit is set, __int128 has 16-byte alignment. this bit is not used by ida yet 
            

ida_ida.ABI_MAP_STKARGS
    register arguments are mapped to stack area (and consume stack slots)

ida_ida.ABI_PACK_STKARGS
    do not align stack arguments to stack slots

ida_ida.ABI_SET_BY_USER
    compiler/abi were set by user flag and require SETCOMP_BY_USER flag to be changed

ida_ida.ABI_STACK_LDBL
    long double arguments are passed on stack

ida_ida.ABI_STACK_VARARGS
    varargs are always passed on stack (even when there are free registers)

ida_ida.AF2_DOEH
    Handle EH information.

ida_ida.AF2_DORTTI
    Handle RTTI information.

ida_ida.AF2_MACRO
    Try to combine several instructions into a macro instruction 
            

ida_ida.AF2_MERGESTR
    Merge string literals created using data xrefs 
            

ida_ida.AF_ANORET
    Perform 'no-return' analysis.

ida_ida.AF_CHKUNI
    Check for unicode strings.

ida_ida.AF_CODE
    Trace execution flow.

ida_ida.AF_DATOFF
    Automatically convert data to offsets.

ida_ida.AF_DOCODE
    Coagulate code segs at the final pass.

ida_ida.AF_DODATA
    Coagulate data segs at the final pass.

ida_ida.AF_DREFOFF
    Create offset if data xref to seg32 exists.

ida_ida.AF_FINAL
    Final pass of analysis.

ida_ida.AF_FIXUP
    Create offsets and segments using fixup info.

ida_ida.AF_FLIRT
    Use flirt signatures.

ida_ida.AF_FTAIL
    Create function tails.

ida_ida.AF_HFLIRT
    Automatically hide library functions.

ida_ida.AF_IMMOFF
    Convert 32bit instruction operand to offset.

ida_ida.AF_JFUNC
    Rename jump functions as j_...

ida_ida.AF_JUMPTBL
    Locate and create jump tables.

ida_ida.AF_LVAR
    Create stack variables.

ida_ida.AF_MARKCODE
    Mark typical code sequences as code.

ida_ida.AF_MEMFUNC
    Try to guess member function types.

ida_ida.AF_NULLSUB
    Rename empty functions as nullsub_...

ida_ida.AF_PROC
    Create functions if call is present.

ida_ida.AF_PROCPTR
    Create function if data xref data->code32 exists.

ida_ida.AF_PURDAT
    Control flow to data segment is ignored.

ida_ida.AF_REGARG
    Propagate register argument information.

ida_ida.AF_SIGCMT
    Append a signature name comment for recognized anonymous library functions.

ida_ida.AF_SIGMLT
    Allow recognition of several copies of the same function.

ida_ida.AF_STKARG
    Propagate stack argument information.

ida_ida.AF_STRLIT
    Create string literal if data xref exists.

ida_ida.AF_TRACE
    Trace stack pointer.

ida_ida.AF_TRFUNC
    Truncate functions upon code deletion.

ida_ida.AF_UNK
    Delete instructions with no xrefs.

ida_ida.AF_USED
    Analyze and create all xrefs.

ida_ida.AF_VERSP
    Perform full SP-analysis. ( processor_t::verify_sp)

ida_ida.DEMNAM_CMNT
    display demangled names as comments

ida_ida.DEMNAM_FIRST
    override type info

ida_ida.DEMNAM_GCC3
    assume gcc3 names (valid for gnu compiler)

ida_ida.DEMNAM_MASK
    mask for name form

ida_ida.DEMNAM_NAME
    display demangled names as regular names

ida_ida.DEMNAM_NONE
    don't display demangled names

ida_ida.IDAINFO_TAG_SIZE
    The database parameters. This structure is kept in the ida database. It contains the essential parameters for the current program 
            

ida_ida.IDB_COMPRESSED
    compress & pack database components

ida_ida.IDB_PACKED
    pack database components into .idb

ida_ida.IDB_UNPACKED
    leave database components unpacked

ida_ida.IDI_ALTVAL
    netnode: altval

ida_ida.IDI_BITMAP
    bitmap field: interpret bitmask as bit number

ida_ida.IDI_BLOB
    netnode: blob

ida_ida.IDI_BYTEARRAY
    byte array: binary representation

ida_ida.IDI_CSTR
    string

ida_ida.IDI_DEC
    show as decimal

ida_ida.IDI_EA_HEX
    default representation: hex or "BADADDR"

ida_ida.IDI_HASH
    hashed node field, hash name in offset

ida_ida.IDI_HEX
    show as hexadecimal

ida_ida.IDI_HLPSTRUC
    call helper for pointer to structure

ida_ida.IDI_INC
    stored value is incremented (scalars only)

ida_ida.IDI_MAP_VAL
    apply ea2node() to value

ida_ida.IDI_NOMERGE
    field should not be merged as part of INF

ida_ida.IDI_ONOFF
    show boolean as on/off (not true/false)

ida_ida.IDI_QSTRING
    qstring

ida_ida.IDI_READONLY
    read-only field (cannot be modified)

ida_ida.IDI_SCALAR
    scalar value (default)

ida_ida.IDI_STRUCFLD
    structure field (opposite to IDI_NODEVAL)

ida_ida.IDI_SUPVAL
    netnode: supval

ida_ida.IDI_VALOBJ
    netnode: valobj

ida_ida.INFFL_ALLASM
    may use constructs not supported by the target assembler 
            

ida_ida.INFFL_AUTO
    Autoanalysis is enabled?

ida_ida.INFFL_CHKOPS
    check manual operands? (unused)

ida_ida.INFFL_GRAPH_VIEW
    currently using graph options ( text_options_t::graph)

ida_ida.INFFL_LOADIDC
    loading an idc file that contains database info

ida_ida.INFFL_NMOPS
    allow non-matched operands? (unused)

ida_ida.INFFL_NOUSER
    do not store user info in the database

ida_ida.INFFL_READONLY
    (internal) temporary interdiction to modify the database

ida_ida.INF_ABINAME
    ABI name (processor specific)

ida_ida.INF_ARCHIVE_PATH
    archive file path

ida_ida.INF_CRC32
    input file crc32

ida_ida.INF_CTIME
    database creation timestamp

ida_ida.INF_C_MACROS
    C predefined macros.

ida_ida.INF_DBG_BINPATHS
    unused (20 indexes)

ida_ida.INF_DUALOP_GRAPH
    Graph text representation options.

ida_ida.INF_DUALOP_TEXT
    Text text representation options.

ida_ida.INF_ELAPSED
    seconds database stayed open

ida_ida.INF_FILE_FORMAT_NAME
    file format name for loader modules

ida_ida.INF_FSIZE
    input file size

ida_ida.INF_GROUPS
    segment group information (see init_groups())

ida_ida.INF_H_PATH
    C header path.

ida_ida.INF_IDA_VERSION
    version of ida which created the database

ida_ida.INF_IDSNODE
    ids modnode id (for import_module)

ida_ida.INF_IMAGEBASE
    image base

ida_ida.INF_INCLUDE
    assembler include file name

ida_ida.INF_INITIAL_VERSION
    initial version of database

ida_ida.INF_MD5
    MD5 of the input file.

ida_ida.INF_NOPENS
    how many times the database is opened

ida_ida.INF_NOTEPAD
    notepad blob, occupies 1000 indexes (1MB of text)

ida_ida.INF_OUTFILEENC
    output file encoding index

ida_ida.INF_PROBLEMS
    problem lists

ida_ida.INF_SELECTORS
    2..63 are for selector_t blob (see init_selectors())

ida_ida.INF_SHA256
    SHA256 of the input file.

ida_ida.INF_SRCDBG_PATHS
    source debug paths, occupies 20 indexes

ida_ida.INF_SRCDBG_UNDESIRED
    user-closed source files, occupies 20 indexes

ida_ida.INF_STR_ENCODINGS
    a list of encodings for the program strings

ida_ida.LFLG_64BIT
    64-bit program?

ida_ida.LFLG_COMPRESS
    compress the database?

ida_ida.LFLG_DBG_NOPATH
    do not store input full path in debugger process options

ida_ida.LFLG_FLAT_OFF32
    treat REF_OFF32 as 32-bit offset for 16bit segments (otherwise try SEG16:OFF16)

ida_ida.LFLG_ILP32
    64-bit instructions with 64-bit registers, but 32-bit pointers and address space. this bit is mutually exclusive with LFLG_64BIT 
            

ida_ida.LFLG_IS_DLL
    Is dynamic library?

ida_ida.LFLG_KERNMODE
    is kernel mode binary?

ida_ida.LFLG_MSF
    Byte order: is MSB first?

ida_ida.LFLG_PACK
    pack the database?

ida_ida.LFLG_PC_FLAT
    32-bit program (or higher)?

ida_ida.LFLG_PC_FPP
    decode floating point processor instructions?

ida_ida.LFLG_SNAPSHOT
    memory snapshot was taken?

ida_ida.LFLG_WIDE_HBF
    Bit order of wide bytes: high byte first? (wide bytes: processor_t::dnbits > 8) 
            

ida_ida.LMT_EMPTY
    empty lines at the end of basic blocks

ida_ida.LMT_THICK
    thick borders

ida_ida.LMT_THIN
    thin borders

ida_ida.LN_AUTO
    include autogenerated names

ida_ida.LN_NORMAL
    include normal names

ida_ida.LN_PUBLIC
    include public names

ida_ida.LN_WEAK
    include weak names

ida_ida.OFLG_GEN_ASSUME
    Generate 'assume' directives?

ida_ida.OFLG_GEN_NULL
    Generate empty lines?

ida_ida.OFLG_GEN_ORG
    Generate 'org' directives?

ida_ida.OFLG_GEN_TRYBLKS
    Generate try/catch directives?

ida_ida.OFLG_LZERO
    generate leading zeroes in numbers

ida_ida.OFLG_PREF_SEG
    line prefixes with segment name?

ida_ida.OFLG_SHOW_AUTO
    Display autoanalysis indicator?

ida_ida.OFLG_SHOW_PREF
    Show line prefixes?

ida_ida.OFLG_SHOW_VOID
    Display void marks?

ida_ida.PREF_FNCOFF
    show function offsets?

ida_ida.PREF_PFXTRUNC
    truncate instruction bytes if they would need more than 1 line

ida_ida.PREF_SEGADR
    show segment addresses?

ida_ida.PREF_STACK
    show stack pointer?

ida_ida.SCF_ALLCMT
    comment all lines?

ida_ida.SCF_LINNUM
    show source line numbers

ida_ida.SCF_NOCMT
    no comments at all

ida_ida.SCF_RPTCMT
    show repeatable comments?

ida_ida.SCF_SHHID_FUNC
    show hidden functions

ida_ida.SCF_SHHID_ITEM
    show hidden instructions

ida_ida.SCF_SHHID_SEGM
    show hidden segments

ida_ida.SCF_TESTMODE
    testida.idc is running

ida_ida.STRF_AUTO
    names have 'autogenerated' bit?

ida_ida.STRF_COMMENT
    generate auto comment for string references?

ida_ida.STRF_GEN
    generate names?

ida_ida.STRF_SAVECASE
    preserve case of strings for identifiers

ida_ida.STRF_SERIAL
    generate serial names?

ida_ida.STRF_UNICODE
    unicode strings are present?

ida_ida.STT_CUR
    use current storage type (may be used only as a function argument)

ida_ida.STT_DBG
    memory map: temporary debugger storage. used internally

ida_ida.STT_MM
    memory map: sparse storage. useful for huge objects

ida_ida.STT_VA
    regular storage: virtual arrays, an explicit flag for each byte

ida_ida.SW_SEGXRF
    show segments in xrefs?

ida_ida.SW_XRFFNC
    show function offsets?

ida_ida.SW_XRFMRK
    show xref type marks?

ida_ida.SW_XRFVAL
    show xref values? (otherwise-"...")

ida_ida.UA_MAXOP
    max number of operands allowed for an instruction

ida_ida.VLD_AUTO_REPAIR
    automatically repair the database

ida_ida.VLD_DIALOG
    ask user to repair (this bit is mutually exclusive with VLD_AUTO_REPAIR)

ida_ida.VLD_SILENT
    no messages to the output window

ida_ida.__make_idainfo_accessors(attr, getter_name = None, setter_name = None)

ida_ida.__make_idainfo_bound(func, attr)

ida_ida.__make_idainfo_bound.__func(self, *args)

ida_ida.__make_idainfo_getter(name)

ida_ida.__set_module_dynattrs(modname, pdict)

ida_ida.__wrap_hooks_callback(klass, new_name, old_name, do_call)

ida_ida.__wrap_hooks_callback.__wrapper(self, *args)

ida_ida.calc_default_idaplace_flags() -> int
    Get default disassembly line options.

ida_ida.compiler_info_t

ida_ida.compiler_info_t.__init__(self)

ida_ida.compiler_info_t.cm
    memory model and calling convention (see CM)

ida_ida.compiler_info_t.defalign
    default alignment for structures

ida_ida.compiler_info_t.id
    compiler id (see Compiler IDs)

ida_ida.compiler_info_t.size_b
    sizeof(bool)

ida_ida.compiler_info_t.size_e
    sizeof(enum)

ida_ida.compiler_info_t.size_i
    sizeof(int)

ida_ida.compiler_info_t.size_l
    long

ida_ida.compiler_info_t.size_ldbl
    longdouble (if different from processor_t::tbyte_size)

ida_ida.compiler_info_t.size_ll
    longlong

ida_ida.compiler_info_t.size_s
    short

ida_ida.delinf(tag: "inftag_t") -> bool
    Undefine a program specific information 
            
    @param tag: one of inftag_t constants
    @returns success

ida_ida.f_AIXAR
    AIX ar library.

ida_ida.f_AOUT
    Linux a.out (AOUT)

ida_ida.f_AR
    ar library

ida_ida.f_BIN
    Binary File.

ida_ida.f_COFF
    Common Object File Format (COFF)

ida_ida.f_COM
    MS DOS COM File.

ida_ida.f_COM_old
    MS DOS COM File.

ida_ida.f_DRV
    MS DOS Driver.

ida_ida.f_ELF
    Executable and Linkable Format (ELF)

ida_ida.f_EXE
    MS DOS EXE File.

ida_ida.f_EXE_old
    MS DOS EXE File.

ida_ida.f_HEX
    Intel Hex Object File.

ida_ida.f_LE
    Linear Executable (LE)

ida_ida.f_LOADER
    file is loaded using LOADER DLL

ida_ida.f_LX
    Linear Executable (LX)

ida_ida.f_MACHO
    Mac OS X Mach-O.

ida_ida.f_MD1IMG
    Mediatek Firmware Image.

ida_ida.f_MEX
    MOS Technology Hex Object File.

ida_ida.f_NLM
    Netware Loadable Module (NLM)

ida_ida.f_OMF
    Object Module Format.

ida_ida.f_OMFLIB
    Library of OMF Modules.

ida_ida.f_PE
    Portable Executable (PE)

ida_ida.f_PRC
    PalmPilot program file.

ida_ida.f_PSXOBJ
    Sony Playstation PSX object file.

ida_ida.f_SREC
    Motorola SREC (S-record)

ida_ida.f_W32RUN
    Watcom DOS32 Extender (W32RUN)

ida_ida.f_WIN
    New Executable (NE)

ida_ida.f_ZIP
    ZIP file (this file is never loaded to IDA database)

ida_ida.get_dbctx_id() -> "ssize_t"
    Get the current database context ID 
            
    @returns the database context ID, or -1 if no current database

ida_ida.get_dbctx_qty() -> "size_t"
    Get number of database contexts 
            
    @returns number of database contexts

ida_ida.getinf_str(tag: "inftag_t") -> str
    Get program specific information (a non-scalar value) 
            
    @param tag: one of inftag_t constants
    @returns number of bytes stored in the buffer (<0 - not defined)

ida_ida.idainfo

ida_ida.idainfo.__init__(self, *args, **kwargs)

ida_ida.idainfo._get_lflags(self) -> int

ida_ida.idainfo._set_lflags(self, _f: int) -> None

ida_ida.idainfo.abibits
    ABI features. Depends on info returned by get_abi_name() Processor modules may modify them in set_compiler 
            

ida_ida.idainfo.af
    Analysis flags 
            

ida_ida.idainfo.af2
    Analysis flags 2 
            

ida_ida.idainfo.appcall_options
    appcall options, see idd.hpp

ida_ida.idainfo.apptype
    Application type bit definitions in libfuncs.hpp 
            

ida_ida.idainfo.asmtype
    target assembler number

ida_ida.idainfo.baseaddr
    remaining 28 bits are reserved
    
    base address of the program (paragraphs) 
            

ida_ida.idainfo.bin_prefix_size
    Number of instruction bytes (opcodes) to show in line prefix.

ida_ida.idainfo.cc
    COMPILER.
    
    Target compiler 
            

ida_ida.idainfo.cmt_indent
    Indentation for comments.

ida_ida.idainfo.database_change_count
    incremented after each byte and regular segment modifications 
            

ida_ida.idainfo.datatypes
    data types allowed in data carousel

ida_ida.idainfo.demnames
    Demangled name flags 
            

ida_ida.idainfo.filetype
    The input file type.

ida_ida.idainfo.get_abiname(self) -> str

ida_ida.idainfo.highoff
    High limit for offsets (used in calculation of 'void' operands) 
            

ida_ida.idainfo.indent
    DISASSEMBLY LISTING DETAILS.
    
    Indentation for instructions 
            

ida_ida.idainfo.lenxref
    max length of line with xrefs

ida_ida.idainfo.lflags
    Misc. database flags 
            

ida_ida.idainfo.listnames
    Name list options 
            

ida_ida.idainfo.long_demnames
    long form of demangled names see demangle.h for definitions 
            

ida_ida.idainfo.lowoff
    Low limit for offsets (used in calculation of 'void' operands) 
            

ida_ida.idainfo.main
    address of main()

ida_ida.idainfo.margin
    max length of data lines

ida_ida.idainfo.max_autoname_len
    NAMES.
    
    max autogenerated name length (without zero byte) 
            

ida_ida.idainfo.max_ea
    maxEA is excluded

ida_ida.idainfo.maxref
    Max tail for references.

ida_ida.idainfo.min_ea
    current limits of program

ida_ida.idainfo.nametype
    Dummy names representation types 
            

ida_ida.idainfo.omax_ea
    original maxEA (is set after loading the input file)

ida_ida.idainfo.omin_ea
    original minEA (is set after loading the input file)

ida_ida.idainfo.ostype
    OS type the program is for bit definitions in libfuncs.hpp 
            

ida_ida.idainfo.outflags
    output flags 
            

ida_ida.idainfo.procname
    Name of the current processor (with \0)

ida_ida.idainfo.refcmtnum
    Number of comment lines to generate for refs to string literals or demangled names 0 - such comments won't be generated at all 
            

ida_ida.idainfo.s_cmtflg
    Comment options 
            

ida_ida.idainfo.s_genflags
    General idainfo flags 
            

ida_ida.idainfo.s_limiter
    Delimiter options 
            

ida_ida.idainfo.s_prefflag
    Line prefix options 
            

ida_ida.idainfo.s_xrefflag
    Xref options 
            

ida_ida.idainfo.short_demnames
    short form of demangled names

ida_ida.idainfo.specsegs
    What format do special segments use? 0-unspecified, 4-entries are 4 bytes, 8- entries are 8 bytes.

ida_ida.idainfo.start_cs
    selector of the segment with the main entry point

ida_ida.idainfo.start_ea
    Linear address of program entry point.

ida_ida.idainfo.start_ip
    IP register value at the start of program execution 
            

ida_ida.idainfo.start_sp
    SP register value at the start of program execution 
            

ida_ida.idainfo.start_ss
    selector of the initial stack segment

ida_ida.idainfo.strlit_break
    string literal line break symbol

ida_ida.idainfo.strlit_flags
    STRING LITERALS.
    
    string literal flags 
            

ida_ida.idainfo.strlit_pref
    prefix for string literal names

ida_ida.idainfo.strlit_sernum
    serial number

ida_ida.idainfo.strlit_zeroes
    leading zeroes

ida_ida.idainfo.strtype
    current ascii string type see nalt.hpp for string types 
            

ida_ida.idainfo.tag
    'IDA'

ida_ida.idainfo.type_xrefnum
    Number of references to generate in the struct & enum windows 0 - xrefs won't be generated at all 
            

ida_ida.idainfo.version
    Version of database.

ida_ida.idainfo.xrefnum
    CROSS REFERENCES.
    
    Number of references to generate in the disassembly listing 0 - xrefs won't be generated at all 
            

ida_ida.idainfo_is_32bit()

ida_ida.idbattr_info_t

ida_ida.idbattr_info_t.__init__(self, name: str, offset: "uintptr_t", width: "size_t", bitmask: "uint64" = 0, tag: "uchar" = 0, idi_flags: "uint" = 0)

ida_ida.idbattr_info_t.__lt__(self, r: "idbattr_info_t") -> bool

ida_ida.idbattr_info_t.bitmask
    mask for bitfields (0-not bitfield)

ida_ida.idbattr_info_t.has_individual_node(self) -> bool

ida_ida.idbattr_info_t.hashname(self) -> str

ida_ida.idbattr_info_t.individual_node
    individual node name (nullptr - use default)

ida_ida.idbattr_info_t.is_bitfield(self) -> bool

ida_ida.idbattr_info_t.is_bitmap(self) -> bool

ida_ida.idbattr_info_t.is_boolean(self) -> bool

ida_ida.idbattr_info_t.is_buf_var(self) -> bool

ida_ida.idbattr_info_t.is_bytearray(self) -> bool

ida_ida.idbattr_info_t.is_cstr(self) -> bool

ida_ida.idbattr_info_t.is_decimal(self) -> bool

ida_ida.idbattr_info_t.is_hash(self) -> bool

ida_ida.idbattr_info_t.is_hexadecimal(self) -> bool

ida_ida.idbattr_info_t.is_incremented(self) -> bool

ida_ida.idbattr_info_t.is_node_altval(self) -> bool

ida_ida.idbattr_info_t.is_node_blob(self) -> bool

ida_ida.idbattr_info_t.is_node_supval(self) -> bool

ida_ida.idbattr_info_t.is_node_valobj(self) -> bool

ida_ida.idbattr_info_t.is_node_var(self) -> bool

ida_ida.idbattr_info_t.is_onoff(self) -> bool

ida_ida.idbattr_info_t.is_qstring(self) -> bool

ida_ida.idbattr_info_t.is_readonly_var(self) -> bool

ida_ida.idbattr_info_t.is_scalar_var(self) -> bool

ida_ida.idbattr_info_t.is_struc_field(self) -> bool

ida_ida.idbattr_info_t.is_val_mapped(self) -> bool

ida_ida.idbattr_info_t.maxsize
    max bytes reserved for storage in netnode

ida_ida.idbattr_info_t.name
    human-readable name

ida_ida.idbattr_info_t.offset
    field position: offset within a structure (IDI_STRUCFLD) altval or supval index (IDI_NODEVAL) hashval name (IDI_ALTVAL/IDI_SUPVAL+IDI_HASH) 
            

ida_ida.idbattr_info_t.ridx(self) -> "size_t"

ida_ida.idbattr_info_t.str_false(self) -> str

ida_ida.idbattr_info_t.str_true(self) -> str

ida_ida.idbattr_info_t.tag
    tag of node value (if IDI_NODEVAL is set)

ida_ida.idbattr_info_t.use_hlpstruc(self) -> bool

ida_ida.idbattr_info_t.vmap
    array value=>name (terminated by empty element)

ida_ida.idbattr_info_t.width
    field width in bytes

ida_ida.idbattr_valmap_t

ida_ida.idbattr_valmap_t.__init__(self)

ida_ida.inf_abi_set_by_user() -> bool

ida_ida.inf_allow_non_matched_ops() -> bool

ida_ida.inf_allow_sigmulti() -> bool

ida_ida.inf_append_sigcmt() -> bool

ida_ida.inf_big_arg_align(*args) -> bool

ida_ida.inf_check_manual_ops() -> bool

ida_ida.inf_check_unicode_strlits() -> bool

ida_ida.inf_coagulate_code() -> bool

ida_ida.inf_coagulate_data() -> bool

ida_ida.inf_compress_idb() -> bool

ida_ida.inf_create_all_xrefs() -> bool

ida_ida.inf_create_func_from_call() -> bool

ida_ida.inf_create_func_from_ptr() -> bool

ida_ida.inf_create_func_tails() -> bool

ida_ida.inf_create_jump_tables() -> bool

ida_ida.inf_create_off_on_dref() -> bool

ida_ida.inf_create_off_using_fixup() -> bool

ida_ida.inf_create_strlit_on_xref() -> bool

ida_ida.inf_data_offset() -> bool

ida_ida.inf_dbg_no_store_path() -> bool

ida_ida.inf_decode_fpp() -> bool

ida_ida.inf_del_no_xref_insns() -> bool

ida_ida.inf_final_pass() -> bool

ida_ida.inf_full_sp_ana() -> bool

ida_ida.inf_gen_assume() -> bool

ida_ida.inf_gen_lzero() -> bool

ida_ida.inf_gen_null() -> bool

ida_ida.inf_gen_org() -> bool

ida_ida.inf_gen_tryblks() -> bool

ida_ida.inf_get_abibits() -> int

ida_ida.inf_get_af() -> int

ida_ida.inf_get_af2() -> int

ida_ida.inf_get_af2_low() -> "ushort"
    Get/set low 16bit half of inf.af2.

ida_ida.inf_get_af_high() -> "ushort"

ida_ida.inf_get_af_low() -> "ushort"
    Get/set low/high 16bit halves of inf.af.

ida_ida.inf_get_app_bitness() -> "uint"

ida_ida.inf_get_appcall_options() -> int

ida_ida.inf_get_apptype() -> "ushort"

ida_ida.inf_get_asmtype() -> "uchar"

ida_ida.inf_get_baseaddr() -> int

ida_ida.inf_get_bin_prefix_size() -> "short"

ida_ida.inf_get_cc(out: "compiler_info_t") -> bool

ida_ida.inf_get_cc_cm() -> "cm_t"

ida_ida.inf_get_cc_defalign() -> "uchar"

ida_ida.inf_get_cc_id() -> "comp_t"

ida_ida.inf_get_cc_size_b() -> "uchar"

ida_ida.inf_get_cc_size_e() -> "uchar"

ida_ida.inf_get_cc_size_i() -> "uchar"

ida_ida.inf_get_cc_size_l() -> "uchar"

ida_ida.inf_get_cc_size_ldbl() -> "uchar"

ida_ida.inf_get_cc_size_ll() -> "uchar"

ida_ida.inf_get_cc_size_s() -> "uchar"

ida_ida.inf_get_cmt_indent() -> "uchar"

ida_ida.inf_get_cmtflg() -> "uchar"

ida_ida.inf_get_database_change_count() -> int

ida_ida.inf_get_datatypes() -> int

ida_ida.inf_get_demname_form() -> "uchar"
    Get DEMNAM_MASK bits of #demnames.

ida_ida.inf_get_demnames() -> "uchar"

ida_ida.inf_get_filetype() -> "filetype_t"

ida_ida.inf_get_genflags() -> "ushort"

ida_ida.inf_get_highoff() -> ida_idaapi.ea_t

ida_ida.inf_get_indent() -> "uchar"

ida_ida.inf_get_lenxref() -> "ushort"

ida_ida.inf_get_lflags() -> int

ida_ida.inf_get_limiter() -> "uchar"

ida_ida.inf_get_listnames() -> "uchar"

ida_ida.inf_get_long_demnames() -> int

ida_ida.inf_get_lowoff() -> ida_idaapi.ea_t

ida_ida.inf_get_main() -> ida_idaapi.ea_t

ida_ida.inf_get_margin() -> "ushort"

ida_ida.inf_get_max_autoname_len() -> "ushort"

ida_ida.inf_get_max_ea() -> ida_idaapi.ea_t

ida_ida.inf_get_maxref() -> int

ida_ida.inf_get_min_ea() -> ida_idaapi.ea_t

ida_ida.inf_get_nametype() -> "char"

ida_ida.inf_get_netdelta() -> int

ida_ida.inf_get_omax_ea() -> ida_idaapi.ea_t

ida_ida.inf_get_omin_ea() -> ida_idaapi.ea_t

ida_ida.inf_get_ostype() -> "ushort"

ida_ida.inf_get_outflags() -> int

ida_ida.inf_get_pack_mode() -> int

ida_ida.inf_get_prefflag() -> "uchar"

ida_ida.inf_get_privrange(*args) -> "range_t"
    This function has the following signatures:
    
        0. inf_get_privrange(out: range_t *) -> bool
        1. inf_get_privrange() -> range_t
    
    # 0: inf_get_privrange(out: range_t *) -> bool
    
    
    # 1: inf_get_privrange() -> range_t

ida_ida.inf_get_privrange_end_ea() -> ida_idaapi.ea_t

ida_ida.inf_get_privrange_start_ea() -> ida_idaapi.ea_t

ida_ida.inf_get_procname() -> str

ida_ida.inf_get_refcmtnum() -> "uchar"

ida_ida.inf_get_short_demnames() -> int

ida_ida.inf_get_specsegs() -> "uchar"

ida_ida.inf_get_start_cs() -> "sel_t"

ida_ida.inf_get_start_ea() -> ida_idaapi.ea_t

ida_ida.inf_get_start_ip() -> ida_idaapi.ea_t

ida_ida.inf_get_start_sp() -> ida_idaapi.ea_t

ida_ida.inf_get_start_ss() -> "sel_t"

ida_ida.inf_get_strlit_break() -> "uchar"

ida_ida.inf_get_strlit_flags() -> "uchar"

ida_ida.inf_get_strlit_pref() -> str

ida_ida.inf_get_strlit_sernum() -> int

ida_ida.inf_get_strlit_zeroes() -> "char"

ida_ida.inf_get_strtype() -> int

ida_ida.inf_get_type_xrefnum() -> "uchar"

ida_ida.inf_get_version() -> "ushort"

ida_ida.inf_get_xrefflag() -> "uchar"

ida_ida.inf_get_xrefnum() -> "uchar"

ida_ida.inf_guess_func_type() -> bool

ida_ida.inf_handle_eh() -> bool

ida_ida.inf_handle_rtti() -> bool

ida_ida.inf_hide_comments() -> bool

ida_ida.inf_hide_libfuncs() -> bool

ida_ida.inf_huge_arg_align(*args) -> bool

ida_ida.inf_inc_database_change_count(cnt: int = 1) -> None

ida_ida.inf_is_16bit() -> bool

ida_ida.inf_is_32bit_exactly() -> bool

ida_ida.inf_is_32bit_or_higher() -> bool

ida_ida.inf_is_64bit() -> bool

ida_ida.inf_is_auto_enabled() -> bool

ida_ida.inf_is_be() -> bool

ida_ida.inf_is_dll() -> bool

ida_ida.inf_is_flat_off32() -> bool

ida_ida.inf_is_graph_view() -> bool

ida_ida.inf_is_hard_float() -> bool

ida_ida.inf_is_ilp32() -> bool

ida_ida.inf_is_kernel_mode() -> bool

ida_ida.inf_is_limiter_empty() -> bool

ida_ida.inf_is_limiter_thick() -> bool

ida_ida.inf_is_limiter_thin() -> bool

ida_ida.inf_is_mem_aligned4() -> bool

ida_ida.inf_is_snapshot() -> bool

ida_ida.inf_is_wide_high_byte_first() -> bool

ida_ida.inf_like_binary() -> bool

ida_ida.inf_line_pref_with_seg() -> bool

ida_ida.inf_loading_idc() -> bool

ida_ida.inf_macros_enabled() -> bool

ida_ida.inf_map_stkargs() -> bool

ida_ida.inf_mark_code() -> bool

ida_ida.inf_merge_strlits() -> bool

ida_ida.inf_no_store_user_info() -> bool

ida_ida.inf_noflow_to_data() -> bool

ida_ida.inf_noret_ana() -> bool

ida_ida.inf_op_offset() -> bool

ida_ida.inf_pack_idb() -> bool

ida_ida.inf_pack_stkargs(*args) -> bool

ida_ida.inf_postinc_strlit_sernum(cnt: int = 1) -> int

ida_ida.inf_prefix_show_funcoff() -> bool

ida_ida.inf_prefix_show_segaddr() -> bool

ida_ida.inf_prefix_show_stack() -> bool

ida_ida.inf_prefix_truncate_opcode_bytes() -> bool

ida_ida.inf_propagate_regargs() -> bool

ida_ida.inf_propagate_stkargs() -> bool

ida_ida.inf_readonly_idb() -> bool

ida_ida.inf_rename_jumpfunc() -> bool

ida_ida.inf_rename_nullsub() -> bool

ida_ida.inf_set_32bit(_v: bool = True) -> bool

ida_ida.inf_set_64bit(_v: bool = True) -> bool

ida_ida.inf_set_abi_set_by_user(_v: bool = True) -> bool

ida_ida.inf_set_abibits(_v: int) -> bool

ida_ida.inf_set_af(_v: int) -> bool

ida_ida.inf_set_af2(_v: int) -> bool

ida_ida.inf_set_af2_low(saf: "ushort") -> None

ida_ida.inf_set_af_high(saf2: "ushort") -> None

ida_ida.inf_set_af_low(saf: "ushort") -> None

ida_ida.inf_set_allow_non_matched_ops(_v: bool = True) -> bool

ida_ida.inf_set_allow_sigmulti(_v: bool = True) -> bool

ida_ida.inf_set_app_bitness(bitness: "uint") -> None

ida_ida.inf_set_appcall_options(_v: int) -> bool

ida_ida.inf_set_append_sigcmt(_v: bool = True) -> bool

ida_ida.inf_set_apptype(_v: "ushort") -> bool

ida_ida.inf_set_asmtype(_v: "uchar") -> bool

ida_ida.inf_set_auto_enabled(_v: bool = True) -> bool

ida_ida.inf_set_baseaddr(_v: int) -> bool

ida_ida.inf_set_be(_v: bool = True) -> bool

ida_ida.inf_set_big_arg_align(_v: bool = True) -> bool

ida_ida.inf_set_bin_prefix_size(_v: "short") -> bool

ida_ida.inf_set_cc(_v: "compiler_info_t") -> bool

ida_ida.inf_set_cc_cm(_v: "cm_t") -> bool

ida_ida.inf_set_cc_defalign(_v: "uchar") -> bool

ida_ida.inf_set_cc_id(_v: "comp_t") -> bool

ida_ida.inf_set_cc_size_b(_v: "uchar") -> bool

ida_ida.inf_set_cc_size_e(_v: "uchar") -> bool

ida_ida.inf_set_cc_size_i(_v: "uchar") -> bool

ida_ida.inf_set_cc_size_l(_v: "uchar") -> bool

ida_ida.inf_set_cc_size_ldbl(_v: "uchar") -> bool

ida_ida.inf_set_cc_size_ll(_v: "uchar") -> bool

ida_ida.inf_set_cc_size_s(_v: "uchar") -> bool

ida_ida.inf_set_check_manual_ops(_v: bool = True) -> bool

ida_ida.inf_set_check_unicode_strlits(_v: bool = True) -> bool

ida_ida.inf_set_cmt_indent(_v: "uchar") -> bool

ida_ida.inf_set_cmtflg(_v: "uchar") -> bool

ida_ida.inf_set_coagulate_code(_v: bool = True) -> bool

ida_ida.inf_set_coagulate_data(_v: bool = True) -> bool

ida_ida.inf_set_compress_idb(_v: bool = True) -> bool

ida_ida.inf_set_create_all_xrefs(_v: bool = True) -> bool

ida_ida.inf_set_create_func_from_call(_v: bool = True) -> bool

ida_ida.inf_set_create_func_from_ptr(_v: bool = True) -> bool

ida_ida.inf_set_create_func_tails(_v: bool = True) -> bool

ida_ida.inf_set_create_jump_tables(_v: bool = True) -> bool

ida_ida.inf_set_create_off_on_dref(_v: bool = True) -> bool

ida_ida.inf_set_create_off_using_fixup(_v: bool = True) -> bool

ida_ida.inf_set_create_strlit_on_xref(_v: bool = True) -> bool

ida_ida.inf_set_data_offset(_v: bool = True) -> bool

ida_ida.inf_set_database_change_count(_v: int) -> bool

ida_ida.inf_set_datatypes(_v: int) -> bool

ida_ida.inf_set_dbg_no_store_path(_v: bool = True) -> bool

ida_ida.inf_set_decode_fpp(_v: bool = True) -> bool

ida_ida.inf_set_del_no_xref_insns(_v: bool = True) -> bool

ida_ida.inf_set_demnames(_v: "uchar") -> bool

ida_ida.inf_set_dll(_v: bool = True) -> bool

ida_ida.inf_set_filetype(_v: "filetype_t") -> bool

ida_ida.inf_set_final_pass(_v: bool = True) -> bool

ida_ida.inf_set_flat_off32(_v: bool = True) -> bool

ida_ida.inf_set_full_sp_ana(_v: bool = True) -> bool

ida_ida.inf_set_gen_assume(_v: bool = True) -> bool

ida_ida.inf_set_gen_lzero(_v: bool = True) -> bool

ida_ida.inf_set_gen_null(_v: bool = True) -> bool

ida_ida.inf_set_gen_org(_v: bool = True) -> bool

ida_ida.inf_set_gen_tryblks(_v: bool = True) -> bool

ida_ida.inf_set_genflags(_v: "ushort") -> bool

ida_ida.inf_set_graph_view(_v: bool = True) -> bool

ida_ida.inf_set_guess_func_type(_v: bool = True) -> bool

ida_ida.inf_set_handle_eh(_v: bool = True) -> bool

ida_ida.inf_set_handle_rtti(_v: bool = True) -> bool

ida_ida.inf_set_hard_float(_v: bool = True) -> bool

ida_ida.inf_set_hide_comments(_v: bool = True) -> bool

ida_ida.inf_set_hide_libfuncs(_v: bool = True) -> bool

ida_ida.inf_set_highoff(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_huge_arg_align(_v: bool = True) -> bool

ida_ida.inf_set_ilp32(_v: bool = True) -> bool

ida_ida.inf_set_indent(_v: "uchar") -> bool

ida_ida.inf_set_kernel_mode(_v: bool = True) -> bool

ida_ida.inf_set_lenxref(_v: "ushort") -> bool

ida_ida.inf_set_lflags(_v: int) -> bool

ida_ida.inf_set_limiter(_v: "uchar") -> bool

ida_ida.inf_set_limiter_empty(_v: bool = True) -> bool

ida_ida.inf_set_limiter_thick(_v: bool = True) -> bool

ida_ida.inf_set_limiter_thin(_v: bool = True) -> bool

ida_ida.inf_set_line_pref_with_seg(_v: bool = True) -> bool

ida_ida.inf_set_listnames(_v: "uchar") -> bool

ida_ida.inf_set_loading_idc(_v: bool = True) -> bool

ida_ida.inf_set_long_demnames(_v: int) -> bool

ida_ida.inf_set_lowoff(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_macros_enabled(_v: bool = True) -> bool

ida_ida.inf_set_main(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_map_stkargs(_v: bool = True) -> bool

ida_ida.inf_set_margin(_v: "ushort") -> bool

ida_ida.inf_set_mark_code(_v: bool = True) -> bool

ida_ida.inf_set_max_autoname_len(_v: "ushort") -> bool

ida_ida.inf_set_max_ea(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_maxref(_v: int) -> bool

ida_ida.inf_set_mem_aligned4(_v: bool = True) -> bool

ida_ida.inf_set_merge_strlits(_v: bool = True) -> bool

ida_ida.inf_set_min_ea(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_nametype(_v: "char") -> bool

ida_ida.inf_set_netdelta(_v: int) -> bool

ida_ida.inf_set_no_store_user_info(_v: bool = True) -> bool

ida_ida.inf_set_noflow_to_data(_v: bool = True) -> bool

ida_ida.inf_set_noret_ana(_v: bool = True) -> bool

ida_ida.inf_set_omax_ea(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_omin_ea(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_op_offset(_v: bool = True) -> bool

ida_ida.inf_set_ostype(_v: "ushort") -> bool

ida_ida.inf_set_outflags(_v: int) -> bool

ida_ida.inf_set_pack_idb(_v: bool = True) -> bool

ida_ida.inf_set_pack_mode(pack_mode: int) -> int

ida_ida.inf_set_pack_stkargs(_v: bool = True) -> bool

ida_ida.inf_set_prefflag(_v: "uchar") -> bool

ida_ida.inf_set_prefix_show_funcoff(_v: bool = True) -> bool

ida_ida.inf_set_prefix_show_segaddr(_v: bool = True) -> bool

ida_ida.inf_set_prefix_show_stack(_v: bool = True) -> bool

ida_ida.inf_set_prefix_truncate_opcode_bytes(_v: bool = True) -> bool

ida_ida.inf_set_privrange(_v: "range_t") -> bool

ida_ida.inf_set_privrange_end_ea(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_privrange_start_ea(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_procname(*args) -> bool

ida_ida.inf_set_propagate_regargs(_v: bool = True) -> bool

ida_ida.inf_set_propagate_stkargs(_v: bool = True) -> bool

ida_ida.inf_set_readonly_idb(_v: bool = True) -> bool

ida_ida.inf_set_refcmtnum(_v: "uchar") -> bool

ida_ida.inf_set_rename_jumpfunc(_v: bool = True) -> bool

ida_ida.inf_set_rename_nullsub(_v: bool = True) -> bool

ida_ida.inf_set_short_demnames(_v: int) -> bool

ida_ida.inf_set_should_create_stkvars(_v: bool = True) -> bool

ida_ida.inf_set_should_trace_sp(_v: bool = True) -> bool

ida_ida.inf_set_show_all_comments(_v: bool = True) -> bool

ida_ida.inf_set_show_auto(_v: bool = True) -> bool

ida_ida.inf_set_show_hidden_funcs(_v: bool = True) -> bool

ida_ida.inf_set_show_hidden_insns(_v: bool = True) -> bool

ida_ida.inf_set_show_hidden_segms(_v: bool = True) -> bool

ida_ida.inf_set_show_line_pref(_v: bool = True) -> bool

ida_ida.inf_set_show_repeatables(_v: bool = True) -> bool

ida_ida.inf_set_show_src_linnum(_v: bool = True) -> bool

ida_ida.inf_set_show_void(_v: bool = True) -> bool

ida_ida.inf_set_show_xref_fncoff(_v: bool = True) -> bool

ida_ida.inf_set_show_xref_seg(_v: bool = True) -> bool

ida_ida.inf_set_show_xref_tmarks(_v: bool = True) -> bool

ida_ida.inf_set_show_xref_val(_v: bool = True) -> bool

ida_ida.inf_set_snapshot(_v: bool = True) -> bool

ida_ida.inf_set_specsegs(_v: "uchar") -> bool

ida_ida.inf_set_stack_ldbl(_v: bool = True) -> bool

ida_ida.inf_set_stack_varargs(_v: bool = True) -> bool

ida_ida.inf_set_start_cs(_v: "sel_t") -> bool

ida_ida.inf_set_start_ea(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_start_ip(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_start_sp(_v: ida_idaapi.ea_t) -> bool

ida_ida.inf_set_start_ss(_v: "sel_t") -> bool

ida_ida.inf_set_strlit_autocmt(_v: bool = True) -> bool

ida_ida.inf_set_strlit_break(_v: "uchar") -> bool

ida_ida.inf_set_strlit_flags(_v: "uchar") -> bool

ida_ida.inf_set_strlit_name_bit(_v: bool = True) -> bool

ida_ida.inf_set_strlit_names(_v: bool = True) -> bool

ida_ida.inf_set_strlit_pref(*args) -> bool

ida_ida.inf_set_strlit_savecase(_v: bool = True) -> bool

ida_ida.inf_set_strlit_serial_names(_v: bool = True) -> bool

ida_ida.inf_set_strlit_sernum(_v: int) -> bool

ida_ida.inf_set_strlit_zeroes(_v: "char") -> bool

ida_ida.inf_set_strtype(_v: int) -> bool

ida_ida.inf_set_trace_flow(_v: bool = True) -> bool

ida_ida.inf_set_truncate_on_del(_v: bool = True) -> bool

ida_ida.inf_set_type_xrefnum(_v: "uchar") -> bool

ida_ida.inf_set_unicode_strlits(_v: bool = True) -> bool

ida_ida.inf_set_use_allasm(_v: bool = True) -> bool

ida_ida.inf_set_use_flirt(_v: bool = True) -> bool

ida_ida.inf_set_use_gcc_layout(_v: bool = True) -> bool

ida_ida.inf_set_version(_v: "ushort") -> bool

ida_ida.inf_set_wide_high_byte_first(_v: bool = True) -> bool

ida_ida.inf_set_xrefflag(_v: "uchar") -> bool

ida_ida.inf_set_xrefnum(_v: "uchar") -> bool

ida_ida.inf_should_create_stkvars() -> bool

ida_ida.inf_should_trace_sp() -> bool

ida_ida.inf_show_all_comments() -> bool

ida_ida.inf_show_auto() -> bool

ida_ida.inf_show_hidden_funcs() -> bool

ida_ida.inf_show_hidden_insns() -> bool

ida_ida.inf_show_hidden_segms() -> bool

ida_ida.inf_show_line_pref() -> bool

ida_ida.inf_show_repeatables() -> bool

ida_ida.inf_show_src_linnum() -> bool

ida_ida.inf_show_void() -> bool

ida_ida.inf_show_xref_fncoff() -> bool

ida_ida.inf_show_xref_seg() -> bool

ida_ida.inf_show_xref_tmarks() -> bool

ida_ida.inf_show_xref_val() -> bool

ida_ida.inf_stack_ldbl() -> bool

ida_ida.inf_stack_varargs() -> bool

ida_ida.inf_strlit_autocmt() -> bool

ida_ida.inf_strlit_name_bit() -> bool

ida_ida.inf_strlit_names() -> bool

ida_ida.inf_strlit_savecase() -> bool

ida_ida.inf_strlit_serial_names() -> bool

ida_ida.inf_test_mode() -> bool

ida_ida.inf_trace_flow() -> bool

ida_ida.inf_truncate_on_del() -> bool

ida_ida.inf_unicode_strlits() -> bool

ida_ida.inf_use_allasm() -> bool

ida_ida.inf_use_flirt() -> bool

ida_ida.inf_use_gcc_layout() -> bool

ida_ida.is_database_busy() -> bool
    Check if the database is busy (e.g. performing some critical operations and cannot be safely accessed) 
            

ida_ida.is_filetype_like_binary(ft: "filetype_t") -> bool
    Is unstructured input file?

ida_ida.move_privrange(new_privrange_start: ida_idaapi.ea_t) -> bool
    Move privrange to the specified address 
            
    @param new_privrange_start: new start address of the privrange
    @returns success

ida_ida.switch_dbctx(idx: "size_t") -> "dbctx_t *"
    Switch to the database with the provided context ID 
            
    @param idx: the index of the database to switch to
    @returns the current dbctx_t instance or nullptr

ida_ida.to_ea(reg_cs: "sel_t", reg_ip: int) -> ida_idaapi.ea_t
    Convert (sel,off) value to a linear address.

ida_ida.validate_idb(vld_flags: int = 0) -> "size_t"
    Validate the database 
            
    @param vld_flags: combination of VLD_.. constants
    @returns number of corrupted/fixed records

ida_idaapi

ida_idaapi.IDAPython_ExecScript(path, g, print_error = True)
    Run the specified script.
    
    This function is used by the low-level plugin code.

ida_idaapi.IDAPython_ExecSystem(cmd)
    Executes a command with popen().

ida_idaapi.IDAPython_FormatExc(etype, value = None, tb = None, limit = None)
    This function is used to format an exception given the
    values returned by a PyErr_Fetch()

ida_idaapi.IDAPython_GetDocstrings(obj)

ida_idaapi.IDAPython_GetDocstrings._dedent(source: str) -> str

ida_idaapi.IDAPython_GetDocstrings._nodes(tree)
    Returns the list of all nodes in tree's body.

ida_idaapi.IDAPython_GetDocstrings._nodes_iter(tree)

ida_idaapi.IDAPython_GetDocstrings._pairwise_longest(iterable)
    s -> (s0,s1), (s1,s2), (s2, s3),  ..., (sN, None)

ida_idaapi.IDAPython_GetDocstrings._walk_tree(tree)

ida_idaapi.IDAPython_LoadProcMod(path, g, print_error = True)
    Load processor module.

ida_idaapi.IDAPython_UnLoadProcMod(script, g, print_error = True)
    Unload processor module.

ida_idaapi.IDAPython_displayhook

ida_idaapi.IDAPython_displayhook.__init__(self)

ida_idaapi.IDAPython_displayhook._print_hex(self, x)

ida_idaapi.IDAPython_displayhook.displayhook(self, item)

ida_idaapi.IDAPython_displayhook.displayhook_format(self, item)

ida_idaapi.IDAPython_displayhook.format_item(self, num_printer, storage, item)

ida_idaapi.IDAPython_displayhook.format_seq(self, num_printer, storage, item, opn, cls)

ida_idaapi.NW_CLOSEIDB
    Notify when the database is closed. Its callback is of the form: def notify_when_callback(nw_code)

ida_idaapi.NW_INITIDA
    Notify when the IDA starts. Its callback is of the form: def notify_when_callback(nw_code)

ida_idaapi.NW_OPENIDB
    Notify when the database is opened. Its callback is of the form: def notify_when_callback(nw_code, is_old_database)

ida_idaapi.NW_REMOVE
    Use this flag with other flags to uninstall a notifywhen callback

ida_idaapi.NW_TERMIDA
    Notify when the IDA terminates. Its callback is of the form: def notify_when_callback(nw_code)

ida_idaapi.PY_ICID_BYREF
    byref object

ida_idaapi.PY_ICID_INT64
    int64 object

ida_idaapi.PY_ICID_OPAQUE
    opaque object

ida_idaapi.PyIdc_cvt_int64__
    Helper class for explicitly representing VT_INT64 values

ida_idaapi.PyIdc_cvt_int64__.__add__(self, other)

ida_idaapi.PyIdc_cvt_int64__.__div__(self, other)

ida_idaapi.PyIdc_cvt_int64__.__init__(self, v)

ida_idaapi.PyIdc_cvt_int64__.__mul__(self, other)

ida_idaapi.PyIdc_cvt_int64__.__op(self, op_n, other, rev = False)

ida_idaapi.PyIdc_cvt_int64__.__radd__(self, other)

ida_idaapi.PyIdc_cvt_int64__.__rdiv__(self, other)

ida_idaapi.PyIdc_cvt_int64__.__rmul__(self, other)

ida_idaapi.PyIdc_cvt_int64__.__rsub__(self, other)

ida_idaapi.PyIdc_cvt_int64__.__sub__(self, other)

ida_idaapi.PyIdc_cvt_refclass__
    Helper class for representing references to immutable objects

ida_idaapi.PyIdc_cvt_refclass__.__init__(self, v)

ida_idaapi.PyIdc_cvt_refclass__.cstr(self)
    Returns the string as a C string (up to the zero termination)

ida_idaapi.ST_OVER_DEBUG_SEG
    step tracing will be disabled when IP is in a debugger segment

ida_idaapi.ST_OVER_LIB_FUNC
    step tracing will be disabled when IP is in a library function

ida_idaapi.TRUNC(ea)
    Truncate EA for the current application bitness

ida_idaapi.__IDAPython_Completion_Util
    Internal utility class for auto-completion support

ida_idaapi.__IDAPython_Completion_Util.__call__(self, line, x)

ida_idaapi.__IDAPython_Completion_Util.__init__(self)

ida_idaapi.__IDAPython_Completion_Util.__parse_arg(self, arg)

ida_idaapi.__IDAPython_Completion_Util.__proto_from_argspec(self, name, args, defaults, annotations)

ida_idaapi.__IDAPython_Completion_Util.__proto_from_argspec.__repr_type(typ)

ida_idaapi.__IDAPython_Completion_Util.__proto_from_docstring(self, name, doc, altname = None)

ida_idaapi.__IDAPython_Completion_Util.__render_args(self, args, types, defaults)

ida_idaapi.__IDAPython_Completion_Util.__render_constant(self, name, attr)

ida_idaapi.__IDAPython_Completion_Util.__render_default(self, name)

ida_idaapi.__IDAPython_Completion_Util.__render_docstr(self, doc, name, proto)

ida_idaapi.__IDAPython_Completion_Util.__render_int_member(self, name, typ, val)

ida_idaapi.__IDAPython_Completion_Util.__render_proto(self, name, args, types, defaults, rets, is_ctor = False)

ida_idaapi.__IDAPython_Completion_Util.__render_rets(self, rets)

ida_idaapi.__IDAPython_Completion_Util.__resolve_type(self, tname)

ida_idaapi.__IDAPython_Completion_Util.build_hints(self, names, ns)

ida_idaapi.__IDAPython_Completion_Util.debug(self, *args)

ida_idaapi.__IDAPython_Completion_Util.dir_namespace(self, m, prefix)

ida_idaapi.__IDAPython_Completion_Util.get_candidates(self, qname, line, match_syntax_char)

ida_idaapi.__IDAPython_Completion_Util.maybe_extend_syntactically(self, ns, name, line, syntax_char)

ida_idaapi.__install_excepthook()

ida_idaapi._bounded_getitem_iterator(self)
    Helper function, to be set as __iter__ method for qvector-, or array-based classes.

ida_idaapi._listify_types(*classes)

ida_idaapi._make_missed_695bwcompat_property(bad_attr, new_attr, has_setter)

ida_idaapi._make_missed_695bwcompat_property._getter(self)

ida_idaapi._make_missed_695bwcompat_property._setter(self, v)

ida_idaapi._make_one_time_warning_message(bad_attr, new_attr)

ida_idaapi._make_one_time_warning_message.f()

ida_idaapi._qvector_back(self)

ida_idaapi._qvector_front(self)

ida_idaapi._replace_module_function(replacement)

ida_idaapi.as_UTF16(s)
    Convenience function to convert a string into appropriate unicode format

ida_idaapi.as_cstr(val)
    Returns a C str from the passed value. The passed value can be of type refclass (returned by a call to buffer() or byref())
    It scans for the first \x00 and returns the string value up to that point.

ida_idaapi.as_int32(v)
    Returns a number as a signed int32 number

ida_idaapi.as_signed(v, nbits = 32)
    Returns a number as signed. The number of bits are specified by the user.
    The MSB holds the sign.

ida_idaapi.as_uint32(v)
    Returns a number as an unsigned int32 number

ida_idaapi.copy_bits(v, s, e = -1)
    Copy bits from a value
    @param v: the value
    @param s: starting bit (0-based)
    @param e: ending bit

ida_idaapi.disable_script_timeout()
    Disables the script timeout and hides the script wait box.
    Calling L{set_script_timeout} will not have any effects until the script is compiled and executed again
    
    @return: None

ida_idaapi.enable_extlang_python(enable)
    Enables or disables Python extlang.
    When enabled, all expressions will be evaluated by Python.
    
    @param enable: Set to True to enable, False otherwise

ida_idaapi.enable_python_cli(enable: bool) -> None

ida_idaapi.format_basestring(_in: "PyObject *") -> str

ida_idaapi.loader_input_t
    A helper class to work with linput_t related functions.
    This class is also used by file loaders scripts.

ida_idaapi.loader_input_t.__init__(self, pycapsule = None)

ida_idaapi.loader_input_t.close(self)
    Closes the file

ida_idaapi.loader_input_t.file2base(self, pos: int, ea1: ea_t, ea2: ea_t, patchable: bool)
    Load portion of file into the database
    This function will include (ea1..ea2) into the addressing space of the
    program (make it enabled)
    
    @param li: pointer ot input source
    @param pos: position in the file
    @param (ea1..ea2): range of destination linear addresses
    @param patchable: should the kernel remember correspondance of
                      file offsets to linear addresses.
    @return: 1-ok,0-read error, a warning is displayed

ida_idaapi.loader_input_t.filename(self) -> "PyObject *"

ida_idaapi.loader_input_t.from_capsule(pycapsule: "PyObject *") -> "loader_input_t *"

ida_idaapi.loader_input_t.from_fp(fp)
    A static method to construct an instance from a FILE*
    
    @param fp: a FILE pointer
    @return: a new instance, or None

ida_idaapi.loader_input_t.from_linput(linput: "linput_t *") -> "loader_input_t *"

ida_idaapi.loader_input_t.get_byte(self)
    Reads a single byte from the file. Returns None if EOF or the read byte

ida_idaapi.loader_input_t.get_linput(self) -> "linput_t *"

ida_idaapi.loader_input_t.gets(self, len: int)
    Reads a line from the input file. Returns the read line or None
    
    @param len: the maximum line length
    @return: a str, or None

ida_idaapi.loader_input_t.getz(self, size: int, fpos: int = -1)
    Returns a zero terminated string at the given position
    
    @param size: maximum size of the string
    @param fpos: if != -1 then seek will be performed before reading
    @return: The string or None on failure.

ida_idaapi.loader_input_t.open(self, filename, remote = False)
    Opens a file (or a remote file)
    
    @param filename: the file name
    @param remote: whether the file is local, or remote
    @return: Boolean

ida_idaapi.loader_input_t.open_memory(self, start: ea_t, size: int)
    Create a linput for process memory (By internally calling idaapi.create_memory_linput())
    This linput will use dbg->read_memory() to read data
    
    @param start: starting address of the input
    @param size: size of the memory range to represent as linput
                if unknown, may be passed as 0

ida_idaapi.loader_input_t.opened(self)
    Checks if the file is opened or not

ida_idaapi.loader_input_t.read(self, size: int = -1)
    Read up to size bytes (all data if size is negative). Return an empty bytes object on EOF.
    
    @param size: the maximum number of bytes to read
    @return a bytes object

ida_idaapi.loader_input_t.readbytes(self, size: int, big_endian: bool)
    Similar to read() but it respect the endianness
    
    @param size: the maximum number of bytes to read
    @param big_endian: endianness
    @return a str, or None

ida_idaapi.loader_input_t.seek(self, offset: int, whence = SEEK_SET)
    Set input source position
    
    @param offset: the seek offset
    @param whence: the position to seek from
    @return: the new position (not 0 as fseek!)

ida_idaapi.loader_input_t.set_linput(self, linput)
    Links the current loader_input_t instance to a linput_t instance
    
    @param linput: the linput_t to link to

ida_idaapi.loader_input_t.size(self) -> "int64"

ida_idaapi.loader_input_t.tell(self)
    Returns the current position

ida_idaapi.notify_when(when, callback)
    Register a callback that will be called when an event happens.
    @param when: one of NW_XXXX constants
    @param callback: This callback prototype varies depending on the 'when' parameter:
                     The general callback format:
                         def notify_when_callback(nw_code)
                     In the case of NW_OPENIDB:
                         def notify_when_callback(nw_code, is_old_database)
    @return: Boolean

ida_idaapi.object_t
    Helper class used to initialize empty objects

ida_idaapi.object_t.__getitem__(self, idx)
    Allow access to object attributes by index (like dictionaries)

ida_idaapi.object_t.__init__(self, **kwds)

ida_idaapi.parse_command_line3(cmdline: str) -> "PyObject *"

ida_idaapi.plugin_t
    Base class for all scripted plugins.

ida_idaapi.plugin_t.run(self, arg)

ida_idaapi.plugin_t.term(self)

ida_idaapi.plugmod_t
    Base class for all scripted multi-plugins.

ida_idaapi.py_clinked_object_t
    This is a utility and base class for C linked objects

ida_idaapi.py_clinked_object_t.__del__(self)
    Delete the link upon object destruction (only if not static)

ida_idaapi.py_clinked_object_t.__init__(self, lnk = None)

ida_idaapi.py_clinked_object_t._create_clink(self)
    Overwrite me.
    Creates a new clink
    @return: PyCapsule representing the C link

ida_idaapi.py_clinked_object_t._del_clink(self, lnk)
    Overwrite me.
    This method deletes the link

ida_idaapi.py_clinked_object_t._free(self)
    Explicitly delete the link (only if not static)

ida_idaapi.py_clinked_object_t._get_clink_ptr(self)
    Overwrite me.
    Returns the C link pointer as a 64bit number

ida_idaapi.py_clinked_object_t.assign(self, other)
    Overwrite me.
    This method allows you to assign an instance contents to anothers
    @return: Boolean

ida_idaapi.py_clinked_object_t.clink
    Returns the C link as a PyObject

ida_idaapi.py_clinked_object_t.clink_ptr
    Returns the C link pointer as a number

ida_idaapi.py_clinked_object_t.copy(self)
    Returns a new copy of this class

ida_idaapi.pycim_get_widget(_self: "PyObject *") -> "TWidget *"

ida_idaapi.pycim_view_close(_self: "PyObject *") -> None

ida_idaapi.pygc_create_groups(_self: "PyObject *", groups_infos: "PyObject *") -> "PyObject *"

ida_idaapi.pygc_delete_groups(_self: "PyObject *", groups: "PyObject *", new_current: "PyObject *") -> "PyObject *"

ida_idaapi.pygc_refresh(_self: "PyObject *") -> None

ida_idaapi.pygc_set_groups_visibility(_self: "PyObject *", groups: "PyObject *", expand: "PyObject *", new_current: "PyObject *") -> "PyObject *"

ida_idaapi.pyidc_cvt_helper__
    This is a special helper object that helps detect which kind
    of object is this python object wrapping and how to convert it
    back and from IDC.
    This object is characterized by its special attribute and its value

ida_idaapi.pyidc_cvt_helper__.__get_value(self)

ida_idaapi.pyidc_cvt_helper__.__init__(self, cvt_id, value)

ida_idaapi.pyidc_cvt_helper__.__set_value(self, v)

ida_idaapi.pyidc_opaque_object_t
    This is the base class for all Python<->IDC opaque objects

ida_idaapi.replfun(func)

ida_idaapi.require(modulename, package = None)
    Load, or reload a module.
    
    When under heavy development, a user's tool might consist of multiple
    modules. If those are imported using the standard 'import' mechanism,
    there is no guarantee that the Python implementation will re-read
    and re-evaluate the module's Python code. In fact, it usually doesn't.
    What should be done instead is 'reload()'-ing that module.
    
    This is a simple helper function that will do just that: In case the
    module doesn't exist, it 'import's it, and if it does exist,
    'reload()'s it.
    
    The importing module (i.e., the module calling require()) will have
    the loaded module bound to its globals(), under the name 'modulename'.
    (If require() is called from the command line, the importing module
    will be '__main__'.)
    
    For more information, see: <http://www.hexblog.com/?p=749>.

ida_idaapi.set_script_timeout(timeout)
    Changes the script timeout value. The script wait box dialog will be hidden and shown again when the timeout elapses.
    See also L{disable_script_timeout}.
    
    @param timeout: This value is in seconds.
                    If this value is set to zero then the script will never timeout.
    @return: Returns the old timeout value

ida_idaapi.struct_unpack(buffer, signed = False, offs = 0)
    Unpack a buffer given its length and offset using struct.unpack_from().
    This function will know how to unpack the given buffer by using the lookup table '__struct_unpack_table'
    If the buffer is of unknown length then None is returned. Otherwise the unpacked value is returned.

ida_idc

ida_idc.get_mark_comment(slot: int) -> "PyObject *"

ida_idc.get_marked_pos(slot: int) -> ida_idaapi.ea_t

ida_idc.mark_position(ea: ida_idaapi.ea_t, lnnum: int, x: "short", y: "short", slot: int, comment: str) -> None

ida_idd
    Contains definition of the interface to IDD modules.
    
    The interface consists of structures describing the target debugged processor and a debugging API. 
        

ida_idd.APPCALL_DEBEV
    Return debug event information.

ida_idd.APPCALL_MANUAL
    Only set up the appcall, do not run. debugger_t::cleanup_appcall will not be generated by ida! 
            

ida_idd.APPCALL_TIMEOUT
    Appcall with timeout. If timed out, errbuf will contain "timeout". See SET_APPCALL_TIMEOUT and GET_APPCALL_TIMEOUT 
            

ida_idd.Appcall__
    Appcall with timeout
    The timeout value in milliseconds is specified
    in the high 2 bytes of the 'options' argument:
    If timed out, errbuf will contain "timeout".

ida_idd.Appcall__.APPCALL_DEBEV
    Return debug event information.

ida_idd.Appcall__.APPCALL_MANUAL
    Only set up the appcall, do not run. debugger_t::cleanup_appcall will not be generated by ida! 
            

ida_idd.Appcall__.APPCALL_TIMEOUT
    Appcall with timeout. If timed out, errbuf will contain "timeout". See SET_APPCALL_TIMEOUT and GET_APPCALL_TIMEOUT 
            

ida_idd.Appcall__.Consts
    Use Appcall.Consts.CONST_NAME to access constants

ida_idd.Appcall__.UTF16(s)

ida_idd.Appcall__.__get_consts(self)

ida_idd.Appcall__.__getattr__(self, name_or_ea)
    Allows you to call functions as if they were member functions (by returning a callable object)

ida_idd.Appcall__.__getitem__(self, idx)
    Use self[func_name] syntax if the function name contains invalid characters for an attribute name
    See __getattr___

ida_idd.Appcall__.__init__(self)

ida_idd.Appcall__.__name_or_ea(name_or_ea)
    Function that accepts a name or an ea and checks if the address is enabled.
    If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
    @return:
        - Returns the resolved EA or
        - Raises an exception if the address is not enabled

ida_idd.Appcall__.__typedecl_or_tinfo(typedecl_or_tinfo, flags = None)
    Function that accepts a tinfo_t object or type declaration as a string
    If a type declaration is passed then ida_typeinf.parse_decl() is applied to prepare tinfo_t object
    @return:
        - Returns the tinfo_t object
        - Raises an exception if the declaration cannot be parsed

ida_idd.Appcall__.array(type_name)
    Defines an array type. Later you need to pack() / unpack()

ida_idd.Appcall__.buffer(str = None, size = 0, fill = " ")
    Creates a string buffer. The returned value (r) will be a byref object.
    Use r.value to get the contents and r.size to get the buffer's size

ida_idd.Appcall__.byref(val)
    Method to create references to immutable objects
    Currently we support references to int/strings
    Objects need not be passed by reference (this will be done automatically)

ida_idd.Appcall__.cleanup_appcall(tid = 0)
    Cleanup after manual appcall. 
            
    @param tid: thread to use. NO_THREAD means to use the current thread The application state is restored as it was before calling the last appcall(). Nested appcalls are supported.
    @returns eOk if successful, otherwise an error code

ida_idd.Appcall__.cstr(val)

ida_idd.Appcall__.get_appcall_options()
    Return the global Appcall options

ida_idd.Appcall__.int64(v)
    Whenever a 64bit number is needed use this method to construct an object

ida_idd.Appcall__.obj(**kwds)
    Returns an empty object or objects with attributes as passed via its keywords arguments

ida_idd.Appcall__.proto(name_or_ea, proto_or_tinfo, flags = None)
    Allows you to instantiate an appcall (callable object) with the desired prototype
    @param name_or_ea: The name of the function (will be resolved with LocByName())
    @param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
    @return:
        - On failure it raises an exception if the prototype could not be parsed
          or the address is not resolvable
        - Returns a callbable Appcall instance with the given prototypes and flags

ida_idd.Appcall__.set_appcall_options(opt)
    Method to change the Appcall options globally (not per Appcall)

ida_idd.Appcall__.typedobj(typedecl_or_tinfo, ea = None)
    Returns an appcall object for a type (can be given as tinfo_t object or
    as a string declaration)
    One can then use retrieve() member method
    @param ea: Optional parameter that later can be used to retrieve the type
    @return: Appcall object or raises ValueError exception

ida_idd.Appcall__.valueof(name, default = 0)
    Returns the numeric value of a given name string.
    If the name could not be resolved then the default value will be returned

ida_idd.Appcall_array__
    This class is used with Appcall.array() method

ida_idd.Appcall_array__.__init__(self, tp)

ida_idd.Appcall_array__.pack(self, L)
    Packs a list or tuple into a byref buffer

ida_idd.Appcall_array__.try_to_convert_to_list(self, obj)
    Is this object a list? We check for the existance of attribute zero and attribute self.size-1

ida_idd.Appcall_array__.unpack(self, buf, as_list = True)
    Unpacks an array back into a list or an object

ida_idd.Appcall_callable__
    Helper class to issue appcalls using a natural syntax:
      appcall.FunctionNameInTheDatabase(arguments, ....)
    or
      appcall["Function@8"](arguments, ...)
    or
      f8 = appcall["Function@8"]
      f8(arg1, arg2, ...)
    or
      o = appcall.obj()
      i = byref(5)
      appcall.funcname(arg1, i, "hello", o)

ida_idd.Appcall_callable__.__call__(self, *args)
    Make object callable. We redirect execution to idaapi.appcall()

ida_idd.Appcall_callable__.__get_ea(self)

ida_idd.Appcall_callable__.__get_fields(self)

ida_idd.Appcall_callable__.__get_options(self)

ida_idd.Appcall_callable__.__get_size(self)

ida_idd.Appcall_callable__.__get_tif(self)

ida_idd.Appcall_callable__.__get_timeout(self)

ida_idd.Appcall_callable__.__get_type(self)

ida_idd.Appcall_callable__.__init__(self, ea, tinfo_or_typestr = None, fields = None)
    Initializes an appcall with a given function ea

ida_idd.Appcall_callable__.__set_ea(self, val)

ida_idd.Appcall_callable__.__set_options(self, v)

ida_idd.Appcall_callable__.__set_timeout(self, v)

ida_idd.Appcall_callable__.ea
    Returns or sets the EA associated with this object

ida_idd.Appcall_callable__.fields
    Returns the field names

ida_idd.Appcall_callable__.options
    Sets the Appcall options locally to this Appcall instance

ida_idd.Appcall_callable__.retrieve(self, src = None, flags = 0)
    Unpacks a typed object from the database if an ea is given or from a string if a string was passed
    @param src: the address of the object or a string
    @return: Returns a tuple of boolean and object or error number (Bool, Error | Object).

ida_idd.Appcall_callable__.size
    Returns the size of the type

ida_idd.Appcall_callable__.store(self, obj, dest_ea = None, base_ea = 0, flags = 0)
    Packs an object into a given ea if provided or into a string if no address was passed.
    @param obj: The object to pack
    @param dest_ea: If packing to idb this will be the store location
    @param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers
    
    @return:
        - If packing to a string then a Tuple(Boolean, packed_string or error code)
        - If packing to the database then a return code is returned (0 is success)

ida_idd.Appcall_callable__.tif
    Returns the tinfo_t object

ida_idd.Appcall_callable__.timeout
    An Appcall instance can change its timeout value with this attribute

ida_idd.Appcall_callable__.type
    Returns the typestring

ida_idd.Appcall_consts__
    Helper class used by Appcall.Consts attribute
    It is used to retrieve constants via attribute access

ida_idd.Appcall_consts__.__getattr__(self, attr)

ida_idd.Appcall_consts__.__init__(self, default = None)

ida_idd.BBLK_TRACE
    basic block tracing

ida_idd.BITNESS_CHANGED
    Debugger detected the process bitness changing.

ida_idd.BPT_BAD_ADDR
    ea is invalid

ida_idd.BPT_BAD_ALIGN
    alignment is invalid

ida_idd.BPT_BAD_LEN
    bpt len is invalid

ida_idd.BPT_BAD_TYPE
    bpt type is not supported

ida_idd.BPT_DEFAULT
    Choose bpt type automatically.

ida_idd.BPT_EXEC
    Execute instruction.

ida_idd.BPT_INTERNAL_ERR
    interr occurred when verifying breakpoint

ida_idd.BPT_OK
    breakpoint can be set

ida_idd.BPT_PAGE_OK
    update_bpts(): ok, added a page bpt

ida_idd.BPT_RDWR
    Read/write access.

ida_idd.BPT_READ
    Read access.

ida_idd.BPT_READ_ERROR
    failed to read memory at bpt ea

ida_idd.BPT_SKIP
    update_bpts(): do not process bpt

ida_idd.BPT_SOFT
    Software breakpoint.

ida_idd.BPT_TOO_MANY
    reached max number of supported breakpoints

ida_idd.BPT_WRITE
    Write access.

ida_idd.BPT_WRITE_ERROR
    failed to write memory at bpt ea

ida_idd.BREAKPOINT
    Breakpoint has been reached. IDA will complain about unknown breakpoints, they should be reported as exceptions. 
              

ida_idd.DBG_FLAG_ADD_ENVS
    The debugger supports launching processes with environment variables.

ida_idd.DBG_FLAG_ANYSIZE_HWBPT
    The debugger supports arbitrary size hardware breakpoints.

ida_idd.DBG_FLAG_CAN_CONT_BPT
    Debugger knows to continue from a bpt. This flag also means that the debugger module hides breakpoints from ida upon read_memory 
            

ida_idd.DBG_FLAG_CLEAN_EXIT
    IDA must suspend the application and remove all breakpoints before terminating the application. Usually this is not required because the application memory disappears upon termination. 
            

ida_idd.DBG_FLAG_CONNSTRING
    Display "Connection string" instead of "Hostname" and hide the "Port" field.

ida_idd.DBG_FLAG_DEBTHREAD
    Supports creation of a separate thread in ida for the debugger (the debthread). Most debugger functions will be called from debthread (exceptions are marked below) The debugger module may directly call only THREAD_SAFE functions. To call other functions please use execute_sync(). The debthread significantly increases debugging speed, especially if debug events occur frequently. 
            

ida_idd.DBG_FLAG_DEBUG_DLL
    Can debug standalone DLLs. For example, Bochs debugger can debug any snippet of code 
            

ida_idd.DBG_FLAG_DISABLE_ASLR
    The debugger support ASLR disabling (Address space layout randomization) 
            

ida_idd.DBG_FLAG_DONT_DISTURB
    Debugger can handle only get_debug_event(), request_pause(), exit_process() when the debugged process is running. The kernel may also call service functions (file I/O, map_address, etc) 
            

ida_idd.DBG_FLAG_EXITSHOTOK
    IDA may take a memory snapshot at PROCESS_EXITED event.

ida_idd.DBG_FLAG_FAKE_ATTACH
    PROCESS_ATTACHED is a fake event and does not suspend the execution 
            

ida_idd.DBG_FLAG_FAKE_MEMORY
    get_memory_info()/read_memory()/write_memory() work with the idb. (there is no real process to read from, as for the replayer module) the kernel will not call these functions if this flag is set. however, third party plugins may call them, they must be implemented. 
            

ida_idd.DBG_FLAG_FAST_STEP
    Do not refresh memory layout info after single stepping.

ida_idd.DBG_FLAG_FULL_INSTR_BPT
    Setting a breakpoint in the middle of an instruction will also break.

ida_idd.DBG_FLAG_HWDATBPT_ONE
    Hardware data breakpoints are one byte size by default 
            

ida_idd.DBG_FLAG_LAZY_WATCHPTS
    Watchpoints are triggered before the offending instruction is executed. The debugger must temporarily disable the watchpoint and single-step before resuming. 
            

ida_idd.DBG_FLAG_LOWCNDS
    Low level breakpoint conditions are supported.

ida_idd.DBG_FLAG_MANMEMINFO
    If set, manual memory region manipulation commands will be available. Use this bit for debugger modules that cannot return memory layout information 
            

ida_idd.DBG_FLAG_MERGE_ENVS
    The debugger supports merge or replace setting for environment variables (only makes sense if DBG_FLAG_ADD_ENVS is set) 
            

ida_idd.DBG_FLAG_NEEDPORT
    Remote debugger requires port number (to be used with DBG_FLAG_NOHOST)

ida_idd.DBG_FLAG_NOHOST
    Remote debugger with does not require network params (host/port/pass). (a unique device connected to the machine) 
            

ida_idd.DBG_FLAG_NOPARAMETERS
    Debugger module doesn't use commandline parameters.

ida_idd.DBG_FLAG_NOPASSWORD
    Remote debugger doesn't use password.

ida_idd.DBG_FLAG_NOSTARTDIR
    Debugger module doesn't use startup directory.

ida_idd.DBG_FLAG_PREFER_SWBPTS
    Prefer to use software breakpoints.

ida_idd.DBG_FLAG_REMOTE
    Remote debugger (requires remote host name unless DBG_FLAG_NOHOST)

ida_idd.DBG_FLAG_SAFE
    The debugger is safe (probably because it just emulates the application without really running it) 
            

ida_idd.DBG_FLAG_SMALLBLKS
    If set, IDA uses 256-byte blocks for caching memory contents. Otherwise, 1024-byte blocks are used 
            

ida_idd.DBG_FLAG_TRACER_MODULE
    The module is a tracer, not a full featured debugger module.

ida_idd.DBG_FLAG_TTD
    The debugger is a time travel debugger and supports continuing backwards.

ida_idd.DBG_FLAG_USE_SREGS
    Take segment register values into account (non flat memory)

ida_idd.DBG_FLAG_VIRTHREADS
    Thread IDs may be shuffled after each debug event. (to be used for virtual threads that represent cpus for windbg kmode) 
            

ida_idd.DBG_HAS_APPCALL
    supports ev_appcall, ev_cleanup_appcall

ida_idd.DBG_HAS_ATTACH_PROCESS
    supports ev_attach_process

ida_idd.DBG_HAS_CHECK_BPT
    supports ev_check_bpt

ida_idd.DBG_HAS_DETACH_PROCESS
    supports ev_detach_process

ida_idd.DBG_HAS_GET_PROCESSES
    supports ev_get_processes

ida_idd.DBG_HAS_MAP_ADDRESS
    supports ev_map_address. Avoid using this bit, especially together with DBG_FLAG_DEBTHREAD because it may cause big slow downs 
            

ida_idd.DBG_HAS_OPEN_FILE
    supports ev_open_file, ev_close_file, ev_read_file, ev_write_file

ida_idd.DBG_HAS_REQUEST_PAUSE
    supports ev_request_pause

ida_idd.DBG_HAS_REXEC
    supports ev_rexec

ida_idd.DBG_HAS_SET_EXCEPTION_INFO
    supports ev_set_exception_info

ida_idd.DBG_HAS_SET_RESUME_MODE
    supports ev_set_resume_mode. Cannot be set inside the debugger_t::init_debugger() 
            

ida_idd.DBG_HAS_THREAD_CONTINUE
    supports ev_thread_continue

ida_idd.DBG_HAS_THREAD_GET_SREG_BASE
    supports ev_thread_get_sreg_base

ida_idd.DBG_HAS_THREAD_SUSPEND
    supports ev_thread_suspend

ida_idd.DBG_HAS_UPDATE_CALL_STACK
    supports ev_update_call_stack

ida_idd.DBG_HIDE_WINDOW
    application should be hidden on startup (windows)

ida_idd.DBG_NO_ASLR
    disable ASLR (linux)

ida_idd.DBG_NO_TRACE
    do not trace the application (mac/linux)

ida_idd.DBG_PROC_32BIT
    application is 32-bit

ida_idd.DBG_PROC_64BIT
    application is 64-bit

ida_idd.DBG_PROC_IS_DLL
    database contains a dll (not exe)

ida_idd.DBG_PROC_IS_GUI
    using gui version of ida

ida_idd.DBG_RESMOD_STEP_BACKINTO
    RESMOD_BACKINTO is available

ida_idd.DBG_RESMOD_STEP_HANDLE
    RESMOD_HANDLE is available

ida_idd.DBG_RESMOD_STEP_INTO
    RESMOD_INTO is available

ida_idd.DBG_RESMOD_STEP_OUT
    RESMOD_OUT is available

ida_idd.DBG_RESMOD_STEP_OVER
    RESMOD_OVER is available

ida_idd.DBG_RESMOD_STEP_SRCINTO
    RESMOD_SRCINTO is available

ida_idd.DBG_RESMOD_STEP_SRCOUT
    RESMOD_SRCOUT is available

ida_idd.DBG_RESMOD_STEP_SRCOVER
    RESMOD_SRCOVER is available

ida_idd.DBG_RESMOD_STEP_USER
    RESMOD_USER is available

ida_idd.DBG_SUSPENDED
    application should be suspended on startup (mac)

ida_idd.DEBUGGER_ID_6811_EMULATOR
    MC6812 emulator (beta)

ida_idd.DEBUGGER_ID_ARM_IPHONE_USER
    iPhone 1.x

ida_idd.DEBUGGER_ID_ARM_LINUX_USER
    Userland arm linux.

ida_idd.DEBUGGER_ID_ARM_MACOS_USER
    Userland arm MAC OS.

ida_idd.DEBUGGER_ID_DALVIK_USER
    Dalvik.

ida_idd.DEBUGGER_ID_GDB_USER
    GDB remote.

ida_idd.DEBUGGER_ID_TRACE_REPLAYER
    Fake debugger to replay recorded traces.

ida_idd.DEBUGGER_ID_WINDBG
    WinDBG using Microsoft Debug engine.

ida_idd.DEBUGGER_ID_X86_DOSBOX_EMULATOR
    Dosbox MS-DOS emulator.

ida_idd.DEBUGGER_ID_X86_IA32_BOCHS
    BochsDbg.exe 32.

ida_idd.DEBUGGER_ID_X86_IA32_LINUX_USER
    Userland linux processes (ptrace())

ida_idd.DEBUGGER_ID_X86_IA32_MACOSX_USER
    Userland MAC OS X processes.

ida_idd.DEBUGGER_ID_X86_IA32_WIN32_USER
    Userland win32 processes (win32 debugging APIs)

ida_idd.DEBUGGER_ID_X86_PIN_TRACER
    PIN Tracer module.

ida_idd.DEBUGGER_ID_XNU_USER
    XNU Kernel.

ida_idd.DRC_CRC
    success, but the input file crc does not match

ida_idd.DRC_ERROR
    unclassified error, may be complemented by errbuf

ida_idd.DRC_EVENTS
    success, there are pending events

ida_idd.DRC_FAILED
    failed or false

ida_idd.DRC_IDBSEG
    use idb segmentation

ida_idd.DRC_NETERR
    network error

ida_idd.DRC_NOCHG
    no changes

ida_idd.DRC_NOFILE
    file not found

ida_idd.DRC_NONE
    reaction to the event not implemented

ida_idd.DRC_NOPROC
    the process does not exist anymore

ida_idd.DRC_OK
    success

ida_idd.EXCEPTION
    Exception.

ida_idd.EXC_BREAK
    break on the exception

ida_idd.EXC_HANDLE
    should be handled by the debugger?

ida_idd.EXC_MSG
    instead of a warning, log the exception to the output window

ida_idd.EXC_SILENT
    do not warn or log to the output window

ida_idd.FUNC_TRACE
    function tracing

ida_idd.IDD_INTERFACE_VERSION
    The IDD interface version number.

ida_idd.INFORMATION
    User-defined information. This event can be used to return empty information This will cause IDA to call get_debug_event() immediately once more. 
              

ida_idd.INSN_TRACE
    instruction tracing

ida_idd.LIB_LOADED
    New library has been loaded.

ida_idd.LIB_UNLOADED
    Library has been unloaded.

ida_idd.NO_EVENT
    Not an interesting event. This event can be used if the debugger module needs to return an event but there are no valid events. 
              

ida_idd.NO_PROCESS
    No process.

ida_idd.NO_THREAD
    No thread. in PROCESS_STARTED this value can be used to specify that the main thread has not been created. It will be initialized later by a THREAD_STARTED event. 
            

ida_idd.NO_THREAD
    No thread. in PROCESS_STARTED this value can be used to specify that the main thread has not been created. It will be initialized later by a THREAD_STARTED event. 
            

ida_idd.PROCESS_ATTACHED
    Successfully attached to running process.

ida_idd.PROCESS_DETACHED
    Successfully detached from process.

ida_idd.PROCESS_EXITED
    Process has been stopped.

ida_idd.PROCESS_STARTED
    New process has been started.

ida_idd.PROCESS_SUSPENDED
    Process has been suspended. This event can be used by the debugger module to signal if the process spontaneously gets suspended (not because of an exception, breakpoint, or single step). IDA will silently switch to the 'suspended process' mode without displaying any messages. 
              

ida_idd.REGISTER_ADDRESS
    may contain an address

ida_idd.REGISTER_CS
    code segment

ida_idd.REGISTER_CUSTFMT
    register should be displayed using a custom data format. the format name is in bit_strings[0]; the corresponding regval_t will use bytevec_t 
            

ida_idd.REGISTER_FP
    frame pointer

ida_idd.REGISTER_IP
    instruction pointer

ida_idd.REGISTER_NOLF
    displays this register without returning to the next line, allowing the next register to be displayed to its right (on the same line) 
            

ida_idd.REGISTER_READONLY
    the user can't modify the current value of this register

ida_idd.REGISTER_SP
    stack pointer

ida_idd.REGISTER_SS
    stack segment

ida_idd.RESMOD_BACKINTO
    step backwards into call (in time-travel debugging)

ida_idd.RESMOD_HANDLE
    step into the exception handler

ida_idd.RESMOD_INTO
    step into call (the most typical single stepping)

ida_idd.RESMOD_NONE
    no stepping, run freely

ida_idd.RESMOD_OUT
    step out of the current function (run until return)

ida_idd.RESMOD_OVER
    step over call

ida_idd.RESMOD_SRCINTO
    until control reaches a different source line

ida_idd.RESMOD_SRCOUT
    next source line in the previous stack frame

ida_idd.RESMOD_SRCOVER
    next source line in the current stack frame

ida_idd.RESMOD_USER
    step out to the user code

ida_idd.RQ_IDAIDLE
    handle_debug_event: ida is idle

ida_idd.RQ_IGNWERR
    ignore breakpoint write failures

ida_idd.RQ_MASKING
    masking step handler: unless errors, tmpbpt handlers won't be generated should be used only with request_internal_step() 
            

ida_idd.RQ_NOSUSP
    running step handler: continues the app

ida_idd.RQ_PROCEXIT
    snapshots: the process is exiting

ida_idd.RQ_RESMOD
    resume_mode_t

ida_idd.RQ_RESUME
    handle_debug_event: resume application

ida_idd.RQ_SILENT
    all: no dialog boxes

ida_idd.RQ_SUSPEND
    suspending step handler: suspends the app handle_debug_event: suspends the app 
            

ida_idd.RQ_SUSPRUN
    handle_debug_event: suspend at PROCESS_STARTED

ida_idd.RQ_SWSCREEN
    handle_debug_event: switch screens

ida_idd.RQ_VERBOSE
    all: display dialog boxes

ida_idd.RQ__NOTHRRF
    handle_debug_event: do not refresh threads

ida_idd.RVT_FLOAT
    floating point

ida_idd.RVT_INT
    integer

ida_idd.RVT_UNAVAILABLE
    unavailable; other values mean custom data type 
            

ida_idd.STATUS_MASK
    additional info about process state

ida_idd.STEP
    One instruction has been executed. Spurious events of this kind are silently ignored by IDA. 
              

ida_idd.STEP_TRACE
    lowest level trace. trace buffers are not maintained

ida_idd.THREAD_EXITED
    Thread has been stopped.

ida_idd.THREAD_STARTED
    New thread has been started.

ida_idd.TRACE_FULL
    The trace buffer of the tracer module is full and IDA needs to read it before continuing 
              

ida_idd.appcall(func_ea: ida_idaapi.ea_t, tid: "thid_t", _type_or_none: "bytevec_t const &", _fields: "bytevec_t const &", arg_list: "PyObject *") -> "PyObject *"

ida_idd.bptaddr_t

ida_idd.bptaddr_t.__init__(self)

ida_idd.bptaddr_t.hea
    Possible address referenced by hardware breakpoints.

ida_idd.bptaddr_t.kea
    Address of the triggered bpt from the kernel's point of view. (for some systems with special memory mappings, the triggered ea might be different from event ea). Use to BADADDR for flat memory model. 
            

ida_idd.call_stack_info_t

ida_idd.call_stack_info_t.__eq__(self, r: "call_stack_info_t") -> bool

ida_idd.call_stack_info_t.__init__(self)

ida_idd.call_stack_info_t.__ne__(self, r: "call_stack_info_t") -> bool

ida_idd.call_stack_info_t.callea
    the address of the call instruction. for the 0th frame this is usually just the current value of EIP. 
            

ida_idd.call_stack_info_t.fp
    the value of the frame pointer of the called function

ida_idd.call_stack_info_t.funcea
    the address of the called function

ida_idd.call_stack_info_t.funcok
    is the function present?

ida_idd.call_stack_info_vec_t

ida_idd.call_stack_info_vec_t.__eq__(self, r: "call_stack_info_vec_t") -> bool

ida_idd.call_stack_info_vec_t.__getitem__(self, i: "size_t") -> "call_stack_info_t const &"

ida_idd.call_stack_info_vec_t.__init__(self, *args)

ida_idd.call_stack_info_vec_t.__len__(self) -> "size_t"

ida_idd.call_stack_info_vec_t.__ne__(self, r: "call_stack_info_vec_t") -> bool

ida_idd.call_stack_info_vec_t.__setitem__(self, i: "size_t", v: "call_stack_info_t") -> None

ida_idd.call_stack_info_vec_t._del(self, x: "call_stack_info_t") -> bool

ida_idd.call_stack_info_vec_t.add_unique(self, x: "call_stack_info_t") -> bool

ida_idd.call_stack_info_vec_t.append(self, x: "call_stack_info_t") -> None

ida_idd.call_stack_info_vec_t.at(self, _idx: "size_t") -> "call_stack_info_t const &"

ida_idd.call_stack_info_vec_t.begin(self, *args) -> "qvector< call_stack_info_t >::const_iterator"

ida_idd.call_stack_info_vec_t.capacity(self) -> "size_t"

ida_idd.call_stack_info_vec_t.clear(self) -> None

ida_idd.call_stack_info_vec_t.empty(self) -> bool

ida_idd.call_stack_info_vec_t.end(self, *args) -> "qvector< call_stack_info_t >::const_iterator"

ida_idd.call_stack_info_vec_t.erase(self, *args) -> "qvector< call_stack_info_t >::iterator"

ida_idd.call_stack_info_vec_t.extend(self, x: "call_stack_info_vec_t") -> None

ida_idd.call_stack_info_vec_t.extract(self) -> "call_stack_info_t *"

ida_idd.call_stack_info_vec_t.find(self, *args) -> "qvector< call_stack_info_t >::const_iterator"

ida_idd.call_stack_info_vec_t.grow(self, *args) -> None

ida_idd.call_stack_info_vec_t.has(self, x: "call_stack_info_t") -> bool

ida_idd.call_stack_info_vec_t.inject(self, s: "call_stack_info_t", len: "size_t") -> None

ida_idd.call_stack_info_vec_t.insert(self, it: "call_stack_info_t", x: "call_stack_info_t") -> "qvector< call_stack_info_t >::iterator"

ida_idd.call_stack_info_vec_t.pop_back(self) -> None

ida_idd.call_stack_info_vec_t.push_back(self, *args) -> "call_stack_info_t &"

ida_idd.call_stack_info_vec_t.qclear(self) -> None

ida_idd.call_stack_info_vec_t.reserve(self, cnt: "size_t") -> None

ida_idd.call_stack_info_vec_t.resize(self, *args) -> None

ida_idd.call_stack_info_vec_t.size(self) -> "size_t"

ida_idd.call_stack_info_vec_t.swap(self, r: "call_stack_info_vec_t") -> None

ida_idd.call_stack_info_vec_t.truncate(self) -> None

ida_idd.call_stack_t

ida_idd.call_stack_t.__init__(self)

ida_idd.can_exc_continue(ev: "debug_event_t") -> bool

ida_idd.cleanup_appcall(tid: "thid_t") -> "error_t"
    Cleanup after manual appcall. 
            
    @param tid: thread to use. NO_THREAD means to use the current thread The application state is restored as it was before calling the last appcall(). Nested appcalls are supported.
    @returns eOk if successful, otherwise an error code

ida_idd.cpu2ieee(ieee_out: "fpvalue_t *", cpu_fpval: "void const *", size: int) -> int
    Convert a floating point number in CPU native format to IDA's internal format. 
            
    @param ieee_out: output buffer
    @param cpu_fpval: floating point number in CPU native format
    @param size: size of cpu_fpval in bytes (size of the input buffer)
    @returns Floating point/IEEE Conversion codes

ida_idd.dbg_appcall(retval: "idc_value_t *", func_ea: ida_idaapi.ea_t, tid: "thid_t", ptif: "tinfo_t", argv: "idc_value_t *", argnum: "size_t") -> "error_t"
    Call a function from the debugged application. 
            
    @param retval: function return value
    * for APPCALL_MANUAL, r will hold the new stack point value
    * for APPCALL_DEBEV, r will hold the exception information upon failure and the return code will be eExecThrow
    @param func_ea: address to call
    @param tid: thread to use. NO_THREAD means to use the current thread
    @param ptif: pointer to type of the function to call
    @param argv: array of arguments
    @param argnum: number of actual arguments
    @returns eOk if successful, otherwise an error code

ida_idd.dbg_get_memory_info()
    This function returns the memory configuration of a debugged process.
    
    @return:
        None if no debugger is active
        tuple(start_ea, end_ea, name, sclass, sbase, bitness, perm)

ida_idd.dbg_get_name()
    This function returns the current debugger's name.
    
    @return: Debugger name or None if no debugger is active

ida_idd.dbg_get_registers()
    This function returns the register definition from the currently loaded debugger.
    Basically, it returns an array of structure similar to to idd.hpp / register_info_t
    
    @return:
        None if no debugger is loaded
        tuple(name, flags, class, dtype, bit_strings, default_bit_strings_mask)
        The bit_strings can be a tuple of strings or None (if the register does not have bit_strings)

ida_idd.dbg_get_thread_sreg_base(tid, sreg_value)
    Returns the segment register base value
    
    @param tid: thread id
    @param sreg_value: segment register (selector) value
    @return:
        - The base as an 'ea'
        - Or None on failure

ida_idd.dbg_read_memory(ea, sz)
    Reads from the debugee's memory at the specified ea
    
    @param ea: the debuggee's memory address
    @param sz: the amount of data to read
    @return:
        - The read buffer (as bytes)
        - Or None on failure

ida_idd.dbg_write_memory(ea, buffer)
    Writes a buffer to the debugee's memory
    
    @param ea: the debuggee's memory address
    @param buf: a bytes object to write
    @return: Boolean

ida_idd.debapp_attrs_t

ida_idd.debapp_attrs_t.__init__(self)

ida_idd.debapp_attrs_t.addrsize
    address size of the process. Since 64-bit debuggers usually can debug 32-bit applications, we cannot rely on sizeof(ea_t) to detect the current address size. The following variable should be used instead. It is initialized with 8 for 64-bit debuggers but they should adjust it as soon as they learn that a 32-bit application is being debugged. For 32-bit debuggers it is initialized with 4. 
            

ida_idd.debapp_attrs_t.cbsize
    control field: size of this structure

ida_idd.debapp_attrs_t.platform
    platform name process is running/debugging under. (is used as a key value in exceptions.cfg) 
            

ida_idd.debug_event_t

ida_idd.debug_event_t.__init__(self, *args)

ida_idd.debug_event_t.bpt(self) -> "bptaddr_t &"
    EXCEPTION

ida_idd.debug_event_t.bpt_ea(self) -> ida_idaapi.ea_t
    On some systems with special memory mappings the triggered ea might be different from the actual ea. Calculate the address to use. 
            

ida_idd.debug_event_t.clear(self) -> None
    clear the dependent information (see below), set event code to NO_EVENT

ida_idd.debug_event_t.clear_all(self) -> None

ida_idd.debug_event_t.copy(self, r: "debug_event_t") -> "debug_event_t &"

ida_idd.debug_event_t.ea
    Address where the event occurred.

ida_idd.debug_event_t.eid(self) -> "event_id_t"
    Event code.

ida_idd.debug_event_t.exc(self) -> "excinfo_t &"

ida_idd.debug_event_t.exit_code(self) -> "int const &"
    THREAD_STARTED (thread name) LIB_UNLOADED (unloaded library name) INFORMATION (will be displayed in the output window if not empty) 
            

ida_idd.debug_event_t.handled
    Is event handled by the debugger?. (from the system's point of view) Meaningful for EXCEPTION events 
            

ida_idd.debug_event_t.info(self) -> str
    BREAKPOINT

ida_idd.debug_event_t.is_bitness_changed(self) -> bool
    process bitness

ida_idd.debug_event_t.modinfo(self) -> "modinfo_t &"
    Information that depends on the event code:
    
    < PROCESS_STARTED, PROCESS_ATTACHED, LIB_LOADED PROCESS_EXITED, THREAD_EXITED 
            

ida_idd.debug_event_t.pid
    Process where the event occurred.

ida_idd.debug_event_t.set_bitness_changed(self, on: bool = True) -> None

ida_idd.debug_event_t.set_bpt(self) -> "bptaddr_t &"

ida_idd.debug_event_t.set_eid(self, id: "event_id_t") -> None
    Set event code. If the new event code is compatible with the old one then the dependent information (see below) will be preserved. Otherwise the event will be cleared and the new event code will be set. 
            

ida_idd.debug_event_t.set_exception(self) -> "excinfo_t &"

ida_idd.debug_event_t.set_exit_code(self, id: "event_id_t", code: int) -> None

ida_idd.debug_event_t.set_info(self, id: "event_id_t") -> str

ida_idd.debug_event_t.set_modinfo(self, id: "event_id_t") -> "modinfo_t &"

ida_idd.debug_event_t.tid
    Thread where the event occurred.

ida_idd.debugger_t

ida_idd.debugger_t.__get_bpt_bytes(self) -> "bytevec_t"

ida_idd.debugger_t.__get_nregisters(self) -> int

ida_idd.debugger_t.__get_regclasses(self) -> "PyObject *"

ida_idd.debugger_t.__get_registers(self) -> "dynamic_wrapped_array_t< register_info_t >"

ida_idd.debugger_t.__init__(self)

ida_idd.debugger_t.attach_process(self, pid: "pid_t", event_id: int, dbg_proc_flags: int) -> "drc_t"

ida_idd.debugger_t.bin_search(self, start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, data: "compiled_binpat_vec_t const &", srch_flags: int) -> "drc_t"

ida_idd.debugger_t.bpt_bytes
    A software breakpoint instruction.

ida_idd.debugger_t.bpt_size
    Size of the software breakpoint instruction in bytes.

ida_idd.debugger_t.cache_block_size(self) -> "size_t"

ida_idd.debugger_t.can_continue_from_bpt(self) -> bool

ida_idd.debugger_t.can_debug_standalone_dlls(self) -> bool

ida_idd.debugger_t.check_bpt(self, bptvc: "int *", type: "bpttype_t", ea: ida_idaapi.ea_t, len: int) -> "drc_t"

ida_idd.debugger_t.cleanup_appcall(self, tid: "thid_t") -> "drc_t"

ida_idd.debugger_t.close_file(self, fn: int) -> None

ida_idd.debugger_t.dbg_enable_trace(self, tid: "thid_t", enable: bool, trace_flags: int) -> bool

ida_idd.debugger_t.default_regclasses
    Mask of default printed register classes.

ida_idd.debugger_t.detach_process(self) -> "drc_t"

ida_idd.debugger_t.ev_appcall
    Call application function. This event calls a function from the debugged application. This event is generated in debthread Available if HAS_APPCALL is set 
              

ida_idd.debugger_t.ev_attach_process
    Attach to an existing running process. event_id should be equal to -1 if not attaching to a crashed process. This event is generated in debthread. Available if DBG_HAS_ATTACH_PROCESS is set 
              

ida_idd.debugger_t.ev_bin_search
    Search for a binary pattern in the program. 
              

ida_idd.debugger_t.ev_check_bpt
    Is it possible to set breakpoint? This event is generated in debthread or in the main thread if debthread is not running yet. It is generated to verify hardware breakpoints. Available if DBG_HAS_CHECK_BPT is set 
              

ida_idd.debugger_t.ev_cleanup_appcall
    Cleanup after appcall(). The debugger module must keep the stack blob in the memory until this event is generated. It will be generated by the kernel for each successful appcall(). There is an exception: if APPCALL_MANUAL, IDA may not call cleanup_appcall. If the user selects to terminate a manual appcall, then cleanup_appcall will be generated. Otherwise, the debugger module should terminate the appcall when the generated event returns. This event is generated in debthread. Available if HAS_APPCALL is set 
              

ida_idd.debugger_t.ev_dbg_enable_trace
    Enable/Disable tracing. The kernel will generated this event if the debugger plugin set DBG_FLAG_TRACER_MODULE. TRACE_FLAGS can be a set of STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE. This event is generated in the main thread. 
              

ida_idd.debugger_t.ev_detach_process
    Detach from the debugged process. May be generated while the process is running or suspended. Must detach from the process in any case. The kernel will repeatedly call get_debug_event() until PROCESS_DETACHED is received. In this mode, all other events will be automatically handled and process will be resumed. This event is generated from debthread. Available if DBG_HAS_DETACH_PROCESS is set 
              

ida_idd.debugger_t.ev_eval_lowcnd
    Evaluate a low level breakpoint condition at 'ea'. Other evaluation errors are displayed in a dialog box. This call is used by IDA when the process has already been temporarily suspended for some reason and IDA has to decide whether the process should be resumed or definitely suspended because of a breakpoint with a low level condition. This event is generated in debthread. 
              

ida_idd.debugger_t.ev_exit_process
    Stop the process. May be generated while the process is running or suspended. Must terminate the process in any case. The kernel will repeatedly call get_debug_event() until PROCESS_EXITED is received. In this mode, all other events will be automatically handled and process will be resumed. This event is generated in debthread. Must be implemented. 
              

ida_idd.debugger_t.ev_get_debapp_attrs
    Retrieve process- and debugger-specific runtime attributes. This event is generated in the main thread. 
              

ida_idd.debugger_t.ev_get_debmod_extensions
    Get pointer to debugger specific events. This event returns a pointer to a structure that holds pointers to debugger module specific events. For information on the structure layout, please check the corresponding debugger module. Most debugger modules return nullptr because they do not have any extensions. Available extensions may be generated from plugins. This event is generated in the main thread. 
              

ida_idd.debugger_t.ev_get_debug_event
    Get a pending debug event and suspend the process. This event will be generated regularly by IDA. This event is generated in debthread. IMPORTANT: the BREAKPOINT/EXCEPTION/STEP events must be reported only after reporting other pending events for a thread. Must be implemented. 
              

ida_idd.debugger_t.ev_get_dynamic_register_set
    Ask debuger to send dynamic register set 
              

ida_idd.debugger_t.ev_get_memory_info
    Get information on the memory ranges. The debugger module fills 'ranges'. The returned vector must be sorted. This event is generated in debthread. Must be implemented. 
              

ida_idd.debugger_t.ev_get_processes
    Return information about the running processes. This event is generated in the main thread. Available if DBG_HAS_GET_PROCESSES is set 
              

ida_idd.debugger_t.ev_get_srcinfo_path
    Get the path to a file containing source debug info for the given module. This allows srcinfo providers to call into the debugger when looking for debug info. It is useful in certain cases like the iOS debugger, which is a remote debugger but the remote debugserver does not provide dwarf info. So, we allow the debugger client to decide where to look for debug info locally. 
              

ida_idd.debugger_t.ev_init_debugger
    Initialize debugger. This event is generated in the main thread. 
              

ida_idd.debugger_t.ev_is_tracing_enabled
    Is tracing enabled? The kernel will generated this event if the debugger plugin set DBG_FLAG_TRACER_MODULE. TRACE_BIT can be one of the following: STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE 
              

ida_idd.debugger_t.ev_map_address
    Map process address. The debugger module may ignore this event. This event is generated in debthread. IDA will generate this event only if DBG_HAS_MAP_ADDRESS is set. 
              

ida_idd.debugger_t.ev_read_memory
    Read process memory. This event is generated in debthread. 
              

ida_idd.debugger_t.ev_read_registers
    Read thread registers. This event is generated in debthread. Must be implemented. 
              

ida_idd.debugger_t.ev_rebase_if_required_to
    Rebase database if the debugged program has been rebased by the system. This event is generated in the main thread. 
              

ida_idd.debugger_t.ev_request_pause
    Prepare to pause the process. Normally the next get_debug_event() will pause the process If the process is sleeping, then the pause will not occur until the process wakes up. If the debugger module does not react to this event, then it will be impossible to pause the program. This event is generated in debthread. Available if DBG_HAS_REQUEST_PAUSE is set 
              

ida_idd.debugger_t.ev_resume
    Continue after handling the event. This event is generated in debthread. Must be implemented. 
              

ida_idd.debugger_t.ev_rexec
    Execute a command on the remote computer. Available if DBG_HAS_REXEC is set 
              

ida_idd.debugger_t.ev_send_ioctl
    Perform a debugger-specific event. This event is generated in debthread 
              

ida_idd.debugger_t.ev_set_backwards
    Set whether the debugger should continue backwards or forwards. This event is generated in debthread. Available if DBG_FLAG_TTD is set 
              

ida_idd.debugger_t.ev_set_dbg_options
    Set debugger options (parameters that are specific to the debugger module). 
              

ida_idd.debugger_t.ev_set_exception_info
    Set exception handling. This event is generated in debthread or the main thread. Available if DBG_HAS_SET_EXCEPTION_INFO is set 
              

ida_idd.debugger_t.ev_set_resume_mode
    Specify resume action Available if DBG_HAS_SET_RESUME_MODE is set 
              

ida_idd.debugger_t.ev_start_process
    Start an executable to debug. This event is generated in debthread. Must be implemented. 
              

ida_idd.debugger_t.ev_suspended
    This event will be generated by the kernel each time it has suspended the debuggee process and refreshed the database. The debugger module may add information to the database if necessary.
    The reason for introducing this event is that when an event like LOAD_DLL happens, the database does not reflect the memory state yet and therefore we can't add information about the dll into the database in the get_debug_event() function. Only when the kernel has adjusted the database we can do it. Example: for loaded PE DLLs we can add the exported function names to the list of debug names (see set_debug_names()).
    This event is generated in the main thread. 
              

ida_idd.debugger_t.ev_term_debugger
    Terminate debugger. This event is generated in the main thread. 
              

ida_idd.debugger_t.ev_thread_continue
    Resume a suspended thread Available if DBG_HAS_THREAD_CONTINUE is set 
              

ida_idd.debugger_t.ev_thread_get_sreg_base
    Get information about the base of a segment register. Currently used by the IBM PC module to resolve references like fs:0. This event is generated in debthread. Available if DBG_HAS_THREAD_GET_SREG_BASE is set 
              

ida_idd.debugger_t.ev_thread_suspend
    Suspend a running thread Available if DBG_HAS_THREAD_SUSPEND is set 
              

ida_idd.debugger_t.ev_update_bpts
    Add/del breakpoints. bpts array contains nadd bpts to add, followed by ndel bpts to del. This event is generated in debthread. 
              

ida_idd.debugger_t.ev_update_call_stack
    Calculate the call stack trace for the given thread. This event is generated when the process is suspended and should fill the 'trace' object with the information about the current call stack. If this event returns DRC_NONE, IDA will try to invoke a processor-specific mechanism (see processor_t::ev_update_call_stack). If the current processor module does not implement stack tracing, then IDA will fall back to a generic algorithm (based on the frame pointer chain) to calculate the trace. This event is ideal if the debugging targets manage stack frames in a peculiar way, requiring special analysis. This event is generated in the main thread. Available if DBG_HAS_UPDATE_CALL_STACK is set 
              

ida_idd.debugger_t.ev_update_lowcnds
    Update low-level (server side) breakpoint conditions. This event is generated in debthread. 
              

ida_idd.debugger_t.ev_write_memory
    Write process memory. This event is generated in debthread. 
              

ida_idd.debugger_t.ev_write_register
    Write one thread register. This event is generated in debthread. Must be implemented. 
              

ida_idd.debugger_t.eval_lowcnd(self, tid: "thid_t", ea: ida_idaapi.ea_t) -> "drc_t"

ida_idd.debugger_t.exit_process(self) -> "drc_t"

ida_idd.debugger_t.fake_memory(self) -> bool

ida_idd.debugger_t.filetype
    Input file type for the instant debugger. This value will be used after attaching to a new process. 
            

ida_idd.debugger_t.get_debapp_attrs(self, out_pattrs: "debapp_attrs_t") -> bool

ida_idd.debugger_t.get_debmod_extensions(self) -> "void const *"

ida_idd.debugger_t.get_debug_event(self, event: "debug_event_t", timeout_ms: int) -> "gdecode_t"

ida_idd.debugger_t.get_dynamic_register_set(self, regset: "dynamic_register_set_t *") -> bool

ida_idd.debugger_t.get_memory_info(self, ranges: "meminfo_vec_t") -> "drc_t"

ida_idd.debugger_t.get_processes(self, procs: "procinfo_vec_t") -> "drc_t"

ida_idd.debugger_t.get_srcinfo_path(self, path: str, base: ida_idaapi.ea_t) -> bool

ida_idd.debugger_t.has_appcall(self) -> bool

ida_idd.debugger_t.has_attach_process(self) -> bool

ida_idd.debugger_t.has_check_bpt(self) -> bool

ida_idd.debugger_t.has_detach_process(self) -> bool

ida_idd.debugger_t.has_get_processes(self) -> bool

ida_idd.debugger_t.has_map_address(self) -> bool

ida_idd.debugger_t.has_open_file(self) -> bool

ida_idd.debugger_t.has_request_pause(self) -> bool

ida_idd.debugger_t.has_rexec(self) -> bool

ida_idd.debugger_t.has_set_exception_info(self) -> bool

ida_idd.debugger_t.has_set_resume_mode(self) -> bool

ida_idd.debugger_t.has_soft_bpt(self) -> bool

ida_idd.debugger_t.has_thread_continue(self) -> bool

ida_idd.debugger_t.has_thread_get_sreg_base(self) -> bool

ida_idd.debugger_t.has_thread_suspend(self) -> bool

ida_idd.debugger_t.has_update_call_stack(self) -> bool

ida_idd.debugger_t.have_set_options(self) -> bool

ida_idd.debugger_t.id
    one of Debugger API module id

ida_idd.debugger_t.init_debugger(self, hostname: str, portnum: int, password: str) -> bool

ida_idd.debugger_t.is_remote(self) -> bool

ida_idd.debugger_t.is_resmod_avail(self, resmod: int) -> bool

ida_idd.debugger_t.is_safe(self) -> bool

ida_idd.debugger_t.is_tracing_enabled(self, tid: "thid_t", tracebit: int) -> bool

ida_idd.debugger_t.is_ttd(self) -> bool

ida_idd.debugger_t.map_address(self, off: ida_idaapi.ea_t, regs: "regval_t", regnum: int) -> ida_idaapi.ea_t

ida_idd.debugger_t.may_disturb(self) -> bool

ida_idd.debugger_t.may_take_exit_snapshot(self) -> bool

ida_idd.debugger_t.memory_page_size
    Size of a memory page. Usually 4K.

ida_idd.debugger_t.must_have_hostname(self) -> bool

ida_idd.debugger_t.name
    Short debugger name like win32 or linux.

ida_idd.debugger_t.nregisters
    Number of registers.

ida_idd.debugger_t.open_file(self, file: str, fsize: "uint64 *", readonly: bool) -> int

ida_idd.debugger_t.processor
    Required processor name. Used for instant debugging to load the correct processor module 
            

ida_idd.debugger_t.read_file(self, fn: int, off: "qoff64_t", buf: "void *", size: "size_t") -> "ssize_t"

ida_idd.debugger_t.read_memory(self, nbytes: "size_t *", ea: ida_idaapi.ea_t, buffer: "void *", size: "size_t") -> "drc_t"

ida_idd.debugger_t.read_registers(self, tid: "thid_t", clsmask: int, values: "regval_t") -> "drc_t"

ida_idd.debugger_t.rebase_if_required_to(self, new_base: ida_idaapi.ea_t) -> None

ida_idd.debugger_t.regclasses
    Array of register class names.

ida_idd.debugger_t.registers
    Array of registers. Use regs() to access it.

ida_idd.debugger_t.regs(self, idx: int) -> "register_info_t &"

ida_idd.debugger_t.request_pause(self) -> "drc_t"

ida_idd.debugger_t.resume(self, event: "debug_event_t") -> "drc_t"

ida_idd.debugger_t.resume_modes
    Resume modes 
            

ida_idd.debugger_t.rexec(self, cmdline: str) -> int

ida_idd.debugger_t.send_ioctl(self, fn: int, buf: "void const *", poutbuf: "void **", poutsize: "ssize_t *") -> "drc_t"

ida_idd.debugger_t.set_backwards(self, backwards: bool) -> "drc_t"

ida_idd.debugger_t.set_exception_info(self, info: "exception_info_t", qty: int) -> None

ida_idd.debugger_t.set_resume_mode(self, tid: "thid_t", resmod: "resume_mode_t") -> "drc_t"

ida_idd.debugger_t.start_process(self, path: str, args: str, envs: "launch_env_t", startdir: str, dbg_proc_flags: int, input_path: str, input_file_crc32: int) -> "drc_t"

ida_idd.debugger_t.supports_debthread(self) -> bool

ida_idd.debugger_t.supports_lowcnds(self) -> bool

ida_idd.debugger_t.suspended(self, dlls_added: bool, thr_names: "thread_name_vec_t *" = None) -> None

ida_idd.debugger_t.term_debugger(self) -> bool

ida_idd.debugger_t.thread_continue(self, tid: "thid_t") -> "drc_t"

ida_idd.debugger_t.thread_get_sreg_base(self, answer: "ea_t *", tid: "thid_t", sreg_value: int) -> "drc_t"

ida_idd.debugger_t.thread_suspend(self, tid: "thid_t") -> "drc_t"

ida_idd.debugger_t.update_bpts(self, nbpts: "int *", bpts: "update_bpt_info_t *", nadd: int, ndel: int) -> "drc_t"

ida_idd.debugger_t.update_call_stack(self, tid: "thid_t", trace: "call_stack_t") -> "drc_t"

ida_idd.debugger_t.update_lowcnds(self, nupdated: "int *", lowcnds: "lowcnd_t const *", nlowcnds: int) -> "drc_t"

ida_idd.debugger_t.use_memregs(self) -> bool

ida_idd.debugger_t.use_sregs(self) -> bool

ida_idd.debugger_t.version
    Expected kernel version, should be IDD_INTERFACE_VERSION 
            

ida_idd.debugger_t.virtual_threads(self) -> bool

ida_idd.debugger_t.write_file(self, fn: int, off: "qoff64_t", buf: "void const *") -> "ssize_t"

ida_idd.debugger_t.write_memory(self, nbytes: "size_t *", ea: ida_idaapi.ea_t, buffer: "void const *", size: "size_t") -> "drc_t"

ida_idd.debugger_t.write_register(self, tid: "thid_t", regidx: int, value: "regval_t") -> "drc_t"

ida_idd.dyn_register_info_array

ida_idd.dyn_register_info_array.__getitem__(self, i: "size_t") -> "register_info_t const &"

ida_idd.dyn_register_info_array.__init__(self, _data: "register_info_t", _count: "size_t")

ida_idd.dyn_register_info_array.__len__(self) -> "size_t"

ida_idd.dyn_register_info_array.__setitem__(self, i: "size_t", v: "register_info_t") -> None

ida_idd.exception_info_t

ida_idd.exception_info_t.__init__(self, *args)

ida_idd.exception_info_t.break_on(self) -> bool
    Should we break on the exception?

ida_idd.exception_info_t.code
    exception code

ida_idd.exception_info_t.desc
    Long message used to display info about the exception.

ida_idd.exception_info_t.flags
    Exception info flags 
            

ida_idd.exception_info_t.handle(self) -> bool
    Should we handle the exception?

ida_idd.exception_info_t.name
    Exception standard name.

ida_idd.excinfo_t

ida_idd.excinfo_t.__init__(self)

ida_idd.excinfo_t.can_cont
    Execution of the process can continue after this exception?

ida_idd.excinfo_t.code
    Exception code.

ida_idd.excinfo_t.ea
    Possible address referenced by the exception.

ida_idd.excinfo_t.info
    Exception message.

ida_idd.excvec_t

ida_idd.excvec_t.__getitem__(self, i: "size_t") -> "exception_info_t const &"

ida_idd.excvec_t.__init__(self, *args)

ida_idd.excvec_t.__len__(self) -> "size_t"

ida_idd.excvec_t.__setitem__(self, i: "size_t", v: "exception_info_t") -> None

ida_idd.excvec_t.append(self, x: "exception_info_t") -> None

ida_idd.excvec_t.at(self, _idx: "size_t") -> "exception_info_t const &"

ida_idd.excvec_t.begin(self, *args) -> "qvector< exception_info_t >::const_iterator"

ida_idd.excvec_t.capacity(self) -> "size_t"

ida_idd.excvec_t.clear(self) -> None

ida_idd.excvec_t.empty(self) -> bool

ida_idd.excvec_t.end(self, *args) -> "qvector< exception_info_t >::const_iterator"

ida_idd.excvec_t.erase(self, *args) -> "qvector< exception_info_t >::iterator"

ida_idd.excvec_t.extend(self, x: "excvec_t") -> None

ida_idd.excvec_t.extract(self) -> "exception_info_t *"

ida_idd.excvec_t.grow(self, *args) -> None

ida_idd.excvec_t.inject(self, s: "exception_info_t", len: "size_t") -> None

ida_idd.excvec_t.insert(self, it: "exception_info_t", x: "exception_info_t") -> "qvector< exception_info_t >::iterator"

ida_idd.excvec_t.pop_back(self) -> None

ida_idd.excvec_t.push_back(self, *args) -> "exception_info_t &"

ida_idd.excvec_t.qclear(self) -> None

ida_idd.excvec_t.reserve(self, cnt: "size_t") -> None

ida_idd.excvec_t.resize(self, *args) -> None

ida_idd.excvec_t.size(self) -> "size_t"

ida_idd.excvec_t.swap(self, r: "excvec_t") -> None

ida_idd.excvec_t.truncate(self) -> None

ida_idd.get_dbg() -> "debugger_t *"

ida_idd.get_debug_event_name(dev: "debug_event_t") -> str
    get debug event name

ida_idd.get_event_bpt_hea(ev: "debug_event_t") -> ida_idaapi.ea_t

ida_idd.get_event_exc_code(ev: "debug_event_t") -> "uint"

ida_idd.get_event_exc_ea(ev: "debug_event_t") -> ida_idaapi.ea_t

ida_idd.get_event_exc_info(ev: "debug_event_t") -> str

ida_idd.get_event_info(ev: "debug_event_t") -> str

ida_idd.get_event_module_base(ev: "debug_event_t") -> ida_idaapi.ea_t

ida_idd.get_event_module_name(ev: "debug_event_t") -> str

ida_idd.get_event_module_size(ev: "debug_event_t") -> "asize_t"

ida_idd.ieee2cpu(cpu_fpval_out: "void *", ieee: "fpvalue_t const &", size: int) -> int
    Convert a floating point number in IDA's internal format to CPU native format. 
            
    @param cpu_fpval_out: output buffer
    @param ieee: floating point number of IDA's internal format
    @param size: size of cpu_fpval in bytes (size of the output buffer)
    @returns Floating point/IEEE Conversion codes

ida_idd.launch_env_t

ida_idd.launch_env_t.__init__(self)

ida_idd.launch_env_t.envs(self) -> "PyObject *"

ida_idd.launch_env_t.set(self, envvar: str, value: str) -> None

ida_idd.meminfo_vec_t

ida_idd.meminfo_vec_t.__init__(self)

ida_idd.meminfo_vec_template_t

ida_idd.meminfo_vec_template_t.__eq__(self, r: "meminfo_vec_template_t") -> bool

ida_idd.meminfo_vec_template_t.__getitem__(self, i: "size_t") -> "memory_info_t const &"

ida_idd.meminfo_vec_template_t.__init__(self, *args)

ida_idd.meminfo_vec_template_t.__len__(self) -> "size_t"

ida_idd.meminfo_vec_template_t.__ne__(self, r: "meminfo_vec_template_t") -> bool

ida_idd.meminfo_vec_template_t.__setitem__(self, i: "size_t", v: "memory_info_t") -> None

ida_idd.meminfo_vec_template_t._del(self, x: "memory_info_t") -> bool

ida_idd.meminfo_vec_template_t.add_unique(self, x: "memory_info_t") -> bool

ida_idd.meminfo_vec_template_t.append(self, x: "memory_info_t") -> None

ida_idd.meminfo_vec_template_t.at(self, _idx: "size_t") -> "memory_info_t const &"

ida_idd.meminfo_vec_template_t.begin(self, *args) -> "qvector< memory_info_t >::const_iterator"

ida_idd.meminfo_vec_template_t.capacity(self) -> "size_t"

ida_idd.meminfo_vec_template_t.clear(self) -> None

ida_idd.meminfo_vec_template_t.empty(self) -> bool

ida_idd.meminfo_vec_template_t.end(self, *args) -> "qvector< memory_info_t >::const_iterator"

ida_idd.meminfo_vec_template_t.erase(self, *args) -> "qvector< memory_info_t >::iterator"

ida_idd.meminfo_vec_template_t.extend(self, x: "meminfo_vec_template_t") -> None

ida_idd.meminfo_vec_template_t.extract(self) -> "memory_info_t *"

ida_idd.meminfo_vec_template_t.find(self, *args) -> "qvector< memory_info_t >::const_iterator"

ida_idd.meminfo_vec_template_t.grow(self, *args) -> None

ida_idd.meminfo_vec_template_t.has(self, x: "memory_info_t") -> bool

ida_idd.meminfo_vec_template_t.inject(self, s: "memory_info_t", len: "size_t") -> None

ida_idd.meminfo_vec_template_t.insert(self, it: "memory_info_t", x: "memory_info_t") -> "qvector< memory_info_t >::iterator"

ida_idd.meminfo_vec_template_t.pop_back(self) -> None

ida_idd.meminfo_vec_template_t.push_back(self, *args) -> "memory_info_t &"

ida_idd.meminfo_vec_template_t.qclear(self) -> None

ida_idd.meminfo_vec_template_t.reserve(self, cnt: "size_t") -> None

ida_idd.meminfo_vec_template_t.resize(self, *args) -> None

ida_idd.meminfo_vec_template_t.size(self) -> "size_t"

ida_idd.meminfo_vec_template_t.swap(self, r: "meminfo_vec_template_t") -> None

ida_idd.meminfo_vec_template_t.truncate(self) -> None

ida_idd.memory_info_t

ida_idd.memory_info_t.__eq__(self, r: "memory_info_t") -> bool

ida_idd.memory_info_t.__init__(self)

ida_idd.memory_info_t.__ne__(self, r: "memory_info_t") -> bool

ida_idd.memory_info_t.bitness
    Number of bits in segment addresses (0-16bit, 1-32bit, 2-64bit)

ida_idd.memory_info_t.name
    Memory range name.

ida_idd.memory_info_t.perm
    Memory range permissions (0-no information): see segment.hpp.

ida_idd.memory_info_t.sbase
    Segment base (meaningful only for segmented architectures, e.g. 16-bit x86) The base is specified in paragraphs (i.e. shifted to the right by 4) 
            

ida_idd.memory_info_t.sclass
    Memory range class name.

ida_idd.modinfo_t

ida_idd.modinfo_t.__init__(self)

ida_idd.modinfo_t.base
    module base address. if unknown pass BADADDR

ida_idd.modinfo_t.name
    full name of the module

ida_idd.modinfo_t.rebase_to
    if not BADADDR, then rebase the program to the specified address

ida_idd.modinfo_t.size
    module size. if unknown pass 0

ida_idd.process_info_t

ida_idd.process_info_t.__init__(self)

ida_idd.process_info_t.name
    process name

ida_idd.process_info_t.pid
    process id

ida_idd.procinfo_vec_t

ida_idd.procinfo_vec_t.__getitem__(self, i: "size_t") -> "process_info_t const &"

ida_idd.procinfo_vec_t.__init__(self, *args)

ida_idd.procinfo_vec_t.__len__(self) -> "size_t"

ida_idd.procinfo_vec_t.__setitem__(self, i: "size_t", v: "process_info_t") -> None

ida_idd.procinfo_vec_t.append(self, x: "process_info_t") -> None

ida_idd.procinfo_vec_t.at(self, _idx: "size_t") -> "process_info_t const &"

ida_idd.procinfo_vec_t.begin(self, *args) -> "qvector< process_info_t >::const_iterator"

ida_idd.procinfo_vec_t.capacity(self) -> "size_t"

ida_idd.procinfo_vec_t.clear(self) -> None

ida_idd.procinfo_vec_t.empty(self) -> bool

ida_idd.procinfo_vec_t.end(self, *args) -> "qvector< process_info_t >::const_iterator"

ida_idd.procinfo_vec_t.erase(self, *args) -> "qvector< process_info_t >::iterator"

ida_idd.procinfo_vec_t.extend(self, x: "procinfo_vec_t") -> None

ida_idd.procinfo_vec_t.extract(self) -> "process_info_t *"

ida_idd.procinfo_vec_t.grow(self, *args) -> None

ida_idd.procinfo_vec_t.inject(self, s: "process_info_t", len: "size_t") -> None

ida_idd.procinfo_vec_t.insert(self, it: "process_info_t", x: "process_info_t") -> "qvector< process_info_t >::iterator"

ida_idd.procinfo_vec_t.pop_back(self) -> None

ida_idd.procinfo_vec_t.push_back(self, *args) -> "process_info_t &"

ida_idd.procinfo_vec_t.qclear(self) -> None

ida_idd.procinfo_vec_t.reserve(self, cnt: "size_t") -> None

ida_idd.procinfo_vec_t.resize(self, *args) -> None

ida_idd.procinfo_vec_t.size(self) -> "size_t"

ida_idd.procinfo_vec_t.swap(self, r: "procinfo_vec_t") -> None

ida_idd.procinfo_vec_t.truncate(self) -> None

ida_idd.register_info_t

ida_idd.register_info_t.__get_bit_strings(self) -> "PyObject *"

ida_idd.register_info_t.__init__(self)

ida_idd.register_info_t.bit_strings
    strings corresponding to each bit of the register. (nullptr = no bit, same name = multi-bits mask) 
            

ida_idd.register_info_t.default_bit_strings_mask
    mask of default bits

ida_idd.register_info_t.dtype
    Register size (see Operand value types)

ida_idd.register_info_t.flags
    Register info attribute flags 
            

ida_idd.register_info_t.name
    Register name.

ida_idd.register_info_t.register_class
    segment, mmx, etc.

ida_idd.regval_t

ida_idd.regval_t.__eq__(self, r: "regval_t") -> bool

ida_idd.regval_t.__init__(self, *args)

ida_idd.regval_t.__ne__(self, r: "regval_t") -> bool

ida_idd.regval_t.bytes(self, *args) -> "bytevec_t const &"

ida_idd.regval_t.clear(self) -> None
    Clear register value.

ida_idd.regval_t.get_data(self, *args) -> "void const *"

ida_idd.regval_t.get_data_size(self) -> "size_t"

ida_idd.regval_t.ival
    RVT_INT.

ida_idd.regval_t.pyval(self, dtype: "op_dtype_t") -> "PyObject *"

ida_idd.regval_t.rvtype
    one of Register value types

ida_idd.regval_t.set_bytes(self, *args) -> "bytevec_t &"

ida_idd.regval_t.set_float(self, v: "bytevec_t const &") -> None

ida_idd.regval_t.set_int(self, x: "uint64") -> None

ida_idd.regval_t.set_pyval(self, o: "PyObject *", dtype: "op_dtype_t") -> bool

ida_idd.regval_t.set_unavailable(self) -> None

ida_idd.regval_t.swap(self, r: "regval_t") -> None
    Set this = r and r = this.

ida_idd.regval_t.use_bytevec(self) -> bool

ida_idd.regvals_t

ida_idd.regvals_t.__eq__(self, r: "regvals_t") -> bool

ida_idd.regvals_t.__getitem__(self, i: "size_t") -> "regval_t const &"

ida_idd.regvals_t.__init__(self, *args)

ida_idd.regvals_t.__len__(self) -> "size_t"

ida_idd.regvals_t.__ne__(self, r: "regvals_t") -> bool

ida_idd.regvals_t.__setitem__(self, i: "size_t", v: "regval_t") -> None

ida_idd.regvals_t._del(self, x: "regval_t") -> bool

ida_idd.regvals_t.add_unique(self, x: "regval_t") -> bool

ida_idd.regvals_t.append(self, x: "regval_t") -> None

ida_idd.regvals_t.at(self, _idx: "size_t") -> "regval_t const &"

ida_idd.regvals_t.begin(self, *args) -> "qvector< regval_t >::const_iterator"

ida_idd.regvals_t.capacity(self) -> "size_t"

ida_idd.regvals_t.clear(self) -> None

ida_idd.regvals_t.empty(self) -> bool

ida_idd.regvals_t.end(self, *args) -> "qvector< regval_t >::const_iterator"

ida_idd.regvals_t.erase(self, *args) -> "qvector< regval_t >::iterator"

ida_idd.regvals_t.extend(self, x: "regvals_t") -> None

ida_idd.regvals_t.extract(self) -> "regval_t *"

ida_idd.regvals_t.find(self, *args) -> "qvector< regval_t >::const_iterator"

ida_idd.regvals_t.grow(self, *args) -> None

ida_idd.regvals_t.has(self, x: "regval_t") -> bool

ida_idd.regvals_t.inject(self, s: "regval_t", len: "size_t") -> None

ida_idd.regvals_t.insert(self, it: "regval_t", x: "regval_t") -> "qvector< regval_t >::iterator"

ida_idd.regvals_t.pop_back(self) -> None

ida_idd.regvals_t.push_back(self, *args) -> "regval_t &"

ida_idd.regvals_t.qclear(self) -> None

ida_idd.regvals_t.reserve(self, cnt: "size_t") -> None

ida_idd.regvals_t.resize(self, *args) -> None

ida_idd.regvals_t.size(self) -> "size_t"

ida_idd.regvals_t.swap(self, r: "regvals_t") -> None

ida_idd.regvals_t.truncate(self) -> None

ida_idd.scattered_segm_t

ida_idd.scattered_segm_t.__init__(self)

ida_idd.scattered_segm_t.name
    name of the segment

ida_idd.set_debug_event_code(ev: "debug_event_t", id: "event_id_t") -> None

ida_idd.thread_name_t

ida_idd.thread_name_t.__init__(self)

ida_idd.thread_name_t.name
    new thread name

ida_idd.thread_name_t.tid
    thread

ida_idp
    Contains definition of the interface to IDP modules.
    
    The interface consists of two structures:
    * definition of target assembler: ::ash
    * definition of current processor: ::ph
    
    
    These structures contain information about target processor and assembler features.
    It also defines two groups of kernel events:
    * processor_t::event_t processor related events
    * idb_event:event_code_t database related events
    
    
    The processor related events are used to communicate with the processor module. The database related events are used to inform any interested parties, like plugins or processor modules, about the changes in the database. 
        

ida_idp.AS2_BRACE
    Use braces for all expressions.

ida_idp.AS2_BYTE1CHAR
    One symbol per processor byte. Meaningful only for wide byte processors 
            

ida_idp.AS2_COLONSUF
    addresses may have ":xx" suffix; this suffix must be ignored when extracting the address under the cursor 
            

ida_idp.AS2_IDEALDSCR
    Description of struc/union is in the 'reverse' form (keyword before name), the same as in borland tasm ideal 
            

ida_idp.AS2_STRINV
    Invert meaning of idainfo::wide_high_byte_first for text strings (for processors with bytes bigger than 8 bits) 
            

ida_idp.AS2_TERSESTR
    'terse' structure initialization form; NAME<fld,fld,...> is supported 
            

ida_idp.AS2_YWORD
    a_yword field is present and valid

ida_idp.AS2_ZWORD
    a_zword field is present and valid

ida_idp.ASB_BINF0
    010101b

ida_idp.ASB_BINF1
    ^B010101

ida_idp.ASB_BINF2
    %010101

ida_idp.ASB_BINF3
    0b1010101

ida_idp.ASB_BINF4
    b'1010101

ida_idp.ASB_BINF5
    b'1010101'

ida_idp.ASD_DECF0
    34

ida_idp.ASD_DECF1
    #34

ida_idp.ASD_DECF2
    34.

ida_idp.ASD_DECF3
    .34

ida_idp.ASH_HEXF0
    34h

ida_idp.ASH_HEXF1
    h'34

ida_idp.ASH_HEXF2
    34

ida_idp.ASH_HEXF3
    0x34

ida_idp.ASH_HEXF4
    $34

ida_idp.ASH_HEXF5
    <^R > (radix)

ida_idp.ASO_OCTF0
    123o

ida_idp.ASO_OCTF1
    0123

ida_idp.ASO_OCTF2
    123

ida_idp.ASO_OCTF3
    @123

ida_idp.ASO_OCTF4
    o'123

ida_idp.ASO_OCTF5
    123q

ida_idp.ASO_OCTF6
    ~123

ida_idp.ASO_OCTF7
    q'123

ida_idp.AS_1TEXT
    1 text per line, no bytes

ida_idp.AS_2CHRE
    double char constants are: "xy

ida_idp.AS_ALIGN2
    .align directive expects an exponent rather than a power of 2 (.align 5 means to align at 32byte boundary) 
            

ida_idp.AS_ASCIIC
    ascii directive accepts C-like escape sequences (\n,\x01 and similar) 
            

ida_idp.AS_ASCIIZ
    ascii directive inserts implicit zero byte at the end

ida_idp.AS_BINFM
    mask - binary number format

ida_idp.AS_COLON
    create colons after data names ?

ida_idp.AS_DECFM
    mask - decimal number format

ida_idp.AS_HEXFM
    mask - hex number format

ida_idp.AS_LALIGN
    Labels at "align" keyword are supported.

ida_idp.AS_N2CHR
    can't have 2 byte char consts

ida_idp.AS_NCHRE
    char constants are: 'x

ida_idp.AS_NCMAS
    no commas in ascii directives

ida_idp.AS_NHIAS
    no characters with high bit

ida_idp.AS_NOCODECLN
    don't create colons after code names

ida_idp.AS_NOSPACE
    No spaces in expressions.

ida_idp.AS_NOXRF
    Disable xrefs during the output file generation.

ida_idp.AS_OCTFM
    mask - octal number format

ida_idp.AS_OFFST
    offsets are 'offset xxx' ?

ida_idp.AS_ONEDUP
    One array definition per line.

ida_idp.AS_RELSUP
    Checkarg: 'and','or','xor' operations with addresses are possible.

ida_idp.AS_UDATA
    can use '?' in data directives

ida_idp.AS_UNEQU
    replace undefined data items with EQU (for ANTA's A80)

ida_idp.AS_XTRNTYPE
    Assembler understands type of extern symbols as ":type" suffix.

ida_idp.AssembleLine(ea, cs, ip, use32, line)
    Assemble an instruction to a string (display a warning if an error is found)
    
    @param ea: linear address of instruction
    @param cs:  cs of instruction
    @param ip:  ip of instruction
    @param use32: is 32bit segment
    @param line: line to assemble
    @return:
        - None on failure
        - or a string containing the assembled instruction

ida_idp.CF_CALL
    CALL instruction (should make a procedure here)

ida_idp.CF_CHG1
    The instruction modifies the first operand.

ida_idp.CF_CHG2
    The instruction modifies the second operand.

ida_idp.CF_CHG3
    The instruction modifies the third operand.

ida_idp.CF_CHG4
    The instruction modifies the fourth operand.

ida_idp.CF_CHG5
    The instruction modifies the fifth operand.

ida_idp.CF_CHG6
    The instruction modifies the sixth operand.

ida_idp.CF_CHG7
    The instruction modifies the seventh operand.

ida_idp.CF_CHG8
    The instruction modifies the eighth operand.

ida_idp.CF_HLL
    Instruction may be present in a high level language function 
            

ida_idp.CF_JUMP
    The instruction passes execution using indirect jump or call (thus needs additional analysis) 
            

ida_idp.CF_SHFT
    Bit-shift instruction (shl,shr...)

ida_idp.CF_STOP
    Instruction doesn't pass execution to the next instruction 
            

ida_idp.CF_USE1
    The instruction uses value of the first operand.

ida_idp.CF_USE2
    The instruction uses value of the second operand.

ida_idp.CF_USE3
    The instruction uses value of the third operand.

ida_idp.CF_USE4
    The instruction uses value of the fourth operand.

ida_idp.CF_USE5
    The instruction uses value of the fifth operand.

ida_idp.CF_USE6
    The instruction uses value of the sixth operand.

ida_idp.CF_USE7
    The instruction uses value of the seventh operand.

ida_idp.CF_USE8
    The instruction uses value of the eighth operand.

ida_idp.CUSTOM_INSN_ITYPE
    Custom instruction codes defined by processor extension plugins must be greater than or equal to this 
            

ida_idp.HKCB_GLOBAL
    is global event listener? if true, the listener will survive database closing and opening. it will stay in the memory until explicitly unhooked. otherwise the kernel will delete it as soon as the owner is unloaded. should be used only with PLUGIN_FIX plugins. 
            

ida_idp.IDB_Hooks

ida_idp.IDB_Hooks.__disown__(self)

ida_idp.IDB_Hooks.__init__(self, _flags: int = 0, _hkcb_flags: int = 1)

ida_idp.IDB_Hooks.adding_segm(self, s: "segment_t *") -> None
    A segment is being created. 
              
    @param s: (segment_t *)

ida_idp.IDB_Hooks.allsegs_moved(self, info: "segm_move_infos_t *") -> None
    Program rebasing is complete. This event is generated after series of segm_moved events 
              
    @param info: (segm_move_infos_t *)

ida_idp.IDB_Hooks.auto_empty(self) -> None
    Info: all analysis queues are empty. This callback is called once when the initial analysis is finished. If the queue is not empty upon the return from this callback, it will be called later again. 
              

ida_idp.IDB_Hooks.auto_empty_finally(self) -> None
    Info: all analysis queues are empty definitively. This callback is called only once. 
              

ida_idp.IDB_Hooks.bookmark_changed(self, index: int, pos: "lochist_entry_t const *", desc: str, operation: int) -> None
    Boomarked position changed. 
              
    @param index: (uint32)
    @param pos: (::const lochist_entry_t *)
    @param desc: (::const char *)
    @param operation: (int) 0-added, 1-updated, 2-deleted if desc==nullptr, then the bookmark was deleted.

ida_idp.IDB_Hooks.byte_patched(self, ea: ida_idaapi.ea_t, old_value: int) -> None
    A byte has been patched. 
              
    @param ea: (::ea_t)
    @param old_value: (uint32)

ida_idp.IDB_Hooks.callee_addr_changed(self, ea: ida_idaapi.ea_t, callee: ida_idaapi.ea_t) -> None
    Callee address has been updated by the user. 
              
    @param ea: (::ea_t)
    @param callee: (::ea_t)

ida_idp.IDB_Hooks.changing_cmt(self, ea: ida_idaapi.ea_t, repeatable_cmt: bool, newcmt: str) -> None
    An item comment is to be changed. 
              
    @param ea: (::ea_t)
    @param repeatable_cmt: (bool)
    @param newcmt: (const char *)

ida_idp.IDB_Hooks.changing_op_ti(self, ea: ida_idaapi.ea_t, n: int, new_type: "type_t const *", new_fnames: "p_list const *") -> None
    An operand typestring (c/c++ prototype) is to be changed. 
              
    @param ea: (::ea_t)
    @param n: (int)
    @param new_type: (const type_t *)
    @param new_fnames: (const p_list *)

ida_idp.IDB_Hooks.changing_op_type(self, ea: ida_idaapi.ea_t, n: int, opinfo: "opinfo_t") -> None
    An operand type (offset, hex, etc...) is to be changed. 
              
    @param ea: (::ea_t)
    @param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL
    @param opinfo: (const opinfo_t *) additional operand info

ida_idp.IDB_Hooks.changing_range_cmt(self, kind: "range_kind_t", a: "range_t", cmt: str, repeatable: bool) -> None
    Range comment is to be changed. 
              
    @param kind: (range_kind_t)
    @param a: (const range_t *)
    @param cmt: (const char *)
    @param repeatable: (bool)

ida_idp.IDB_Hooks.changing_segm_class(self, s: "segment_t *") -> None
    Segment class is being changed. 
              
    @param s: (segment_t *)

ida_idp.IDB_Hooks.changing_segm_end(self, s: "segment_t *", new_end: ida_idaapi.ea_t, segmod_flags: int) -> None
    Segment end address is to be changed. 
              
    @param s: (segment_t *)
    @param new_end: (::ea_t)
    @param segmod_flags: (int)

ida_idp.IDB_Hooks.changing_segm_name(self, s: "segment_t *", oldname: str) -> None
    Segment name is being changed. 
              
    @param s: (segment_t *)
    @param oldname: (const char *)

ida_idp.IDB_Hooks.changing_segm_start(self, s: "segment_t *", new_start: ida_idaapi.ea_t, segmod_flags: int) -> None
    Segment start address is to be changed. 
              
    @param s: (segment_t *)
    @param new_start: (::ea_t)
    @param segmod_flags: (int)

ida_idp.IDB_Hooks.changing_ti(self, ea: ida_idaapi.ea_t, new_type: "type_t const *", new_fnames: "p_list const *") -> None
    An item typestring (c/c++ prototype) is to be changed. 
              
    @param ea: (::ea_t)
    @param new_type: (const type_t *)
    @param new_fnames: (const p_list *)

ida_idp.IDB_Hooks.closebase(self) -> None
    The database will be closed now.

ida_idp.IDB_Hooks.cmt_changed(self, ea: ida_idaapi.ea_t, repeatable_cmt: bool) -> None
    An item comment has been changed. 
              
    @param ea: (::ea_t)
    @param repeatable_cmt: (bool)

ida_idp.IDB_Hooks.compiler_changed(self, adjust_inf_fields: bool) -> None
    The kernel has changed the compiler information. ( idainfo::cc structure; get_abi_name) 
              
    @param adjust_inf_fields: (::bool) may change inf fields?

ida_idp.IDB_Hooks.deleting_func(self, pfn: "func_t *") -> None
    The kernel is about to delete a function. 
              
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.deleting_func_tail(self, pfn: "func_t *", tail: "range_t") -> None
    A function tail chunk is to be removed. 
              
    @param pfn: (func_t *)
    @param tail: (const range_t *)

ida_idp.IDB_Hooks.deleting_segm(self, start_ea: ida_idaapi.ea_t) -> None
    A segment is to be deleted. 
              
    @param start_ea: (::ea_t)

ida_idp.IDB_Hooks.deleting_tryblks(self, range: "range_t") -> None
    About to delete tryblk information in given range 
              
    @param range: (const range_t *)

ida_idp.IDB_Hooks.destroyed_items(self, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, will_disable_range: bool) -> None
    Instructions/data have been destroyed in [ea1,ea2). 
              
    @param ea1: (::ea_t)
    @param ea2: (::ea_t)
    @param will_disable_range: (bool)

ida_idp.IDB_Hooks.determined_main(self, main: ida_idaapi.ea_t) -> None
    The main() function has been determined. 
              
    @param main: (::ea_t) address of the main() function

ida_idp.IDB_Hooks.dirtree_link(self, dt: "dirtree_t *", path: str, link: bool) -> None
    Dirtree: an item has been linked/unlinked. 
              
    @param dt: (dirtree_t *)
    @param path: (::const char *)
    @param link: (::bool)

ida_idp.IDB_Hooks.dirtree_mkdir(self, dt: "dirtree_t *", path: str) -> None
    Dirtree: a directory has been created. 
              
    @param dt: (dirtree_t *)
    @param path: (::const char *)

ida_idp.IDB_Hooks.dirtree_move(self, dt: "dirtree_t *", _from: str, to: str) -> None
    Dirtree: a directory or item has been moved. 
              
    @param dt: (dirtree_t *)
    @param to: (::const char *)

ida_idp.IDB_Hooks.dirtree_rank(self, dt: "dirtree_t *", path: str, rank: "size_t") -> None
    Dirtree: a directory or item rank has been changed. 
              
    @param dt: (dirtree_t *)
    @param path: (::const char *)
    @param rank: (::size_t)

ida_idp.IDB_Hooks.dirtree_rmdir(self, dt: "dirtree_t *", path: str) -> None
    Dirtree: a directory has been deleted. 
              
    @param dt: (dirtree_t *)
    @param path: (::const char *)

ida_idp.IDB_Hooks.dirtree_rminode(self, dt: "dirtree_t *", inode: "inode_t") -> None
    Dirtree: an inode became unavailable. 
              
    @param dt: (dirtree_t *)
    @param inode: (inode_t)

ida_idp.IDB_Hooks.dirtree_segm_moved(self, dt: "dirtree_t *") -> None
    Dirtree: inodes were changed due to a segment movement or a program rebasing 
              
    @param dt: (dirtree_t *)

ida_idp.IDB_Hooks.extlang_changed(self, kind: int, el: "extlang_t *", idx: int) -> None
    The list of extlangs or the default extlang was changed. 
              
    @param kind: (int) 0: extlang installed 1: extlang removed 2: default extlang changed
    @param el: (extlang_t *) pointer to the extlang affected
    @param idx: (int) extlang index

ida_idp.IDB_Hooks.extra_cmt_changed(self, ea: ida_idaapi.ea_t, line_idx: int, cmt: str) -> None
    An extra comment has been changed. 
              
    @param ea: (::ea_t)
    @param line_idx: (int)
    @param cmt: (const char *)

ida_idp.IDB_Hooks.flow_chart_created(self, fc: "qflow_chart_t") -> None
    Gui has retrieved a function flow chart. Plugins may modify the flow chart in this callback. 
              
    @param fc: (qflow_chart_t *)

ida_idp.IDB_Hooks.frame_created(self, func_ea: ida_idaapi.ea_t) -> None
    A function frame has been created. 
              
    @param func_ea: (::ea_t) idb_event::frame_deleted

ida_idp.IDB_Hooks.frame_deleted(self, pfn: "func_t *") -> None
    The kernel has deleted a function frame. 
              
    @param pfn: (func_t *) idb_event::frame_created

ida_idp.IDB_Hooks.frame_expanded(self, func_ea: ida_idaapi.ea_t, udm_tid: "tid_t", delta: "adiff_t") -> None
    A frame type has been expanded/shrank. 
              
    @param func_ea: (::ea_t)
    @param udm_tid: (tid_t) the gap was added/removed before this member
    @param delta: (::adiff_t) number of added/removed bytes

ida_idp.IDB_Hooks.frame_udm_changed(self, func_ea: ida_idaapi.ea_t, udm_tid: "tid_t", udmold: "udm_t", udmnew: "udm_t") -> None
    Frame member has been changed. 
              
    @param func_ea: (::ea_t)
    @param udm_tid: (tid_t)
    @param udmold: (::const udm_t *)
    @param udmnew: (::const udm_t *)

ida_idp.IDB_Hooks.frame_udm_created(self, func_ea: ida_idaapi.ea_t, udm: "udm_t") -> None
    Frame member has been added. 
              
    @param func_ea: (::ea_t)
    @param udm: (::const udm_t *)

ida_idp.IDB_Hooks.frame_udm_deleted(self, func_ea: ida_idaapi.ea_t, udm_tid: "tid_t", udm: "udm_t") -> None
    Frame member has been deleted. 
              
    @param func_ea: (::ea_t)
    @param udm_tid: (tid_t)
    @param udm: (::const udm_t *)

ida_idp.IDB_Hooks.frame_udm_renamed(self, func_ea: ida_idaapi.ea_t, udm: "udm_t", oldname: str) -> None
    Frame member has been renamed. 
              
    @param func_ea: (::ea_t)
    @param udm: (::const udm_t *)
    @param oldname: (::const char *)

ida_idp.IDB_Hooks.func_added(self, pfn: "func_t *") -> None
    The kernel has added a function. 
              
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.func_deleted(self, func_ea: ida_idaapi.ea_t) -> None
    A function has been deleted. 
              
    @param func_ea: (::ea_t)

ida_idp.IDB_Hooks.func_noret_changed(self, pfn: "func_t *") -> None
    FUNC_NORET bit has been changed. 
              
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.func_tail_appended(self, pfn: "func_t *", tail: "func_t *") -> None
    A function tail chunk has been appended. 
              
    @param pfn: (func_t *)
    @param tail: (func_t *)

ida_idp.IDB_Hooks.func_tail_deleted(self, pfn: "func_t *", tail_ea: ida_idaapi.ea_t) -> None
    A function tail chunk has been removed. 
              
    @param pfn: (func_t *)
    @param tail_ea: (::ea_t)

ida_idp.IDB_Hooks.func_updated(self, pfn: "func_t *") -> None
    The kernel has updated a function. 
              
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.hook(self) -> bool

ida_idp.IDB_Hooks.idasgn_loaded(self, short_sig_name: str) -> None
    FLIRT signature has been loaded for normal processing (not for recognition of startup sequences). 
              
    @param short_sig_name: (const char *)

ida_idp.IDB_Hooks.idasgn_matched_ea(self, ea: ida_idaapi.ea_t, name: str, lib_name: str) -> None
    A FLIRT match has been found 
              
    @param ea: (::ea_t) the matching address
    @param name: (::const char *) the matched name
    @param lib_name: (::const char *) library name extracted from signature file

ida_idp.IDB_Hooks.item_color_changed(self, ea: ida_idaapi.ea_t, color: "bgcolor_t") -> None
    An item color has been changed. 
              
    @param ea: (::ea_t)
    @param color: (bgcolor_t) if color==DEFCOLOR, the the color is deleted.

ida_idp.IDB_Hooks.kernel_config_loaded(self, pass_number: int) -> None
    This event is issued when ida.cfg is parsed. 
              
    @param pass_number: (int)

ida_idp.IDB_Hooks.loader_finished(self, li: "linput_t *", neflags: "uint16", filetypename: str) -> None
    External file loader finished its work. Use this event to augment the existing loader functionality. 
              
    @param li: (linput_t *)
    @param neflags: (uint16) Load file flags
    @param filetypename: (const char *)

ida_idp.IDB_Hooks.local_types_changed(self, ltc: "local_type_change_t", ordinal: int, name: str) -> None
    Local types have been changed 
              
    @param ltc: (local_type_change_t)
    @param ordinal: (uint32) 0 means ordinal is unknown
    @param name: (const char *) nullptr means name is unknown

ida_idp.IDB_Hooks.lt_udm_changed(self, udtname: str, udm_tid: "tid_t", udmold: "udm_t", udmnew: "udm_t") -> None
    local type udt member has been changed 
              
    @param udtname: (::const char *)
    @param udm_tid: (tid_t)
    @param udmold: (::const udm_t *)
    @param udmnew: (::const udm_t *)

ida_idp.IDB_Hooks.lt_udm_created(self, udtname: str, udm: "udm_t") -> None
    local type udt member has been added 
              
    @param udtname: (::const char *)
    @param udm: (::const udm_t *)

ida_idp.IDB_Hooks.lt_udm_deleted(self, udtname: str, udm_tid: "tid_t", udm: "udm_t") -> None
    local type udt member has been deleted 
              
    @param udtname: (::const char *)
    @param udm_tid: (tid_t)
    @param udm: (::const udm_t *)

ida_idp.IDB_Hooks.lt_udm_renamed(self, udtname: str, udm: "udm_t", oldname: str) -> None
    local type udt member has been renamed 
              
    @param udtname: (::const char *)
    @param udm: (::const udm_t *)
    @param oldname: (::const char *)

ida_idp.IDB_Hooks.lt_udt_expanded(self, udtname: str, udm_tid: "tid_t", delta: "adiff_t") -> None
    A structure type has been expanded/shrank. 
              
    @param udtname: (::const char *)
    @param udm_tid: (tid_t) the gap was added/removed before this member
    @param delta: (::adiff_t) number of added/removed bytes

ida_idp.IDB_Hooks.make_code(self, insn: "insn_t const *") -> None
    An instruction is being created. 
              
    @param insn: (const insn_t*)

ida_idp.IDB_Hooks.make_data(self, ea: ida_idaapi.ea_t, flags: "flags64_t", tid: "tid_t", len: "asize_t") -> None
    A data item is being created. 
              
    @param ea: (::ea_t)
    @param flags: (flags64_t)
    @param tid: (tid_t)
    @param len: (::asize_t)

ida_idp.IDB_Hooks.op_ti_changed(self, ea: ida_idaapi.ea_t, n: int, type: "type_t const *", fnames: "p_list const *") -> None
    An operand typestring (c/c++ prototype) has been changed. 
              
    @param ea: (::ea_t)
    @param n: (int)
    @param type: (const type_t *)
    @param fnames: (const p_list *)

ida_idp.IDB_Hooks.op_type_changed(self, ea: ida_idaapi.ea_t, n: int) -> None
    An operand type (offset, hex, etc...) has been set or deleted. 
              
    @param ea: (::ea_t)
    @param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL

ida_idp.IDB_Hooks.range_cmt_changed(self, kind: "range_kind_t", a: "range_t", cmt: str, repeatable: bool) -> None
    Range comment has been changed. 
              
    @param kind: (range_kind_t)
    @param a: (const range_t *)
    @param cmt: (const char *)
    @param repeatable: (bool)

ida_idp.IDB_Hooks.renamed(self, ea: ida_idaapi.ea_t, new_name: str, local_name: bool, old_name: str) -> None
    The kernel has renamed a byte. See also the rename event 
              
    @param ea: (::ea_t)
    @param new_name: (const char *) can be nullptr
    @param local_name: (bool)
    @param old_name: (const char *) can be nullptr

ida_idp.IDB_Hooks.savebase(self) -> None
    The database is being saved.

ida_idp.IDB_Hooks.segm_added(self, s: "segment_t *") -> None
    A new segment has been created. 
              
    @param s: (segment_t *) See also adding_segm

ida_idp.IDB_Hooks.segm_attrs_updated(self, s: "segment_t *") -> None
    Segment attributes has been changed. 
              
    @param s: (segment_t *) This event is generated for secondary segment attributes (examples: color, permissions, etc)

ida_idp.IDB_Hooks.segm_class_changed(self, s: "segment_t *", sclass: str) -> None
    Segment class has been changed. 
              
    @param s: (segment_t *)
    @param sclass: (const char *)

ida_idp.IDB_Hooks.segm_deleted(self, start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, flags: int) -> None
    A segment has been deleted. 
              
    @param start_ea: (::ea_t)
    @param end_ea: (::ea_t)
    @param flags: (int)

ida_idp.IDB_Hooks.segm_end_changed(self, s: "segment_t *", oldend: ida_idaapi.ea_t) -> None
    Segment end address has been changed. 
              
    @param s: (segment_t *)
    @param oldend: (::ea_t)

ida_idp.IDB_Hooks.segm_moved(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, size: "asize_t", changed_netmap: bool) -> None
    Segment has been moved. 
              
    @param to: (::ea_t)
    @param size: (::asize_t)
    @param changed_netmap: (bool) See also idb_event::allsegs_moved

ida_idp.IDB_Hooks.segm_name_changed(self, s: "segment_t *", name: str) -> None
    Segment name has been changed. 
              
    @param s: (segment_t *)
    @param name: (const char *)

ida_idp.IDB_Hooks.segm_start_changed(self, s: "segment_t *", oldstart: ida_idaapi.ea_t) -> None
    Segment start address has been changed. 
              
    @param s: (segment_t *)
    @param oldstart: (::ea_t)

ida_idp.IDB_Hooks.set_func_end(self, pfn: "func_t *", new_end: ida_idaapi.ea_t) -> None
    Function chunk end address will be changed. 
              
    @param pfn: (func_t *)
    @param new_end: (::ea_t)

ida_idp.IDB_Hooks.set_func_start(self, pfn: "func_t *", new_start: ida_idaapi.ea_t) -> None
    Function chunk start address will be changed. 
              
    @param pfn: (func_t *)
    @param new_start: (::ea_t)

ida_idp.IDB_Hooks.sgr_changed(self, start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, regnum: int, value: "sel_t", old_value: "sel_t", tag: "uchar") -> None
    The kernel has changed a segment register value. 
              
    @param start_ea: (::ea_t)
    @param end_ea: (::ea_t)
    @param regnum: (int)
    @param value: (::sel_t)
    @param old_value: (::sel_t)
    @param tag: (uchar) Segment register range tags

ida_idp.IDB_Hooks.sgr_deleted(self, start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, regnum: int) -> None
    The kernel has deleted a segment register value. 
              
    @param start_ea: (::ea_t)
    @param end_ea: (::ea_t)
    @param regnum: (int)

ida_idp.IDB_Hooks.stkpnts_changed(self, pfn: "func_t *") -> None
    Stack change points have been modified. 
              
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.tail_owner_changed(self, tail: "func_t *", owner_func: ida_idaapi.ea_t, old_owner: ida_idaapi.ea_t) -> None
    A tail chunk owner has been changed. 
              
    @param tail: (func_t *)
    @param owner_func: (::ea_t)
    @param old_owner: (::ea_t)

ida_idp.IDB_Hooks.thunk_func_created(self, pfn: "func_t *") -> None
    A thunk bit has been set for a function. 
              
    @param pfn: (func_t *)

ida_idp.IDB_Hooks.ti_changed(self, ea: ida_idaapi.ea_t, type: "type_t const *", fnames: "p_list const *") -> None
    An item typestring (c/c++ prototype) has been changed. 
              
    @param ea: (::ea_t)
    @param type: (const type_t *)
    @param fnames: (const p_list *)

ida_idp.IDB_Hooks.tryblks_updated(self, tbv: "tryblks_t const *") -> None
    Updated tryblk information 
              
    @param tbv: (const ::tryblks_t *)

ida_idp.IDB_Hooks.unhook(self) -> bool

ida_idp.IDB_Hooks.updating_tryblks(self, tbv: "tryblks_t const *") -> None
    About to update tryblk information 
              
    @param tbv: (const ::tryblks_t *)

ida_idp.IDB_Hooks.upgraded(self, _from: int) -> None
    The database has been upgraded and the receiver can upgrade its info as well 
              

ida_idp.IDP_Hooks

ida_idp.IDP_Hooks.__disown__(self)

ida_idp.IDP_Hooks.__init__(self, _flags: int = 0, _hkcb_flags: int = 1)

ida_idp.IDP_Hooks.ev_add_cref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: "cref_t") -> int
    A code reference is being created. 
              
    @param to: (::ea_t)
    @param type: (cref_t)
    @retval <0: cancel cref creation
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_add_dref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: "dref_t") -> int
    A data reference is being created. 
              
    @param to: (::ea_t)
    @param type: (dref_t)
    @retval <0: cancel dref creation
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_adjust_argloc(self, argloc: "argloc_t", optional_type: "tinfo_t", size: int) -> int
    Adjust argloc according to its type/size and platform endianess 
              
    @param argloc: (argloc_t *), inout
    @param size: (int) 'size' makes no sense if type != nullptr (type->get_size() should be used instead)
    @retval 0: not implemented
    @retval 1: ok
    @retval -1: error

ida_idp.IDP_Hooks.ev_adjust_libfunc_ea(self, sig: "idasgn_t const *", libfun: "libfunc_t const *", ea: "ea_t *") -> int
    Called when a signature module has been matched against bytes in the database. This is used to compute the offset at which a particular module's libfunc should be applied. 
              
    @param sig: (const idasgn_t *)
    @param libfun: (const libfunc_t *)
    @param ea: (::ea_t *)
    @retval 1: the ea_t pointed to by the third argument was modified.
    @retval <=0: not modified. use default algorithm.

ida_idp.IDP_Hooks.ev_adjust_refinfo(self, ri: "refinfo_t", ea: ida_idaapi.ea_t, n: int, fd: "fixup_data_t const *") -> int
    Called from apply_fixup before converting operand to reference. Can be used for changing the reference info. (e.g. the PPC module adds REFINFO_NOBASE for some references) 
              
    @param ri: (refinfo_t *)
    @param ea: (::ea_t) instruction address
    @param n: (int) operand number
    @param fd: (const fixup_data_t *)
    @retval <0: do not create an offset
    @retval 0: not implemented or refinfo adjusted

ida_idp.IDP_Hooks.ev_ana_insn(self, out: "insn_t *") -> bool
    Analyze one instruction and fill 'out' structure. This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. insn_t::ea contains address of instruction to analyze. 
              
    @param out: (insn_t *)
    @returns length of the instruction in bytes, 0 if instruction can't be decoded.
    @retval 0: if instruction can't be decoded.

ida_idp.IDP_Hooks.ev_analyze_prolog(self, ea: ida_idaapi.ea_t) -> int
    Analyzes function prolog, epilog, and updates purge, and function attributes 
              
    @param ea: (::ea_t) start of function
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_arch_changed(self) -> int
    The loader is done parsing arch-related information, which the processor module might want to use to finish its initialization. 
              
    @retval 1: if success
    @retval 0: not implemented or failed

ida_idp.IDP_Hooks.ev_arg_addrs_ready(self, caller: ida_idaapi.ea_t, n: int, tif: "tinfo_t", addrs: "ea_t *") -> int
    Argument address info is ready. 
              
    @param caller: (::ea_t)
    @param n: (int) number of formal arguments
    @param tif: (tinfo_t *) call prototype
    @param addrs: (::ea_t *) argument intilization addresses
    @retval <0: do not save into idb; other values mean "ok to save"

ida_idp.IDP_Hooks.ev_asm_installed(self, asmnum: int) -> int
    After setting a new assembler 
              
    @param asmnum: (int) See also ev_newasm

ida_idp.IDP_Hooks.ev_assemble(self, ea: ida_idaapi.ea_t, cs: ida_idaapi.ea_t, ip: ida_idaapi.ea_t, use32: bool, line: str) -> "PyObject *"
    Assemble an instruction. (display a warning if an error is found). 
              
    @param ea: (::ea_t) linear address of instruction
    @param cs: (::ea_t) cs of instruction
    @param ip: (::ea_t) ip of instruction
    @param use32: (bool) is 32bit segment?
    @param line: (const char *) line to assemble
    @returns size of the instruction in bytes

ida_idp.IDP_Hooks.ev_auto_queue_empty(self, type: "atype_t") -> int
    One analysis queue is empty. 
              
    @param type: (atype_t)
    @retval void: see also idb_event::auto_empty_finally

ida_idp.IDP_Hooks.ev_calc_arglocs(self, fti: "func_type_data_t") -> int
    Calculate function argument locations. This callback should fill retloc, all arglocs, and stkargs. This callback is never called for CM_CC_SPECIAL functions. 
              
    @param fti: (func_type_data_t *) points to the func type info
    @retval 0: not implemented
    @retval 1: ok
    @retval -1: error

ida_idp.IDP_Hooks.ev_calc_cdecl_purged_bytes(self, ea: ida_idaapi.ea_t) -> int
    Calculate number of purged bytes after call. 
              
    @param ea: (::ea_t) address of the call instruction
    @returns number of purged bytes (usually add sp, N)

ida_idp.IDP_Hooks.ev_calc_next_eas(self, res: "eavec_t *", insn: "insn_t const *", over: bool) -> int
    Calculate list of addresses the instruction in 'insn' may pass control to. This callback is required for source level debugging. 
              
    @param res: (eavec_t *), out: array for the results.
    @param insn: (const insn_t*) the instruction
    @param over: (bool) calculate for step over (ignore call targets)
    @retval <0: incalculable (indirect jumps, for example)
    @retval >=0: number of addresses of called functions in the array. They must be put at the beginning of the array (0 if over=true)

ida_idp.IDP_Hooks.ev_calc_purged_bytes(self, p_purged_bytes: "int *", fti: "func_type_data_t") -> int
    Calculate number of purged bytes by the given function type. 
              
    @param p_purged_bytes: (int *) ptr to output
    @param fti: (const func_type_data_t *) func type details
    @retval 1: 
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_calc_retloc(self, retloc: "argloc_t", rettype: "tinfo_t", cc: "cm_t") -> int
    Calculate return value location. 
              
    @param retloc: (argloc_t *)
    @param rettype: (const tinfo_t *)
    @param cc: (cm_t)
    @retval 0: not implemented
    @retval 1: ok,
    @retval -1: error

ida_idp.IDP_Hooks.ev_calc_spdelta(self, spdelta: "sval_t *", insn: "insn_t const *") -> int
    Calculate amount of change to sp for the given insn. This event is required to decompile code snippets. 
              
    @param spdelta: (sval_t *)
    @param insn: (const insn_t *)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_calc_step_over(self, target: "ea_t *", ip: ida_idaapi.ea_t) -> int
    Calculate the address of the instruction which will be executed after "step over". The kernel will put a breakpoint there. If the step over is equal to step into or we cannot calculate the address, return BADADDR. 
              
    @param target: (::ea_t *) pointer to the answer
    @param ip: (::ea_t) instruction address
    @retval 0: unimplemented
    @retval 1: implemented

ida_idp.IDP_Hooks.ev_calc_switch_cases(self, casevec: "casevec_t *", targets: "eavec_t *", insn_ea: ida_idaapi.ea_t, si: "switch_info_t") -> int
    Calculate case values and targets for a custom jump table. 
              
    @param casevec: (::casevec_t *) vector of case values (may be nullptr)
    @param targets: (eavec_t *) corresponding target addresses (my be nullptr)
    @param insn_ea: (::ea_t) address of the 'indirect jump' instruction
    @param si: (switch_info_t *) switch information
    @retval 1: ok
    @retval <=0: failed

ida_idp.IDP_Hooks.ev_calc_varglocs(self, ftd: "func_type_data_t", aux_regs: "regobjs_t", aux_stkargs: "relobj_t", nfixed: int) -> int
    Calculate locations of the arguments that correspond to '...'. 
              
    @param ftd: (func_type_data_t *), inout: info about all arguments (including varargs)
    @param aux_regs: (regobjs_t *) buffer for hidden register arguments, may be nullptr
    @param aux_stkargs: (relobj_t *) buffer for hidden stack arguments, may be nullptr
    @param nfixed: (int) number of fixed arguments
    @retval 0: not implemented
    @retval 1: ok
    @retval -1: error On some platforms variadic calls require passing additional information: for example, number of floating variadic arguments must be passed in rax on gcc-x64. The locations and values that constitute this additional information are returned in the buffers pointed by aux_regs and aux_stkargs

ida_idp.IDP_Hooks.ev_calcrel(self) -> int
    Reserved.

ida_idp.IDP_Hooks.ev_can_have_type(self, op: "op_t const *") -> int
    Can the operand have a type as offset, segment, decimal, etc? (for example, a register AX can't have a type, meaning that the user can't change its representation. see bytes.hpp for information about types and flags) 
              
    @param op: (const op_t *)
    @retval 0: unknown
    @retval <0: no
    @retval 1: yes

ida_idp.IDP_Hooks.ev_clean_tbit(self, ea: ida_idaapi.ea_t, getreg: "processor_t::regval_getter_t *", regvalues: "regval_t") -> int
    Clear the TF bit after an insn like pushf stored it in memory. 
              
    @param ea: (::ea_t) instruction address
    @param getreg: (::processor_t::regval_getter_t *) function to get register values
    @param regvalues: (const regval_t *) register values array
    @retval 1: ok
    @retval 0: failed

ida_idp.IDP_Hooks.ev_cmp_operands(self, op1: "op_t const *", op2: "op_t const *") -> int
    Compare instruction operands 
              
    @param op1: (const op_t*)
    @param op2: (const op_t*)
    @retval 1: equal
    @retval -1: not equal
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_coagulate(self, start_ea: ida_idaapi.ea_t) -> int
    Try to define some unexplored bytes. This notification will be called if the kernel tried all possibilities and could not find anything more useful than to convert to array of bytes. The module can help the kernel and convert the bytes into something more useful. 
              
    @param start_ea: (::ea_t)
    @returns number of converted bytes

ida_idp.IDP_Hooks.ev_coagulate_dref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, may_define: bool, code_ea: "ea_t *") -> int
    Data reference is being analyzed. plugin may correct 'code_ea' (e.g. for thumb mode refs, we clear the last bit) 
              
    @param to: (::ea_t)
    @param may_define: (bool)
    @param code_ea: (::ea_t *)
    @retval <0: failed dref analysis, >0 done dref analysis
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_create_flat_group(self, image_base: ida_idaapi.ea_t, bitness: int, dataseg_sel: "sel_t") -> int
    Create special segment representing the flat group. 
              
    @param image_base: (::ea_t)
    @param bitness: (int)
    @param dataseg_sel: (::sel_t) return value is ignored

ida_idp.IDP_Hooks.ev_create_func_frame(self, pfn: "func_t *") -> int
    Create a function frame for a newly created function Set up frame size, its attributes etc 
              
    @param pfn: (func_t *)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_create_merge_handlers(self, md: "merge_data_t *") -> int
    Create merge handlers, if needed 
              
    @param md: (merge_data_t *) This event is generated immediately after opening idbs.
    @returns must be 0

ida_idp.IDP_Hooks.ev_create_switch_xrefs(self, jumpea: ida_idaapi.ea_t, si: "switch_info_t") -> int
    Create xrefs for a custom jump table. 
              
    @param jumpea: (::ea_t) address of the jump insn
    @param si: (const switch_info_t *) switch information
    @returns must return 1 Must be implemented if module uses custom jump tables, SWI_CUSTOM

ida_idp.IDP_Hooks.ev_creating_segm(self, seg: "segment_t *") -> int
    A new segment is about to be created. 
              
    @param seg: (segment_t *)
    @retval 1: ok
    @retval <0: segment should not be created

ida_idp.IDP_Hooks.ev_cvt64_hashval(self, node: "nodeidx_t", tag: "uchar", name: str, data: "uchar const *") -> int
    perform 32-64 conversion for a hash value 
              
    @param node: (::nodeidx_t)
    @param tag: (uchar)
    @param name: (const ::char *)
    @param data: (const uchar *)
    @retval 0: nothing was done
    @retval 1: converted successfully
    @retval -1: error (and message in errbuf)

ida_idp.IDP_Hooks.ev_cvt64_supval(self, node: "nodeidx_t", tag: "uchar", idx: "nodeidx_t", data: "uchar const *") -> int
    perform 32-64 conversion for a netnode array element 
              
    @param node: (::nodeidx_t)
    @param tag: (uchar)
    @param idx: (::nodeidx_t)
    @param data: (const uchar *)
    @retval 0: nothing was done
    @retval 1: converted successfully
    @retval -1: error (and message in errbuf)

ida_idp.IDP_Hooks.ev_decorate_name(self, name: str, mangle: bool, cc: int, optional_type: "tinfo_t") -> "PyObject *"
    Decorate/undecorate a C symbol name. 
              
    @param name: (const char *) name of symbol
    @param mangle: (bool) true-mangle, false-unmangle
    @param cc: (cm_t) calling convention
    @retval 1: if success
    @retval 0: not implemented or failed

ida_idp.IDP_Hooks.ev_del_cref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, expand: bool) -> int
    A code reference is being deleted. 
              
    @param to: (::ea_t)
    @param expand: (bool)
    @retval <0: cancel cref deletion
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_del_dref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> int
    A data reference is being deleted. 
              
    @param to: (::ea_t)
    @retval <0: cancel dref deletion
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_delay_slot_insn(self, ea: ida_idaapi.ea_t, bexec: bool, fexec: bool) -> "PyObject *"
    Get delay slot instruction 
              
    @param ea: (::ea_t *) in: instruction address in question, out: (if the answer is positive) if the delay slot contains valid insn: the address of the delay slot insn else: BADADDR (invalid insn, e.g. a branch)
    @param bexec: (bool *) execute slot if jumping, initially set to 'true'
    @param fexec: (bool *) execute slot if not jumping, initally set to 'true'
    @retval 1: positive answer
    @retval <=0: ordinary insn

ida_idp.IDP_Hooks.ev_demangle_name(self, name: str, disable_mask: int, demreq: int) -> "PyObject *"
    Demangle a C++ (or another language) name into a user-readable string. This event is called by demangle_name() 
              
    @param name: (const char *) mangled name
    @param disable_mask: (uint32) flags to inhibit parts of output or compiler info/other (see MNG_)
    @param demreq: (demreq_type_t) operation to perform
    @retval 1: if success
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_emu_insn(self, insn: "insn_t const *") -> bool
    Emulate instruction, create cross-references, plan to analyze subsequent instructions, modify flags etc. Upon entrance to this function, all information about the instruction is in 'insn' structure. 
              
    @param insn: (const insn_t *)
    @retval 1: ok
    @retval -1: the kernel will delete the instruction

ida_idp.IDP_Hooks.ev_endbinary(self, ok: bool) -> int
    IDA has loaded a binary file. 
              
    @param ok: (bool) file loaded successfully?

ida_idp.IDP_Hooks.ev_ending_undo(self, action_name: str, is_undo: bool) -> int
    Ended undoing/redoing an action 
              
    @param action_name: (const char *) action that we finished undoing/redoing. is not nullptr.
    @param is_undo: (bool) true if performing undo, false if performing redo

ida_idp.IDP_Hooks.ev_equal_reglocs(self, a1: "argloc_t", a2: "argloc_t") -> int
    Are 2 register arglocs the same?. We need this callback for the pc module. 
              
    @param a1: (argloc_t *)
    @param a2: (argloc_t *)
    @retval 1: yes
    @retval -1: no
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_extract_address(self, out_ea: "ea_t *", screen_ea: ida_idaapi.ea_t, string: str, position: "size_t") -> int
    Extract address from a string. 
              
    @param out_ea: (ea_t *), out
    @param screen_ea: (ea_t)
    @param string: (const char *)
    @param position: (size_t)
    @retval 1: ok
    @retval 0: kernel should use the standard algorithm
    @retval -1: error

ida_idp.IDP_Hooks.ev_find_op_value(self, pinsn: "insn_t const *", opn: int) -> "PyObject *"
    Find operand value via a register tracker. The returned value in 'out' is valid before executing the instruction. 
              
    @param pinsn: (const insn_t *) instruction
    @param opn: (int) operand index
    @retval 1: if implemented, and value was found
    @retval 0: not implemented, -1 decoding failed, or no value found

ida_idp.IDP_Hooks.ev_find_reg_value(self, pinsn: "insn_t const *", reg: int) -> "PyObject *"
    Find register value via a register tracker. The returned value in 'out' is valid before executing the instruction. 
              
    @param pinsn: (const insn_t *) instruction
    @param reg: (int) register index
    @retval 1: if implemented, and value was found
    @retval 0: not implemented, -1 decoding failed, or no value found

ida_idp.IDP_Hooks.ev_func_bounds(self, possible_return_code: "int *", pfn: "func_t *", max_func_end_ea: ida_idaapi.ea_t) -> int
    find_func_bounds() finished its work. The module may fine tune the function bounds 
              
    @param possible_return_code: (int *), in/out
    @param pfn: (func_t *)
    @param max_func_end_ea: (::ea_t) (from the kernel's point of view)
    @retval void: 

ida_idp.IDP_Hooks.ev_gen_asm_or_lst(self, starting: bool, fp: "FILE *", is_asm: bool, flags: int, outline: "html_line_cb_t **") -> int
    Callback: generating asm or lst file. The kernel calls this callback twice, at the beginning and at the end of listing generation. The processor module can intercept this event and adjust its output 
              
    @param starting: (bool) beginning listing generation
    @param fp: (FILE *) output file
    @param is_asm: (bool) true:assembler, false:listing
    @param flags: (int) flags passed to gen_file()
    @param outline: (html_line_cb_t **) ptr to ptr to outline callback. if this callback is defined for this code, it will be used by the kernel to output the generated lines
    @retval void: 

ida_idp.IDP_Hooks.ev_gen_map_file(self, nlines: "int *", fp: "FILE *") -> int
    Generate map file. If not implemented the kernel itself will create the map file. 
              
    @param nlines: (int *) number of lines in map file (-1 means write error)
    @param fp: (FILE *) output file
    @retval 0: not implemented
    @retval 1: ok
    @retval -1: write error

ida_idp.IDP_Hooks.ev_gen_regvar_def(self, outctx: "outctx_t *", v: "regvar_t *") -> int
    Generate register variable definition line. 
              
    @param outctx: (outctx_t *)
    @param v: (regvar_t *)
    @retval >0: ok, generated the definition text
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_gen_src_file_lnnum(self, outctx: "outctx_t *", file: str, lnnum: "size_t") -> int
    Callback: generate analog of: 
         #line  123
        
    
    
              
    @param outctx: (outctx_t *) output context
    @param file: (const char *) source file (may be nullptr)
    @param lnnum: (size_t) line number
    @retval 1: directive has been generated
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_gen_stkvar_def(self, outctx: "outctx_t *", stkvar: "udm_t", v: int, tid: "tid_t") -> int
    Generate stack variable definition line Default line is varname = type ptr value, where 'type' is one of byte,word,dword,qword,tbyte 
              
    @param outctx: (outctx_t *)
    @param stkvar: (const udm_t *)
    @param v: (sval_t)
    @param tid: (tid_t) stkvar TID
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_get_abi_info(self, comp: "comp_t") -> int
    Get all possible ABI names and optional extensions for given compiler abiname/option is a string entirely consisting of letters, digits and underscore 
              
    @param comp: (comp_t) - compiler ID
    @retval 0: not implemented
    @retval 1: ok

ida_idp.IDP_Hooks.ev_get_autocmt(self, insn: "insn_t const *") -> "PyObject *"
    Callback: get dynamic auto comment. Will be called if the autocomments are enabled and the comment retrieved from ida.int starts with '$!'. 'insn' contains valid info. 
              
    @param insn: (const insn_t*) the instruction
    @retval 1: new comment has been generated
    @retval 0: callback has not been handled. the buffer must not be changed in this case

ida_idp.IDP_Hooks.ev_get_bg_color(self, color: "bgcolor_t *", ea: ida_idaapi.ea_t) -> int
    Get item background color. Plugins can hook this callback to color disassembly lines dynamically 
              
    @param color: (bgcolor_t *), out
    @param ea: (::ea_t)
    @retval 0: not implemented
    @retval 1: color set

ida_idp.IDP_Hooks.ev_get_cc_regs(self, regs: "callregs_t", cc: "cm_t") -> int
    Get register allocation convention for given calling convention 
              
    @param regs: (callregs_t *), out
    @param cc: (cm_t)
    @retval 1: 
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_get_code16_mode(self, ea: ida_idaapi.ea_t) -> int
    Get ISA 16-bit mode 
              
    @param ea: (ea_t) address to get the ISA mode
    @retval 1: 16-bit mode
    @retval 0: not implemented or 32-bit mode

ida_idp.IDP_Hooks.ev_get_dbr_opnum(self, opnum: "int *", insn: "insn_t const *") -> int
    Get the number of the operand to be displayed in the debugger reference view (text mode). 
              
    @param opnum: (int *) operand number (out, -1 means no such operand)
    @param insn: (const insn_t*) the instruction
    @retval 0: unimplemented
    @retval 1: implemented

ida_idp.IDP_Hooks.ev_get_default_enum_size(self) -> int
    Get default enum size. Not generated anymore. inf_get_cc_size_e() is used instead 
              

ida_idp.IDP_Hooks.ev_get_frame_retsize(self, frsize: "int *", pfn: "func_t const *") -> int
    Get size of function return address in bytes If this event is not implemented, the kernel will assume
    * 8 bytes for 64-bit function
    * 4 bytes for 32-bit function
    * 2 bytes otherwise
    
    
    
    @param frsize: (int *) frame size (out)
    @param pfn: (const func_t *), can't be nullptr
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_get_macro_insn_head(self, head: "ea_t *", ip: ida_idaapi.ea_t) -> int
    Calculate the start of a macro instruction. This notification is called if IP points to the middle of an instruction 
              
    @param head: (::ea_t *), out: answer, BADADDR means normal instruction
    @param ip: (::ea_t) instruction address
    @retval 0: unimplemented
    @retval 1: implemented

ida_idp.IDP_Hooks.ev_get_operand_string(self, insn: "insn_t const *", opnum: int) -> "PyObject *"
    Request text string for operand (cli, java, ...). 
              
    @param insn: (const insn_t*) the instruction
    @param opnum: (int) operand number, -1 means any string operand
    @retval 0: no string (or empty string)
    @retval >0: original string length without terminating zero

ida_idp.IDP_Hooks.ev_get_procmod(self) -> int
    Get pointer to the processor module object. All processor modules must implement this. The pointer is returned as size_t. 
              

ida_idp.IDP_Hooks.ev_get_reg_accesses(self, accvec: "reg_accesses_t", insn: "insn_t const *", flags: int) -> int
    Get info about the registers that are used/changed by an instruction. 
              
    @param accvec: (reg_accesses_t*) out: info about accessed registers
    @param insn: (const insn_t *) instruction in question
    @param flags: (int) reserved, must be 0
    @retval -1: if accvec is nullptr
    @retval 1: found the requested access (and filled accvec)
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_get_reg_info(self, main_regname: "char const **", bitrange: "bitrange_t", regname: str) -> int
    Get register information by its name. example: "ah" returns:
    * main_regname="eax"
    * bitrange_t = { offset==8, nbits==8 }
    
    
    This callback may be unimplemented if the register names are all present in processor_t::reg_names and they all have the same size 
              
    @param main_regname: (const char **), out
    @param bitrange: (bitrange_t *), out: position and size of the value within 'main_regname' (empty bitrange == whole register)
    @param regname: (const char *)
    @retval 1: ok
    @retval -1: failed (not found)
    @retval 0: unimplemented

ida_idp.IDP_Hooks.ev_get_reg_name(self, reg: int, width: "size_t", reghi: int) -> "PyObject *"
    Generate text representation of a register. Most processor modules do not need to implement this callback. It is useful only if processor_t::reg_names[reg] does not provide the correct register name. 
              
    @param reg: (int) internal register number as defined in the processor module
    @param width: (size_t) register width in bytes
    @param reghi: (int) if not -1 then this function will return the register pair
    @retval -1: if error
    @retval strlen(buf): if success

ida_idp.IDP_Hooks.ev_get_simd_types(self, out: "simd_info_vec_t *", simd_attrs: "simd_info_t", argloc: "argloc_t", create_tifs: bool) -> int
    Get SIMD-related types according to given attributes ant/or argument location 
              
    @param out: (::simd_info_vec_t *)
    @param simd_attrs: (const simd_info_t *), may be nullptr
    @param argloc: (const argloc_t *), may be nullptr
    @param create_tifs: (bool) return valid tinfo_t objects, create if neccessary
    @retval number: of found types
    @retval -1: error If name==nullptr, initialize all SIMD types

ida_idp.IDP_Hooks.ev_get_stkarg_area_info(self, out: "stkarg_area_info_t", cc: "cm_t") -> int
    Get some metrics of the stack argument area. 
              
    @param out: (stkarg_area_info_t *) ptr to stkarg_area_info_t
    @param cc: (cm_t) calling convention
    @retval 1: if success
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_get_stkvar_scale_factor(self) -> int
    Should stack variable references be multiplied by a coefficient before being used in the stack frame?. Currently used by TMS320C55 because the references into the stack should be multiplied by 2 
              
    @returns scaling factor
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_getreg(self, regval: "uval_t *", regnum: int) -> int
    IBM PC only internal request, should never be used for other purpose Get register value by internal index 
              
    @param regval: (uval_t *), out
    @param regnum: (int)
    @retval 1: ok
    @retval 0: not implemented
    @retval -1: failed (undefined value or bad regnum)

ida_idp.IDP_Hooks.ev_init(self, idp_modname: str) -> int
    The IDP module is just loaded. 
              
    @param idp_modname: (const char *) processor module name
    @retval <0: on failure

ida_idp.IDP_Hooks.ev_insn_reads_tbit(self, insn: "insn_t const *", getreg: "processor_t::regval_getter_t *", regvalues: "regval_t") -> int
    Check if insn will read the TF bit. 
              
    @param insn: (const insn_t*) the instruction
    @param getreg: (::processor_t::regval_getter_t *) function to get register values
    @param regvalues: (const regval_t *) register values array
    @retval 2: yes, will generate 'step' exception
    @retval 1: yes, will store the TF bit in memory
    @retval 0: no

ida_idp.IDP_Hooks.ev_is_align_insn(self, ea: ida_idaapi.ea_t) -> int
    Is the instruction created only for alignment purposes?. Do not directly call this function, use is_align_insn() 
              
    @param ea: (ea_t) - instruction address
    @retval number: of bytes in the instruction

ida_idp.IDP_Hooks.ev_is_alloca_probe(self, ea: ida_idaapi.ea_t) -> int
    Does the function at 'ea' behave as __alloca_probe? 
              
    @param ea: (::ea_t)
    @retval 1: yes
    @retval 0: no

ida_idp.IDP_Hooks.ev_is_basic_block_end(self, insn: "insn_t const *", call_insn_stops_block: bool) -> int
    Is the current instruction end of a basic block?. This function should be defined for processors with delayed jump slots. 
              
    @param insn: (const insn_t*) the instruction
    @param call_insn_stops_block: (bool)
    @retval 0: unknown
    @retval <0: no
    @retval 1: yes

ida_idp.IDP_Hooks.ev_is_call_insn(self, insn: "insn_t const *") -> int
    Is the instruction a "call"? 
              
    @param insn: (const insn_t *) instruction
    @retval 0: unknown
    @retval <0: no
    @retval 1: yes

ida_idp.IDP_Hooks.ev_is_cond_insn(self, insn: "insn_t const *") -> int
    Is conditional instruction? 
              
    @param insn: (const insn_t *) instruction address
    @retval 1: yes
    @retval -1: no
    @retval 0: not implemented or not instruction

ida_idp.IDP_Hooks.ev_is_control_flow_guard(self, p_reg: "int *", insn: "insn_t const *") -> int
    Detect if an instruction is a "thunk call" to a flow guard function (equivalent to call reg/return/nop) 
              
    @param p_reg: (int *) indirect register number, may be -1
    @param insn: (const insn_t *) call/jump instruction
    @retval -1: no thunk detected
    @retval 1: indirect call
    @retval 2: security check routine call (NOP)
    @retval 3: return thunk
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_is_far_jump(self, icode: int) -> int
    is indirect far jump or call instruction? meaningful only if the processor has 'near' and 'far' reference types 
              
    @param icode: (int)
    @retval 0: not implemented
    @retval 1: yes
    @retval -1: no

ida_idp.IDP_Hooks.ev_is_indirect_jump(self, insn: "insn_t const *") -> int
    Determine if instruction is an indirect jump. If CF_JUMP bit cannot describe all jump types jumps, please define this callback. 
              
    @param insn: (const insn_t*) the instruction
    @retval 0: use CF_JUMP
    @retval 1: no
    @retval 2: yes

ida_idp.IDP_Hooks.ev_is_insn_table_jump(self) -> int
    Reserved.

ida_idp.IDP_Hooks.ev_is_jump_func(self, pfn: "func_t *", jump_target: "ea_t *", func_pointer: "ea_t *") -> int
    Is the function a trivial "jump" function?. 
              
    @param pfn: (func_t *)
    @param jump_target: (::ea_t *)
    @param func_pointer: (::ea_t *)
    @retval <0: no
    @retval 0: don't know
    @retval 1: yes, see 'jump_target' and 'func_pointer'

ida_idp.IDP_Hooks.ev_is_ret_insn(self, insn: "insn_t const *", flags: "uchar") -> int
    Is the instruction a "return"? 
              
    @param insn: (const insn_t *) instruction
    @param flags: (uchar), combination of IRI_... flags (see above)
    @retval 0: unknown
    @retval <0: no
    @retval 1: yes

ida_idp.IDP_Hooks.ev_is_sane_insn(self, insn: "insn_t const *", no_crefs: int) -> int
    Is the instruction sane for the current file type?. 
              
    @param insn: (const insn_t*) the instruction
    @param no_crefs: (int) 1: the instruction has no code refs to it. ida just tries to convert unexplored bytes to an instruction (but there is no other reason to convert them into an instruction) 0: the instruction is created because of some coderef, user request or another weighty reason.
    @retval >=0: ok
    @retval <0: no, the instruction isn't likely to appear in the program

ida_idp.IDP_Hooks.ev_is_sp_based(self, mode: "int *", insn: "insn_t const *", op: "op_t const *") -> int
    Check whether the operand is relative to stack pointer or frame pointer This event is used to determine how to output a stack variable If not implemented, then all operands are sp based by default. Implement this event only if some stack references use frame pointer instead of stack pointer. 
              
    @param mode: (int *) out, combination of SP/FP operand flags
    @param insn: (const insn_t *)
    @param op: (const op_t *)
    @retval 0: not implemented
    @retval 1: ok

ida_idp.IDP_Hooks.ev_is_switch(self, si: "switch_info_t", insn: "insn_t const *") -> int
    Find 'switch' idiom or override processor module's decision. It will be called for instructions marked with CF_JUMP. 
              
    @param si: (switch_info_t *), out
    @param insn: (const insn_t *) instruction possibly belonging to a switch
    @retval 1: switch is found, 'si' is filled. IDA will create the switch using the filled 'si'
    @retval -1: no switch found. This value forbids switch creation by the processor module
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_last_cb_before_loader(self) -> int

ida_idp.IDP_Hooks.ev_loader(self) -> int
    This code and higher ones are reserved for the loaders. The arguments and the return values are defined by the loaders 
              

ida_idp.IDP_Hooks.ev_lower_func_type(self, argnums: "intvec_t *", fti: "func_type_data_t") -> int
    Get function arguments which should be converted to pointers when lowering function prototype. The processor module can also modify 'fti' in order to make non-standard conversion of some arguments. 
              
    @param argnums: (intvec_t *), out - numbers of arguments to be converted to pointers in acsending order
    @param fti: (func_type_data_t *), inout func type details
    @retval 0: not implemented
    @retval 1: argnums was filled
    @retval 2: argnums was filled and made substantial changes to fti argnums[0] can contain a special negative value indicating that the return value should be passed as a hidden 'retstr' argument: -1 this argument is passed as the first one and the function returns a pointer to the argument, -2 this argument is passed as the last one and the function returns a pointer to the argument, -3 this argument is passed as the first one and the function returns 'void'.

ida_idp.IDP_Hooks.ev_max_ptr_size(self) -> int
    Get maximal size of a pointer in bytes. 
              
    @returns max possible size of a pointer

ida_idp.IDP_Hooks.ev_may_be_func(self, insn: "insn_t const *", state: int) -> int
    Can a function start here? 
              
    @param insn: (const insn_t*) the instruction
    @param state: (int) autoanalysis phase 0: creating functions 1: creating chunks
    @returns probability 1..100

ida_idp.IDP_Hooks.ev_may_show_sreg(self, current_ea: ida_idaapi.ea_t) -> int
    The kernel wants to display the segment registers in the messages window. 
              
    @param current_ea: (::ea_t)
    @retval <0: if the kernel should not show the segment registers. (assuming that the module has done it)
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_moving_segm(self, seg: "segment_t *", to: ida_idaapi.ea_t, flags: int) -> int
    May the kernel move the segment? 
              
    @param seg: (segment_t *) segment to move
    @param to: (::ea_t) new segment start address
    @param flags: (int) combination of Move segment flags
    @retval 0: yes
    @retval <0: the kernel should stop

ida_idp.IDP_Hooks.ev_newasm(self, asmnum: int) -> int
    Before setting a new assembler. 
              
    @param asmnum: (int) See also ev_asm_installed

ida_idp.IDP_Hooks.ev_newbinary(self, filename: "char *", fileoff: "qoff64_t", basepara: ida_idaapi.ea_t, binoff: ida_idaapi.ea_t, nbytes: "uint64") -> int
    IDA is about to load a binary file. 
              
    @param filename: (char *) binary file name
    @param fileoff: (qoff64_t) offset in the file
    @param basepara: (::ea_t) base loading paragraph
    @param binoff: (::ea_t) loader offset
    @param nbytes: (::uint64) number of bytes to load

ida_idp.IDP_Hooks.ev_newfile(self, fname: "char *") -> int
    A new file has been loaded. 
              
    @param fname: (char *) input file name

ida_idp.IDP_Hooks.ev_newprc(self, pnum: int, keep_cfg: bool) -> int
    Before changing processor type. 
              
    @param pnum: (int) processor number in the array of processor names
    @param keep_cfg: (bool) true: do not modify kernel configuration
    @retval 1: ok
    @retval <0: prohibit

ida_idp.IDP_Hooks.ev_next_exec_insn(self, target: "ea_t *", ea: ida_idaapi.ea_t, tid: int, getreg: "processor_t::regval_getter_t *", regvalues: "regval_t") -> int
    Get next address to be executed This function must return the next address to be executed. If the instruction following the current one is executed, then it must return BADADDR Usually the instructions to consider are: jumps, branches, calls, returns. This function is essential if the 'single step' is not supported in hardware. 
              
    @param target: (::ea_t *), out: pointer to the answer
    @param ea: (::ea_t) instruction address
    @param tid: (int) current therad id
    @param getreg: (::processor_t::regval_getter_t *) function to get register values
    @param regvalues: (const regval_t *) register values array
    @retval 0: unimplemented
    @retval 1: implemented

ida_idp.IDP_Hooks.ev_oldfile(self, fname: "char *") -> int
    An old file has been loaded. 
              
    @param fname: (char *) input file name

ida_idp.IDP_Hooks.ev_out_assumes(self, outctx: "outctx_t *") -> int
    Function to produce assume directives when segment register value changes. 
              
    @param outctx: (outctx_t *)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_out_data(self, outctx: "outctx_t *", analyze_only: bool) -> int
    Generate text representation of data items This function may change the database and create cross-references if analyze_only is set 
              
    @param outctx: (outctx_t *)
    @param analyze_only: (bool)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_out_footer(self, outctx: "outctx_t *") -> int
    Function to produce end of disassembled text 
              
    @param outctx: (outctx_t *)
    @retval void: 

ida_idp.IDP_Hooks.ev_out_header(self, outctx: "outctx_t *") -> int
    Function to produce start of disassembled text 
              
    @param outctx: (outctx_t *)
    @retval void: 

ida_idp.IDP_Hooks.ev_out_insn(self, outctx: "outctx_t *") -> bool
    Generate text representation of an instruction in 'ctx.insn' outctx_t provides functions to output the generated text. This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. 
              
    @param outctx: (outctx_t *)
    @retval void: 

ida_idp.IDP_Hooks.ev_out_label(self, outctx: "outctx_t *", colored_name: str) -> int
    The kernel is going to generate an instruction label line or a function header. 
              
    @param outctx: (outctx_t *)
    @param colored_name: (const char *)
    @retval <0: if the kernel should not generate the label
    @retval 0: not implemented or continue

ida_idp.IDP_Hooks.ev_out_mnem(self, outctx: "outctx_t *") -> int
    Generate instruction mnemonics. This callback should append the colored mnemonics to ctx.outbuf Optional notification, if absent, out_mnem will be called. 
              
    @param outctx: (outctx_t *)
    @retval 1: if appended the mnemonics
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_out_operand(self, outctx: "outctx_t *", op: "op_t const *") -> bool
    Generate text representation of an instruction operand outctx_t provides functions to output the generated text. All these actions should be performed only by emu_insn() function. 
              
    @param outctx: (outctx_t *)
    @param op: (const op_t *)
    @retval 1: ok
    @retval -1: operand is hidden

ida_idp.IDP_Hooks.ev_out_segend(self, outctx: "outctx_t *", seg: "segment_t *") -> int
    Function to produce end of segment 
              
    @param outctx: (outctx_t *)
    @param seg: (segment_t *)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_out_segstart(self, outctx: "outctx_t *", seg: "segment_t *") -> int
    Function to produce start of segment 
              
    @param outctx: (outctx_t *)
    @param seg: (segment_t *)
    @retval 1: ok
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_out_special_item(self, outctx: "outctx_t *", segtype: "uchar") -> int
    Generate text representation of an item in a special segment i.e. absolute symbols, externs, communal definitions etc 
              
    @param outctx: (outctx_t *)
    @param segtype: (uchar)
    @retval 1: ok
    @retval 0: not implemented
    @retval -1: overflow

ida_idp.IDP_Hooks.ev_privrange_changed(self, old_privrange: "range_t", delta: "adiff_t") -> int
    Privrange interval has been moved to a new location. Most common actions to be done by module in this case: fix indices of netnodes used by module 
              
    @param old_privrange: (const range_t *) - old privrange interval
    @param delta: (::adiff_t)
    @retval 0: Ok
    @retval -1: error (and message in errbuf)

ida_idp.IDP_Hooks.ev_realcvt(self, m: "void *", e: "fpvalue_t *", swt: "uint16") -> int
    Floating point -> IEEE conversion 
              
    @param m: (void *) ptr to processor-specific floating point value
    @param e: (fpvalue_t *) IDA representation of a floating point value
    @param swt: (uint16) operation (see realcvt() in ieee.h)
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_rename(self, ea: ida_idaapi.ea_t, new_name: str) -> int
    The kernel is going to rename a byte. 
              
    @param ea: (::ea_t)
    @param new_name: (const char *)
    @retval <0: if the kernel should not rename it.
    @retval 2: to inhibit the notification. I.e., the kernel should not rename, but 'set_name()' should return 'true'. also see renamed the return value is ignored when kernel is going to delete name

ida_idp.IDP_Hooks.ev_replaying_undo(self, action_name: str, vec: "undo_records_t const *", is_undo: bool) -> int
    Replaying an undo/redo buffer 
              
    @param action_name: (const char *) action that we perform undo/redo for. may be nullptr for intermediary buffers.
    @param vec: (const undo_records_t *)
    @param is_undo: (bool) true if performing undo, false if performing redo This event may be generated multiple times per undo/redo

ida_idp.IDP_Hooks.ev_set_code16_mode(self, ea: ida_idaapi.ea_t, code16: bool) -> int
    Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE, MIPS16 Set ISA 16-bit mode 
              
    @param ea: (ea_t) address to set new ISA mode
    @param code16: (bool) true for 16-bit mode, false for 32-bit mode

ida_idp.IDP_Hooks.ev_set_idp_options(self, keyword: str, value_type: int, value: "void const *", idb_loaded: bool) -> int
    Set IDP-specific configuration option Also see set_options_t in config.hpp 
              
    @param keyword: (const char *)
    @param value_type: (int)
    @param value: (const void *)
    @param idb_loaded: (bool) true if the ev_oldfile/ev_newfile events have been generated
    @retval 1: ok
    @retval 0: not implemented
    @retval -1: error (and message in errbuf)

ida_idp.IDP_Hooks.ev_set_proc_options(self, options: str, confidence: int) -> int
    Called if the user specified an option string in the command line: -p<processor name>:<options>. Can be used for setting a processor subtype. Also called if option string is passed to set_processor_type() and IDC's SetProcessorType(). 
              
    @param options: (const char *)
    @param confidence: (int) 0: loader's suggestion 1: user's decision
    @retval <0: if bad option string

ida_idp.IDP_Hooks.ev_setup_til(self) -> int
    Setup default type libraries. (called after loading a new file into the database). The processor module may load tils, setup memory model and perform other actions required to set up the type system. This is an optional callback. 
              
    @retval void: 

ida_idp.IDP_Hooks.ev_str2reg(self, regname: str) -> int
    Convert a register name to a register number. The register number is the register index in the processor_t::reg_names array Most processor modules do not need to implement this callback It is useful only if processor_t::reg_names[reg] does not provide the correct register names 
              
    @param regname: (const char *)
    @retval register: number + 1
    @retval 0: not implemented or could not be decoded

ida_idp.IDP_Hooks.ev_term(self) -> int
    The IDP module is being unloaded.

ida_idp.IDP_Hooks.ev_treat_hindering_item(self, hindering_item_ea: ida_idaapi.ea_t, new_item_flags: "flags64_t", new_item_ea: ida_idaapi.ea_t, new_item_length: "asize_t") -> int
    An item hinders creation of another item. 
              
    @param hindering_item_ea: (::ea_t)
    @param new_item_flags: (flags64_t) (0 for code)
    @param new_item_ea: (::ea_t)
    @param new_item_length: (::asize_t)
    @retval 0: no reaction
    @retval !=0: the kernel may delete the hindering item

ida_idp.IDP_Hooks.ev_undefine(self, ea: ida_idaapi.ea_t) -> int
    An item in the database (insn or data) is being deleted. 
              
    @param ea: (ea_t)
    @retval 1: do not delete srranges at the item end
    @retval 0: srranges can be deleted

ida_idp.IDP_Hooks.ev_update_call_stack(self, stack: "call_stack_t", tid: int, getreg: "processor_t::regval_getter_t *", regvalues: "regval_t") -> int
    Calculate the call stack trace for the given thread. This callback is invoked when the process is suspended and should fill the 'trace' object with the information about the current call stack. Note that this callback is NOT invoked if the current debugger backend implements stack tracing via debugger_t::event_t::ev_update_call_stack. The debugger-specific algorithm takes priority. Implementing this callback in the processor module is useful when multiple debugging platforms follow similar patterns, and thus the same processor-specific algorithm can be used for different platforms. 
              
    @param stack: (call_stack_t *) result
    @param tid: (int) thread id
    @param getreg: (::processor_t::regval_getter_t *) function to get register values
    @param regvalues: (const regval_t *) register values array
    @retval 1: ok
    @retval -1: failed
    @retval 0: unimplemented

ida_idp.IDP_Hooks.ev_use_arg_types(self, ea: ida_idaapi.ea_t, fti: "func_type_data_t", rargs: "funcargvec_t *") -> int
    Use information about callee arguments. 
              
    @param ea: (::ea_t) address of the call instruction
    @param fti: (func_type_data_t *) info about function type
    @param rargs: (funcargvec_t *) array of register arguments
    @retval 1: (and removes handled arguments from fti and rargs)
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_use_regarg_type(self, ea: ida_idaapi.ea_t, rargs: "funcargvec_t const *") -> "PyObject *"
    Use information about register argument. 
              
    @param ea: (::ea_t) address of the instruction
    @param rargs: (const funcargvec_t *) vector of register arguments (including regs extracted from scattered arguments)
    @retval 1: 
    @retval 0: not implemented

ida_idp.IDP_Hooks.ev_use_stkarg_type(self, ea: ida_idaapi.ea_t, arg: "funcarg_t") -> int
    Use information about a stack argument. 
              
    @param ea: (::ea_t) address of the push instruction which pushes the function argument into the stack
    @param arg: (const funcarg_t *) argument info
    @retval 1: ok
    @retval <=0: failed, the kernel will create a comment with the argument name or type for the instruction

ida_idp.IDP_Hooks.ev_validate_flirt_func(self, start_ea: ida_idaapi.ea_t, funcname: str) -> int
    Flirt has recognized a library function. This callback can be used by a plugin or proc module to intercept it and validate such a function. 
              
    @param start_ea: (::ea_t)
    @param funcname: (const char *)
    @retval -1: do not create a function,
    @retval 0: function is validated

ida_idp.IDP_Hooks.ev_verify_noreturn(self, pfn: "func_t *") -> int
    The kernel wants to set 'noreturn' flags for a function. 
              
    @param pfn: (func_t *)
    @retval 0: ok. any other value: do not set 'noreturn' flag

ida_idp.IDP_Hooks.ev_verify_sp(self, pfn: "func_t *") -> int
    All function instructions have been analyzed. Now the processor module can analyze the stack pointer for the whole function 
              
    @param pfn: (func_t *)
    @retval 0: ok
    @retval <0: bad stack pointer

ida_idp.IDP_Hooks.hook(self) -> bool

ida_idp.IDP_Hooks.unhook(self) -> bool

ida_idp.IDP_INTERFACE_VERSION
    The interface version number. 
            

ida_idp.IRI_EXTENDED
    Is the instruction a "return"?
    
    include instructions like "leave" that begin the function epilog 
            

ida_idp.IRI_RET_LITERALLY
    report only 'ret' instructions

ida_idp.IRI_SKIP_RETTARGET
    exclude 'ret' instructions that have special targets (see set_ret_target in PC) 
            

ida_idp.LTC_ADDED
    added a local type

ida_idp.LTC_ALIASED
    added a type alias

ida_idp.LTC_COMPILER
    changed the compiler and calling convention

ida_idp.LTC_DELETED
    deleted a local type

ida_idp.LTC_EDITED
    edited a local type

ida_idp.LTC_NONE
    no event (internal use)

ida_idp.LTC_TIL_COMPACTED
    numbered types have been compacted compact_numbered_types()

ida_idp.LTC_TIL_LOADED
    loaded a til file

ida_idp.LTC_TIL_UNLOADED
    unloaded a til file

ida_idp.OP_FP_BASED
    operand is FP based

ida_idp.OP_SP_ADD
    operand value is added to the pointer

ida_idp.OP_SP_BASED
    operand is SP based

ida_idp.OP_SP_SUB
    operand value is subtracted from the pointer

ida_idp.PLFM_386
    Intel 80x86.

ida_idp.PLFM_6502
    6502

ida_idp.PLFM_65C816
    65802/65816

ida_idp.PLFM_6800
    Motorola 68xx.

ida_idp.PLFM_68K
    Motorola 680x0.

ida_idp.PLFM_80196
    Intel 80196.

ida_idp.PLFM_8051
    8051

ida_idp.PLFM_AD2106X
    Analog Devices ADSP 2106X.

ida_idp.PLFM_AD218X
    Analog Devices ADSP 218X.

ida_idp.PLFM_ALPHA
    DEC Alpha.

ida_idp.PLFM_ARC
    Argonaut RISC Core.

ida_idp.PLFM_ARM
    Advanced RISC Machines.

ida_idp.PLFM_AVR
    Atmel 8-bit RISC processor(s)

ida_idp.PLFM_C166
    Siemens C166 family.

ida_idp.PLFM_C39
    Rockwell C39.

ida_idp.PLFM_CR16
    NSC CR16.

ida_idp.PLFM_DALVIK
    Android Dalvik Virtual Machine.

ida_idp.PLFM_DSP56K
    Motorola DSP5600x.

ida_idp.PLFM_DSP96K
    Motorola DSP96000.

ida_idp.PLFM_EBC
    EFI Bytecode.

ida_idp.PLFM_F2MC
    Fujistu F2MC-16.

ida_idp.PLFM_FR
    Fujitsu FR Family.

ida_idp.PLFM_H8
    Hitachi H8/300, H8/2000.

ida_idp.PLFM_H8500
    Hitachi H8/500.

ida_idp.PLFM_HPPA
    Hewlett-Packard PA-RISC.

ida_idp.PLFM_I860
    Intel 860.

ida_idp.PLFM_I960
    Intel 960.

ida_idp.PLFM_IA64
    Intel Itanium IA64.

ida_idp.PLFM_JAVA
    Java.

ida_idp.PLFM_KR1878
    Angstrem KR1878.

ida_idp.PLFM_M16C
    Renesas M16C.

ida_idp.PLFM_M32R
    Mitsubishi 32bit RISC.

ida_idp.PLFM_M740
    Mitsubishi 8bit.

ida_idp.PLFM_M7700
    Mitsubishi 16bit.

ida_idp.PLFM_M7900
    Mitsubishi 7900.

ida_idp.PLFM_MC6812
    Motorola 68HC12.

ida_idp.PLFM_MC6816
    Motorola 68HC16.

ida_idp.PLFM_MIPS
    MIPS.

ida_idp.PLFM_MN102L00
    Panasonic MN10200.

ida_idp.PLFM_MSP430
    Texas Instruments MSP430.

ida_idp.PLFM_NEC_78K0
    NEC 78K0.

ida_idp.PLFM_NEC_78K0S
    NEC 78K0S.

ida_idp.PLFM_NEC_V850X
    NEC V850 and V850ES/E1/E2.

ida_idp.PLFM_NET
    Microsoft Visual Studio.Net.

ida_idp.PLFM_OAKDSP
    Atmel OAK DSP.

ida_idp.PLFM_PDP
    PDP11.

ida_idp.PLFM_PIC
    Microchip's PIC.

ida_idp.PLFM_PIC16
    Microchip's 16-bit PIC.

ida_idp.PLFM_PPC
    PowerPC.

ida_idp.PLFM_RISCV
    RISC-V.

ida_idp.PLFM_RL78
    Renesas RL78.

ida_idp.PLFM_RX
    Renesas RX.

ida_idp.PLFM_S390
    IBM's S390.

ida_idp.PLFM_SCR_ADPT
    Processor module adapter for processor modules written in scripting languages.

ida_idp.PLFM_SH
    Renesas (formerly Hitachi) SuperH.

ida_idp.PLFM_SPARC
    SPARC.

ida_idp.PLFM_SPC700
    Sony SPC700.

ida_idp.PLFM_SPU
    Cell Broadband Engine Synergistic Processor Unit.

ida_idp.PLFM_ST20
    SGS-Thomson ST20.

ida_idp.PLFM_ST7
    SGS-Thomson ST7.

ida_idp.PLFM_ST9
    ST9+.

ida_idp.PLFM_TLCS900
    Toshiba TLCS-900.

ida_idp.PLFM_TMS
    Texas Instruments TMS320C5x.

ida_idp.PLFM_TMS320C1X
    Texas Instruments TMS320C1x.

ida_idp.PLFM_TMS320C28
    Texas Instruments TMS320C28x.

ida_idp.PLFM_TMS320C3
    Texas Instruments TMS320C3.

ida_idp.PLFM_TMS320C54
    Texas Instruments TMS320C54xx.

ida_idp.PLFM_TMS320C55
    Texas Instruments TMS320C55xx.

ida_idp.PLFM_TMSC6
    Texas Instruments TMS320C6x.

ida_idp.PLFM_TRICORE
    Tasking Tricore.

ida_idp.PLFM_TRIMEDIA
    Trimedia.

ida_idp.PLFM_UNSP
    SunPlus unSP.

ida_idp.PLFM_WASM
    WASM.

ida_idp.PLFM_XTENSA
    Tensilica Xtensa.

ida_idp.PLFM_Z8
    Z8.

ida_idp.PLFM_Z80
    8085, Z80

ida_idp.PR2_CODE16_BIT
    low bit of code addresses has special meaning e.g. ARM Thumb, MIPS16 
            

ida_idp.PR2_FORCE_16BIT
    use 16-bit basic types despite of 32-bit segments (used by c166)

ida_idp.PR2_IDP_OPTS
    the module has processor-specific configuration options

ida_idp.PR2_MACRO
    processor supports macro instructions

ida_idp.PR2_MAPPINGS
    the processor module uses memory mapping

ida_idp.PR2_REL_BITS
    (Lumina) calcrel info has bits granularity, not bytes - construction flag only

ida_idp.PR2_USE_CALCREL
    (Lumina) the module supports calcrel info

ida_idp.PRN_BIN
    binary

ida_idp.PRN_DEC
    decimal

ida_idp.PRN_HEX
    hex

ida_idp.PRN_OCT
    octal

ida_idp.PR_ADJSEGS
    IDA may adjust segments' starting/ending addresses.

ida_idp.PR_ALIGN
    All data items should be aligned properly.

ida_idp.PR_ALIGN_INSN
    allow ida to create alignment instructions arbitrarily. Since these instructions might lead to other wrong instructions and spoil the listing, IDA does not create them by default anymore 
            

ida_idp.PR_ASSEMBLE
    Module has a built-in assembler and will react to ev_assemble.

ida_idp.PR_BINMEM
    the processor module provides correct segmentation for binary files (i.e. it creates additional segments). The kernel will not ask the user to specify the RAM/ROM sizes 
            

ida_idp.PR_CHK_XREF
    don't allow near xrefs between segments with different bases

ida_idp.PR_CNDINSNS
    has conditional instructions

ida_idp.PR_DEFNUM
    mask - default number representation

ida_idp.PR_DEFSEG32
    segments are 32-bit by default

ida_idp.PR_DEFSEG64
    segments are 64-bit by default

ida_idp.PR_DELAYED
    has delayed jumps and calls. If this flag is set, processor_t::is_basic_block_end, processor_t::delay_slot_insn should be implemented 
            

ida_idp.PR_NOCHANGE
    The user can't change segments and code/data attributes (display only) 
            

ida_idp.PR_NO_SEGMOVE
    the processor module doesn't support move_segm() (i.e. the user can't move segments) 
            

ida_idp.PR_OUTER
    has outer operands (currently only mc68k)

ida_idp.PR_PURGING
    there are calling conventions which may purge bytes from the stack

ida_idp.PR_RNAMESOK
    allow user register names for location names

ida_idp.PR_SCALE_STKVARS
    use processor_t::get_stkvar_scale callback

ida_idp.PR_SEGS
    has segment registers?

ida_idp.PR_SEGTRANS
    the processor module supports the segment translation feature (meaning it calculates the code addresses using the map_code_ea() function) 
            

ida_idp.PR_SGROTHER
    the segment registers don't contain the segment selectors.

ida_idp.PR_STACK_UP
    the stack grows up

ida_idp.PR_TYPEINFO
    the processor module fully supports type information callbacks; without full support, function argument locations and other things will probably be wrong. 
            

ida_idp.PR_USE32
    supports 32-bit addressing?

ida_idp.PR_USE64
    supports 64-bit addressing?

ida_idp.PR_USE_ARG_TYPES
    use processor_t::use_arg_types callback

ida_idp.PR_USE_TBYTE
    BTMT_SPECFLT means _TBYTE type

ida_idp.PR_WORD_INS
    instruction codes are grouped 2bytes in binary line prefix

ida_idp.REG_SPOIL
    processor_t::use_regarg_type uses this bit in the return value to indicate that the register value has been spoiled 
            

ida_idp.SETPROC_IDB
    set processor type for old idb

ida_idp.SETPROC_LOADER
    set processor type for new idb; if the user has specified a compatible processor, return success without changing it. if failure, call loader_failure() 
              

ida_idp.SETPROC_LOADER_NON_FATAL
    the same as SETPROC_LOADER but non-fatal failures.

ida_idp.SETPROC_USER
    set user-specified processor used for -p and manual processor change at later time 
              

ida_idp.__ph

ida_idp._notify_when_dispatcher_t

ida_idp._notify_when_dispatcher_t._IDB_Hooks

ida_idp._notify_when_dispatcher_t._IDB_Hooks.__init__(self, dispatcher)

ida_idp._notify_when_dispatcher_t._IDB_Hooks.closebase(self)

ida_idp._notify_when_dispatcher_t._IDP_Hooks

ida_idp._notify_when_dispatcher_t._IDP_Hooks.__init__(self, dispatcher)

ida_idp._notify_when_dispatcher_t._IDP_Hooks.ev_newfile(self, name)

ida_idp._notify_when_dispatcher_t._IDP_Hooks.ev_oldfile(self, name)

ida_idp._notify_when_dispatcher_t.__init__(self)

ida_idp._notify_when_dispatcher_t._callback_t

ida_idp._notify_when_dispatcher_t._callback_t.__init__(self, fun)

ida_idp._notify_when_dispatcher_t._find(self, fun)

ida_idp._notify_when_dispatcher_t.dispatch(self, slot, *args)

ida_idp._notify_when_dispatcher_t.notify_when(self, when, fun)

ida_idp._processor_t

ida_idp._processor_t.__init__(self)

ida_idp._processor_t.add_cref(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: "cref_t") -> "ssize_t"

ida_idp._processor_t.add_dref(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: "dref_t") -> "ssize_t"

ida_idp._processor_t.adjust_argloc(argloc: "argloc_t", type: "tinfo_t", size: int) -> "ssize_t"

ida_idp._processor_t.adjust_libfunc_ea(sig: "idasgn_t const &", libfun: "libfunc_t const &", ea: "ea_t *") -> "ssize_t"

ida_idp._processor_t.adjust_refinfo(ri: "refinfo_t", ea: ida_idaapi.ea_t, n: int, fd: "fixup_data_t const &") -> "ssize_t"

ida_idp._processor_t.ana_insn(out: "insn_t *") -> "ssize_t"

ida_idp._processor_t.analyze_prolog(fct_ea: ida_idaapi.ea_t) -> "ssize_t"

ida_idp._processor_t.arch_changed() -> "ssize_t"

ida_idp._processor_t.arg_addrs_ready(caller: ida_idaapi.ea_t, n: int, tif: "tinfo_t", addrs: "ea_t *") -> "ssize_t"

ida_idp._processor_t.asm_installed(asmnum: int) -> "ssize_t"

ida_idp._processor_t.assemble(_bin: "uchar *", ea: ida_idaapi.ea_t, cs: ida_idaapi.ea_t, ip: ida_idaapi.ea_t, _use32: bool, line: str) -> "ssize_t"

ida_idp._processor_t.auto_queue_empty(type: int) -> None

ida_idp._processor_t.calc_arglocs(fti: "func_type_data_t") -> "ssize_t"

ida_idp._processor_t.calc_cdecl_purged_bytes(ea: ida_idaapi.ea_t) -> "ssize_t"

ida_idp._processor_t.calc_next_eas(res: "eavec_t *", insn: "insn_t const &", over: bool) -> "ssize_t"

ida_idp._processor_t.calc_purged_bytes(p_purged_bytes: "int *", fti: "func_type_data_t") -> "ssize_t"

ida_idp._processor_t.calc_retloc(retloc: "argloc_t", rettype: "tinfo_t", cc: "cm_t") -> "ssize_t"

ida_idp._processor_t.calc_spdelta(spdelta: "sval_t *", ins: "insn_t const &") -> "ssize_t"

ida_idp._processor_t.calc_step_over(target: "ea_t *", ip: ida_idaapi.ea_t) -> "ssize_t"

ida_idp._processor_t.calc_switch_cases(casevec: "void *", targets: "eavec_t *", insn_ea: ida_idaapi.ea_t, si: "switch_info_t") -> "ssize_t"

ida_idp._processor_t.calc_varglocs(ftd: "func_type_data_t", regs: "regobjs_t", stkargs: "relobj_t", nfixed: int) -> "ssize_t"

ida_idp._processor_t.calcrel(ea: ida_idaapi.ea_t) -> "bytevec_t *, size_t *"

ida_idp._processor_t.calcrel_in_bits(self) -> bool

ida_idp._processor_t.can_have_type(op: "op_t const &") -> "ssize_t"

ida_idp._processor_t.cbsize(self) -> int

ida_idp._processor_t.clean_tbit(ea: ida_idaapi.ea_t, _getreg: "processor_t::regval_getter_t *", regvalues: "regval_t") -> "ssize_t"

ida_idp._processor_t.cmp_operands(op1: "op_t const &", op2: "op_t const &") -> "ssize_t"

ida_idp._processor_t.coagulate(start_ea: ida_idaapi.ea_t) -> "ssize_t"

ida_idp._processor_t.coagulate_dref(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, may_define: bool, code_ea: "ea_t *") -> "ssize_t"

ida_idp._processor_t.create_flat_group(image_base: ida_idaapi.ea_t, bitness: int, dataseg_sel: "sel_t") -> "ssize_t"

ida_idp._processor_t.create_func_frame(pfn: "func_t *") -> "ssize_t"

ida_idp._processor_t.create_merge_handlers(md: "merge_data_t *") -> "ssize_t"

ida_idp._processor_t.create_switch_xrefs(jumpea: ida_idaapi.ea_t, si: "switch_info_t") -> "ssize_t"

ida_idp._processor_t.creating_segm(seg: "segment_t *") -> "ssize_t"

ida_idp._processor_t.cvt64_hashval(self, node: "nodeidx_t", tag: "uchar", name: str, data: "uchar const *") -> "ssize_t"

ida_idp._processor_t.cvt64_supval(self, node: "nodeidx_t", tag: "uchar", idx: "nodeidx_t", data: "uchar const *") -> "ssize_t"

ida_idp._processor_t.dbsize(self) -> int

ida_idp._processor_t.decorate_name(outbuf: str, name: str, mangle: bool, cc: "cm_t", type: "tinfo_t") -> "ssize_t"

ida_idp._processor_t.del_cref(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, expand: bool) -> "ssize_t"

ida_idp._processor_t.del_dref(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> "ssize_t"

ida_idp._processor_t.delay_slot_insn(self, ea: "ea_t *", bexec: "bool *", fexec: "bool *") -> bool

ida_idp._processor_t.demangle_name(res: "int32 *", name: str, disable_mask: int, demreq: int) -> int

ida_idp._processor_t.emu_insn(insn: "insn_t const &") -> "ssize_t"

ida_idp._processor_t.endbinary(ok: bool) -> "ssize_t"

ida_idp._processor_t.equal_reglocs(a1: "argloc_t", a2: "argloc_t") -> "ssize_t"

ida_idp._processor_t.extract_address(out_ea: "ea_t *", screen_ea: ida_idaapi.ea_t, string: str, x: "size_t") -> "ssize_t"

ida_idp._processor_t.find_op_value(insn: "insn_t const &", op: int) -> "uint64 *"

ida_idp._processor_t.find_reg_value(insn: "insn_t const &", reg: int) -> "uint64 *"

ida_idp._processor_t.func_bounds(possible_return_code: "int *", pfn: "func_t *", max_func_end_ea: ida_idaapi.ea_t) -> "ssize_t"

ida_idp._processor_t.gen_asm_or_lst(starting: bool, fp: "FILE *", is_asm: bool, flags: int, outline: "void *") -> "ssize_t"

ida_idp._processor_t.gen_map_file(nlines: "int *", fp: "FILE *") -> "ssize_t"

ida_idp._processor_t.gen_regvar_def(ctx: "outctx_t &", v: "regvar_t *") -> "ssize_t"

ida_idp._processor_t.gen_src_file_lnnum(ctx: "outctx_t &", file: str, lnnum: "size_t") -> "ssize_t"

ida_idp._processor_t.gen_stkvar_def(ctx: "outctx_t &", mptr: "udm_t", v: int, tid: "tid_t") -> "ssize_t"

ida_idp._processor_t.get_abi_info(comp: "comp_t") -> "qstrvec_t *, qstrvec_t *"

ida_idp._processor_t.get_autocmt(insn: "insn_t const &") -> str

ida_idp._processor_t.get_bg_color(color: "bgcolor_t *", ea: ida_idaapi.ea_t) -> "ssize_t"

ida_idp._processor_t.get_canon_feature(self, itype: "uint16") -> int

ida_idp._processor_t.get_canon_mnem(self, itype: "uint16") -> str

ida_idp._processor_t.get_cc_regs(regs: "callregs_t", cc: "cm_t") -> "ssize_t"

ida_idp._processor_t.get_code16_mode(ea: ida_idaapi.ea_t) -> bool

ida_idp._processor_t.get_dbr_opnum(opnum: "int *", insn: "insn_t const &") -> "ssize_t"

ida_idp._processor_t.get_default_segm_bitness(self, is_64bit_app: bool) -> int

ida_idp._processor_t.get_frame_retsize(retsize: "int *", pfn: "func_t const *") -> "ssize_t"

ida_idp._processor_t.get_idd_opinfo(opinf: "idd_opinfo_t", ea: ida_idaapi.ea_t, n: int, thread_id: int, _getreg: "processor_t::regval_getter_t *", regvalues: "regval_t") -> "ssize_t"

ida_idp._processor_t.get_macro_insn_head(head: "ea_t *", ip: ida_idaapi.ea_t) -> "ssize_t"

ida_idp._processor_t.get_operand_string(insn: "insn_t const &", opnum: int) -> str

ida_idp._processor_t.get_proc_index(self) -> int

ida_idp._processor_t.get_reg_accesses(accvec: "reg_accesses_t", insn: "insn_t const &", flags: int) -> "ssize_t"

ida_idp._processor_t.get_reg_info(regname: str, bitrange: "bitrange_t") -> str

ida_idp._processor_t.get_reg_name(reg: int, width: "size_t", reghi: int) -> str
    Get text representation of a register. For most processors this function will just return processor_t::reg_names[reg]. If the processor module has implemented processor_t::get_reg_name, it will be used instead 
            
    @param reg: internal register number as defined in the processor module
    @param width: register width in bytes
    @param reghi: if specified, then this function will return the register pair
    @returns length of register name in bytes or -1 if failure

ida_idp._processor_t.get_simd_types(out: "void *", simd_attrs: "simd_info_t", argloc: "argloc_t", create_tifs: bool) -> "ssize_t"

ida_idp._processor_t.get_stkarg_area_info(out: "stkarg_area_info_t", cc: "cm_t") -> "ssize_t"

ida_idp._processor_t.get_stkvar_scale(self) -> int

ida_idp._processor_t.get_stkvar_scale_factor() -> "ssize_t"

ida_idp._processor_t.getreg(rv: "uval_t *", regnum: int) -> "ssize_t"

ida_idp._processor_t.has_code16_bit(self) -> bool

ida_idp._processor_t.has_idp_opts(self) -> bool

ida_idp._processor_t.has_segregs(self) -> bool

ida_idp._processor_t.init(idp_modname: str) -> "ssize_t"

ida_idp._processor_t.insn_reads_tbit(insn: "insn_t const &", _getreg: "processor_t::regval_getter_t *", regvalues: "regval_t") -> "ssize_t"

ida_idp._processor_t.is_align_insn(ea: ida_idaapi.ea_t) -> "ssize_t"
    If the instruction at 'ea' looks like an alignment instruction, return its length in bytes. Otherwise return 0. 
            

ida_idp._processor_t.is_alloca_probe(ea: ida_idaapi.ea_t) -> "ssize_t"

ida_idp._processor_t.is_basic_block_end(insn: "insn_t const &", call_insn_stops_block: bool) -> "ssize_t"
    Is the instruction the end of a basic block?

ida_idp._processor_t.is_call_insn(insn: "insn_t const &") -> "ssize_t"
    Is the instruction a "call"?

ida_idp._processor_t.is_cond_insn(insn: "insn_t const &") -> "ssize_t"

ida_idp._processor_t.is_control_flow_guard(p_reg: "int *", insn: "insn_t const *") -> "ssize_t"

ida_idp._processor_t.is_far_jump(icode: int) -> "ssize_t"

ida_idp._processor_t.is_indirect_jump(insn: "insn_t const &") -> "ssize_t"

ida_idp._processor_t.is_jump_func(pfn: "func_t *", jump_target: "ea_t *", func_pointer: "ea_t *") -> "ssize_t"

ida_idp._processor_t.is_ret_insn(insn: "insn_t const &", iri_flags: "uchar") -> "ssize_t"

ida_idp._processor_t.is_sane_insn(insn: "insn_t const &", no_crefs: int) -> "ssize_t"

ida_idp._processor_t.is_sp_based(insn: "insn_t const &", x: "op_t const &") -> "ssize_t"

ida_idp._processor_t.is_switch(si: "switch_info_t", insn: "insn_t const &") -> "ssize_t"

ida_idp._processor_t.loader_elf_machine(li: "linput_t *", machine_type: int, p_procname: "char const **", p_pd: "proc_def_t **", ldr: "elf_loader_t *", reader: "reader_t *") -> "ssize_t"

ida_idp._processor_t.lower_func_type(argnums: "intvec_t *", fti: "func_type_data_t") -> "ssize_t"

ida_idp._processor_t.max_ptr_size() -> "ssize_t"

ida_idp._processor_t.may_be_func(insn: "insn_t const &", state: int) -> "ssize_t"

ida_idp._processor_t.may_show_sreg(current_ea: ida_idaapi.ea_t) -> "ssize_t"

ida_idp._processor_t.moving_segm(seg: "segment_t *", to: ida_idaapi.ea_t, flags: int) -> "ssize_t"

ida_idp._processor_t.newasm(asmnum: int) -> "ssize_t"

ida_idp._processor_t.newbinary(filename: str, fileoff: "qoff64_t", basepara: ida_idaapi.ea_t, binoff: ida_idaapi.ea_t, nbytes: "uint64") -> "ssize_t"

ida_idp._processor_t.newfile(fname: str) -> "ssize_t"

ida_idp._processor_t.newprc(pnum: int, keep_cfg: bool) -> "ssize_t"

ida_idp._processor_t.next_exec_insn(target: "ea_t *", ea: ida_idaapi.ea_t, tid: int, _getreg: "processor_t::regval_getter_t *", regvalues: "regval_t") -> "ssize_t"

ida_idp._processor_t.notify(*args) -> "ssize_t"

ida_idp._processor_t.oldfile(fname: str) -> "ssize_t"

ida_idp._processor_t.out_assumes(ctx: "outctx_t &") -> "ssize_t"

ida_idp._processor_t.out_data(ctx: "outctx_t &", analyze_only: bool) -> "ssize_t"

ida_idp._processor_t.out_footer(ctx: "outctx_t &") -> "ssize_t"

ida_idp._processor_t.out_header(ctx: "outctx_t &") -> "ssize_t"

ida_idp._processor_t.out_insn(ctx: "outctx_t &") -> "ssize_t"

ida_idp._processor_t.out_label(ctx: "outctx_t &", colored_name: str) -> "ssize_t"

ida_idp._processor_t.out_mnem(ctx: "outctx_t &") -> "ssize_t"

ida_idp._processor_t.out_operand(ctx: "outctx_t &", op: "op_t const &") -> "ssize_t"

ida_idp._processor_t.out_segend(ctx: "outctx_t &", seg: "segment_t *") -> "ssize_t"

ida_idp._processor_t.out_segstart(ctx: "outctx_t &", seg: "segment_t *") -> "ssize_t"

ida_idp._processor_t.out_special_item(ctx: "outctx_t &", segtype: "uchar") -> "ssize_t"

ida_idp._processor_t.privrange_changed(self, old_privrange: "range_t", delta: "adiff_t") -> "ssize_t"

ida_idp._processor_t.realcvt(m: "void *", e: "fpvalue_t *", swt: "uint16") -> "fpvalue_error_t"

ida_idp._processor_t.rename(ea: ida_idaapi.ea_t, new_name: str, flags: int) -> "ssize_t"

ida_idp._processor_t.set_code16_mode(ea: ida_idaapi.ea_t, code16: bool = True) -> "ssize_t"

ida_idp._processor_t.set_idp_options(keyword: str, vtype: int, value: "void const *", idb_loaded: bool = True) -> str

ida_idp._processor_t.set_proc_options(options: str, confidence: int) -> "ssize_t"

ida_idp._processor_t.setup_til() -> "ssize_t"

ida_idp._processor_t.sizeof_ldbl(self) -> "size_t"

ida_idp._processor_t.stkup(self) -> bool

ida_idp._processor_t.str2reg(regname: str) -> "ssize_t"
    Get any register number (-1 on error)

ida_idp._processor_t.supports_calcrel(self) -> bool

ida_idp._processor_t.supports_macros(self) -> bool

ida_idp._processor_t.term() -> "ssize_t"

ida_idp._processor_t.ti(self) -> bool

ida_idp._processor_t.treat_hindering_item(hindering_item_ea: ida_idaapi.ea_t, new_item_flags: "flags64_t", new_item_ea: ida_idaapi.ea_t, new_item_length: "asize_t") -> "ssize_t"

ida_idp._processor_t.undefine(ea: ida_idaapi.ea_t) -> "ssize_t"

ida_idp._processor_t.update_call_stack(stack: "call_stack_t", tid: int, _getreg: "processor_t::regval_getter_t *", regvalues: "regval_t") -> "ssize_t"

ida_idp._processor_t.use32(self) -> bool

ida_idp._processor_t.use64(self) -> bool

ida_idp._processor_t.use_arg_types(ea: ida_idaapi.ea_t, fti: "func_type_data_t", rargs: "void *") -> "ssize_t"

ida_idp._processor_t.use_mappings(self) -> bool

ida_idp._processor_t.use_regarg_type(idx: "int *", ea: ida_idaapi.ea_t, rargs: "void *") -> "ssize_t"

ida_idp._processor_t.use_stkarg_type(ea: ida_idaapi.ea_t, arg: "funcarg_t") -> "ssize_t"

ida_idp._processor_t.use_tbyte(self) -> bool

ida_idp._processor_t.validate_flirt_func(start_ea: ida_idaapi.ea_t, funcname: str) -> "ssize_t"

ida_idp._processor_t.verify_noreturn(pfn: "func_t *") -> "ssize_t"

ida_idp._processor_t.verify_sp(pfn: "func_t *") -> "ssize_t"

ida_idp._processor_t_Trampoline_IDB_Hooks

ida_idp._processor_t_Trampoline_IDB_Hooks.__dummy(self, *args)

ida_idp._processor_t_Trampoline_IDB_Hooks.__init__(self, proc)

ida_idp._processor_t_Trampoline_IDB_Hooks.__make_parent_caller(self, key)

ida_idp._processor_t_Trampoline_IDB_Hooks.__make_parent_caller.call_parent(*args)

ida_idp.asm_t

ida_idp.asm_t.__init__(self)

ida_idp.asm_t.a_align
    "align" keyword

ida_idp.asm_t.a_ascii
    string literal directive

ida_idp.asm_t.a_band
    & bit and assembler time operation

ida_idp.asm_t.a_bnot
    ~ bit not assembler time operation

ida_idp.asm_t.a_bor
    | bit or assembler time operation

ida_idp.asm_t.a_bss
    uninitialized data directive should include 's' for the size of data 
            

ida_idp.asm_t.a_byte
    byte directive

ida_idp.asm_t.a_comdef
    "comm" (communal variable)

ida_idp.asm_t.a_curip
    current IP (instruction pointer) symbol in assembler

ida_idp.asm_t.a_double
    double; 8bytes; nullptr if not allowed

ida_idp.asm_t.a_dups
    array keyword. the following sequences may appear:
    * #h header
    * #d size
    * #v value
    * #s(b,w,l,q,f,d,o) size specifiers for byte,word, dword,qword, float,double,oword 
    
    
            

ida_idp.asm_t.a_dword
    nullptr if not allowed

ida_idp.asm_t.a_equ
    'equ' Used if AS_UNEQU is set

ida_idp.asm_t.a_extrn
    "extern" name keyword

ida_idp.asm_t.a_float
    float; 4bytes; nullptr if not allowed

ida_idp.asm_t.a_include_fmt
    the include directive (format string)

ida_idp.asm_t.a_mod
    % mod assembler time operation

ida_idp.asm_t.a_oword
    nullptr if not allowed

ida_idp.asm_t.a_packreal
    packed decimal real nullptr if not allowed

ida_idp.asm_t.a_public
    "public" name keyword. nullptr-use default, ""-do not generate

ida_idp.asm_t.a_qword
    nullptr if not allowed

ida_idp.asm_t.a_rva
    'rva' keyword for image based offsets (see REFINFO_RVAOFF) 
            

ida_idp.asm_t.a_seg
    'seg ' prefix (example: push seg seg001)

ida_idp.asm_t.a_shl
    << shift left assembler time operation

ida_idp.asm_t.a_shr
    >> shift right assembler time operation

ida_idp.asm_t.a_sizeof_fmt
    size of type (format string)

ida_idp.asm_t.a_tbyte
    long double; nullptr if not allowed

ida_idp.asm_t.a_vstruc_fmt
    if a named item is a structure and displayed in the verbose (multiline) form then display the name as printf(a_strucname_fmt, typename) (for asms with type checking, e.g. tasm ideal) 
            

ida_idp.asm_t.a_weak
    "weak" name keyword. nullptr-use default, ""-do not generate

ida_idp.asm_t.a_word
    word directive

ida_idp.asm_t.a_xor
    ^ bit xor assembler time operation

ida_idp.asm_t.a_yword
    32-byte (256-bit) data; nullptr if not allowed requires AS2_YWORD 
            

ida_idp.asm_t.a_zword
    64-byte (512-bit) data; nullptr if not allowed requires AS2_ZWORD 
            

ida_idp.asm_t.accsep
    char constant delimiter

ida_idp.asm_t.ascsep
    string literal delimiter

ida_idp.asm_t.cmnt
    comment string (see also cmnt2)

ida_idp.asm_t.cmnt2
    comment close string (usually nullptr) this is used to denote a string which closes comments, for example, if the comments are represented with (* ... *) then cmnt = "(*" and cmnt2 = "*)" 
            

ida_idp.asm_t.end
    end directive

ida_idp.asm_t.esccodes
    special chars that cannot appear as is in string and char literals 
            

ida_idp.asm_t.flag
    Assembler feature bits 
            

ida_idp.asm_t.flag2
    Secondary assembler feature bits 
            

ida_idp.asm_t.header
    array of automatically generated header lines they appear at the start of disassembled text 
            

ida_idp.asm_t.help
    Help screen number, 0 - no help.

ida_idp.asm_t.high16
    high16

ida_idp.asm_t.high8
    high8

ida_idp.asm_t.lbrace
    left brace used in complex expressions

ida_idp.asm_t.low16
    low16

ida_idp.asm_t.low8
    low8 operation, should contain s for the operand

ida_idp.asm_t.name
    Assembler name (displayed in menus)

ida_idp.asm_t.origin
    org directive

ida_idp.asm_t.rbrace
    right brace used in complex expressions

ida_idp.asm_t.uflag
    user defined flags (local only for IDP) you may define and use your own bits 
            

ida_idp.assemble(ea, cs, ip, use32, line)
    Assemble an instruction into the database (display a warning if an error is found)
    
    @param ea: linear address of instruction
    @param cs: cs of instruction
    @param ip: ip of instruction
    @param use32: is 32bit segment?
    @param line: line to assemble
    
    @return: Boolean. True on success.

ida_idp.cfg_get_cc_header_path(compid: "comp_t") -> str

ida_idp.cfg_get_cc_parm(compid: "comp_t", name: str) -> str

ida_idp.cfg_get_cc_predefined_macros(compid: "comp_t") -> str

ida_idp.delay_slot_insn(ea: "ea_t *", bexec: "bool *", fexec: "bool *") -> bool

ida_idp.gen_idb_event(*args) -> None
    the kernel will use this function to generate idb_events

ida_idp.get_ash() -> "asm_t *"

ida_idp.get_config_value(key: str) -> "jvalue_t *"

ida_idp.get_idb_notifier_addr(arg1: "PyObject *") -> "PyObject *"

ida_idp.get_idb_notifier_ud_addr(hooks: "IDB_Hooks") -> "PyObject *"

ida_idp.get_idp_name() -> str
    Get name of the current processor module. The name is derived from the file name. For example, for IBM PC the module is named "pc.w32" (windows version), then the module name is "PC" (uppercase). If no processor module is loaded, this function will return nullptr 
            

ida_idp.get_idp_notifier_addr(arg1: "PyObject *") -> "PyObject *"

ida_idp.get_idp_notifier_ud_addr(hooks: "IDP_Hooks") -> "PyObject *"

ida_idp.get_ph() -> "processor_t *"

ida_idp.get_reg_info(regname: str, bitrange: "bitrange_t") -> str

ida_idp.get_reg_name(reg: int, width: "size_t", reghi: int = -1) -> str
    Get text representation of a register. For most processors this function will just return processor_t::reg_names[reg]. If the processor module has implemented processor_t::get_reg_name, it will be used instead 
            
    @param reg: internal register number as defined in the processor module
    @param width: register width in bytes
    @param reghi: if specified, then this function will return the register pair
    @returns length of register name in bytes or -1 if failure

ida_idp.has_cf_chg(feature: int, opnum: "uint") -> bool
    Does an instruction with the specified feature modify the i-th operand?

ida_idp.has_cf_use(feature: int, opnum: "uint") -> bool
    Does an instruction with the specified feature use a value of the i-th operand?

ida_idp.has_insn_feature(icode: "uint16", bit: int) -> bool
    Does the specified instruction have the specified feature?

ida_idp.is_align_insn(ea: ida_idaapi.ea_t) -> int
    If the instruction at 'ea' looks like an alignment instruction, return its length in bytes. Otherwise return 0. 
            

ida_idp.is_basic_block_end(insn: "insn_t const &", call_insn_stops_block: bool) -> bool
    Is the instruction the end of a basic block?

ida_idp.is_call_insn(insn: "insn_t const &") -> bool
    Is the instruction a "call"?

ida_idp.is_indirect_jump_insn(insn: "insn_t const &") -> bool
    Is the instruction an indirect jump?

ida_idp.is_ret_insn(*args) -> bool

ida_idp.num_range_t

ida_idp.num_range_t.__init__(self, _min: "int64", _max: "int64")

ida_idp.params_t

ida_idp.params_t.__init__(self, _p1: "int64", _p2: "int64")

ida_idp.parse_reg_name(ri: "reg_info_t", regname: str) -> bool
    Get register info by name. 
            
    @param ri: result
    @param regname: name of register
    @returns success

ida_idp.ph_calcrel(ea: ida_idaapi.ea_t) -> "bytevec_t *, size_t *"

ida_idp.ph_find_op_value(insn: "insn_t const &", op: int) -> "uint64 *"

ida_idp.ph_find_reg_value(insn: "insn_t const &", reg: int) -> "uint64 *"

ida_idp.ph_get_abi_info(comp: "comp_t") -> "qstrvec_t *, qstrvec_t *"

ida_idp.ph_get_cnbits()
    Returns the 'ph.cnbits'

ida_idp.ph_get_dnbits()
    Returns the 'ph.dnbits'

ida_idp.ph_get_flag()
    Returns the 'ph.flag'

ida_idp.ph_get_icode_return()
    Returns the 'ph.icode_return'

ida_idp.ph_get_id()
    Returns the 'ph.id' field

ida_idp.ph_get_instruc()
    Returns a list of tuples (instruction_name, instruction_feature) containing the
    instructions list as defined in he processor module

ida_idp.ph_get_instruc_end()
    Returns the 'ph.instruc_end'

ida_idp.ph_get_instruc_start()
    Returns the 'ph.instruc_start'

ida_idp.ph_get_operand_info(ea: ida_idaapi.ea_t, n: int) -> Union[Tuple[int, ida_idaapi.ea_t, int, int, int], None]
    Returns the operand information given an ea and operand number.
    
    @param ea: address
    @param n: operand number
    
    @return: Returns an idd_opinfo_t as a tuple: (modified, ea, reg_ival, regidx, value_size).
             Please refer to idd_opinfo_t structure in the SDK.

ida_idp.ph_get_reg_accesses(accvec: "reg_accesses_t", insn: "insn_t const &", flags: int) -> "ssize_t"

ida_idp.ph_get_reg_code_sreg()
    Returns the 'ph.reg_code_sreg'

ida_idp.ph_get_reg_data_sreg()
    Returns the 'ph.reg_data_sreg'

ida_idp.ph_get_reg_first_sreg()
    Returns the 'ph.reg_first_sreg'

ida_idp.ph_get_reg_last_sreg()
    Returns the 'ph.reg_last_sreg'

ida_idp.ph_get_regnames()
    Returns the list of register names as defined in the processor module

ida_idp.ph_get_segreg_size()
    Returns the 'ph.segreg_size'

ida_idp.ph_get_tbyte_size()
    Returns the 'ph.tbyte_size' field as defined in he processor module

ida_idp.ph_get_version()
    Returns the 'ph.version'

ida_idp.process_config_directive(directive: str, priority: int = 2) -> None

ida_idp.processor_t

ida_idp.processor_t.__idc_cvt_id__
    Base class for all processor module scripts
    
    A processor_t instance is both an ida_idp.IDP_Hooks, and an
    ida_idp.IDB_Hooks at the same time: any method of those two classes
    can be overridden in your processor_t subclass (with the exception of
    'ida_idp.IDP_Hooks.ev_init' (replaced with processor_t.__init__),
    and 'ida_idp.IDP_Hooks.ev_term' (replaced with processor_t.__del__)).

ida_idp.processor_t.__init__(self)

ida_idp.processor_t._get_idb_notifier_addr(self)

ida_idp.processor_t._get_idb_notifier_ud_addr(self)

ida_idp.processor_t._get_idp_notifier_addr(self)

ida_idp.processor_t._get_idp_notifier_ud_addr(self)

ida_idp.processor_t._get_notify(self, what, unimp_val = 0, imp_forced_val = None, add_prefix = True, mandatory_impl = None)
    This helper is used to implement backward-compatibility
    of pre IDA 7.3 processor_t interfaces.

ida_idp.processor_t._make_forced_value_wrapper(self, val, meth = None)

ida_idp.processor_t._make_forced_value_wrapper.f(*args)

ida_idp.processor_t._make_int_returning_wrapper(self, meth, intval = 0)

ida_idp.processor_t._make_int_returning_wrapper.f(*args)

ida_idp.processor_t.auto_empty(self, *args)

ida_idp.processor_t.auto_empty_finally(self, *args)

ida_idp.processor_t.closebase(self, *args)

ida_idp.processor_t.compiler_changed(self, *args)

ida_idp.processor_t.deleting_func(self, pfn)

ida_idp.processor_t.determined_main(self, *args)

ida_idp.processor_t.ev_ana_insn(self, *args)

ida_idp.processor_t.ev_assemble(self, *args)

ida_idp.processor_t.ev_auto_queue_empty(self, *args)

ida_idp.processor_t.ev_calc_step_over(self, target, ip)

ida_idp.processor_t.ev_can_have_type(self, *args)

ida_idp.processor_t.ev_cmp_operands(self, *args)

ida_idp.processor_t.ev_coagulate(self, *args)

ida_idp.processor_t.ev_coagulate_dref(self, from_ea, to_ea, may_define, _code_ea)

ida_idp.processor_t.ev_create_func_frame(self, pfn)

ida_idp.processor_t.ev_create_switch_xrefs(self, *args)

ida_idp.processor_t.ev_creating_segm(self, s)

ida_idp.processor_t.ev_emu_insn(self, *args)

ida_idp.processor_t.ev_endbinary(self, *args)

ida_idp.processor_t.ev_func_bounds(self, _possible_return_code, pfn, max_func_end_ea)

ida_idp.processor_t.ev_gen_map_file(self, nlines, fp)

ida_idp.processor_t.ev_gen_regvar_def(self, ctx, v)

ida_idp.processor_t.ev_gen_src_file_lnnum(self, *args)

ida_idp.processor_t.ev_get_autocmt(self, *args)

ida_idp.processor_t.ev_get_frame_retsize(self, frsize, pfn)

ida_idp.processor_t.ev_get_operand_string(self, buf, insn, opnum)

ida_idp.processor_t.ev_is_align_insn(self, *args)

ida_idp.processor_t.ev_is_alloca_probe(self, *args)

ida_idp.processor_t.ev_is_basic_block_end(self, *args)

ida_idp.processor_t.ev_is_call_insn(self, *args)

ida_idp.processor_t.ev_is_far_jump(self, *args)

ida_idp.processor_t.ev_is_indirect_jump(self, *args)

ida_idp.processor_t.ev_is_insn_table_jump(self, *args)

ida_idp.processor_t.ev_is_ret_insn(self, *args)

ida_idp.processor_t.ev_is_sane_insn(self, *args)

ida_idp.processor_t.ev_is_sp_based(self, mode, insn, op)

ida_idp.processor_t.ev_is_switch(self, *args)

ida_idp.processor_t.ev_may_be_func(self, *args)

ida_idp.processor_t.ev_may_show_sreg(self, *args)

ida_idp.processor_t.ev_moving_segm(self, s, to_ea, flags)

ida_idp.processor_t.ev_newbinary(self, *args)

ida_idp.processor_t.ev_newfile(self, *args)

ida_idp.processor_t.ev_newprc(self, *args)

ida_idp.processor_t.ev_oldfile(self, *args)

ida_idp.processor_t.ev_out_assumes(self, *args)

ida_idp.processor_t.ev_out_data(self, *args)

ida_idp.processor_t.ev_out_footer(self, *args)

ida_idp.processor_t.ev_out_header(self, *args)

ida_idp.processor_t.ev_out_insn(self, *args)

ida_idp.processor_t.ev_out_label(self, *args)

ida_idp.processor_t.ev_out_mnem(self, *args)

ida_idp.processor_t.ev_out_operand(self, *args)

ida_idp.processor_t.ev_out_segend(self, ctx, s)

ida_idp.processor_t.ev_out_segstart(self, ctx, s)

ida_idp.processor_t.ev_out_special_item(self, *args)

ida_idp.processor_t.ev_rename(self, *args)

ida_idp.processor_t.ev_set_idp_options(self, keyword, value_type, value, idb_loaded)

ida_idp.processor_t.ev_set_proc_options(self, *args)

ida_idp.processor_t.ev_str2reg(self, *args)

ida_idp.processor_t.ev_treat_hindering_item(self, *args)

ida_idp.processor_t.ev_undefine(self, *args)

ida_idp.processor_t.ev_validate_flirt_func(self, *args)

ida_idp.processor_t.ev_verify_noreturn(self, pfn)

ida_idp.processor_t.ev_verify_sp(self, pfn)

ida_idp.processor_t.func_added(self, pfn)

ida_idp.processor_t.get_auxpref(self, insn)
    This function returns insn.auxpref value

ida_idp.processor_t.get_idpdesc(self)
    This function must be present and should return the list of
    short processor names similar to the one in ph.psnames.
    This method can be overridden to return to the kernel a different IDP description.

ida_idp.processor_t.idasgn_loaded(self, *args)

ida_idp.processor_t.kernel_config_loaded(self, *args)

ida_idp.processor_t.make_code(self, *args)

ida_idp.processor_t.make_data(self, *args)

ida_idp.processor_t.renamed(self, *args)

ida_idp.processor_t.savebase(self, *args)

ida_idp.processor_t.segm_moved(self, from_ea, to_ea, size, changed_netmap)

ida_idp.processor_t.set_func_end(self, *args)

ida_idp.processor_t.set_func_start(self, *args)

ida_idp.processor_t.sgr_changed(self, *args)

ida_idp.reg_access_t

ida_idp.reg_access_t.__eq__(self, r: "reg_access_t") -> bool

ida_idp.reg_access_t.__init__(self)

ida_idp.reg_access_t.__ne__(self, r: "reg_access_t") -> bool

ida_idp.reg_access_t.have_common_bits(self, r: "reg_access_t") -> bool

ida_idp.reg_access_t.opnum
    operand number

ida_idp.reg_access_t.range
    bitrange inside the register

ida_idp.reg_access_t.regnum
    register number (only entire registers)

ida_idp.reg_access_vec_t

ida_idp.reg_access_vec_t.__eq__(self, r: "reg_access_vec_t") -> bool

ida_idp.reg_access_vec_t.__getitem__(self, i: "size_t") -> "reg_access_t const &"

ida_idp.reg_access_vec_t.__init__(self, *args)

ida_idp.reg_access_vec_t.__len__(self) -> "size_t"

ida_idp.reg_access_vec_t.__ne__(self, r: "reg_access_vec_t") -> bool

ida_idp.reg_access_vec_t.__setitem__(self, i: "size_t", v: "reg_access_t") -> None

ida_idp.reg_access_vec_t._del(self, x: "reg_access_t") -> bool

ida_idp.reg_access_vec_t.add_unique(self, x: "reg_access_t") -> bool

ida_idp.reg_access_vec_t.append(self, x: "reg_access_t") -> None

ida_idp.reg_access_vec_t.at(self, _idx: "size_t") -> "reg_access_t const &"

ida_idp.reg_access_vec_t.begin(self, *args) -> "qvector< reg_access_t >::const_iterator"

ida_idp.reg_access_vec_t.capacity(self) -> "size_t"

ida_idp.reg_access_vec_t.clear(self) -> None

ida_idp.reg_access_vec_t.empty(self) -> bool

ida_idp.reg_access_vec_t.end(self, *args) -> "qvector< reg_access_t >::const_iterator"

ida_idp.reg_access_vec_t.erase(self, *args) -> "qvector< reg_access_t >::iterator"

ida_idp.reg_access_vec_t.extend(self, x: "reg_access_vec_t") -> None

ida_idp.reg_access_vec_t.extract(self) -> "reg_access_t *"

ida_idp.reg_access_vec_t.find(self, *args) -> "qvector< reg_access_t >::const_iterator"

ida_idp.reg_access_vec_t.grow(self, *args) -> None

ida_idp.reg_access_vec_t.has(self, x: "reg_access_t") -> bool

ida_idp.reg_access_vec_t.inject(self, s: "reg_access_t", len: "size_t") -> None

ida_idp.reg_access_vec_t.insert(self, it: "reg_access_t", x: "reg_access_t") -> "qvector< reg_access_t >::iterator"

ida_idp.reg_access_vec_t.pop_back(self) -> None

ida_idp.reg_access_vec_t.push_back(self, *args) -> "reg_access_t &"

ida_idp.reg_access_vec_t.qclear(self) -> None

ida_idp.reg_access_vec_t.reserve(self, cnt: "size_t") -> None

ida_idp.reg_access_vec_t.resize(self, *args) -> None

ida_idp.reg_access_vec_t.size(self) -> "size_t"

ida_idp.reg_access_vec_t.swap(self, r: "reg_access_vec_t") -> None

ida_idp.reg_access_vec_t.truncate(self) -> None

ida_idp.reg_accesses_t

ida_idp.reg_accesses_t.__init__(self)

ida_idp.reg_info_t

ida_idp.reg_info_t.__eq__(self, r: "reg_info_t") -> bool

ida_idp.reg_info_t.__ge__(self, r: "reg_info_t") -> bool

ida_idp.reg_info_t.__gt__(self, r: "reg_info_t") -> bool

ida_idp.reg_info_t.__init__(self)

ida_idp.reg_info_t.__le__(self, r: "reg_info_t") -> bool

ida_idp.reg_info_t.__lt__(self, r: "reg_info_t") -> bool

ida_idp.reg_info_t.__ne__(self, r: "reg_info_t") -> bool

ida_idp.reg_info_t.compare(self, r: "reg_info_t") -> int

ida_idp.reg_info_t.reg
    register number

ida_idp.reg_info_t.size
    register size

ida_idp.register_cfgopts(opts: "cfgopt_t const []", nopts: "size_t", cb: "config_changed_cb_t *" = None, obj: "void *" = None) -> bool

ida_idp.set_processor_type(procname: str, level: "setproc_level_t") -> bool
    Set target processor type. Once a processor module is loaded, it cannot be replaced until we close the idb. 
            
    @param procname: name of processor type (one of names present in processor_t::psnames)
    @param level: SETPROC_
    @returns success

ida_idp.set_target_assembler(asmnum: int) -> bool
    Set target assembler. 
            
    @param asmnum: number of assembler in the current processor module
    @returns success

ida_idp.sizeof_ldbl() -> "size_t"

ida_idp.str2reg(p: str) -> int
    Get any register number (-1 on error)

ida_idp.str2sreg(name: str)
    get segment register number from its name or -1

ida_ieee
    IEEE floating point functions.

ida_ieee.E_SPECIAL_EXP
    Exponent in fpvalue_t for NaN and Inf.

ida_ieee.FPVAL_NWORDS
    number of words in fpvalue_t

ida_ieee.FPV_BADARG
    wrong value of max_exp

ida_ieee.FPV_NAN
    NaN.

ida_ieee.FPV_NINF
    negative infinity

ida_ieee.FPV_NORM
    regular value

ida_ieee.FPV_PINF
    positive infinity

ida_ieee.IEEE_E
    Array offset to exponent.

ida_ieee.IEEE_EXONE
    The exponent of 1.0.

ida_ieee.IEEE_M
    Array offset to high guard word 
            

ida_ieee.IEEE_NI
    Number of 16 bit words in eNI.

ida_ieee.REAL_ERROR_BADDATA
    realcvt: illegal real data for load (IEEE data not filled)

ida_ieee.REAL_ERROR_BADSTR
    asctoreal: illegal input string

ida_ieee.REAL_ERROR_FORMAT
    realcvt: not supported format for current .idp

ida_ieee.REAL_ERROR_FPOVER
    floating overflow or underflow

ida_ieee.REAL_ERROR_INTOVER
    eetol*: integer overflow

ida_ieee.REAL_ERROR_OK
    no error

ida_ieee.REAL_ERROR_RANGE
    realcvt: number too big (small) for store (mem NOT modified)

ida_ieee.REAL_ERROR_ZERODIV
    ediv: divide by 0

ida_ieee.ecleaz(x: "eNI") -> None

ida_ieee.fpvalue_shorts_array_t

ida_ieee.fpvalue_shorts_array_t.__getitem__(self, i: "size_t") -> "unsigned short const &"

ida_ieee.fpvalue_shorts_array_t.__init__(self, data: "unsigned short (&)[FPVAL_NWORDS]")

ida_ieee.fpvalue_shorts_array_t.__len__(self) -> "size_t"

ida_ieee.fpvalue_shorts_array_t.__setitem__(self, i: "size_t", v: "unsigned short const &") -> None

ida_ieee.fpvalue_shorts_array_t._get_bytes(self) -> "bytevec_t"

ida_ieee.fpvalue_shorts_array_t._set_bytes(self, bts: "bytevec_t const &") -> None

ida_ieee.fpvalue_t

ida_ieee.fpvalue_t.__add__(self, o: "fpvalue_t") -> "fpvalue_t"

ida_ieee.fpvalue_t.__eq__(self, r: "fpvalue_t") -> bool

ida_ieee.fpvalue_t.__ge__(self, r: "fpvalue_t") -> bool

ida_ieee.fpvalue_t.__getitem__(self, i)

ida_ieee.fpvalue_t.__gt__(self, r: "fpvalue_t") -> bool

ida_ieee.fpvalue_t.__init__(self, *args)

ida_ieee.fpvalue_t.__iter__(self)

ida_ieee.fpvalue_t.__le__(self, r: "fpvalue_t") -> bool

ida_ieee.fpvalue_t.__lt__(self, r: "fpvalue_t") -> bool

ida_ieee.fpvalue_t.__mul__(self, o: "fpvalue_t") -> "fpvalue_t"

ida_ieee.fpvalue_t.__ne__(self, r: "fpvalue_t") -> bool

ida_ieee.fpvalue_t.__repr__(self)

ida_ieee.fpvalue_t.__setitem__(self, i, v)

ida_ieee.fpvalue_t.__str__(self) -> str

ida_ieee.fpvalue_t.__sub__(self, o: "fpvalue_t") -> "fpvalue_t"

ida_ieee.fpvalue_t.__truediv__(self, o: "fpvalue_t") -> "fpvalue_t"

ida_ieee.fpvalue_t._get_bytes(self) -> None

ida_ieee.fpvalue_t._get_float(self) -> "double"

ida_ieee.fpvalue_t._get_shorts(self) -> "wrapped_array_t< uint16,FPVAL_NWORDS >"

ida_ieee.fpvalue_t._set_bytes(self, _in: "bytevec16_t const &") -> None

ida_ieee.fpvalue_t._set_float(self, v: "double") -> None

ida_ieee.fpvalue_t.assign(self, r: "fpvalue_t") -> None

ida_ieee.fpvalue_t.clear(self) -> None

ida_ieee.fpvalue_t.compare(self, r: "fpvalue_t") -> int

ida_ieee.fpvalue_t.copy(self) -> "fpvalue_t"

ida_ieee.fpvalue_t.eabs(self) -> None
    Calculate absolute value.

ida_ieee.fpvalue_t.fadd(self, y: "fpvalue_t") -> "fpvalue_error_t"
    Arithmetic operations.

ida_ieee.fpvalue_t.fdiv(self, y: "fpvalue_t") -> "fpvalue_error_t"

ida_ieee.fpvalue_t.fmul(self, y: "fpvalue_t") -> "fpvalue_error_t"

ida_ieee.fpvalue_t.from_10bytes(self, fpval: "void const *") -> "fpvalue_error_t"
    Conversions for 10-byte floating point values.

ida_ieee.fpvalue_t.from_12bytes(self, fpval: "void const *") -> "fpvalue_error_t"
    Conversions for 12-byte floating point values.

ida_ieee.fpvalue_t.from_int64(self, x: "int64") -> None

ida_ieee.fpvalue_t.from_str(self, p: str) -> "fpvalue_error_t"
    Convert string to IEEE. 
            

ida_ieee.fpvalue_t.from_sval(self, x: int) -> None
    Convert integer to IEEE.

ida_ieee.fpvalue_t.from_uint64(self, x: "uint64") -> None

ida_ieee.fpvalue_t.fsub(self, y: "fpvalue_t") -> "fpvalue_error_t"

ida_ieee.fpvalue_t.get_kind(self) -> "fpvalue_kind_t"
    Get value kind.

ida_ieee.fpvalue_t.is_negative(self) -> bool
    Is negative value?

ida_ieee.fpvalue_t.mul_pow2(self, power_of_2: int) -> "fpvalue_error_t"
    Multiply by a power of 2.

ida_ieee.fpvalue_t.negate(self) -> None
    Negate.

ida_ieee.fpvalue_t.new_from_str(p: str) -> "fpvalue_t"

ida_ieee.fpvalue_t.to_10bytes(self, fpval: "void *") -> "fpvalue_error_t"

ida_ieee.fpvalue_t.to_12bytes(self, fpval: "void *") -> "fpvalue_error_t"

ida_ieee.fpvalue_t.to_int64(self, round: bool = False) -> "fpvalue_error_t"

ida_ieee.fpvalue_t.to_str(self, *args) -> None
    Convert IEEE to string. 
            
    @param buf: the output buffer
    @param bufsize: the size of the output buffer
    @param mode: broken down into:
    * low byte: number of digits after '.'
    * second byte: FPNUM_LENGTH
    * third byte: FPNUM_DIGITS

ida_ieee.fpvalue_t.to_sval(self, round: bool = False) -> "fpvalue_error_t"
    Convert IEEE to integer (+-0.5 if round)

ida_ieee.fpvalue_t.to_uint64(self, round: bool = False) -> "fpvalue_error_t"

ida_kernwin
    Defines the interface between the kernel and the UI.
    
    It contains:
    * the UI dispatcher notification codes (ui_notification_t)
    * convenience functions for UI services
    * structures which hold information about the lines (disassembly, structures, enums) generated by the kernel
    * functions to interact with the user (dialog boxes)
    * some string and conversion functions. 
    
    
        

ida_kernwin.AA_CHECKABLE
    see update_action_checkable()

ida_kernwin.AA_CHECKED
    see update_action_checked()

ida_kernwin.AA_ICON
    see update_action_icon()

ida_kernwin.AA_LABEL
    see update_action_label()

ida_kernwin.AA_NONE
    no effect

ida_kernwin.AA_SHORTCUT
    see update_action_shortcut()

ida_kernwin.AA_STATE
    see update_action_state()

ida_kernwin.AA_TOOLTIP
    see update_action_tooltip()

ida_kernwin.AA_VISIBILITY
    see update_action_visibility()

ida_kernwin.ACF_HAS_FIELD_DIRTREE_SELECTION
    'dirtree_selection' field is present

ida_kernwin.ACF_HAS_SELECTION
    there is currently a valid selection

ida_kernwin.ACF_HAS_SOURCE
    'source' field is present

ida_kernwin.ACF_HAS_TYPE_REF
    'type_ref' field is present

ida_kernwin.ACF_XTRN_EA
    cur_ea is in 'externs' segment

ida_kernwin.ADF_CHECKABLE
    action is checkable

ida_kernwin.ADF_CHECKED
    starts in a checked state (requires ADF_CHECKABLE)

ida_kernwin.ADF_GLOBAL
    Register the action globally, so that it's available even if no IDB is present 
            

ida_kernwin.ADF_NO_HIGHLIGHT
    After activating, do not update the highlight according to what's under the cursor (listings only.) 
            

ida_kernwin.ADF_NO_UNDO
    the action does not create an undo point. useful for actions that do not modify the database. 
            

ida_kernwin.ADF_OT_MASK
    Owner type mask.

ida_kernwin.ADF_OT_PLUGIN
    Owner is a plugin_t.

ida_kernwin.ADF_OT_PLUGMOD
    Owner is a plugmod_t.

ida_kernwin.ADF_OT_PROCMOD
    Owner is a procmod_t.

ida_kernwin.ADF_OWN_HANDLER
    handler is owned by the action; it'll be destroyed when the action is unregistered. Use DYNACTION_DESC_LITERAL to set this bit. 
            

ida_kernwin.AHF_VERSION
    action handler version (used by action_handler_t::flags)

ida_kernwin.AHF_VERSION_MASK
    mask for action_handler_t::flags

ida_kernwin.ASKBTN_BTN1
    First (Yes) button.

ida_kernwin.ASKBTN_BTN2
    Second (No) button.

ida_kernwin.ASKBTN_BTN3
    Third (Cancel) button.

ida_kernwin.ASKBTN_CANCEL
    Cancel button.

ida_kernwin.ASKBTN_NO
    No button.

ida_kernwin.ASKBTN_YES
    Yes button.

ida_kernwin.AST_DISABLE
    analog of AST_ENABLE

ida_kernwin.AST_DISABLE_ALWAYS
    disable action and do not call action_handler_t::action() anymore

ida_kernwin.AST_DISABLE_FOR_IDB
    analog of AST_ENABLE_FOR_IDB

ida_kernwin.AST_DISABLE_FOR_WIDGET
    analog of AST_ENABLE_FOR_WIDGET

ida_kernwin.AST_ENABLE
    enable action - call action_handler_t::update() when anything changes

ida_kernwin.AST_ENABLE_ALWAYS
    enable action and do not call action_handler_t::update() anymore

ida_kernwin.AST_ENABLE_FOR_IDB
    enable action for the current idb. call action_handler_t::update() when a database is opened/closed 
              

ida_kernwin.AST_ENABLE_FOR_WIDGET
    enable action for the current widget. call action_handler_t::update() when a widget gets/loses focus 
              

ida_kernwin.BWN_ADDRWATCH
    the 'Watch List' window

ida_kernwin.BWN_BOOKMARKS
    a persistent 'Bookmarks' widget

ida_kernwin.BWN_BPTS
    breakpoints

ida_kernwin.BWN_CALLS
    function calls

ida_kernwin.BWN_CALLS_CALLEES
    function calls, callees

ida_kernwin.BWN_CALLS_CALLERS
    function calls, callers

ida_kernwin.BWN_CALL_STACK
    call stack

ida_kernwin.BWN_CHOOSER
    a non-builtin chooser

ida_kernwin.BWN_CLI
    the command-line, in the output window

ida_kernwin.BWN_CMDPALCSR
    the command palette chooser (Qt version only)

ida_kernwin.BWN_CMDPALWIN
    the command palette window (Qt version only)

ida_kernwin.BWN_CPUREGS
    one of the 'General registers', 'FPU register', ... debugger windows

ida_kernwin.BWN_CUSTVIEW
    custom viewers

ida_kernwin.BWN_CV_LINE_INFOS
    custom viewers' lineinfo widget

ida_kernwin.BWN_DISASM
    disassembly views

ida_kernwin.BWN_DISASM_ARROWS
    disassembly arrows widget

ida_kernwin.BWN_EXPORTS
    exports

ida_kernwin.BWN_FRAME
    function frame

ida_kernwin.BWN_FUNCS
    functions

ida_kernwin.BWN_HEXVIEW
    hex view

ida_kernwin.BWN_IMPORTS
    imports

ida_kernwin.BWN_LOCALS
    the 'locals' debugger window

ida_kernwin.BWN_MDVIEWCSR
    lumina metadata view chooser

ida_kernwin.BWN_MODULES
    modules

ida_kernwin.BWN_NAMES
    names

ida_kernwin.BWN_NAVBAND
    navigation band

ida_kernwin.BWN_NOTEPAD
    notepad

ida_kernwin.BWN_OUTPUT
    the text area, in the output window

ida_kernwin.BWN_PROBS
    problems

ida_kernwin.BWN_PSEUDOCODE
    hexrays decompiler views

ida_kernwin.BWN_SCRIPTS_CSR
    the "Recent scripts" chooser

ida_kernwin.BWN_SEARCH
    search results

ida_kernwin.BWN_SEGREGS
    segment registers

ida_kernwin.BWN_SEGS
    segments

ida_kernwin.BWN_SELS
    selectors

ida_kernwin.BWN_SHORTCUTCSR
    the shortcuts chooser (Qt version only)

ida_kernwin.BWN_SHORTCUTWIN
    the shortcuts window (Qt version only)

ida_kernwin.BWN_SIGNS
    signatures

ida_kernwin.BWN_SNIPPETS
    the 'Execute script' window

ida_kernwin.BWN_SNIPPETS_CSR
    the list of snippets in the 'Execute script' window

ida_kernwin.BWN_SO_OFFSETS
    the 'Structure offsets' dialog's offset panel

ida_kernwin.BWN_SO_STRUCTS
    the 'Structure offsets' dialog's 'Structures and Unions' panel

ida_kernwin.BWN_SRCPTHMAP_CSR
    "Source paths..."'s path mappings chooser

ida_kernwin.BWN_SRCPTHUND_CSR
    "Source paths..."'s undesired paths chooser

ida_kernwin.BWN_STKVIEW
    the 'Stack view' debugger window

ida_kernwin.BWN_STRINGS
    strings

ida_kernwin.BWN_THREADS
    threads

ida_kernwin.BWN_TICSR
    type library widget's (e.g., "Local types") chooser

ida_kernwin.BWN_TILIST
    a type listing widget

ida_kernwin.BWN_TILS
    type libraries

ida_kernwin.BWN_TIL_VIEW
    a type library's toplevel widget

ida_kernwin.BWN_TRACE
    tracing view

ida_kernwin.BWN_UNDOHIST
    Undo history.

ida_kernwin.BWN_UNKNOWN
    unknown window

ida_kernwin.BWN_WATCH
    the 'watches' debugger window

ida_kernwin.BWN_XREFS
    xrefs

ida_kernwin.CDVF_LINEICONS
    icons can be drawn over the line control

ida_kernwin.CDVF_NOLINES
    don't show line numbers

ida_kernwin.CDVF_STATUSBAR
    keep the status bar in the custom viewer

ida_kernwin.CDVH_LINES_ALIGNMENT
    see set_code_viewer_lines_alignment()

ida_kernwin.CDVH_LINES_CLICK
    see code_viewer_lines_click_t

ida_kernwin.CDVH_LINES_DBLCLICK
    see code_viewer_lines_click_t

ida_kernwin.CDVH_LINES_DRAWICON
    see code_viewer_lines_icon_t

ida_kernwin.CDVH_LINES_ICONMARGIN
    see set_code_viewer_lines_icon_margin()

ida_kernwin.CDVH_LINES_LINENUM
    see code_viewer_lines_linenum_t

ida_kernwin.CDVH_LINES_POPUP
    see code_viewer_lines_click_t

ida_kernwin.CDVH_LINES_RADIX
    see set_code_viewer_lines_radix()

ida_kernwin.CDVH_SRCVIEW
    see set_code_viewer_is_source()

ida_kernwin.CDVH_USERDATA
    see set_code_viewer_user_data()

ida_kernwin.CH2_LAZY_LOADED
    The chooser is lazy-loaded; it receives the callback do_lazy_load_dir() (only meaningful when CH_HAS_DIRTREE is set) 
            

ida_kernwin.CHCOL_DEC
    decimal number

ida_kernwin.CHCOL_DEFHIDDEN
    column should be hidden by default

ida_kernwin.CHCOL_DRAGHINT
    the column number that will be used to build hints for the dragging undo label. This should be provided for at most one column for any given chooser. 
            

ida_kernwin.CHCOL_EA
    address

ida_kernwin.CHCOL_FNAME
    function name. If a chooser column has this flag set and implements chooser_base_t::get_ea(), rows background colors will be automatically set to match the navigator's "Library function", "Lumina function" and "External symbol" colors 
            

ida_kernwin.CHCOL_FORMAT
    column format mask

ida_kernwin.CHCOL_HEX
    hexadecimal number

ida_kernwin.CHCOL_INODENAME
    if CH_HAS_DIRTREE has been specified, this instructs the chooser that this column shows the inode name. This should be provided for at most one column for any given chooser. 
            

ida_kernwin.CHCOL_PATH
    file path. TUI IDA will truncate excessive cell lengths starting at their beginning, and prepending the resulting text with "..." order to leave the filename visible 
            

ida_kernwin.CHCOL_PLAIN
    plain string

ida_kernwin.CHITEM_BOLD
    display the item in bold

ida_kernwin.CHITEM_GRAY
    gray out the item

ida_kernwin.CHITEM_ITALIC
    display the item in italic

ida_kernwin.CHITEM_STRIKE
    strikeout the item

ida_kernwin.CHITEM_UNDER
    underline the item

ida_kernwin.CHOOSER_NOMAINMENU
    do not display main menu

ida_kernwin.CHOOSER_NOSTATUSBAR
    do not display status bar (obsolete. Use CH_NO_STATUS_BAR instead)

ida_kernwin.CH_ATTRS
    generate ui_get_chooser_item_attrs (gui only)

ida_kernwin.CH_BUILTIN_MASK
    Mask for builtin chooser numbers. Plugins should not use them.

ida_kernwin.CH_CAN_DEL
    allow to delete existing item(s)

ida_kernwin.CH_CAN_EDIT
    allow to edit existing item(s)

ida_kernwin.CH_CAN_INS
    allow to insert new items

ida_kernwin.CH_CAN_REFRESH
    allow to refresh chooser

ida_kernwin.CH_FORCE_DEFAULT
    if a non-modal chooser was already open, change selection to the default one 
            

ida_kernwin.CH_HAS_DIFF
    The chooser can be used in a diffing/merging workflow.

ida_kernwin.CH_HAS_DIRTREE
    The chooser can provide a dirtree_t, meaning a tree-like structure can be provided to the user (instead of a flat table) 
            

ida_kernwin.CH_KEEP
    The chooser instance's lifecycle is not tied to the lifecycle of the widget showing its contents. Closing the widget will not destroy the chooser structure. This allows for, e.g., static global chooser instances that don't need to be allocated on the heap. Also stack-allocated chooser instances must set this bit. 
            

ida_kernwin.CH_MODAL
    Modal chooser.

ida_kernwin.CH_MULTI
    The chooser will allow multi-selection (only for GUI choosers). This bit is set when using the chooser_multi_t structure. 
            

ida_kernwin.CH_MULTI_EDIT
    Obsolete.

ida_kernwin.CH_NOBTNS
    do not display ok/cancel/help/search buttons. Meaningful only for gui modal windows because non-modal windows do not have any buttons anyway. Text mode does not have them neither. 
            

ida_kernwin.CH_NON_PERSISTED_TREE
    the chooser tree is not persisted (it is not loaded on startup and is not saved on exit) 
            

ida_kernwin.CH_NO_FILTER
    The chooser will not have filtering abilities.

ida_kernwin.CH_NO_SORT
    The chooser will not have sorting abilities.

ida_kernwin.CH_NO_STATUS_BAR
    don't show a status bar

ida_kernwin.CH_QFLT
    open with quick filter enabled and focused

ida_kernwin.CH_QFTYP_DEFAULT
    set quick filtering type to the possible existing default for this chooser

ida_kernwin.CH_QFTYP_FUZZY
    fuzzy search quick filter type

ida_kernwin.CH_QFTYP_NORMAL
    normal (i.e., lexicographical) quick filter type

ida_kernwin.CH_QFTYP_REGEX
    regex quick filter type

ida_kernwin.CH_QFTYP_WHOLE_WORDS
    whole words quick filter type

ida_kernwin.CH_RENAME_IS_EDIT
    triggering a 'edit/rename' (i.e., F2 shortcut) on a cell, should call the edit() callback for the corresponding row. 
            

ida_kernwin.CH_RESTORE
    restore floating position if present (equivalent of WOPN_RESTORE) (GUI version only)

ida_kernwin.CH_TM_FOLDERS_ONLY
    chooser will show in folders-only mode

ida_kernwin.CH_TM_FULL_TREE
    chooser will show in full-tree mode

ida_kernwin.CH_TM_NO_TREE
    chooser will show in no-tree mode

ida_kernwin.CK_EXTRA1
    extra background overlay #1

ida_kernwin.CK_EXTRA10
    extra background overlay #10

ida_kernwin.CK_EXTRA11
    extra background overlay #11

ida_kernwin.CK_EXTRA12
    extra background overlay #12

ida_kernwin.CK_EXTRA13
    extra background overlay #13

ida_kernwin.CK_EXTRA14
    extra background overlay #14

ida_kernwin.CK_EXTRA15
    extra background overlay #15

ida_kernwin.CK_EXTRA16
    extra background overlay #16

ida_kernwin.CK_EXTRA2
    extra background overlay #2

ida_kernwin.CK_EXTRA3
    extra background overlay #3

ida_kernwin.CK_EXTRA4
    extra background overlay #4

ida_kernwin.CK_EXTRA5
    extra background overlay #5

ida_kernwin.CK_EXTRA6
    extra background overlay #6

ida_kernwin.CK_EXTRA7
    extra background overlay #7

ida_kernwin.CK_EXTRA8
    extra background overlay #8

ida_kernwin.CK_EXTRA9
    extra background overlay #9

ida_kernwin.CK_TRACE
    traced address

ida_kernwin.CK_TRACE_OVL
    overlay trace address

ida_kernwin.CLNL_FINDCMT
    Search for the comment symbol everywhere in the line, not only at the beginning.

ida_kernwin.CLNL_LTRIM
    Remove leading space characters.

ida_kernwin.CLNL_RTRIM
    Remove trailing space characters.

ida_kernwin.CREATETB_ADV
    toolbar is for 'advanced mode' only

ida_kernwin.CVH_CLICK
    see custom_viewer_click_t

ida_kernwin.CVH_CLOSE
    see custom_viewer_close_t

ida_kernwin.CVH_CURPOS
    see custom_viewer_curpos_t

ida_kernwin.CVH_DBLCLICK
    see custom_viewer_dblclick_t

ida_kernwin.CVH_HELP
    see custom_viewer_help_t

ida_kernwin.CVH_KEYDOWN
    see custom_viewer_keydown_t

ida_kernwin.CVH_MOUSEMOVE
    see custom_viewer_mouse_moved_t

ida_kernwin.CVH_POPUP
    see custom_viewer_popup_t

ida_kernwin.CVH_QT_AWARE
    see set_custom_viewer_qt_aware()

ida_kernwin.CVLF_USE_MOUSE
    Fetch the location from the mouse, instead of caret in the listing.

ida_kernwin.CVNF_ACT
    activate (i.e., switch to) the viewer. Activation is performed before the new lochist_entry_t instance is actually copied to the viewer's lochist_t (otherwise, if the viewer was invisible its on_location_changed() handler wouldn't be called.) 
            

ida_kernwin.CVNF_JUMP
    push the current position in this viewer's lochist_t before going to the new location 
            

ida_kernwin.CVNF_LAZY
    try and move the cursor to a line displaying the place_t if possible. This might disregard the Y position in case of success 
            

ida_kernwin.Choose
    The chooser can be used in a diffing/merging workflow

ida_kernwin.Choose.ALREADY_EXISTS
    the non-modal chooser with the same data is already open

ida_kernwin.Choose.Activate(self)
    Activates a visible chooser

ida_kernwin.Choose.AddCommand(self, caption, flags = _ida_kernwin.CHOOSER_POPUP_MENU, menu_index = -1, icon = -1, emb = None, shortcut = None)

ida_kernwin.Choose.CHCOL_DEC
    decimal number

ida_kernwin.Choose.CHCOL_DEFHIDDEN
    column should be hidden by default

ida_kernwin.Choose.CHCOL_DRAGHINT
    the column number that will be used to build hints for the dragging undo label. This should be provided for at most one column for any given chooser. 
            

ida_kernwin.Choose.CHCOL_EA
    address

ida_kernwin.Choose.CHCOL_FNAME
    function name. If a chooser column has this flag set and implements chooser_base_t::get_ea(), rows background colors will be automatically set to match the navigator's "Library function", "Lumina function" and "External symbol" colors 
            

ida_kernwin.Choose.CHCOL_FORMAT
    column format mask

ida_kernwin.Choose.CHCOL_HEX
    hexadecimal number

ida_kernwin.Choose.CHCOL_INODENAME
    if CH_HAS_DIRTREE has been specified, this instructs the chooser that this column shows the inode name. This should be provided for at most one column for any given chooser. 
            

ida_kernwin.Choose.CHCOL_PATH
    file path. TUI IDA will truncate excessive cell lengths starting at their beginning, and prepending the resulting text with "..." order to leave the filename visible 
            

ida_kernwin.Choose.CHCOL_PLAIN
    plain string

ida_kernwin.Choose.CH_ATTRS
    generate ui_get_chooser_item_attrs (gui only)

ida_kernwin.Choose.CH_BUILTIN_MASK
    Mask for builtin chooser numbers. Plugins should not use them.

ida_kernwin.Choose.CH_CAN_DEL
    allow to delete existing item(s)

ida_kernwin.Choose.CH_CAN_EDIT
    allow to edit existing item(s)

ida_kernwin.Choose.CH_CAN_INS
    allow to insert new items

ida_kernwin.Choose.CH_CAN_REFRESH
    allow to refresh chooser

ida_kernwin.Choose.CH_FORCE_DEFAULT
    if a non-modal chooser was already open, change selection to the default one 
            

ida_kernwin.Choose.CH_HAS_DIFF
    The chooser can be used in a diffing/merging workflow.

ida_kernwin.Choose.CH_HAS_DIRTREE
    The chooser can provide a dirtree_t, meaning a tree-like structure can be provided to the user (instead of a flat table) 
            

ida_kernwin.Choose.CH_MODAL
    Modal chooser.

ida_kernwin.Choose.CH_MULTI
    The chooser will allow multi-selection (only for GUI choosers). This bit is set when using the chooser_multi_t structure. 
            

ida_kernwin.Choose.CH_NOBTNS
    do not display ok/cancel/help/search buttons. Meaningful only for gui modal windows because non-modal windows do not have any buttons anyway. Text mode does not have them neither. 
            

ida_kernwin.Choose.CH_NOIDB
    use the chooser even without an open database, same as x0=-2

ida_kernwin.Choose.CH_NO_STATUS_BAR
    don't show a status bar

ida_kernwin.Choose.CH_QFLT
    open with quick filter enabled and focused

ida_kernwin.Choose.CH_QFTYP_DEFAULT
    set quick filtering type to the possible existing default for this chooser

ida_kernwin.Choose.CH_QFTYP_FUZZY
    fuzzy search quick filter type

ida_kernwin.Choose.CH_QFTYP_NORMAL
    normal (i.e., lexicographical) quick filter type

ida_kernwin.Choose.CH_QFTYP_REGEX
    regex quick filter type

ida_kernwin.Choose.CH_QFTYP_WHOLE_WORDS
    whole words quick filter type

ida_kernwin.Choose.CH_RENAME_IS_EDIT
    triggering a 'edit/rename' (i.e., F2 shortcut) on a cell, should call the edit() callback for the corresponding row. 
            

ida_kernwin.Choose.CH_RESTORE
    restore floating position if present (equivalent of WOPN_RESTORE) (GUI version only)

ida_kernwin.Choose.Close(self)
    Closes the chooser

ida_kernwin.Choose.EMPTY_CHOOSER
    the chooser is initialized

ida_kernwin.Choose.Embedded(self, create_chobj = False)
    Creates an embedded chooser (as opposed to Show())
    @return: Returns 0 on success or NO_ATTR

ida_kernwin.Choose.GetEmbSelection(self)
    Deprecated. For embedded choosers, the selection is
    available through 'Form.EmbeddedChooserControl.selection'

ida_kernwin.Choose.GetWidget(self)
    Return the TWidget underlying this view.
    
    @return: The TWidget underlying this view, or None.

ida_kernwin.Choose.NO_ATTR
    some mandatory attribute is missing

ida_kernwin.Choose.NO_SELECTION
    there is no selected item

ida_kernwin.Choose.OnClose(self)
    The chooser window is closed.

ida_kernwin.Choose.OnDeleteLine(self, sel)
    User deleted an element
    
    @param sel the current selection
    @return a tuple (changed, selection)

ida_kernwin.Choose.OnEditLine(self, sel)
    User asked to edit an element.
    
    @param sel the current selection
    @return a tuple (changed, selection)

ida_kernwin.Choose.OnGetDirTree(self)
    Get the dirtree_t that will be used to present a tree-like
    structure to the user (see CH_HAS_DIRTREE)
    
    @return the dirtree_t, or None

ida_kernwin.Choose.OnGetEA(self, n)
    Get the address of an element
    
    When this function returns valid addresses:
      * If any column has the `CHCOL_FNAME` flag, rows will
        be colored according to the attributes of the functions
        who own those addresses (extern, library function,
        Lumina, ... - similar to what the "Functions" widget does)
      * When a selection is present and the user presses `<Enter>`
        (`<Shift+Enter>` if the chooser is modal), IDA will jump
        to that address (through jumpto())
    @param n element number (0-based)
    @return the effective address, ida_idaapi.BADADDR if the element has no address

ida_kernwin.Choose.OnGetIcon(self, n)
    Get an icon to associate with the first cell of an element
    
    @param n index of the element
    @return an icon ID

ida_kernwin.Choose.OnGetLine(self, n)
    Get data for an element
    
    This callback is mandatory
    
    @param n the index to fetch data for
    @return a list of strings

ida_kernwin.Choose.OnGetLineAttr(self, n)
    Get attributes for an element
    
    @param n index of the element
    @return a tuple (color, flags)

ida_kernwin.Choose.OnGetSize(self)
    Get the number of elements in the chooser.
    
    This callback is mandatory
    
    @return the number of elements

ida_kernwin.Choose.OnIndexToDiffpos(self, n)
    Map an element index to a diffpos_t
    
    This callback is mandatory if CH_HAS_DIFF is specified
    
    @param n index of the element
    @return the diffpos

ida_kernwin.Choose.OnIndexToInode(self, n)
    Map an element index to a dirtree_t inode
    
    This callback is mandatory if CH_HAS_DIRTREE is specified
    
    @param n index of the element
    @return the inode number

ida_kernwin.Choose.OnInit(self)
    Initialize the chooser and populate it.
    
    This callback is optional

ida_kernwin.Choose.OnInsertLine(self, sel)
    User asked to insert an element
    
    @param sel the current selection
    @return a tuple (changed, selection)

ida_kernwin.Choose.OnLazyLoadDir(self, path)
    Callback for lazy-loaded, dirtree-based choosers;
    the function will be called when a folder is expanded and it has
    not been loaded before. The implementation should use the
    given dirtree's link() or mkdir() methods to add the folder contents.
    
    @param path an absolute dirtree path to the directory that is being expanded
    @return success

ida_kernwin.Choose.OnPopup(self, widget, popup_handle)

ida_kernwin.Choose.OnRefresh(self, sel)
    The chooser needs to be refreshed.
    It returns the new positions of the selected items.
    
    @param sel the current selection
    @return a tuple (changed, selection)

ida_kernwin.Choose.OnSelectLine(self, sel)
    User pressed the enter key, or double-clicked a selection
    
    @param sel the current selection
    @return a tuple (changed, selection)

ida_kernwin.Choose.OnSelectionChange(self, sel)
    Selection changed
    
    @param sel the new selection

ida_kernwin.Choose.Refresh(self)
    Causes the refresh callback to trigger

ida_kernwin.Choose.Show(self, modal = False)
    Activates or creates a chooser window
    @param modal: Display as modal dialog
    @return: For all choosers it will return NO_ATTR if some mandatory
             attribute is missing. The mandatory attributes are: flags,
             title, cols, OnGetSize(), OnGetLine();
             For modal choosers it will return the selected item index (0-based),
             or NO_SELECTION if no selection,
             or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
             For non-modal choosers it will return 0
             or ALREADY_EXISTS if the chooser was already open and is active now;

ida_kernwin.Choose.UI_Hooks_Trampoline

ida_kernwin.Choose.UI_Hooks_Trampoline.__init__(self, v)

ida_kernwin.Choose.UI_Hooks_Trampoline.populating_widget_popup(self, widget, popup_handle)

ida_kernwin.Choose.__init__(self, title, cols, flags = 0, popup_names = None, icon = -1, x1 = -1, y1 = -1, x2 = -1, y2 = -1, deflt = None, embedded = False, width = None, height = None, forbidden_cb = 0, flags2 = 0)
    Constructs a chooser window.
    @param title: The chooser title
    @param cols: a list of colums; each list item is a list of two items
        example: [ ["Address", 10 | Choose.CHCOL_HEX],
                   ["Name",    30 | Choose.CHCOL_PLAIN] ]
    @param flags: One of CH_XXXX constants
    @param flags2: One of CH2_XXXX constants
    @param deflt: The index of the default item (0-based) for single
        selection choosers or the list of indexes for multi selection
        chooser
    @param popup_names: List of new captions to replace this list
        ["Insert", "Delete", "Edit", "Refresh"]
    @param icon: Icon index (the icon should exist in ida resources or
        an index to a custom loaded icon)
    @param x1, y1, x2, y2: The default location (for txt-version)
    @param embedded: Create as embedded chooser
    @param width: Embedded chooser width
    @param height: Embedded chooser height
    @param forbidden_cb: Explicitly forbidden callbacks

ida_kernwin.Choose.__init__._qccb(ctx, cmd_id)

ida_kernwin.Choose.adjust_last_item(self, n)
    Helper for OnDeleteLine() and OnRefresh() callbacks.
    They can be finished by the following line:
    return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
    @param: line number of the remaining select item
    @return: list of selected lines numbers (one element or empty)

ida_kernwin.CustomIDAMemo

ida_kernwin.CustomIDAMemo.CreateGroups(self, groups_infos)
    Send a request to modify the graph by creating a
    (set of) group(s), and perform an animation.
    
    Each object in the 'groups_infos' list must be of the format:
    {
      "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
      "text" : <string>                    # The synthetic text for that group
    }
    
    @param groups_infos: A list of objects that describe those groups.
    @return: A [<int>, <int>, ...] list of group nodes, or None (failure).

ida_kernwin.CustomIDAMemo.DelNodesInfos(self, *nodes)
    Delete the properties for the given node(s).
    
    @param nodes: A list of node IDs

ida_kernwin.CustomIDAMemo.DeleteGroups(self, groups, new_current = -1)
    Send a request to delete the specified groups in the graph,
    and perform an animation.
    
    @param groups: A list of group node numbers.
    @param new_current: A node to focus on after the groups have been deleted
    @return: True on success, False otherwise.

ida_kernwin.CustomIDAMemo.GetCurrentRendererType(self)

ida_kernwin.CustomIDAMemo.GetNodeInfo(self, *args)
    Get the properties for the given node.
    
    @param ni: A node_info_t instance
    @param node: The index of the node.
    @return: success

ida_kernwin.CustomIDAMemo.GetWidget(self)
    Return the TWidget underlying this view.
    
    @return: The TWidget underlying this view, or None.

ida_kernwin.CustomIDAMemo.GetWidgetAsGraphViewer(self)
    Return the graph_viewer_t underlying this view.
    
    @return: The graph_viewer_t underlying this view, or None.

ida_kernwin.CustomIDAMemo.Refresh(self)
    Refreshes the view. This causes the OnRefresh() to be called

ida_kernwin.CustomIDAMemo.SetCurrentRendererType(self, rtype)
    Set the current view's renderer.
    
    @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.

ida_kernwin.CustomIDAMemo.SetGroupsVisibility(self, groups, expand, new_current = -1)
    Send a request to expand/collapse the specified groups in the graph,
    and perform an animation.
    
    @param groups: A list of group node numbers.
    @param expand: True to expand the group, False otherwise.
    @param new_current: A node to focus on after the groups have been expanded/collapsed.
    @return: True on success, False otherwise.

ida_kernwin.CustomIDAMemo.SetNodeInfo(self, node_index, node_info, flags)
    Set the properties for the given node.
    
    Example usage (set second nodes's bg color to red):
      inst = ...
      p = idaapi.node_info_t()
      p.bg_color = 0x00ff0000
      inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
    
    @param node_index: The node index.
    @param node_info: An idaapi.node_info_t instance.
    @param flags: An OR'ed value of NIF_* values.

ida_kernwin.CustomIDAMemo.SetNodesInfos(self, values)
    Set the properties for the given nodes.
    
    Example usage (set first three nodes's bg color to purple):
      inst = ...
      p = idaapi.node_info_t()
      p.bg_color = 0x00ff00ff
      inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
    
    @param values: A dictionary of 'int -> node_info_t' objects.

ida_kernwin.CustomIDAMemo._OnBind(self, hook)

ida_kernwin.CustomIDAMemo.__init__(self)

ida_kernwin.CustomIDAMemo._dummy_cb(*args)

ida_kernwin.CustomIDAMemo._get_cb(self, view, cb_name)

ida_kernwin.CustomIDAMemo._get_cb_arity(self, cb)

ida_kernwin.CustomIDAMemo._graph_item_tuple(self, ve)

ida_kernwin.CustomIDAMemo.view_activated(self, view)

ida_kernwin.CustomIDAMemo.view_click(self, view, ve)

ida_kernwin.CustomIDAMemo.view_close(self, view, *args)

ida_kernwin.CustomIDAMemo.view_curpos(self, view, *args)

ida_kernwin.CustomIDAMemo.view_dblclick(self, view, ve)

ida_kernwin.CustomIDAMemo.view_deactivated(self, view)

ida_kernwin.CustomIDAMemo.view_keydown(self, view, key, state)

ida_kernwin.CustomIDAMemo.view_loc_changed(self, view, now, was)

ida_kernwin.CustomIDAMemo.view_mouse_moved(self, view, ve)

ida_kernwin.CustomIDAMemo.view_mouse_over(self, view, ve)

ida_kernwin.CustomIDAMemo.view_switched(self, view, rt)

ida_kernwin.DP_BEFORE
    Place src_form before dst_form in the tab bar instead of after; used with DP_INSIDE or DP_TAB. 
            

ida_kernwin.DP_BOTTOM
    Dock src_form below dest_form.

ida_kernwin.DP_FLOATING
    Make src_form floating.

ida_kernwin.DP_INSIDE
    Create a new tab bar with both src_form and dest_form.

ida_kernwin.DP_LEFT
    Dock src_form to the left of dest_form.

ida_kernwin.DP_RIGHT
    Dock src_form to the right of dest_form.

ida_kernwin.DP_SZHINT
    When floating or in a splitter (i.e., not tabbed), use the widget's size hint to determine the best geometry (Qt only) 
            

ida_kernwin.DP_TAB
    Place src_form into a tab next to dest_form, if dest_form is in a tab bar (otherwise the same as DP_INSIDE) 
            

ida_kernwin.DP_TOP
    Dock src_form above dest_form.

ida_kernwin.Form

ida_kernwin.Form.Add(self, name, ctrl, mkattr = True)
    Low level function. Prefer AddControls() to this function.
    This function adds one control to the form.
    
    @param name: Control name
    @param ctrl: Control object
    @param mkattr: Create control name / control object as a form attribute

ida_kernwin.Form.AddControls(self, controls, mkattr = True)
    Adds controls from a dictionary.
    The dictionary key is the control name and the value is a Form.Control object
    @param controls: The control dictionary

ida_kernwin.Form.ButtonInput
    Button control.
    A handler along with a 'code' (numeric value) can be associated with the button.
    This way one handler can handle many buttons based on the button code (or in other terms id or tag)

ida_kernwin.Form.ButtonInput.__init__(self, handler, code = "", swidth = "", hlp = None)
    @param handler: Button handler. A callback taking one argument which is the code.
    @param code: A code associated with the button and that is later passed to the handler.

ida_kernwin.Form.ButtonInput.helper_cb(self, button_code, p_fa)

ida_kernwin.Form.ButtonInput.is_input_field(self)

ida_kernwin.Form.ChkGroupControl
    Checkbox group control class.
    It holds a set of checkbox controls

ida_kernwin.Form.ChkGroupControl.ItemClass
    Group control item factory class instance
    We need this because later we won't be treating ChkGroupControl or RadGroupControl
    individually, instead we will be working with GroupControl in general.

ida_kernwin.Form.ChkGroupControl.__init__(self, children_names, value = 0, secondary = False)

ida_kernwin.Form.ChkGroupItemControl
    Checkbox group item control

ida_kernwin.Form.ChkGroupItemControl.__get_value(self)

ida_kernwin.Form.ChkGroupItemControl.__init__(self, tag, parent)

ida_kernwin.Form.ChkGroupItemControl.__set_value(self, v)

ida_kernwin.Form.ChkGroupItemControl.checked
    Get/Sets checkbox item check status

ida_kernwin.Form.Close(self, close_normally)
    Close the form
    @param close_normally:
               1: form is closed normally as if the user pressed Enter
               0: form is closed abnormally as if the user pressed Esc
    @return: None

ida_kernwin.Form.ColorInput
    Color button input control

ida_kernwin.Form.ColorInput.__init__(self, value = 0)
    @param value: Initial color value in RGB

ida_kernwin.Form.Compile(self)
    Compiles a form and returns the form object (self) and the argument list.
    The form object will contain object names corresponding to the form elements
    
    @return: It will raise an exception on failure. Otherwise the return value is ignored

ida_kernwin.Form.CompileEx(self, form)
    Low level function.
    Compiles (parses the form syntax and adds the control) the form string and
    returns the argument list to be passed the argument list to ask_form().
    
    The form controls are wrapped inside curly braces: {ControlName}.
    
    A special operator can be used to return the index of a given control by its name: {id:ControlName}.
    This is useful when you use the STARTITEM form keyword to set the initially focused control.
    (note that, technically, the index is not the same as the ID; that's because STARTITEM
    uses raw, 0-based indexes rather than control IDs to determine the focused widget.)
    
    @param form: Compiles the form and returns the arguments needed to be passed to ask_form()

ida_kernwin.Form.CompileEx.next_control(form, p, first_pass)

ida_kernwin.Form.Compiled(self)
    Checks if the form has already been compiled
    
    @return: Boolean

ida_kernwin.Form.Control

ida_kernwin.Form.Control.__init__(self)
    Reference to the parent form. It is filled by Form.Add()

ida_kernwin.Form.Control.free(self)
    Free the control

ida_kernwin.Form.Control.get_arg(self)
    Control returns the parameter to be pushed on the stack
    (Of ask_form())

ida_kernwin.Form.Control.get_tag(self)
    Control tag character. One of Form.FT_XXXX.
    The form class will expand the {} notation and replace them with the tags

ida_kernwin.Form.Control.is_input_field(self)
    Return True if this field acts as an input

ida_kernwin.Form.ControlToFieldTypeIdAndSize(ctrl)
    Converts a control object to a tuple containing the field id
    and the associated buffer size

ida_kernwin.Form.DirInput
    Directory browsing control

ida_kernwin.Form.DirInput.__init__(self, width = 512, swidth = 80, hlp = None, value = None)

ida_kernwin.Form.DropdownListControl
    Dropdown control
    This control allows manipulating a dropdown control

ida_kernwin.Form.DropdownListControl.__get_selval(self)

ida_kernwin.Form.DropdownListControl.__init__(self, items = [], readonly = True, selval = 0, width = 50, swidth = 50, hlp = None)
    @param items: A string list of items used to prepopulate the control
    @param readonly: Specifies whether the dropdown list is editable or not
    @param selval: The preselected item index (when readonly) or text value (when editable)
    @param width: the control width (n/a if the dropdown list is readonly)
    @param swidth: string width

ida_kernwin.Form.DropdownListControl.__set_selval(self, val)

ida_kernwin.Form.DropdownListControl.free(self)

ida_kernwin.Form.DropdownListControl.selval
    Read/write the selection value.
    The value is used as an item index in readonly mode or text value in editable mode
    This value can be used only after the form has been closed.

ida_kernwin.Form.DropdownListControl.set_items(self, items)
    Sets the dropdown list items

ida_kernwin.Form.EmbeddedChooserControl
    Embedded chooser control.
    This control links to a Chooser2 control created with the 'embedded=True'

ida_kernwin.Form.EmbeddedChooserControl.__get_selection__(self)

ida_kernwin.Form.EmbeddedChooserControl.__init__(self, chooser = None, swidth = 40, hlp = None)
    Embedded chooser control
    
    @param chooser: A chooser2 instance (must be constructed with 'embedded=True')

ida_kernwin.Form.EmbeddedChooserControl.free(self)
    Frees the embedded chooser data

ida_kernwin.Form.EmbeddedChooserControl.selection
    Returns the selection

ida_kernwin.Form.EmbeddedChooserControl.value
    Returns the embedded chooser instance

ida_kernwin.Form.EnableField(self, ctrl, enable)
    Enable or disable an input field
    @return: False - no such control

ida_kernwin.Form.Execute(self)
    Displays a modal dialog containing the compiled form.
    @return: 1 - ok ; 0 - cancel

ida_kernwin.Form.FT_ADDR
    Address - ea_t *

ida_kernwin.Form.FT_ASCII
    Ascii string - char *

ida_kernwin.Form.FT_BIN
    Binary number, 0b prefix - sval_t *

ida_kernwin.Form.FT_BUTTON
    Button - def handler(code)

ida_kernwin.Form.FT_CHAR
    Char value -- sval_t *

ida_kernwin.Form.FT_COLOR
    Color button - bgcolor_t *

ida_kernwin.Form.FT_DEC
    Decimal number - sval_t *

ida_kernwin.Form.FT_DIR
    Path to directory - char * at least QMAXPATH

ida_kernwin.Form.FT_DROPDOWN_LIST
    Dropdown list control - Form.DropdownControl

ida_kernwin.Form.FT_ECHOOSER
    Embedded chooser - idaapi.Choose

ida_kernwin.Form.FT_FILE
    File browse - char * at least QMAXPATH

ida_kernwin.Form.FT_FORMCHG
    Form change callback - formchgcb_t

ida_kernwin.Form.FT_HEX
    Hex number - uval_t *

ida_kernwin.Form.FT_HTML_LABEL
    HTML label to display (only for GUI version, and for dynamic labels; no input)

ida_kernwin.Form.FT_IDENT
    Identifier - char * at least MAXNAMELEN

ida_kernwin.Form.FT_INT64
    default base int64 - int64

ida_kernwin.Form.FT_MULTI_LINE_TEXT
    Multi text control - textctrl_info_t

ida_kernwin.Form.FT_OCT
    Octal number, C notation - sval_t *

ida_kernwin.Form.FT_RAWHEX
    Hex number, no 0x prefix - uval_t *

ida_kernwin.Form.FT_SEG
    Segment - sel_t *

ida_kernwin.Form.FT_SHEX
    Signed hex number - sval_t *

ida_kernwin.Form.FT_TYPE
    Type declaration - char * at least MAXSTR

ida_kernwin.Form.FT_UINT64
    default base uint64 - uint64

ida_kernwin.Form.FileInput
    File Open/Save input control

ida_kernwin.Form.FileInput.__init__(self, width = 512, swidth = 80, save = False, open = False, hlp = None, value = None)

ida_kernwin.Form.FindControlById(self, id)
    Finds a control instance given its id

ida_kernwin.Form.FormChangeCb
    Form change handler.
    This can be thought of like a dialog procedure.
    Everytime a form action occurs, this handler will be called along with the control id.
    The programmer can then call various form actions accordingly:
      - EnableField
      - ShowField
      - MoveField
      - GetFieldValue
      - etc...
    
    Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)

ida_kernwin.Form.FormChangeCb.__init__(self, handler)
    Constructs the handler.
    @param handler: The handler (preferrably a member function of a class derived from the Form class).

ida_kernwin.Form.FormChangeCb.free(self)

ida_kernwin.Form.FormChangeCb.get_tag(self)

ida_kernwin.Form.FormChangeCb.helper_cb(self, fid, p_fa)

ida_kernwin.Form.Free(self)
    Frees all resources associated with a compiled form.
    Make sure you call this function when you finish using the form.

ida_kernwin.Form.GetControlValue(self, ctrl)
    Returns the control's value depending on its type
    @param ctrl: Form control instance
    @return:
        - color button, radio controls: integer
        - file/dir input, string input and string label: string
        - embedded chooser control (0-based indices of selected items): integer list
        - for multilinetext control: textctrl_info_t
        - dropdown list controls: string (when editable) or index (when readonly)
        - None: on failure

ida_kernwin.Form.GetFocusedField(self)
    Get currently focused input field.
    @return: None if no field is selected otherwise the control ID

ida_kernwin.Form.GroupControl
    Base class for group controls

ida_kernwin.Form.GroupControl.__init__(self, children_names, tag, value = 0)

ida_kernwin.Form.GroupControl._reset(self)

ida_kernwin.Form.GroupControl.get_tag(self)

ida_kernwin.Form.GroupControl.next_child_pos(self)

ida_kernwin.Form.GroupItemControl
    Base class for group control items

ida_kernwin.Form.GroupItemControl.__init__(self, tag, parent)

ida_kernwin.Form.GroupItemControl.assign_pos(self)

ida_kernwin.Form.GroupItemControl.get_tag(self)

ida_kernwin.Form.GroupItemControl.is_input_field(self)

ida_kernwin.Form.InputControl
    Generic form input control.
    It could be numeric control, string control, directory/file browsing, etc...

ida_kernwin.Form.InputControl.__init__(self, tp, width, swidth, hlp = None, is_relative_offset = False)
    @param width:  The maximum possible number of characters that
                   can be entered into the input field
    @param swidth: The width of visible part of the input field

ida_kernwin.Form.InputControl.get_tag(self)

ida_kernwin.Form.InputControl.is_input_field(self)

ida_kernwin.Form.LabelControl
    Base class for static label control

ida_kernwin.Form.LabelControl.__init__(self, tp)

ida_kernwin.Form.LabelControl.get_tag(self)

ida_kernwin.Form.MoveField(self, ctrl, x, y, w, h)
    Move/resize an input field
    
    @return: False - no such fiel

ida_kernwin.Form.MultiLineTextControl
    Multi line text control.
    This class inherits from textctrl_info_t. Thus the attributes are also inherited
    This control allows manipulating a multilinetext control

ida_kernwin.Form.MultiLineTextControl.__init__(self, text = "", flags = 0, tabsize = 0, width = 50, swidth = 50, hlp = None)
    @param text: Initial text value
    @param flags: One of textctrl_info_t.TXTF_.... values
    @param tabsize: Tab size
    @param width: Display width
    @param swidth: String width

ida_kernwin.Form.MultiLineTextControl.free(self)

ida_kernwin.Form.NumericArgument
    Argument representing various integer arguments (ushort, uint32, uint64, etc...)
    @param tp: One of Form.FT_XXX

ida_kernwin.Form.NumericArgument.__init__(self, tp, value, i64 = None)

ida_kernwin.Form.NumericArgument.__set_value(self, v)

ida_kernwin.Form.NumericInput
    A composite class serving as a base numeric input control class

ida_kernwin.Form.NumericInput.__init__(self, tp = None, value = 0, width = 50, swidth = 10, hlp = None, is_relative_offset = False, i64 = None)

ida_kernwin.Form.NumericLabel
    Numeric label control

ida_kernwin.Form.NumericLabel.__init__(self, value, tp = None)

ida_kernwin.Form.Open(self)
    Opens a widget containing the compiled form.

ida_kernwin.Form.RadGroupControl
    Radiobox group control class.
    It holds a set of radiobox controls

ida_kernwin.Form.RadGroupControl.__init__(self, children_names, value = 0, secondary = False)
    Creates a radiogroup control.
    @param children_names: A tuple containing group item names
    @param value: Initial selected radio item
    @param secondory: Allows rendering one the same line as the previous group control.
                      Use this if you have another group control on the same line.

ida_kernwin.Form.RadGroupItemControl
    Radiobox group item control

ida_kernwin.Form.RadGroupItemControl.__get_value(self)

ida_kernwin.Form.RadGroupItemControl.__init__(self, tag, parent)

ida_kernwin.Form.RadGroupItemControl.__set_value(self, v)

ida_kernwin.Form.RadGroupItemControl.selected
    Get/Sets radiobox item selection status

ida_kernwin.Form.RefreshField(self, ctrl)
    Refresh a field
    @return: False - no such control

ida_kernwin.Form.SetControlValue(self, ctrl, value)
    Set the control's value depending on its type
    @param ctrl: Form control instance
    @param value:
        - embedded chooser: a 0-base indices list to select embedded chooser items
        - multilinetext: a textctrl_info_t
        - dropdown list: an integer designating the selection index if readonly
                         a string designating the edit control value if not readonly
    @return: Boolean true on success

ida_kernwin.Form.SetFocusedField(self, ctrl)
    Set currently focused input field
    @return: False - no such control

ida_kernwin.Form.ShowField(self, ctrl, show)
    Show or hide an input field
    @return: False - no such control

ida_kernwin.Form.StringArgument
    Argument representing a character buffer

ida_kernwin.Form.StringArgument.__get_value(self)

ida_kernwin.Form.StringArgument.__init__(self, size = None, value = None)

ida_kernwin.Form.StringArgument.__set_value(self, v)

ida_kernwin.Form.StringInput
    Base string input control class.
    This class also constructs a StringArgument

ida_kernwin.Form.StringInput.__init__(self, tp = None, width = ida_pro.MAXSTR, swidth = 40, hlp = None, value = None, size = None)
    @param width: String size. But in some cases it has special meaning. For example in FileInput control.
                  If you want to define the string buffer size then pass the 'size' argument
    @param swidth: Control width
    @param value: Initial value
    @param size: String size

ida_kernwin.Form.StringLabel
    String label control

ida_kernwin.Form.StringLabel.__init__(self, value, tp = None, size = ida_pro.MAXSTR)
    Type field can be one of:
    A - ascii string
    T - type declaration
    I - ident
    F - folder
    f - file
    X - command

ida_kernwin.Form._AddGroup(self, Group, mkattr = True)
    Internal function.
    This function expands the group item names and creates individual group item controls
    
    @param Group: The group class (checkbox or radio group class)

ida_kernwin.Form._ChkCompiled(self)

ida_kernwin.Form._FT_USHORT
    Unsigned short

ida_kernwin.Form._ParseFormTitle(form)
    Parses the form's title from the form text

ida_kernwin.Form.__getitem__(self, name)
    Returns a control object by name

ida_kernwin.Form.__init__(self, form, controls)
    If non-modal, these flags will be passed to open_form.
    This is an OR'ed combination of the PluginForm.FORM_* values.

ida_kernwin.Form._reset(self)
    Resets the Form class state variables

ida_kernwin.Form.create_string_buffer(value, size = None)

ida_kernwin.Form.fieldtype_to_ctype(tp, i64 = False)
    Factory method returning a ctype class corresponding to the field type string

ida_kernwin.GCRF_ALL
    Return all rows.

ida_kernwin.GCRF_CURRENT
    Return the current row.

ida_kernwin.GCRF_HEADER
    Return header texts.

ida_kernwin.GCRF_SELECTION
    Return selected rows.

ida_kernwin.HIF_IDENTIFIER
    text is an identifier (i.e., when searching for the current highlight, SEARCH_IDENT will be used)

ida_kernwin.HIF_LOCKED
    locked; clicking/moving the cursor around doesn't change the highlight

ida_kernwin.HIF_NOCASE
    case insensitive

ida_kernwin.HIF_REGISTER
    text represents a register (aliases/subregisters will be highlit as well)

ida_kernwin.HIF_SLOT_0
    operate on slot 0

ida_kernwin.HIF_SLOT_1
    operate on slot 1

ida_kernwin.HIF_SLOT_2
    operate on slot 2

ida_kernwin.HIF_SLOT_3
    operate on slot 3

ida_kernwin.HIF_SLOT_4
    operate on slot 4

ida_kernwin.HIF_SLOT_5
    operate on slot 5

ida_kernwin.HIF_SLOT_6
    operate on slot 6

ida_kernwin.HIF_SLOT_7
    operate on slot 7

ida_kernwin.HIF_SLOT_SHIFT
    position of the 3 top bits specifying which highlight to use

ida_kernwin.HIF_USE_SLOT
    use the given number, or just use the "floating" highlight

ida_kernwin.HIST_CMD
    commands

ida_kernwin.HIST_CMT
    comments

ida_kernwin.HIST_DIR
    directory names (text version only)

ida_kernwin.HIST_FILE
    file names

ida_kernwin.HIST_IDENT
    identifiers. usually CPU register names are forbidden

ida_kernwin.HIST_IDENT2
    identifiers, including CPU register names

ida_kernwin.HIST_SEG
    segment names

ida_kernwin.HIST_SRCH
    search substrings

ida_kernwin.HIST_TYPE
    type declarations

ida_kernwin.IDAViewWrapper
    Deprecated. Use View_Hooks instead.
    
    Because the lifecycle of an IDAView is not trivial to track (e.g., a user
    might close, then re-open the same disassembly view), this wrapper doesn't
    bring anything superior to the View_Hooks: quite the contrary, as the
    latter is much more generic (and better maps IDA's internal model.)

ida_kernwin.IDAViewWrapper.Bind(self)

ida_kernwin.IDAViewWrapper.Unbind(self)

ida_kernwin.IDAViewWrapper.__init__(self, title)

ida_kernwin.IDA_DEBUG_ACCESSIBILITY
    accessibility

ida_kernwin.IDA_DEBUG_ALREADY
    already data or code

ida_kernwin.IDA_DEBUG_ALWAYS
    everything

ida_kernwin.IDA_DEBUG_APPCALL
    appcall

ida_kernwin.IDA_DEBUG_CHECKMEM
    check heap consistency

ida_kernwin.IDA_DEBUG_CONFIG
    config file

ida_kernwin.IDA_DEBUG_DBGINFO
    handling of debug info (e.g. pdb, dwarf)

ida_kernwin.IDA_DEBUG_DEBUGGER
    debugger

ida_kernwin.IDA_DEBUG_DEMANGLE
    demangler

ida_kernwin.IDA_DEBUG_DREFS
    drefs

ida_kernwin.IDA_DEBUG_FLIRT
    flirt

ida_kernwin.IDA_DEBUG_IDP
    idp module

ida_kernwin.IDA_DEBUG_IDS
    ids files

ida_kernwin.IDA_DEBUG_INTERNET
    internet connection (for API backward compatibility)

ida_kernwin.IDA_DEBUG_LDR
    ldr module

ida_kernwin.IDA_DEBUG_LICENSE
    licensing

ida_kernwin.IDA_DEBUG_LUMINA
    lumina related

ida_kernwin.IDA_DEBUG_NETWORK
    network

ida_kernwin.IDA_DEBUG_NOTIFY
    show all notifications

ida_kernwin.IDA_DEBUG_OFFSET
    offsets

ida_kernwin.IDA_DEBUG_PLUGIN
    plugin module

ida_kernwin.IDA_DEBUG_QUEUE
    queue

ida_kernwin.IDA_DEBUG_RANGECB
    range-based entities like segments, functions and so on

ida_kernwin.IDA_DEBUG_REGEX
    regular expression

ida_kernwin.IDA_DEBUG_ROLLBACK
    rollback

ida_kernwin.IDA_DEBUG_SIMPLEX
    full stack analysis

ida_kernwin.IDA_DEBUG_SRCDBG
    source debugging

ida_kernwin.IDA_DEBUG_SUBPROC
    sub process

ida_kernwin.IDA_DEBUG_THEMES
    themes

ida_kernwin.IDA_DEBUG_TIL
    type system

ida_kernwin.IDCHK_ARG
    bad argument(s)

ida_kernwin.IDCHK_KEY
    bad hotkey name

ida_kernwin.IDCHK_MAX
    too many IDC hotkeys

ida_kernwin.IDCHK_OK
    ok

ida_kernwin.IWID_ADDRWATCH
    address watches

ida_kernwin.IWID_ALL
    mask

ida_kernwin.IWID_ANY_LISTING
    anything that uses a listing widget

ida_kernwin.IWID_BOOKMARKS
    bookmarks list

ida_kernwin.IWID_BPTS
    breakpoints

ida_kernwin.IWID_CALLS
    function calls

ida_kernwin.IWID_CALLS_CALLEES
    funcalls, callees

ida_kernwin.IWID_CALLS_CALLERS
    funcalls, callers

ida_kernwin.IWID_CALL_STACK
    call stack

ida_kernwin.IWID_CHOOSER
    chooser

ida_kernwin.IWID_CLI
    input line

ida_kernwin.IWID_CMDPALCSR
    command palette

ida_kernwin.IWID_CMDPALWIN
    command palette

ida_kernwin.IWID_CPUREGS
    registers

ida_kernwin.IWID_CUSTVIEW
    custom viewers

ida_kernwin.IWID_CV_LINE_INFOS
    lineinfo widget

ida_kernwin.IWID_DISASM
    disassembly views

ida_kernwin.IWID_DISASM_ARROWS
    arrows widget

ida_kernwin.IWID_EA_LISTING
    anything that can be used to represent data/code at an address

ida_kernwin.IWID_EXPORTS
    exports

ida_kernwin.IWID_FRAME
    function frame

ida_kernwin.IWID_FUNCS
    functions

ida_kernwin.IWID_HEXVIEW
    hex views

ida_kernwin.IWID_IMPORTS
    imports

ida_kernwin.IWID_LOCALS
    locals

ida_kernwin.IWID_MDVIEWCSR
    lumina md view

ida_kernwin.IWID_MODULES
    modules

ida_kernwin.IWID_NAMES
    names

ida_kernwin.IWID_NAVBAND
    navigation band

ida_kernwin.IWID_NOTEPAD
    notepad

ida_kernwin.IWID_OUTPUT
    output

ida_kernwin.IWID_PROBS
    problems

ida_kernwin.IWID_PSEUDOCODE
    decompiler

ida_kernwin.IWID_SCRIPTS_CSR
    recent scripts

ida_kernwin.IWID_SEARCH
    search results

ida_kernwin.IWID_SEGREGS
    segment registers

ida_kernwin.IWID_SEGS
    segments

ida_kernwin.IWID_SELS
    selectors

ida_kernwin.IWID_SHORTCUTCSR
    shortcuts chooser

ida_kernwin.IWID_SHORTCUTWIN
    shortcuts window

ida_kernwin.IWID_SIGNS
    signatures

ida_kernwin.IWID_SNIPPETS
    snippets

ida_kernwin.IWID_SNIPPETS_CSR
    snippets chooser

ida_kernwin.IWID_SO_OFFSETS
    stroff

ida_kernwin.IWID_SO_STRUCTS
    stroff

ida_kernwin.IWID_SRCPTHMAP_CSR
    mappings chooser

ida_kernwin.IWID_SRCPTHUND_CSR
    undesired chooser

ida_kernwin.IWID_STKVIEW
    stack view

ida_kernwin.IWID_STRINGS
    strings

ida_kernwin.IWID_THREADS
    threads

ida_kernwin.IWID_TICSR
    type library widget's (e.g., "Local types") chooser

ida_kernwin.IWID_TILIST
    type listing

ida_kernwin.IWID_TILS
    type libraries

ida_kernwin.IWID_TIL_VIEW
    type library's toplevel widget

ida_kernwin.IWID_TRACE
    tracing view

ida_kernwin.IWID_UNDOHIST
    Undo history.

ida_kernwin.IWID_WATCH
    watches

ida_kernwin.IWID_XREFS
    xrefs

ida_kernwin.LROEF_CPS_RANGE
    background for range of chars

ida_kernwin.LROEF_FULL_LINE
    full line background

ida_kernwin.MFF_FAST
    Execute code as soon as possible. this mode is ok for calling ui related functions that do not query the database. 
            

ida_kernwin.MFF_NOWAIT
    Do not wait for the request to be executed. the caller should ensure that the request is not destroyed until the execution completes. if not, the request will be ignored. the request must be created using the 'new' operator to use it with this flag. it can be used in cancel_exec_request(). This flag can be used to delay the code execution until the next UI loop run even from the main thread. 
            

ida_kernwin.MFF_READ
    Execute code only when ida is idle and it is safe to query the database. This mode is recommended only for code that does not modify the database. (nb: ida may be in the middle of executing another user request, for example it may be waiting for him to enter values into a modal dialog box) 
            

ida_kernwin.MFF_WRITE
    Execute code only when ida is idle and it is safe to modify the database. in particular, this flag will suspend execution if there is a modal dialog box on the screen. this mode can be used to call any ida api function. MFF_WRITE implies MFF_READ 
            

ida_kernwin.PCF_EA_CAPABLE
    toea() implementation returns meaningful data

ida_kernwin.PCF_MAKEPLACE_ALLOCATES
    makeplace() returns a freshly allocated (i.e., non-static) instance. All new code should pass that flag to register_place_class(), and the corresponding makeplace() class implementation should return new instances. 
            

ida_kernwin.PluginForm
    This flag should be used when Close() is called from an event handler

ida_kernwin.PluginForm.Close(self, options)
    Closes the form.
    
    @param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)
    
    @return: None

ida_kernwin.PluginForm.GetWidget(self)
    Return the TWidget underlying this view.
    
    @return: The TWidget underlying this view, or None.

ida_kernwin.PluginForm.OnClose(self, form)
    Called when the plugin form is closed
    
    @return: None

ida_kernwin.PluginForm.OnCreate(self, form)
    This event is called when the plugin form is created.
    The programmer should populate the form when this event is triggered.
    
    @return: None

ida_kernwin.PluginForm.QtWidgetToTWidget(w, ctx = sys.modules["__main__"])
    Convert a QWidget to a TWidget* to be used by IDA
    
    @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules

ida_kernwin.PluginForm.Show(self, caption, options = 0)
    Creates the form if not was not created or brings to front if it was already created
    
    @param caption: The form caption
    @param options: One of PluginForm.WOPN_ constants

ida_kernwin.PluginForm.WCLS_DELETE_LATER
    assign the deletion of the widget to the UI loop ///<

ida_kernwin.PluginForm.WCLS_DONT_SAVE_SIZE
    don't save size of the window

ida_kernwin.PluginForm.WCLS_NO_CONTEXT
    don't change the current context (useful for toolbars)

ida_kernwin.PluginForm.WCLS_SAVE
    save state in desktop config

ida_kernwin.PluginForm.WOPN_DP_BEFORE
    Place widget before dst_form in the tab bar instead of after; used with WOPN_DP_INSIDE and WOPN_DP_TAB 
            

ida_kernwin.PluginForm.WOPN_DP_BOTTOM
    Dock widget below dest_ctrl.

ida_kernwin.PluginForm.WOPN_DP_FLOATING
    Make widget floating.

ida_kernwin.PluginForm.WOPN_DP_INSIDE
    Create a new tab bar with both widget and dest_ctrl.

ida_kernwin.PluginForm.WOPN_DP_LEFT
    Dock widget to the left of dest_ctrl.

ida_kernwin.PluginForm.WOPN_DP_RIGHT
    Dock widget to the right of dest_ctrl.

ida_kernwin.PluginForm.WOPN_DP_SZHINT
    when floating or in a splitter (i.e., not tabbed), use the widget's size hint to determine the best geometry (Qt only) 
            

ida_kernwin.PluginForm.WOPN_DP_TAB
    Place widget into a tab next to dest_ctrl, if dest_ctrl is in a tab bar (otherwise the same as WOPN_DP_INSIDE) 
            

ida_kernwin.PluginForm.WOPN_DP_TOP
    Dock widget above dest_ctrl.

ida_kernwin.PluginForm.WOPN_PERSIST
    widget will remain available when starting or stopping debugger sessions

ida_kernwin.PluginForm.WOPN_RESTORE
    if the widget was the only widget in a floating area the last time it was closed, it will be restored as floating, with the same position+size as before 
            

ida_kernwin.PluginForm.__init__(self)
            

ida_kernwin.PluginForm._ensure_widget_deps(ctx)

ida_kernwin.RENADDR_HR
    dialog for "Pseudocode"; additional flags:
    * 0x01 Library function
    * 0x02 Mark as decompiled 
    
    
            

ida_kernwin.RENADDR_IDA
    dialog for "IDA View"

ida_kernwin.S2EAOPT_NOCALC
    don't try to interpret string as IDC (or current extlang) expression

ida_kernwin.SETMENU_APP
    add menu item after the specified path

ida_kernwin.SETMENU_ENSURE_SEP
    make sure there is a separator before the action

ida_kernwin.SETMENU_FIRST
    add item to the beginning of menu

ida_kernwin.SETMENU_INS
    add menu item before the specified path (default)

ida_kernwin.SVF_COPY_LINES
    keep a local copy of '*lines'

ida_kernwin.SVF_LINES_BYPTR
    remember the 'lines' ptr. do not make a copy of '*lines'

ida_kernwin.TCCPT_IDAPLACE
    idaplace_t

ida_kernwin.TCCPT_INVALID
    invalid

ida_kernwin.TCCPT_PLACE
    place_t

ida_kernwin.TCCPT_SIMPLELINE_PLACE
    simpleline_place_t

ida_kernwin.TCCPT_TIPLACE
    tiplace_t

ida_kernwin.TCCRT_FLAT
    flat view

ida_kernwin.TCCRT_GRAPH
    graph view

ida_kernwin.TCCRT_INVALID
    invalid

ida_kernwin.TCCRT_PROXIMITY
    proximity view

ida_kernwin.TWidget__from_ptrval__(ptrval: "size_t") -> "TWidget *"

ida_kernwin.UIJMP_ACTIVATE
    activate the new window

ida_kernwin.UIJMP_ANYVIEW
    jump in any ea_t-capable view

ida_kernwin.UIJMP_DONTPUSH
    do not remember the current address in the navigation history 
            

ida_kernwin.UIJMP_IDAVIEW
    jump in idaview

ida_kernwin.UIJMP_IDAVIEW_NEW
    jump in new idaview

ida_kernwin.UI_Hooks

ida_kernwin.UI_Hooks.__disown__(self)

ida_kernwin.UI_Hooks.__init__(self, _flags: int = 0, _hkcb_flags: int = 1)

ida_kernwin.UI_Hooks.create_desktop_widget(self, title: str, cfg: "jobj_wrapper_t") -> "PyObject *"
    create a widget, to be placed in the widget tree (at desktop-creation time.) 
              
    @param title: (const char *)
    @param cfg: (const jobj_t *)
    @returns TWidget * the created widget, or null

ida_kernwin.UI_Hooks.current_widget_changed(self, widget: "TWidget *", prev_widget: "TWidget *") -> None
    The currently-active TWidget changed. 
              
    @param widget: (TWidget *)
    @param prev_widget: (TWidget *)
    @returns void

ida_kernwin.UI_Hooks.database_closed(self) -> None
    The database has been closed. See also processor_t::closebase, it occurs earlier. See also ui_initing_database. This is not the same as IDA exiting. If you need to perform cleanup at the exiting time, use qatexit(). 
              
    @returns void

ida_kernwin.UI_Hooks.database_inited(self, is_new_database: int, idc_script: str) -> None
    database initialization has completed. the kernel is about to run idc scripts 
              
    @param is_new_database: (int)
    @param idc_script: (const char *) - may be nullptr
    @returns void See also ui_initing_database. This event is called for both new and old databases.

ida_kernwin.UI_Hooks.debugger_menu_change(self, enable: bool) -> None
    debugger menu modification detected 
              
    @param enable: (bool) true: debugger menu has been added, or a different debugger has been selected false: debugger menu will be removed (user switched to "No debugger")
    @returns void

ida_kernwin.UI_Hooks.desktop_applied(self, name: str, from_idb: bool, type: int) -> None
    a desktop has been applied 
              
    @param name: (const char *) the desktop name
    @param from_idb: (bool) the desktop was stored in the IDB (false if it comes from the registry)
    @param type: (int) the desktop type (1-disassembly, 2-debugger, 3-merge)

ida_kernwin.UI_Hooks.destroying_plugmod(self, plugmod: "plugmod_t", entry: "plugin_t const *") -> None
    The plugin object is about to be destroyed 
              
    @param plugmod: (const plugmod_t *)
    @param entry: (const plugin_t *)

ida_kernwin.UI_Hooks.destroying_procmod(self, procmod: "procmod_t") -> None
    The processor module is about to be destroyed 
              
    @param procmod: (const procmod_t *)

ida_kernwin.UI_Hooks.finish_populating_widget_popup(self, widget: "TWidget *", popup_handle: "TPopupMenu *", ctx: "action_ctx_base_t" = None) -> None
    IDA is about to be done populating the context menu for a widget. This is your chance to attach_action_to_popup().
    
    @param widget: (TWidget *)
    @param popup_handle: (TPopupMenu *)
    @param ctx: (const action_activation_ctx_t *)
    @returns void

ida_kernwin.UI_Hooks.get_chooser_item_attrs(self, chooser: "chooser_base_t", n: "size_t", attrs: "chooser_item_attrs_t") -> None
    get item-specific attributes for a chooser. This callback is generated only after enable_chooser_attrs() 
              
    @param chooser: (const chooser_base_t *)
    @param n: (::size_t)
    @param attrs: (chooser_item_attrs_t *)
    @returns void

ida_kernwin.UI_Hooks.get_custom_viewer_hint(self, viewer: "TWidget *", place: "place_t") -> "PyObject *"
    ui wants to display a hint for a viewer (idaview or custom). Every subscriber is supposed to append the hint lines to HINT and increment IMPORTANT_LINES accordingly. Completely overwriting the existing lines in HINT is possible but not recommended. If the REG_HINTS_MARKER sequence is found in the returned hints string, it will be replaced with the contents of the "regular" hints. If the SRCDBG_HINTS_MARKER sequence is found in the returned hints string, it will be replaced with the contents of the source-level debugger-generated hints. The following keywords might appear at the beginning of the returned hints: HIGHLIGHT text
     where text will be highlighted CAPTION caption
     caption for the hint widget 
              
    @param viewer: (TWidget*) viewer
    @param place: (place_t *) current position in the viewer
    @retval 0: continue collecting hints with other subscribers
    @retval 1: stop collecting hints

ida_kernwin.UI_Hooks.get_ea_hint(self, ea: ida_idaapi.ea_t) -> "PyObject *"
    ui wants to display a simple hint for an address. Use this event to generate a custom hint See also more generic ui_get_item_hint 
              
    @param ea: (::ea_t)
    @returns true if generated a hint

ida_kernwin.UI_Hooks.get_item_hint(self, ea: ida_idaapi.ea_t, max_lines: int) -> "PyObject *"
    ui wants to display multiline hint for an item. See also more generic ui_get_custom_viewer_hint 
              
    @param ea: (ea_t) or item id like a structure or enum member
    @param max_lines: (int) maximal number of lines
    @returns true if generated a hint

ida_kernwin.UI_Hooks.get_lines_rendering_info(self, out: "lines_rendering_output_t", widget: "TWidget const *", info: "lines_rendering_input_t") -> None
    get lines rendering information 
              
    @param out: (lines_rendering_output_t *)
    @param widget: (const TWidget *)
    @param info: (const lines_rendering_input_t *)
    @returns void

ida_kernwin.UI_Hooks.get_widget_config(self, widget: "TWidget const *", cfg: "jobj_t *") -> "PyObject *"
    retrieve the widget configuration (it will be passed back at ui_create_desktop_widget-, and ui_set_widget_config-time) 
              
    @param widget: (const TWidget *)
    @param cfg: (jobj_t *)
    @returns void

ida_kernwin.UI_Hooks.hook(self) -> bool

ida_kernwin.UI_Hooks.idcstart(self) -> None
    Start of IDC engine work. 
              
    @returns void

ida_kernwin.UI_Hooks.idcstop(self) -> None
    Stop of IDC engine work. 
              
    @returns void

ida_kernwin.UI_Hooks.initing_database(self) -> None
    database initialization has started. 
              
    @returns void See also ui_database_inited. This event is called for both new and old databases.

ida_kernwin.UI_Hooks.plugin_loaded(self, plugin_info: "plugin_info_t const *") -> None
    The plugin was loaded in memory. 
              
    @param plugin_info: (const plugin_info_t *)

ida_kernwin.UI_Hooks.plugin_unloading(self, plugin_info: "plugin_info_t const *") -> None
    The plugin is about to be unloaded 
              
    @param plugin_info: (const plugin_info_t *)

ida_kernwin.UI_Hooks.populating_widget_popup(self, widget: "TWidget *", popup_handle: "TPopupMenu *", ctx: "action_ctx_base_t" = None) -> None
    IDA is populating the context menu for a widget. This is your chance to attach_action_to_popup().
    Have a look at ui_finish_populating_widget_popup, if you want to augment the context menu with your own actions after the menu has had a chance to be properly populated by the owning component or plugin (which typically does it on ui_populating_widget_popup.)
    
    @param widget: (TWidget *)
    @param popup_handle: (TPopupMenu *)
    @param ctx: (const action_activation_ctx_t *)
    @returns void

ida_kernwin.UI_Hooks.postprocess_action(self) -> None
    an ida ui action has been handled

ida_kernwin.UI_Hooks.preprocess_action(self, name: str) -> int
    ida ui is about to handle a user action. 
              
    @param name: (const char *) ui action name. these names can be looked up in ida[tg]ui.cfg
    @retval 0: ok
    @retval nonzero: a plugin has handled the command

ida_kernwin.UI_Hooks.range(self) -> None
    The disassembly range has been changed ( idainfo::min_ea ... idainfo::max_ea). UI should redraw the scrollbars. See also: ui_lock_range_refresh 
              
    @returns void

ida_kernwin.UI_Hooks.ready_to_run(self) -> None
    all UI elements have been initialized. Automatic plugins may hook to this event to perform their tasks. 
              
    @returns void

ida_kernwin.UI_Hooks.resume(self) -> None
    Resume the suspended graphical interface. Only the text version. Interface should respond to it 
              
    @returns void

ida_kernwin.UI_Hooks.saved(self, path: str) -> None
    The kernel has saved the database. This callback just informs the interface. Note that at the time this notification is sent, the internal paths are not updated yet, and calling get_path(PATH_TYPE_IDB) will return the previous path. 
              
    @param path: (const char *) the database path
    @returns void

ida_kernwin.UI_Hooks.saving(self) -> None
    The kernel is flushing its buffers to the disk. The user interface should save its state. Parameters: none Returns: none 
              

ida_kernwin.UI_Hooks.screen_ea_changed(self, ea: ida_idaapi.ea_t, prev_ea: ida_idaapi.ea_t) -> None
    The "current address" changed 
              
    @param ea: (ea_t)
    @param prev_ea: (ea_t)
    @returns void

ida_kernwin.UI_Hooks.set_widget_config(self, widget: "TWidget const *", cfg: "jobj_wrapper_t") -> None
    set the widget configuration 
              
    @param widget: (const TWidget *)
    @param cfg: (const jobj_t *)
    @returns void

ida_kernwin.UI_Hooks.suspend(self) -> None
    Suspend graphical interface. Only the text version. Interface should respond to it. 
              
    @returns void

ida_kernwin.UI_Hooks.unhook(self) -> bool

ida_kernwin.UI_Hooks.updated_actions(self) -> None
    IDA is done updating actions. 
              
    @returns void

ida_kernwin.UI_Hooks.updating_actions(self, ctx: "action_ctx_base_t") -> None
    IDA is about to update all actions. If your plugin needs to perform expensive operations more than once (e.g., once per action it registers), you should do them only once, right away. 
              
    @param ctx: (action_update_ctx_t *)
    @returns void

ida_kernwin.UI_Hooks.widget_closing(self, widget: "TWidget *") -> None
    TWidget is about to close. This event precedes ui_widget_invisible. Use this to perform some possible actions relevant to the lifecycle of this widget 
              
    @param widget: (TWidget *)
    @returns void

ida_kernwin.UI_Hooks.widget_invisible(self, widget: "TWidget *") -> None
    TWidget is being closed. Use this event to destroy the window controls 
              
    @param widget: (TWidget *)
    @returns void

ida_kernwin.UI_Hooks.widget_visible(self, widget: "TWidget *") -> None
    TWidget is displayed on the screen. Use this event to populate the window with controls 
              
    @param widget: (TWidget *)
    @returns void

ida_kernwin.VES_SHIFT
    state & 1 => Shift is pressed 
    state & 2 => Alt is pressed 
    state & 4 => Ctrl is pressed 
    state & 8 => Mouse left button is pressed 
    state & 16 => Mouse right button is pressed 
    state & 32 => Mouse middle button is pressed 
    state & 128 => Meta is pressed (OSX only) 
            

ida_kernwin.VME_LEFT_BUTTON
    left mouse button

ida_kernwin.VME_MID_BUTTON
    middle mouse button

ida_kernwin.VME_RIGHT_BUTTON
    right mouse button

ida_kernwin.VME_UNKNOWN
    unknown mouse button

ida_kernwin.View_Hooks

ida_kernwin.View_Hooks.__disown__(self)

ida_kernwin.View_Hooks.__init__(self, _flags: int = 0, _hkcb_flags: int = 1)

ida_kernwin.View_Hooks.hook(self) -> bool

ida_kernwin.View_Hooks.unhook(self) -> bool

ida_kernwin.View_Hooks.view_activated(self, view: "TWidget *") -> None
    A view is activated 
              
    @param view: (TWidget *)

ida_kernwin.View_Hooks.view_click(self, view: "TWidget *", event: "view_mouse_event_t") -> None
    Click event 
              
    @param view: (TWidget *)
    @param event: (const view_mouse_event_t *)

ida_kernwin.View_Hooks.view_close(self, view: "TWidget *") -> None
    View closed 
              
    @param view: (TWidget *)

ida_kernwin.View_Hooks.view_created(self, view: "TWidget *") -> None
    A view is being created. 
              
    @param view: (TWidget *)

ida_kernwin.View_Hooks.view_curpos(self, view: "TWidget *") -> None
    Cursor position changed 
              
    @param view: (TWidget *)

ida_kernwin.View_Hooks.view_dblclick(self, view: "TWidget *", event: "view_mouse_event_t") -> None
    Double click event 
              
    @param view: (TWidget *)
    @param event: (const view_mouse_event_t *)

ida_kernwin.View_Hooks.view_deactivated(self, view: "TWidget *") -> None
    A view is deactivated 
              
    @param view: (TWidget *)

ida_kernwin.View_Hooks.view_keydown(self, view: "TWidget *", key: int, state: "view_event_state_t") -> None
    Key down event 
              
    @param view: (TWidget *)
    @param key: (int)
    @param state: (::view_event_state_t)

ida_kernwin.View_Hooks.view_loc_changed(self, view: "TWidget *", now: "lochist_entry_t const *", was: "lochist_entry_t const *") -> None
    The location for the view has changed (can be either the place_t, the renderer_info_t, or both.) 
              
    @param view: (TWidget *)
    @param now: (const lochist_entry_t *)
    @param was: (const lochist_entry_t *)

ida_kernwin.View_Hooks.view_mouse_moved(self, view: "TWidget *", event: "view_mouse_event_t") -> None
    The mouse moved on the view 
              
    @param view: (TWidget *)
    @param event: (const view_mouse_event_t *)

ida_kernwin.View_Hooks.view_mouse_over(self, view: "TWidget *", event: "view_mouse_event_t") -> None
    The user moved the mouse over (or out of) a node or an edge. This is only relevant in a graph view. 
              
    @param view: (TWidget *)
    @param event: (const view_mouse_event_t *)

ida_kernwin.View_Hooks.view_switched(self, view: "TWidget *", rt: "tcc_renderer_type_t") -> None
    A view's renderer has changed. 
              
    @param view: (TWidget *)
    @param rt: (tcc_renderer_type_t)

ida_kernwin.WCLS_DELETE_LATER
    assign the deletion of the widget to the UI loop ///<

ida_kernwin.WCLS_DONT_SAVE_SIZE
    don't save size of the window

ida_kernwin.WCLS_NO_CONTEXT
    don't change the current context (useful for toolbars)

ida_kernwin.WCLS_SAVE
    save state in desktop config

ida_kernwin.WOPN_CLOSED_BY_ESC
    override idagui.cfg:CLOSED_BY_ESC: esc will close

ida_kernwin.WOPN_DP_BEFORE
    Place widget before dst_form in the tab bar instead of after; used with WOPN_DP_INSIDE and WOPN_DP_TAB 
            

ida_kernwin.WOPN_DP_BOTTOM
    Dock widget below dest_ctrl.

ida_kernwin.WOPN_DP_FLOATING
    Make widget floating.

ida_kernwin.WOPN_DP_INSIDE
    Create a new tab bar with both widget and dest_ctrl.

ida_kernwin.WOPN_DP_LEFT
    Dock widget to the left of dest_ctrl.

ida_kernwin.WOPN_DP_RIGHT
    Dock widget to the right of dest_ctrl.

ida_kernwin.WOPN_DP_SZHINT
    when floating or in a splitter (i.e., not tabbed), use the widget's size hint to determine the best geometry (Qt only) 
            

ida_kernwin.WOPN_DP_TAB
    Place widget into a tab next to dest_ctrl, if dest_ctrl is in a tab bar (otherwise the same as WOPN_DP_INSIDE) 
            

ida_kernwin.WOPN_DP_TOP
    Dock widget above dest_ctrl.

ida_kernwin.WOPN_NOT_CLOSED_BY_ESC
    override idagui.cfg:CLOSED_BY_ESC: esc will not close

ida_kernwin.WOPN_PERSIST
    widget will remain available when starting or stopping debugger sessions

ida_kernwin.WOPN_RESTORE
    if the widget was the only widget in a floating area the last time it was closed, it will be restored as floating, with the same position+size as before 
            

ida_kernwin.__qtimer_t

ida_kernwin.__qtimer_t.__init__(self)

ida_kernwin._ask_addr(*args) -> "ea_t *"

ida_kernwin._ask_long(*args) -> "sval_t *"

ida_kernwin._ask_seg(*args) -> "sel_t *"

ida_kernwin._kludge_force_declare_dirspec_t(arg1: "dirspec_t const *") -> None

ida_kernwin._kludge_force_declare_dirtree_t(arg1: "dirtree_t const *") -> None

ida_kernwin.action_ctx_base_cur_sel_t

ida_kernwin.action_ctx_base_cur_sel_t.__init__(self)

ida_kernwin.action_ctx_base_cur_sel_t.reset(self) -> None

ida_kernwin.action_ctx_base_cur_sel_t.to
    end of selection

ida_kernwin.action_ctx_base_t

ida_kernwin.action_ctx_base_t.__init__(self)

ida_kernwin.action_ctx_base_t.action
    action name

ida_kernwin.action_ctx_base_t.chooser
    the underlying chooser_base_t (if 'widget' is a chooser widget)

ida_kernwin.action_ctx_base_t.chooser_selection
    current chooser selection (0-based)

ida_kernwin.action_ctx_base_t.cur_ea
    the current EA of the position in the view

ida_kernwin.action_ctx_base_t.cur_fchunk
    the current function chunk

ida_kernwin.action_ctx_base_t.cur_flags
    Current address information. see Action context property bits.

ida_kernwin.action_ctx_base_t.cur_func
    the current function

ida_kernwin.action_ctx_base_t.cur_seg
    the current segment

ida_kernwin.action_ctx_base_t.cur_sel
    the currently selected range. also see ACF_HAS_SELECTION

ida_kernwin.action_ctx_base_t.cur_value
    the possible address, or value the cursor is positioned on

ida_kernwin.action_ctx_base_t.dirtree_selection
    the current dirtree_t selection (if applicable)

ida_kernwin.action_ctx_base_t.focus
    The focused widget in case it is not the 'form' itself (e.g., the 'quick filter' input in choosers.)

ida_kernwin.action_ctx_base_t.graph
    the current graph (if in a graph view)

ida_kernwin.action_ctx_base_t.graph_selection
    the current graph selection (if in a graph view)

ida_kernwin.action_ctx_base_t.has_flag(self, flag: int) -> bool
    Check if the given flag is set.

ida_kernwin.action_ctx_base_t.hovered
    the current item being hovered (if in a graph view)

ida_kernwin.action_ctx_base_t.regname
    register name (if widget_type == BWN_CPUREGS and context menu opened on register)

ida_kernwin.action_ctx_base_t.reset(self) -> None
    Invalidate all context info.

ida_kernwin.action_ctx_base_t.type_ref
    a reference to the current type (if 'widget' is a type listing widget; nullptr otherwise)

ida_kernwin.action_ctx_base_t.widget_title
    title of current widget

ida_kernwin.action_ctx_base_t.widget_type
    type of current widget

ida_kernwin.action_desc_t

ida_kernwin.action_desc_t.__init__(self, name: str, label: str, handler: "PyObject *", shortcut: str = None, tooltip: str = None, icon: int = -1, flags: int = 0)

ida_kernwin.action_desc_t.cb
    size of this structure

ida_kernwin.action_desc_t.flags
    See Action flags.

ida_kernwin.action_desc_t.icon
    an optional icon ID to use

ida_kernwin.action_desc_t.label
    the label of the action, possibly with an accelerator key definition (e.g., "~J~ump to operand") 
            

ida_kernwin.action_desc_t.name
    the internal name of the action; must be unique. a way to reduce possible conflicts is to prefix it with some specific prefix. E.g., "myplugin:doSthg". 
            

ida_kernwin.action_desc_t.owner
    either the plugin_t, or plugmod_t responsible for registering the action. Can be nullptr Please see ACTION_DESC_LITERAL_PLUGMOD 
            

ida_kernwin.action_desc_t.shortcut
    an optional shortcut definition. E.g., "Ctrl+Enter"

ida_kernwin.action_desc_t.tooltip
    an optional tooltip for the action

ida_kernwin.action_handler_t

ida_kernwin.action_handler_t.__init__(self)

ida_kernwin.action_handler_t.activate(self, ctx)
    Activate an action. This function implements the core behavior of an action. It is called when the action is triggered, from a menu, from a popup menu, from the toolbar, or programmatically. 
            
    @returns non-zero: all IDA windows will be refreshed

ida_kernwin.action_handler_t.update(self, ctx)
    Update an action. This is called when the context of the UI changed, and we need to let the action update some of its properties if needed (label, icon, ...)
    In addition, this lets IDA know whether the action is enabled, and when it should be queried for availability again.
    Note: This callback is not meant to change anything in the application's state, except by calling one (or many) of the "update_action_*()" functions on this very action. 
            

ida_kernwin.activate_widget(widget: "TWidget *", take_focus: bool) -> None
    Activate widget (only gui version) (ui_activate_widget). 
            
    @param widget: existing widget to display
    @param take_focus: give focus to given widget

ida_kernwin.add_hotkey(hotkey, callable)
    Associates a function call with a hotkey.
    Callable 'callable' will be called each time the hotkey is pressed
    
    @param hotkey: The hotkey
    @param callable: Callable
    
    @return: Context object on success or None on failure.

ida_kernwin.add_idc_hotkey(hotkey: str, idcfunc: str) -> int
    Add hotkey for IDC function (ui_add_idckey). 
            
    @param hotkey: hotkey name
    @param idcfunc: IDC function name
    @returns IDC hotkey error codes

ida_kernwin.add_spaces(s: str, len: "size_t") -> str
    Add space characters to the colored string so that its length will be at least 'len' characters. Don't trim the string if it is longer than 'len'. 
            
    @param len: the desired length of the string
    @returns pointer to the end of input string

ida_kernwin.addon_count() -> int
    Get number of installed addons.

ida_kernwin.addon_info_t

ida_kernwin.addon_info_t.__init__(self)

ida_kernwin.analyzer_options() -> None
    Allow the user to set analyzer options. (show a dialog box) (ui_analyzer_options)

ida_kernwin.ask_addr(defval, format)
    Output a formatted string to the output window (msg) preprended with "**DATABASE IS CORRUPTED: " Display a dialog box and wait for the user to input an address (ui_ask_addr). 
            
    @param format: printf() style format string with the question
    @retval 0: the user pressed Esc.
    @retval 1: ok, the user entered an address

ida_kernwin.ask_buttons(*args) -> int
    Display a dialog box and get choice from maximum three possibilities (ui_ask_buttons). 
            
    @param Yes: text for the first button
    @param No: text for the second button
    @param Cancel: text for the third button
    @param deflt: default choice: one of Button IDs
    @param format: printf-style format string for question. It may have some prefixes, see below.
    @returns one of Button IDs specifying the selected button (Esc key returns Cancel/3rd button value)

ida_kernwin.ask_file(*args) -> "char *"

ida_kernwin.ask_for_feedback(*args) -> None
    Show a message box asking to send the input file to [support@hex-rays.com](mailto:support@hex-rays.com). 
            
    @param format: the reason why the input file is bad

ida_kernwin.ask_form(*args)
    Display a dialog box and wait for the user. If the form contains the "BUTTON NO <title>" keyword, then the return values are the same as in the ask_yn() function (Button IDs) 
            
    @param form: dialog box as a string. see ask_form()/open_form()
    @retval 0: no memory to display or form syntax error (a warning is displayed in this case). the user pressed the 'No' button (if the form has it) or the user cancelled the dialog otherwise. all variables retain their original values.
    @retval 1: ok, all input fields are filled and validated.
    @retval -1: the form has the 'No' button and the user cancelled the dialog

ida_kernwin.ask_ident(defval, format)
    Display a dialog box and wait for the user to input an identifier. If the user enters a non-valid identifier, this function displays a warning and allows the user to correct it. CPU register names are usually forbidden. 
            
    @param format: printf() style format string with the question
    @returns false if the user cancelled the dialog, otherwise returns true.

ida_kernwin.ask_ident2(*args) -> bool
    Display a dialog box and wait for the user to input an identifier. If the user enters a non-valid identifier, this function displays a warning and allows the user to correct it. CPU register names are permitted. 
            
    @param str: qstring to fill. Can contain the default value. Cannot be nullptr.
    @param format: printf() style format string with the question
    @returns false if the user cancelled the dialog, otherwise returns true.

ida_kernwin.ask_long(defval, format)
    Display a dialog box and wait for the user to input an number (ui_ask_long). The number is represented in C-style. This function allows to enter any IDC expression and properly calculates it. 
            
    @param format: printf() style format string with the question
    @retval 0: if the user pressed Esc.
    @retval 1: ok, the user entered a valid number.

ida_kernwin.ask_seg(defval, format)
    Display a dialog box and wait for the user to input an segment name (ui_ask_seg). This function allows to enter segment register names, segment base paragraphs, segment names to denote a segment. 
            
    @param format: printf() style format string with the question
    @retval 0: if the user pressed Esc.
    @retval 1: ok, the user entered an segment name

ida_kernwin.ask_str(defval, hist, prompt)
    Asks for a long text
    
    @param defval: The default value
    @param hist:   history id
    @param prompt: The prompt value
    @return: None or the entered string

ida_kernwin.ask_text(max_size: int, defval: str, prompt: str) -> Union[str, None]
    Asks for a long text
    
    @param max_size: Maximum text length, 0 for unlimited
    @param defval: The default value
    @param prompt: The prompt value
    @return: None or the entered string

ida_kernwin.ask_yn(*args) -> int
    Display a dialog box and get choice from "Yes", "No", "Cancel". 
            
    @param deflt: default choice: one of Button IDs
    @param format: The question in printf() style format
    @returns the selected button (one of Button IDs). Esc key returns ASKBTN_CANCEL.

ida_kernwin.atoea(str: str) -> "uint64 *"
    Convert a number in C notation to an address. decimal: 1234 
    octal: 0123 
    hexadecimal: 0xabcd 
    binary: 0b00101010 
            
    @param str: the string to parse

ida_kernwin.attach_action_to_menu(menupath: str, name: str, flags: int = 0) -> bool
    Attach a previously-registered action to the menu (ui_attach_action_to_menu). 
            
    @param menupath: path to the menu item after or before which the insertion will take place. 
    
    * Example: Debug/StartProcess
    * Whitespace, punctuation are ignored.
    * It is allowed to specify only the prefix of the menu item.
    * Comparison is case insensitive.
    * menupath may start with the following prefixes:
    * [S] - modify the main menu of the structure window
    * [E] - modify the main menu of the enum window
    @param name: the action name
    @param flags: a combination of Set menu flags, to determine menu item position
    @returns success

ida_kernwin.attach_action_to_popup(widget: "TWidget *", popup_handle: "TPopupMenu *", name: str, popuppath: str = None, flags: int = 0) -> bool
    Insert a previously-registered action into the widget's popup menu (ui_attach_action_to_popup). This function has two "modes": 'single-shot', and 'permanent'. 
            
    @param widget: target widget
    @param popup_handle: target popup menu
    * if non-nullptr, the action is added to this popup menu invocation (i.e., 'single-shot')
    * if nullptr, the action is added to a list of actions that should always be present in context menus for this widget (i.e., 'permanent'.)
    @param name: action name
    @param popuppath: can be nullptr
    @param flags: a combination of SETMENU_ flags (see Set menu flags)
    @returns success

ida_kernwin.attach_action_to_toolbar(toolbar_name: str, name: str) -> bool
    Attach an action to an existing toolbar (ui_attach_action_to_toolbar). 
            
    @param toolbar_name: the name of the toolbar
    @param name: the action name
    @returns success

ida_kernwin.attach_dynamic_action_to_popup(unused, popup_handle, desc, popuppath = None, flags = 0)
    Create & insert an action into the widget's popup menu
    (::ui_attach_dynamic_action_to_popup).
    Note: The action description in the 'desc' parameter is modified by
          this call so you should prepare a new description for each call.
    For example:
        desc = ida_kernwin.action_desc_t(None, 'Dynamic popup action', Handler())
        ida_kernwin.attach_dynamic_action_to_popup(form, popup, desc)
    
    @param unused:       deprecated; should be None
    @param popup_handle: target popup
    @param desc:         action description of type action_desc_t
    @param popuppath:    can be None
    @param flags:        a combination of SETMENU_ constants
    @return: success

ida_kernwin.banner(wait: int) -> bool
    Show a banner dialog box (ui_banner). 
            
    @param wait: time to wait before closing
    @retval 1: ok
    @retval 0: esc was pressed

ida_kernwin.beep(beep_type: "beep_t" = beep_default) -> None
    Issue a beeping sound (ui_beep). 
            
    @param beep_type: beep_t

ida_kernwin.call_nav_colorizer(colorizer, ea: ida_idaapi.ea_t, nbytes: int)
    To be used with the IDA-provided colorizer, that is
    returned as result of the first call to set_nav_colorizer().
    
    @param colorizer: the Python colorizer to call
    @param ea: the address to colorize
    @param nbytes: the size of the range to colorize

ida_kernwin.cancel_exec_request(req_id: int) -> bool
    Try to cancel an asynchronous exec request (::ui_cancel_exec_request). 
            
    @param req_id: request id
    @retval true: successfully canceled
    @retval false: request has already been processed.

ida_kernwin.cancel_thread_exec_requests(tid: "__qthread_t") -> int
    Try to cancel asynchronous exec requests created by the specified thread. 
            
    @param tid: thread id
    @returns number of the canceled requests.

ida_kernwin.choose_activate(_self: "PyObject *") -> None

ida_kernwin.choose_choose(_self: "PyObject *") -> "PyObject *"

ida_kernwin.choose_close(_self: "PyObject *") -> None

ida_kernwin.choose_create_embedded_chobj(_self: "PyObject *") -> "PyObject *"

ida_kernwin.choose_entry(title: str) -> ida_idaapi.ea_t
    Choose an entry point (ui_choose, chtype_entry). 
            
    @param title: chooser title
    @returns ea of selected entry point, BADADDR if none selected

ida_kernwin.choose_enum(out: "tinfo_t", title: str, default_ord: int) -> bool
    Choose an enum (ui_choose, chtype_enum). 
            
    @param out: the selected enum type
    @param title: chooser title
    @param default_ord: ordinal of enum to select by default
    @retval true: the selected type is in OUT
    @retval false: nothing was selected

ida_kernwin.choose_enum_by_value(out: "tinfo_t", title: str, default_ord: int, value: "uint64", nbytes: int) -> "uchar *"
    Choose an enum, restricted by value & size (ui_choose, chtype_enum_by_value_and_size). If the given value cannot be found initially, this function will ask if the user would like to import a standard enum. 
            
    @param out: the selected enum type
    @param title: chooser title
    @param default_ord: ordinal of enum to select by default
    @param value: value to search for
    @param nbytes: size of value
    @retval true: the selected type is in OUT
    @retval false: nothing was selected

ida_kernwin.choose_find(title: str) -> Union[object, None]
    Retrieve the chooser object by title
    
    @param title the chooser title
    @return the chooser, or None

ida_kernwin.choose_func(title: str, default_ea: ida_idaapi.ea_t) -> "func_t *"
    Choose a function (ui_choose, chtype_func). 
            
    @param title: chooser title
    @param default_ea: ea of function to select by default
    @returns pointer to function that was selected, nullptr if none selected

ida_kernwin.choose_get_widget(_self: "PyObject *") -> "TWidget *"

ida_kernwin.choose_idasgn()
    Opens the signature chooser
    
    @return: None or the selected signature name

ida_kernwin.choose_name(title: str) -> ida_idaapi.ea_t
    Choose a name (ui_choose, chtype_name). 
            
    @param title: chooser title
    @returns ea of selected name, BADADDR if none selected

ida_kernwin.choose_refresh(_self: "PyObject *") -> None

ida_kernwin.choose_segm(title: str, default_ea: ida_idaapi.ea_t) -> "segment_t *"
    Choose a segment (ui_choose, chtype_segm). 
            
    @param title: chooser title
    @param default_ea: ea of segment to select by default
    @returns pointer to segment that was selected, nullptr if none selected

ida_kernwin.choose_srcp(title: str) -> "sreg_range_t *"
    Choose a segment register change point (ui_choose, chtype_srcp). 
            
    @param title: chooser title
    @returns pointer to segment register range of selected change point, nullptr if none selected

ida_kernwin.choose_stkvar_xref(pfn: "func_t *", srkvar_tid: "tid_t") -> ida_idaapi.ea_t
    Choose an xref to a stack variable (ui_choose, chtype_name). 
            
    @param pfn: function
    @param srkvar_tid: frame variable TID
    @returns ea of the selected xref, BADADDR if none selected

ida_kernwin.choose_struct(out: "tinfo_t", title: str) -> bool
    Choose a structure (ui_choose, chtype_struct). 
            
    @param out: the selected structure type
    @param title: chooser title
    @retval true: the selected type is in OUT
    @retval false: nothing was selected

ida_kernwin.choose_til() -> str
    Choose a type library (ui_choose, chtype_idatil). 
            
    @retval true: 'buf' was filled with the name of the selected til
    @retval false: otherwise

ida_kernwin.choose_xref(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Choose an xref to an address (ui_choose, chtype_xref). 
            
    @param to: referenced address
    @returns ea of selected xref, BADADDR if none selected

ida_kernwin.chooser_base_t

ida_kernwin.chooser_base_t.__init__(self, *args, **kwargs)

ida_kernwin.chooser_base_t.ask_item_attrs(self) -> bool
    should chooser generate ui_get_chooser_item_attrs events?

ida_kernwin.chooser_base_t.can_del(self) -> bool

ida_kernwin.chooser_base_t.can_edit(self) -> bool

ida_kernwin.chooser_base_t.can_filter(self) -> bool

ida_kernwin.chooser_base_t.can_ins(self) -> bool
    is an operation allowed?

ida_kernwin.chooser_base_t.can_refresh(self) -> bool

ida_kernwin.chooser_base_t.can_sort(self) -> bool

ida_kernwin.chooser_base_t.columns
    number of columns

ida_kernwin.chooser_base_t.deflt_col
    Column that will have focus.

ida_kernwin.chooser_base_t.get_builtin_number(self) -> "uint"
    get number of the built-in chooser

ida_kernwin.chooser_base_t.get_count(self) -> "size_t"
    get the number of elements in the chooser

ida_kernwin.chooser_base_t.get_ea(self, arg2: "size_t") -> ida_idaapi.ea_t
    get the address of an element. When this function returns valid addresses: * If any column has the `CHCOL_FNAME` flag, rows will be colored according to the attributes of the functions who own those addresses (extern, library function, Lumina, ... - similar to what the "Functions" widget does) * When a selection is present and the user presses `<Enter>` (`<Shift+Enter>` if the chooser is modal), IDA will jump to that address (through jumpto()) 
            
    @returns the effective address, BADADDR if the element has no address

ida_kernwin.chooser_base_t.get_quick_filter_initial_mode(self) -> int

ida_kernwin.chooser_base_t.get_row(self, n: int) -> Tuple[List[str], int, chooser_item_attrs_t]
    Get data & attributes for a row in a chooser.
    
    @param n The row number
    @return a tuple (list-of-strings, icon-id, row-attributes)

ida_kernwin.chooser_base_t.has_diff_capability(self) -> bool

ida_kernwin.chooser_base_t.has_dirtree(self) -> bool

ida_kernwin.chooser_base_t.has_inode_to_index(self) -> bool

ida_kernwin.chooser_base_t.has_widget_lifecycle(self) -> bool
    should chooser object be deleted when the widget gets destroyed?

ida_kernwin.chooser_base_t.header
    header line; contains the tooltips, and column name for each of 'columns' columns. When tooltips need to be provided, the syntax should be: "#tooltip#column-name". (Otherwise, the syntax is simply "column-name".) 
            

ida_kernwin.chooser_base_t.height
    (in chars)

ida_kernwin.chooser_base_t.icon
    default icon

ida_kernwin.chooser_base_t.is_dirtree_persisted(self) -> bool

ida_kernwin.chooser_base_t.is_force_default(self) -> bool
    should selection of the already opened non-modal chooser be changed?

ida_kernwin.chooser_base_t.is_lazy_loaded(self) -> bool

ida_kernwin.chooser_base_t.is_modal(self) -> bool
    is choose modal?

ida_kernwin.chooser_base_t.is_multi(self) -> bool
    is multi-selection allowed?

ida_kernwin.chooser_base_t.is_quick_filter_visible_initially(self) -> bool

ida_kernwin.chooser_base_t.is_same(self, other: "chooser_base_t") -> bool
    do the current and the given objects hold the same data?

ida_kernwin.chooser_base_t.is_status_bar_hidden(self) -> bool

ida_kernwin.chooser_base_t.popup_allowed(self, stdact_idx: int) -> bool
    is a standard action allowed?

ida_kernwin.chooser_base_t.popup_names
    array of custom labels of the standard actions. Used to replace labels for these actions. 
    An empty name means that the default name will be used. 
            

ida_kernwin.chooser_base_t.should_rename_trigger_edit(self) -> bool

ida_kernwin.chooser_base_t.should_restore_geometry(self) -> bool

ida_kernwin.chooser_base_t.title
    menu title (includes ptr to help). May have chooser title prefixes (see "Chooser
    title" above). 
           

ida_kernwin.chooser_base_t.width
    (in chars)

ida_kernwin.chooser_base_t.widths
    column widths
    * low 16 bits of each value hold the column width
    * high 16 bits are flags (see Chooser column flags) 
    
    
            

ida_kernwin.chooser_base_t.x0
    screen position, Functions: generic list choosers

ida_kernwin.chooser_item_attrs_t

ida_kernwin.chooser_item_attrs_t.__eq__(self, other: "chooser_item_attrs_t") -> bool

ida_kernwin.chooser_item_attrs_t.__init__(self)

ida_kernwin.chooser_item_attrs_t.color
    item color

ida_kernwin.chooser_item_attrs_t.flags
    Chooser item property bits

ida_kernwin.chooser_item_attrs_t.reset(self) -> None

ida_kernwin.chooser_row_info_t

ida_kernwin.chooser_row_info_t.__eq__(self, other: "chooser_row_info_t") -> bool

ida_kernwin.chooser_row_info_t.__init__(self)

ida_kernwin.chooser_row_info_t.__ne__(self, other: "chooser_row_info_t") -> bool

ida_kernwin.chooser_row_info_t.attrs
    styling attributes

ida_kernwin.chooser_row_info_t.icon
    icon number

ida_kernwin.chooser_row_info_t.texts
    texts, one per chooser column

ida_kernwin.chooser_row_info_vec_t

ida_kernwin.chooser_row_info_vec_t.__eq__(self, r: "chooser_row_info_vec_t") -> bool

ida_kernwin.chooser_row_info_vec_t.__getitem__(self, i: "size_t") -> "chooser_row_info_t const &"

ida_kernwin.chooser_row_info_vec_t.__init__(self, *args)

ida_kernwin.chooser_row_info_vec_t.__len__(self) -> "size_t"

ida_kernwin.chooser_row_info_vec_t.__ne__(self, r: "chooser_row_info_vec_t") -> bool

ida_kernwin.chooser_row_info_vec_t.__setitem__(self, i: "size_t", v: "chooser_row_info_t") -> None

ida_kernwin.chooser_row_info_vec_t._del(self, x: "chooser_row_info_t") -> bool

ida_kernwin.chooser_row_info_vec_t.add_unique(self, x: "chooser_row_info_t") -> bool

ida_kernwin.chooser_row_info_vec_t.append(self, x: "chooser_row_info_t") -> None

ida_kernwin.chooser_row_info_vec_t.at(self, _idx: "size_t") -> "chooser_row_info_t const &"

ida_kernwin.chooser_row_info_vec_t.begin(self, *args) -> "qvector< chooser_row_info_t >::const_iterator"

ida_kernwin.chooser_row_info_vec_t.capacity(self) -> "size_t"

ida_kernwin.chooser_row_info_vec_t.clear(self) -> None

ida_kernwin.chooser_row_info_vec_t.empty(self) -> bool

ida_kernwin.chooser_row_info_vec_t.end(self, *args) -> "qvector< chooser_row_info_t >::const_iterator"

ida_kernwin.chooser_row_info_vec_t.erase(self, *args) -> "qvector< chooser_row_info_t >::iterator"

ida_kernwin.chooser_row_info_vec_t.extend(self, x: "chooser_row_info_vec_t") -> None

ida_kernwin.chooser_row_info_vec_t.extract(self) -> "chooser_row_info_t *"

ida_kernwin.chooser_row_info_vec_t.find(self, *args) -> "qvector< chooser_row_info_t >::const_iterator"

ida_kernwin.chooser_row_info_vec_t.grow(self, *args) -> None

ida_kernwin.chooser_row_info_vec_t.has(self, x: "chooser_row_info_t") -> bool

ida_kernwin.chooser_row_info_vec_t.inject(self, s: "chooser_row_info_t", len: "size_t") -> None

ida_kernwin.chooser_row_info_vec_t.insert(self, it: "chooser_row_info_t", x: "chooser_row_info_t") -> "qvector< chooser_row_info_t >::iterator"

ida_kernwin.chooser_row_info_vec_t.pop_back(self) -> None

ida_kernwin.chooser_row_info_vec_t.push_back(self, *args) -> "chooser_row_info_t &"

ida_kernwin.chooser_row_info_vec_t.qclear(self) -> None

ida_kernwin.chooser_row_info_vec_t.reserve(self, cnt: "size_t") -> None

ida_kernwin.chooser_row_info_vec_t.resize(self, *args) -> None

ida_kernwin.chooser_row_info_vec_t.size(self) -> "size_t"

ida_kernwin.chooser_row_info_vec_t.swap(self, r: "chooser_row_info_vec_t") -> None

ida_kernwin.chooser_row_info_vec_t.truncate(self) -> None

ida_kernwin.chooser_stdact_desc_t

ida_kernwin.chooser_stdact_desc_t.__disown__(self)

ida_kernwin.chooser_stdact_desc_t.__init__(self, _label: str = None, _tooltip: str = None, _icon: int = -1)

ida_kernwin.chooser_stdact_desc_t.label
    see action_desc_t

ida_kernwin.chooser_stdact_desc_t.ucb(self, arg0: "action_ctx_base_t") -> "action_state_t"
    the update callback, see action_handler_t::update() When the update callback is called from the chooser UI engine, it can be sure that ctx.source.chooser is a valid pointer to chooser_base_t and that there are selected items for the Delete and Edit actions. 
            

ida_kernwin.chooser_stdact_desc_t.version
    to support the backward compatibility

ida_kernwin.chtype_entry
    see choose_entry()

ida_kernwin.chtype_enum
    see choose_enum()

ida_kernwin.chtype_enum_by_value_and_size
    see choose_enum_by_value()

ida_kernwin.chtype_func
    see choose_func()

ida_kernwin.chtype_generic
    the generic choose() function

ida_kernwin.chtype_idasgn
    see choose_idasgn()

ida_kernwin.chtype_idatil
    see choose_til()

ida_kernwin.chtype_name
    see choose_name()

ida_kernwin.chtype_segm
    see choose_segm()

ida_kernwin.chtype_srcp
    see choose_srcp()

ida_kernwin.chtype_stkvar_xref
    see choose_stkvar_xref()

ida_kernwin.chtype_strpath
    see choose_struc_path()

ida_kernwin.chtype_struct
    see choose_struct()

ida_kernwin.chtype_xref
    see choose_xref()

ida_kernwin.clear_refresh_request(mask: "uint64") -> None

ida_kernwin.cli_t
    cli_t wrapper class.
    
    This class allows you to implement your own command line interface handlers.

ida_kernwin.cli_t.OnExecuteLine(self, line)
    The user pressed Enter. The CLI is free to execute the line immediately or ask for more lines.
    
    This callback is mandatory.
    
    @param line: typed line(s)
    @return Boolean: True-executed line, False-ask for more lines

ida_kernwin.cli_t.OnFindCompletions(self, line, x)
    The user pressed Tab. Return a list of completions
    
    This callback is optional.
    
    @param line: the current line (string)
    @param x: the index where the cursor is (int)
    
    @return: None if no completion could be generated, otherwise a tuple:
        (completions : Sequence[str], hints : Sequence[str], docs: Sequence[str],
          match_start: int, match_end: int)

ida_kernwin.cli_t.OnKeydown(self, line, x, sellen, vkey, shift)
    A keyboard key has been pressed
    This is a generic callback and the CLI is free to do whatever it wants.
    
    This callback is optional.
    
    @param line: current input line
    @param x: current x coordinate of the cursor
    @param sellen: current selection length (usually 0)
    @param vkey: virtual key code. if the key has been handled, it should be returned as zero
    @param shift: shift state
    
    @return:
        None - Nothing was changed
        tuple(line, x, sellen, vkey): if either of the input line or the x coordinate or the selection length has been modified.
        It is possible to return a tuple with None elements to preserve old values. Example: tuple(new_line, None, None, None) or tuple(new_line)

ida_kernwin.cli_t.__del__(self)

ida_kernwin.cli_t.__init__(self)

ida_kernwin.cli_t.register(self, flags = 0, sname = None, lname = None, hint = None)
    Registers the CLI.
    
    @param flags: Feature bits. No bits are defined yet, must be 0
    @param sname: Short name (displayed on the button)
    @param lname: Long name (displayed in the menu)
    @param hint:  Hint for the input line
    
    @return Boolean: True-Success, False-Failed

ida_kernwin.cli_t.unregister(self)
    Unregisters the CLI (if it was registered)

ida_kernwin.close_chooser(title: str) -> bool
    Close a non-modal chooser (ui_close_chooser). 
            
    @param title: window title of chooser to close
    @returns success

ida_kernwin.close_widget(widget: "TWidget *", options: int) -> None
    Close widget (ui_close_widget, only gui version). 
            
    @param widget: pointer to the widget to close
    @param options: Form close flags

ida_kernwin.clr_cancelled() -> None
    Clear "Cancelled" flag (ui_clr_cancelled)

ida_kernwin.create_code_viewer(custview: "TWidget *", flags: int = 0, parent: "TWidget *" = None) -> "TWidget *"
    Create a code viewer (ui_create_code_viewer). A code viewer contains on the left side a widget representing the line numbers, and on the right side, the child widget passed as parameter. It will inherit its title from the child widget.
    
    @param custview: the custom view to be added
    @param flags: Code viewer flags
    @param parent: widget to contain the new code viewer

ida_kernwin.create_empty_widget(title: str, icon: int = -1) -> "TWidget *"
    Create an empty widget, serving as a container for custom user widgets 
            

ida_kernwin.create_menu(name: str, label: str, menupath: str = None) -> bool
    Create a menu with the given name, label and optional position, either in the menubar, or as a submenu. If 'menupath' is non-nullptr, it provides information about where the menu should be positioned. First, IDA will try and resolve the corresponding menu by its name. If such an existing menu is found and is present in the menubar, then the new menu will be inserted in the menubar before it. Otherwise, IDA will try to resolve 'menupath' as it would for attach_action_to_menu() and, if found, add the new menu like so: 
         The new 'My menu' submenu will appear in the 'Comments' submenu
         before the 'Enter comment..." command
         "My menu", "Edit/Comments/Enter comment...");
    
    
         The new 'My menu' submenu will appear at the end of the
         'Comments' submenu.
         "My menu", "Edit/Comments/");
    
    
            
    @param name: name of menu (must be unique)
    @param label: label of menu
    @param menupath: where should the menu be inserted
    @returns success

ida_kernwin.create_toolbar(name: str, label: str, before: str = None, flags: int = 0) -> bool
    Create a toolbar with the given name, label and optional position 
            
    @param name: name of toolbar (must be unique)
    @param label: label of toolbar
    @param before: if non-nullptr, the toolbar before which the new toolbar will be inserted
    @param flags: a combination of create toolbar flags, to determine toolbar position
    @returns success

ida_kernwin.custom_viewer_jump(v: "TWidget *", loc: "lochist_entry_t const &", flags: int = 0) -> bool
    Append 'loc' to the viewer's history, and cause the viewer to display it. 
            
    @param v: (TWidget *)
    @param loc: (const lochist_entry_t &)
    @param flags: (uint32) or'ed combination of CVNF_* values
    @returns success

ida_kernwin.del_hotkey(ctx)
    Deletes a previously registered function hotkey
    
    @param ctx: Hotkey context previously returned by add_hotkey()
    
    @return: Boolean.

ida_kernwin.del_idc_hotkey(hotkey: str) -> bool

ida_kernwin.delete_menu(name: str) -> bool
    Delete an existing menu 
            
    @param name: name of menu
    @returns success

ida_kernwin.delete_toolbar(name: str) -> bool
    Delete an existing toolbar 
            
    @param name: name of toolbar
    @returns success

ida_kernwin.detach_action_from_menu(menupath: str, name: str) -> bool
    Detach an action from the menu (ui_detach_action_from_menu). 
            
    @param menupath: path to the menu item
    @param name: the action name
    @returns success

ida_kernwin.detach_action_from_popup(widget: "TWidget *", name: str) -> bool
    Remove a previously-registered action, from the list of 'permanent' context menu actions for this widget (ui_detach_action_from_popup). This only makes sense if the action has been added to 'widget's list of permanent popup actions by calling attach_action_to_popup in 'permanent' mode. 
            
    @param widget: target widget
    @param name: action name

ida_kernwin.detach_action_from_toolbar(toolbar_name: str, name: str) -> bool
    Detach an action from the toolbar (ui_detach_action_from_toolbar). 
            
    @param toolbar_name: the name of the toolbar
    @param name: the action name
    @returns success

ida_kernwin.disabled_script_timeout_t

ida_kernwin.disabled_script_timeout_t.__enter__(self)

ida_kernwin.disabled_script_timeout_t.__exit__(self, type, value, tb)

ida_kernwin.disasm_line_t

ida_kernwin.disasm_line_t.__init__(self, *args)

ida_kernwin.disasm_text_t

ida_kernwin.disasm_text_t.__getitem__(self, i: "size_t") -> "disasm_line_t const &"

ida_kernwin.disasm_text_t.__init__(self, *args)

ida_kernwin.disasm_text_t.__len__(self) -> "size_t"

ida_kernwin.disasm_text_t.__setitem__(self, i: "size_t", v: "disasm_line_t") -> None

ida_kernwin.disasm_text_t.append(self, x: "disasm_line_t") -> None

ida_kernwin.disasm_text_t.at(self, _idx: "size_t") -> "disasm_line_t const &"

ida_kernwin.disasm_text_t.begin(self, *args) -> "qvector< disasm_line_t >::const_iterator"

ida_kernwin.disasm_text_t.capacity(self) -> "size_t"

ida_kernwin.disasm_text_t.clear(self) -> None

ida_kernwin.disasm_text_t.empty(self) -> bool

ida_kernwin.disasm_text_t.end(self, *args) -> "qvector< disasm_line_t >::const_iterator"

ida_kernwin.disasm_text_t.erase(self, *args) -> "qvector< disasm_line_t >::iterator"

ida_kernwin.disasm_text_t.extend(self, x: "disasm_text_t") -> None

ida_kernwin.disasm_text_t.extract(self) -> "disasm_line_t *"

ida_kernwin.disasm_text_t.grow(self, *args) -> None

ida_kernwin.disasm_text_t.inject(self, s: "disasm_line_t", len: "size_t") -> None

ida_kernwin.disasm_text_t.insert(self, it: "disasm_line_t", x: "disasm_line_t") -> "qvector< disasm_line_t >::iterator"

ida_kernwin.disasm_text_t.pop_back(self) -> None

ida_kernwin.disasm_text_t.push_back(self, *args) -> "disasm_line_t &"

ida_kernwin.disasm_text_t.qclear(self) -> None

ida_kernwin.disasm_text_t.reserve(self, cnt: "size_t") -> None

ida_kernwin.disasm_text_t.resize(self, *args) -> None

ida_kernwin.disasm_text_t.size(self) -> "size_t"

ida_kernwin.disasm_text_t.swap(self, r: "disasm_text_t") -> None

ida_kernwin.disasm_text_t.truncate(self) -> None

ida_kernwin.display_copyright_warning() -> bool
    Display copyright warning (ui_copywarn). 
            
    @returns yes/no

ida_kernwin.display_widget(widget: "TWidget *", options: int, dest_ctrl: str = None) -> None
    Display a widget, dock it if not done before 
            
    @param widget: widget to display
    @param options: Widget open flags
    @param dest_ctrl: where to dock: if nullptr or invalid then use the active docker if there is not create a new tab relative to current active tab

ida_kernwin.ea2str(ea: ida_idaapi.ea_t) -> str
    Convert linear address to UTF-8 string.

ida_kernwin.ea_viewer_history_push_and_jump(v: "TWidget *", ea: ida_idaapi.ea_t, x: int, y: int, lnnum: int) -> bool
    Push current location in the history and jump to the given location (ui_ea_viewer_history_push_and_jump). This will jump in the given ea viewer and also in other synchronized views. 
            
    @param v: ea viewer
    @param ea: jump destination
    @param x: coords on screen
    @param y: coords on screen
    @param lnnum: desired line number of given address

ida_kernwin.enable_chooser_item_attrs(chooser_caption: str, enable: bool) -> bool
    Enable item-specific attributes for chooser items (ui_enable_chooser_item_attrs). For example: color list items differently depending on a criterium. 
    If enabled, the chooser will generate ui_get_chooser_item_attrs 
    events that can be intercepted by a plugin to modify the item attributes. 
    This event is generated only in the GUI version of IDA. 
    Specifying CH_ATTRS bit at the chooser creation time has the same effect. 
            
    @returns success

ida_kernwin.error(message)
    Display a fatal message in a message box and quit IDA
    
    @param format: message to print

ida_kernwin.execute_sync(callable, reqf)
    Executes a function in the context of the main thread.
    If the current thread not the main thread, then the call is queued and
    executed afterwards.
    
    @param callable: A python callable object, must return an integer value
    @param reqf: one of MFF_ flags
    @return: -1 or the return value of the callable

ida_kernwin.execute_ui_requests(callable_list)
    Inserts a list of callables into the UI message processing queue.
    When the UI is ready it will call one callable.
    A callable can request to be called more than once if it returns True.
    
    @param callable_list: A list of python callable objects.
    @note: A callable should return True if it wants to be called more than once.
    @return: Boolean. False if the list contains a non callable item

ida_kernwin.find_widget(caption: str) -> "TWidget *"
    Find widget with the specified caption (only gui version) (ui_find_widget). NB: this callback works only with the tabbed widgets! 
            
    @param caption: title of tab, or window title if widget is not tabbed
    @returns pointer to the TWidget, nullptr if none is found

ida_kernwin.formchgcbfa_close(p_fa: "size_t", close_normally: int) -> None

ida_kernwin.formchgcbfa_enable_field(p_fa: "size_t", fid: int, enable: bool) -> bool

ida_kernwin.formchgcbfa_get_field_value(p_fa: "size_t", fid: int, ft: int, sz: "size_t") -> "PyObject *"

ida_kernwin.formchgcbfa_get_focused_field(p_fa: "size_t") -> int

ida_kernwin.formchgcbfa_move_field(p_fa: "size_t", fid: int, x: int, y: int, w: int, h: int) -> bool

ida_kernwin.formchgcbfa_refresh_field(p_fa: "size_t", fid: int) -> None

ida_kernwin.formchgcbfa_set_field_value(p_fa: "size_t", fid: int, ft: int, py_val: "PyObject *") -> bool

ida_kernwin.formchgcbfa_set_focused_field(p_fa: "size_t", fid: int) -> bool

ida_kernwin.formchgcbfa_show_field(p_fa: "size_t", fid: int, show: bool) -> bool

ida_kernwin.free_custom_icon(icon_id)
    Frees an icon loaded with load_custom_icon()
    
    @param icon_id: The ID of the icon to free

ida_kernwin.gen_disasm_text(text: "disasm_text_t", ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, truncate_lines: bool) -> None
    Generate disassembly text for a range. 
            
    @param text: result
    @param ea1: start address
    @param ea2: end address
    @param truncate_lines: (on idainfo::margin)

ida_kernwin.get_action_checkable(name: str) -> "bool *"
    Get an action's checkability (ui_get_action_attr). 
            
    @param name: the action name
    @returns success

ida_kernwin.get_action_checked(name: str) -> "bool *"
    Get an action's checked state (ui_get_action_attr). 
            
    @param name: the action name
    @returns success

ida_kernwin.get_action_icon(name: str) -> "int *"
    Get an action's icon (ui_get_action_attr). 
            
    @param name: the action name
    @returns success

ida_kernwin.get_action_label(name: str) -> str
    Get an action's label (ui_get_action_attr). 
            
    @param name: the action name
    @returns success

ida_kernwin.get_action_shortcut(name: str) -> str
    Get an action's shortcut (ui_get_action_attr). 
            
    @param name: the action name
    @returns success

ida_kernwin.get_action_state(name: str) -> "action_state_t *"
    Get an action's state (ui_get_action_attr). 
            
    @param name: the action name
    @returns success

ida_kernwin.get_action_tooltip(name: str) -> str
    Get an action's tooltip (ui_get_action_attr). 
            
    @param name: the action name
    @returns success

ida_kernwin.get_action_visibility(name: str) -> "bool *"
    Get an action's visibility (ui_get_action_attr). 
            
    @param name: the action name
    @returns success

ida_kernwin.get_active_modal_widget() -> "TWidget *"
    Get the current, active modal TWidget instance. Note that in this context, the "wait dialog" is not considered: this function will return nullptr even if it is currently shown. 
            
    @returns TWidget * the active modal widget, or nullptr

ida_kernwin.get_addon_info(id: str, info: "addon_info_t") -> bool
    Get info about a registered addon with a given product code. info->cb must be valid! NB: all pointers are invalidated by next call to register_addon or get_addon_info 
            
    @returns false if not found

ida_kernwin.get_addon_info_idx(index: int, info: "addon_info_t") -> bool
    Get info about a registered addon with specific index. info->cb must be valid! NB: all pointers are invalidated by next call to register_addon or get_addon_info 
            
    @returns false if index is out of range

ida_kernwin.get_chooser_data(title: str, n: int) -> List[str]
    Get the text corresponding to the index N in the chooser data.
    Use -1 to get the header.
    
    @param title The chooser title
    @return a list of strings, or None

ida_kernwin.get_chooser_obj(chooser_caption: str) -> "void *"
    Get the underlying object of the specified chooser (ui_get_chooser_obj).
    This attemps to find the choser by its title and, if found, returns the result of calling its chooser_base_t::get_chooser_obj() method.
    
    @returns the object that was used to create the chooser

ida_kernwin.get_chooser_rows(out: "chooser_row_info_vec_t", chooser_caption: str, what: "size_t") -> bool
    Get the chooser contents corresponding to the rows indicated by "what". 
            
    @param out: A vector of chooser_row_info_t, one entry per returned row.
    @param chooser_caption: The caption that identifies the desired chooser.
    @param what: Either one of the GCRF_ flags, or a row index.
    @returns Success.

ida_kernwin.get_curline() -> str
    Get current line from the disassemble window (ui_get_curline). 
            
    @returns cptr current line with the color codes (use tag_remove() to remove the color codes)

ida_kernwin.get_current_viewer() -> "TWidget *"
    Get current ida viewer (idaview or custom viewer) (ui_get_current_viewer)

ida_kernwin.get_current_widget() -> "TWidget *"
    Get a pointer to the current widget (ui_get_current_widget).

ida_kernwin.get_cursor() -> "int *, int *"
    Get the cursor position on the screen (ui_get_cursor). 
            
    @retval true: pointers are filled
    @retval false: no disassembly window open

ida_kernwin.get_custom_viewer_curline(custom_viewer: "TWidget *", mouse: bool) -> str
    Get current line of custom viewer (ui_get_custom_viewer_curline). The returned line contains color codes
    See also the more powerful get_custom_viewer_location()
    
    @param custom_viewer: view
    @param mouse: mouse position (otherwise cursor position)
    @returns pointer to contents of current line

ida_kernwin.get_custom_viewer_location(*args) -> bool
    Get information about the current location in a listing
    
    This function has the following signatures:
    
        1. get_custom_viewer_location(out_entry: ida_moves.lochist_entry_t, widget: TWidget, mouse: bool=False) -> bool
        2. get_custom_viewer_location(out_entry: ida_kernwin.listing_location_t, widget: TWidget, flags: int=0) -> bool
    
    The 2nd form is a superset of the 1st, and retrieves
    the text (and tags) of the text.

ida_kernwin.get_custom_viewer_place(custom_viewer: "TWidget *", mouse: bool) -> "int *, int *"
    Get current place in a custom viewer (ui_get_curplace).
    See also the more complete get_custom_viewer_location()
    
    @param custom_viewer: view
    @param mouse: mouse position (otherwise cursor position)

ida_kernwin.get_custom_viewer_place_xcoord(custom_viewer: "TWidget *", pline: "place_t", pitem: "place_t") -> int
    Get the X position of the item, in the line 
            
    @param custom_viewer: the widget
    @param pline: a place corresponding to the line
    @param pitem: a place corresponding to the item
    @retval -1: if 'pitem' is not included in the line
    @retval -2: if 'pitem' points at the entire line
    @retval >=: 0 for the X coordinate within the pline, where pitem points

ida_kernwin.get_ea_viewer_history_info(nback: "int *", nfwd: "int *", v: "TWidget *") -> bool
    Get information about what's in the history (ui_ea_viewer_history_info). 
            
    @param nback: number of available back steps
    @param nfwd: number of available forward steps
    @param v: ea viewer
    @retval false: if the given ea viewer does not exist
    @retval true: otherwise

ida_kernwin.get_hexdump_ea(hexdump_num: int) -> ida_idaapi.ea_t
    Get the current address in a hex view. 
            
    @param hexdump_num: number of hexview window

ida_kernwin.get_highlight(v, flags = 0)
    Returns the currently highlighted identifier and flags
    
    @param v: The UI widget to operate on
    @param flags: Optionally specify a slot (see kernwin.hpp), current otherwise
    @return: a tuple (text, flags), or None if nothing
             is highlighted or in case of error.

ida_kernwin.get_icon_id_by_name(icon_name: str) -> int
    Retrieve the id of the icon by name (ui_get_icon_id_by_name). 
            
    @param icon_name: full name of the icon
    @returns icon id

ida_kernwin.get_kernel_version() -> str
    Get IDA kernel version (in a string like "5.1").

ida_kernwin.get_key_code(keyname: str) -> "ushort"
    Get keyboard key code by its name (ui_get_key_code)

ida_kernwin.get_last_widget(*args) -> "TWidget *"
    Get last ida viewer (idaview or custom viewer) (ui_get_last_widget) 
            
    @param mask: an OR'ed set of IWID_* to limit the search to
    @returns the viewer, if found

ida_kernwin.get_navband_ea(pixel: int) -> ida_idaapi.ea_t
    Translate the pixel position on the navigation band, into an address.

ida_kernwin.get_navband_pixel(ea)
    Maps an address, onto a pixel coordinate within the navigation band
    
    @param ea: The address to map
    @return: a list [pixel, is_vertical]

ida_kernwin.get_opnum() -> int
    Get current operand number, -1 means no operand (ui_get_opnum)

ida_kernwin.get_output_curline(mouse: bool) -> str
    Get current line of output window (ui_get_output_curline). 
            
    @param mouse: current for mouse pointer?
    @returns false if output contains no text

ida_kernwin.get_output_cursor() -> "int *, int *"
    Get coordinates of the output window's cursor (ui_get_output_cursor). 
            
    @retval false: the output window has been destroyed.
    @retval true: pointers are filled

ida_kernwin.get_output_selected_text() -> str
    Returns selected text from output window (ui_get_output_selected_text). 
            
    @returns true if there is a selection

ida_kernwin.get_place_class(out_flags: "int *", out_sdk_version: "int *", id: int) -> "place_t const *"
    Get information about a previously-registered place_t class. See also register_place_class(). 
            
    @param out_flags: output flags (can be nullptr)
    @param out_sdk_version: sdk version the place was created with (can be nullptr)
    @param id: place class ID
    @returns the place_t template, or nullptr if not found

ida_kernwin.get_place_class_id(name: str) -> int
    Get the place class ID for the place that has been registered as 'name'. 
            
    @param name: the class name
    @returns the place class ID, or -1 if not found

ida_kernwin.get_place_class_template(id: int) -> "place_t const *"
    See get_place_class()

ida_kernwin.get_registered_actions() -> List[str]
    Get a list with the names of all currently-registered actions.
    
    @return the list of action names

ida_kernwin.get_screen_ea() -> ida_idaapi.ea_t
    Get the address at the screen cursor (ui_screenea)

ida_kernwin.get_synced_group(w: "TWidget const *") -> "synced_group_t const *"
    Get the group of widgets/registers this view is synchronized with 
            
    @param w: the widget
    @returns the group of widgets/registers, or nullptr

ida_kernwin.get_tab_size(path: str) -> int
    Get the size of a tab in spaces (ui_get_tab_size). 
            
    @param path: the path of the source view for which the tab size is requested.
    * if nullptr, the default size is returned.

ida_kernwin.get_user_input_event(out: "input_event_t") -> bool
    Get the current user input event (mouse button press, key press, ...) It is sometimes desirable to be able to tell when a certain situation happens (e.g., 'view_curpos' gets triggered); this function exists to provide that context (GUI version only) 
            
    @param out: the input event data
    @returns false if we are not currently processing a user input event

ida_kernwin.get_user_strlist_options(out: "strwinsetup_t *") -> None

ida_kernwin.get_view_renderer_type(v: "TWidget *") -> "tcc_renderer_type_t"
    Get the type of renderer currently in use in the given view (ui_get_renderer_type)

ida_kernwin.get_viewer_place_type(viewer: "TWidget *") -> "tcc_place_type_t"
    Get the type of place_t instances a viewer uses & creates (ui_get_viewer_place_type).

ida_kernwin.get_viewer_user_data(viewer: "TWidget *") -> "void *"
    Get the user data from a custom viewer (ui_get_viewer_user_data)

ida_kernwin.get_widget_title(widget: "TWidget *") -> str
    Get the TWidget's title (ui_get_widget_title).

ida_kernwin.get_widget_type(widget: "TWidget *") -> "twidget_type_t"
    Get the type of the TWidget * (ui_get_widget_type).

ida_kernwin.get_window_id(name: str = None) -> "void *"
    Get the system-specific window ID (GUI version only) 
            
    @param name: name of the window (nullptr means the main IDA window)
    @returns the low-level window ID

ida_kernwin.hide_wait_box() -> None
    Hide the "Please wait dialog box".

ida_kernwin.idaplace_t

ida_kernwin.idaplace_t.__init__(self, *args, **kwargs)

ida_kernwin.idaplace_t.ea
    address

ida_kernwin.info(*args) -> "ssize_t"

ida_kernwin.input_event_keyboard_data_t

ida_kernwin.input_event_keyboard_data_t.__init__(self)

ida_kernwin.input_event_mouse_data_t

ida_kernwin.input_event_mouse_data_t.__init__(self)

ida_kernwin.input_event_shortcut_data_t

ida_kernwin.input_event_shortcut_data_t.__init__(self)

ida_kernwin.input_event_t

ida_kernwin.input_event_t.__init__(self)

ida_kernwin.input_event_t._source_as_size(self) -> "size_t"

ida_kernwin.input_event_t._target_as_size(self) -> "size_t"

ida_kernwin.input_event_t.cb
    size marker

ida_kernwin.input_event_t.get_source_QEvent(self)

ida_kernwin.input_event_t.get_target_QWidget(self)

ida_kernwin.input_event_t.kind
    the kind of event

ida_kernwin.input_event_t.modifiers
    current keyboard (and mouse) modifiers

ida_kernwin.input_event_t.source
    the source event, should it be required for detailed inform (e.g., a QEvent in the GUI version of IDA)

ida_kernwin.input_event_t.target
    the target widget

ida_kernwin.install_command_interpreter(py_obj: "PyObject *") -> int
    Install command line interpreter (ui_install_cli)

ida_kernwin.internal_register_place_class(tmplate: "place_t", flags: int, owner: "plugin_t const *", sdk_version: int) -> int

ida_kernwin.is_action_enabled(s: "action_state_t") -> bool
    Check if the given action state is one of AST_ENABLE*.

ida_kernwin.is_chooser_widget(t: "twidget_type_t") -> bool
    Does the given widget type specify a chooser widget?

ida_kernwin.is_ida_library(path: "char *", pathsize: "size_t", handle: "void **") -> bool

ida_kernwin.is_idaq()
    Returns True or False depending if IDAPython is hosted by IDAQ

ida_kernwin.is_idaview(v: "TWidget *") -> bool
    Is the given custom view an idaview? (ui_is_idaview)

ida_kernwin.is_msg_inited() -> bool
    Can we use msg() functions?

ida_kernwin.is_place_class_ea_capable(id: int) -> bool
    See get_place_class()

ida_kernwin.is_refresh_requested(mask: "uint64") -> bool
    Get a refresh request state 
            
    @param mask: Window refresh flags
    @returns the state (set or cleared)

ida_kernwin.is_tif_cursor_footer(c: "tif_cursor_t") -> bool

ida_kernwin.is_tif_cursor_header(c: "tif_cursor_t") -> bool

ida_kernwin.is_tif_cursor_index(c: "tif_cursor_t") -> bool

ida_kernwin.jobj_wrapper_t

ida_kernwin.jobj_wrapper_t.__init__(self, *args, **kwargs)

ida_kernwin.jobj_wrapper_t.get_dict(self) -> dict
    Retrieve the contents of this object, as a dict
    
    @return a dict containing all kvp's in this object

ida_kernwin.jumpto(*args) -> bool
    This function has the following signatures:
    
        0. jumpto(ea: ida_idaapi.ea_t, opnum: int=-1, uijmp_flags: int=UIJMP_ACTIVATE) -> bool
        1. jumpto(custom_viewer: TWidget *, place: place_t *, x: int, y: int) -> bool
    
    # 0: jumpto(ea: ida_idaapi.ea_t, opnum: int=-1, uijmp_flags: int=UIJMP_ACTIVATE) -> bool
    
    Jump to the specified address (ui_jumpto). 
            
    @returns success
    
    # 1: jumpto(custom_viewer: TWidget *, place: place_t *, x: int, y: int) -> bool
    
    Set cursor position in custom ida viewer. 
            
    @returns success

ida_kernwin.l_compare2(t1: "place_t", t2: "place_t", ud: "void *") -> int

ida_kernwin.line_rendering_output_entries_refs_t

ida_kernwin.line_rendering_output_entries_refs_t.__eq__(self, r: "line_rendering_output_entries_refs_t") -> bool

ida_kernwin.line_rendering_output_entries_refs_t.__getitem__(self, i: "size_t") -> "line_rendering_output_entry_t *const &"

ida_kernwin.line_rendering_output_entries_refs_t.__init__(self, *args)

ida_kernwin.line_rendering_output_entries_refs_t.__len__(self) -> "size_t"

ida_kernwin.line_rendering_output_entries_refs_t.__ne__(self, r: "line_rendering_output_entries_refs_t") -> bool

ida_kernwin.line_rendering_output_entries_refs_t.__setitem__(self, i: "size_t", v: "line_rendering_output_entry_t") -> None

ida_kernwin.line_rendering_output_entries_refs_t._del(self, x: "line_rendering_output_entry_t") -> bool

ida_kernwin.line_rendering_output_entries_refs_t._internal_push_back(self, e: "line_rendering_output_entry_t") -> None

ida_kernwin.line_rendering_output_entries_refs_t.add_unique(self, x: "line_rendering_output_entry_t") -> bool

ida_kernwin.line_rendering_output_entries_refs_t.append(self, x: "line_rendering_output_entry_t") -> None

ida_kernwin.line_rendering_output_entries_refs_t.at(self, _idx: "size_t") -> "line_rendering_output_entry_t *const &"

ida_kernwin.line_rendering_output_entries_refs_t.begin(self, *args) -> "qvector< line_rendering_output_entry_t * >::const_iterator"

ida_kernwin.line_rendering_output_entries_refs_t.capacity(self) -> "size_t"

ida_kernwin.line_rendering_output_entries_refs_t.clear(self) -> None

ida_kernwin.line_rendering_output_entries_refs_t.empty(self) -> bool

ida_kernwin.line_rendering_output_entries_refs_t.end(self, *args) -> "qvector< line_rendering_output_entry_t * >::const_iterator"

ida_kernwin.line_rendering_output_entries_refs_t.erase(self, *args) -> "qvector< line_rendering_output_entry_t * >::iterator"

ida_kernwin.line_rendering_output_entries_refs_t.extend(self, x: "line_rendering_output_entries_refs_t") -> None

ida_kernwin.line_rendering_output_entries_refs_t.extract(self) -> "line_rendering_output_entry_t **"

ida_kernwin.line_rendering_output_entries_refs_t.find(self, *args) -> "qvector< line_rendering_output_entry_t * >::const_iterator"

ida_kernwin.line_rendering_output_entries_refs_t.has(self, x: "line_rendering_output_entry_t") -> bool

ida_kernwin.line_rendering_output_entries_refs_t.inject(self, s: "line_rendering_output_entry_t **", len: "size_t") -> None

ida_kernwin.line_rendering_output_entries_refs_t.insert(self, it: "qvector< line_rendering_output_entry_t * >::iterator", x: "line_rendering_output_entry_t") -> "qvector< line_rendering_output_entry_t * >::iterator"

ida_kernwin.line_rendering_output_entries_refs_t.pop_back(self) -> None

ida_kernwin.line_rendering_output_entries_refs_t.push_back(self, *args) -> "line_rendering_output_entry_t *&"

ida_kernwin.line_rendering_output_entries_refs_t.push_back(self, e)

ida_kernwin.line_rendering_output_entries_refs_t.qclear(self) -> None

ida_kernwin.line_rendering_output_entries_refs_t.reserve(self, cnt: "size_t") -> None

ida_kernwin.line_rendering_output_entries_refs_t.resize(self, *args) -> None

ida_kernwin.line_rendering_output_entries_refs_t.size(self) -> "size_t"

ida_kernwin.line_rendering_output_entries_refs_t.swap(self, r: "line_rendering_output_entries_refs_t") -> None

ida_kernwin.line_rendering_output_entries_refs_t.truncate(self) -> None

ida_kernwin.line_rendering_output_entry_t

ida_kernwin.line_rendering_output_entry_t.__eq__(self, r: "line_rendering_output_entry_t") -> bool

ida_kernwin.line_rendering_output_entry_t.__init__(self, *args)

ida_kernwin.line_rendering_output_entry_t.__ne__(self, r: "line_rendering_output_entry_t") -> bool

ida_kernwin.line_rendering_output_entry_t.cpx
    number of char to start from, valid if LROEF_CPS_RANGE

ida_kernwin.line_rendering_output_entry_t.flags
    line_rendering_output_entry_t flags

ida_kernwin.line_rendering_output_entry_t.is_bg_color_direct(self) -> bool

ida_kernwin.line_rendering_output_entry_t.is_bg_color_empty(self) -> bool

ida_kernwin.line_rendering_output_entry_t.is_bg_color_key(self) -> bool

ida_kernwin.line_rendering_output_entry_t.nchars
    chars count, valid if LROEF_CPS_RANGE

ida_kernwin.line_section_t

ida_kernwin.line_section_t.__eq__(self, r: "line_section_t") -> bool

ida_kernwin.line_section_t.__init__(self)

ida_kernwin.line_section_t.__ne__(self, r: "line_section_t") -> bool

ida_kernwin.line_section_t.contains(self, x: "cpidx_t") -> bool

ida_kernwin.line_section_t.is_closed(self) -> bool

ida_kernwin.line_section_t.is_open(self) -> bool

ida_kernwin.line_section_t.valid(self) -> bool

ida_kernwin.linearray_t

ida_kernwin.linearray_t.__init__(self, _ud: "void *")

ida_kernwin.linearray_t.beginning(self) -> bool
    Are we at the beginning?

ida_kernwin.linearray_t.down(self) -> str
    Get a line from down direction. place is ok BEFORE 
            

ida_kernwin.linearray_t.ending(self) -> bool

ida_kernwin.linearray_t.get_bg_color(self) -> "bgcolor_t"
    Get current background color. (the same behavior as with get_place(): good before down() and after up()) 
            

ida_kernwin.linearray_t.get_dlnnum(self) -> int
    Get default line number. (the same behavior as with get_place(): good before down() and after up()) 
            

ida_kernwin.linearray_t.get_linecnt(self) -> int
    Get number of lines for the current place. (the same behavior as with get_place(): good before down() and after up()) 
            

ida_kernwin.linearray_t.get_pfx_color(self) -> "bgcolor_t"
    Get current prefix color. (the same behavior as with get_place(): good before down() and after up()) 
            

ida_kernwin.linearray_t.get_place(self) -> "place_t *"
    Get the current place. If called before down(), then returns place of line which will be returned by down(). If called after up(), then returns place if line returned by up(). 
            

ida_kernwin.linearray_t.set_place(self, new_at: "place_t") -> int
    Position the array. This function must be called before calling any other member functions.
    linearray_t doesn't own place_t structures. The caller must take care of place_t objects.
    
    @param new_at: new position of the array
    @returns the delta of lines that the linearray_t had to adjust the place by. 
    For example, if the place_t has a lnnum of 5, but it turns out, upon generating lines, 
    that the number of lines for that particular place is only 2, then 3 will be returned.

ida_kernwin.linearray_t.set_userdata(self, userd: "void *") -> None
    Change the user data.

ida_kernwin.linearray_t.up(self) -> str
    Get a line from up direction. place is ok AFTER 
            

ida_kernwin.linearray_t.userdata(self) -> "void *"
    Get pointer to user data.

ida_kernwin.lines_rendering_input_t

ida_kernwin.lines_rendering_input_t.__init__(self)

ida_kernwin.lines_rendering_input_t.sections_lines
    references to the lines that are used for rendering

ida_kernwin.lines_rendering_input_t.sync_group
    the 'synced' group 'widget' (see ui_get_lines_rendering_info) belongs to, or nullptr

ida_kernwin.lines_rendering_output_t

ida_kernwin.lines_rendering_output_t.__eq__(self, r: "lines_rendering_output_t") -> bool

ida_kernwin.lines_rendering_output_t.__init__(self)

ida_kernwin.lines_rendering_output_t.__ne__(self, r: "lines_rendering_output_t") -> bool

ida_kernwin.lines_rendering_output_t.clear(self) -> None

ida_kernwin.lines_rendering_output_t.swap(self, r: "lines_rendering_output_t") -> None

ida_kernwin.listing_location_t

ida_kernwin.listing_location_t.__init__(self)

ida_kernwin.load_custom_icon(file_name = None, data = None, format = None)
    Load an icon from a file (ui_load_custom_icon_file). Also see load_custom_icon(const void *, unsigned int, const char *) 
            
    @param file_name: path to file
    @returns icon id

ida_kernwin.load_dbg_dbginfo(*args) -> bool
    Load debugging information from a file. 
            
    @param path: path to file
    @param li: loader input. if nullptr, check DBG_NAME_KEY
    @param base: loading address
    @param verbose: dump status to message window

ida_kernwin.lookup_key_code(key: int, shift: int, is_qt: bool) -> "ushort"
    Get shortcut code previously created by ui_get_key_code. 
            
    @param key: key constant
    @param shift: modifiers
    @param is_qt: are we using gui version?

ida_kernwin.mbox_internal
    internal error

ida_kernwin.msg(message)
    Display a message in the message window
    
    @param message: message to print

ida_kernwin.msg_activated
    The message window is activated. 
              

ida_kernwin.msg_clear() -> None
    Clear the "Output" window.

ida_kernwin.msg_click
    Click event. 
              

ida_kernwin.msg_closed
    View closed. 
              

ida_kernwin.msg_dblclick
    Double click event. 
              

ida_kernwin.msg_deactivated
    The message window is deactivated. 
              

ida_kernwin.msg_get_lines(count: int = -1) -> "PyObject *"
    Retrieve the last 'count' lines from the output window, in reverse order (from most recent, to least recent) 
            
    @param count: The number of lines to retrieve. -1 means: all

ida_kernwin.msg_keydown
    Key down event. 
              

ida_kernwin.msg_save(path: str) -> bool
    Save the "Output" window contents into a file 
            
    @param path: The path of the file to save the contents into. An empty path means that the user will be prompted for the destination and, if the file already exists, the user will be asked to confirm before overriding its contents. Upon return, 'path' will contain the path that the user chose.
    @returns success

ida_kernwin.nomem(*args) -> None

ida_kernwin.open_bookmarks_window(w: "TWidget *") -> "TWidget *"
    Open the bookmarks window (ui_open_builtin). 
            
    @param w: The widget for which the bookmarks will open. For example, this can be an IDAView, or Enums view, etc.
    @returns pointer to resulting window

ida_kernwin.open_bpts_window(ea: ida_idaapi.ea_t) -> "TWidget *"
    Open the breakpoints window (ui_open_builtin). 
            
    @param ea: index of entry to select by default
    @returns pointer to resulting window

ida_kernwin.open_calls_window(ea: ida_idaapi.ea_t) -> "TWidget *"
    Open the function calls window (ui_open_builtin). 
            
    @returns pointer to resulting window

ida_kernwin.open_disasm_window(window_title: str, ranges: "rangevec_t" = None) -> "TWidget *"
    Open a disassembly view (ui_open_builtin). 
            
    @param window_title: title of view to open
    @param ranges: if != nullptr, then display a flow chart with the specified ranges
    @returns pointer to resulting window

ida_kernwin.open_exports_window(ea: ida_idaapi.ea_t) -> "TWidget *"
    Open the exports window (ui_open_builtin). 
            
    @param ea: index of entry to select by default
    @returns pointer to resulting window

ida_kernwin.open_form(*args)
    Display a dockable modeless dialog box and return a handle to it. The modeless form can be closed in the following ways:
    * by pressing the small 'x' in the window title
    * by calling form_actions_t::close() from the form callback (form_actions_t)
    
    
    
    @param form: dialog box as a string. see ask_form()/open_form()
    @param flags: Widget open flags
    @returns handle to the form or nullptr. the handle can be used with TWidget functions: close_widget()/activate_widget()/etc

ida_kernwin.open_frame_window(pfn: "func_t *", offset: int) -> "TWidget *"
    Open the frame window for the given function (ui_open_builtin). 
            
    @param pfn: function to analyze
    @param offset: offset where the cursor is placed
    @returns pointer to resulting window if 'pfn' is a valid function and the window was displayed, 
     nullptr otherwise

ida_kernwin.open_funcs_window(ea: ida_idaapi.ea_t) -> "TWidget *"
    Open the 'Functions' window (ui_open_builtin). 
            
    @param ea: index of entry to select by default
    @returns pointer to resulting window

ida_kernwin.open_hexdump_window(window_title: str) -> "TWidget *"
    Open a hexdump view (ui_open_builtin). 
            
    @param window_title: title of view to open
    @returns pointer to resulting window

ida_kernwin.open_imports_window(ea: ida_idaapi.ea_t) -> "TWidget *"
    Open the exports window (ui_open_builtin). 
            
    @param ea: index of entry to select by default
    @returns pointer to resulting window

ida_kernwin.open_loctypes_window(ordinal: int, cursor: "tif_cursor_t const *" = None) -> "TWidget *"
    Open the local types window (ui_open_builtin2). 
            
    @param ordinal: ordinal of type to select by default
    @param cursor: cursor to the type member
    @returns pointer to resulting window

ida_kernwin.open_modules_window() -> "TWidget *"
    Open the modules window (ui_open_builtin). 
            
    @returns pointer to resulting window

ida_kernwin.open_names_window(ea: ida_idaapi.ea_t) -> "TWidget *"
    Open the names window (ui_open_builtin). 
            
    @param ea: index of entry to select by default
    @returns pointer to resulting window

ida_kernwin.open_navband_window(ea: ida_idaapi.ea_t, zoom: int) -> "TWidget *"
    Open the navigation band window (ui_open_builtin). 
            
    @param ea: sets the address of the navband arrow
    @param zoom: sets the navband zoom level
    @returns pointer to resulting window

ida_kernwin.open_notepad_window() -> "TWidget *"
    Open the notepad window (ui_open_builtin). 
            
    @returns pointer to resulting window

ida_kernwin.open_problems_window(ea: ida_idaapi.ea_t) -> "TWidget *"
    Open the problems window (ui_open_builtin). 
            
    @param ea: index of entry to select by default
    @returns pointer to resulting window

ida_kernwin.open_segments_window(ea: ida_idaapi.ea_t) -> "TWidget *"
    Open the segments window (ui_open_builtin). 
            
    @param ea: index of entry to select by default
    @returns pointer to resulting window

ida_kernwin.open_segregs_window(ea: ida_idaapi.ea_t) -> "TWidget *"
    Open the segment registers window (ui_open_builtin). 
            
    @param ea: index of entry to select by default
    @returns pointer to resulting window

ida_kernwin.open_selectors_window() -> "TWidget *"
    Open the selectors window (ui_open_builtin). 
            
    @returns pointer to resulting window

ida_kernwin.open_signatures_window() -> "TWidget *"
    Open the signatures window (ui_open_builtin). 
            
    @returns pointer to resulting window

ida_kernwin.open_stack_window() -> "TWidget *"
    Open the call stack window (ui_open_builtin). 
            
    @returns pointer to resulting window

ida_kernwin.open_strings_window(*args) -> "TWidget *"
    Open the 'Strings' window (ui_open_builtin). 
            
    @param ea: index of entry to select by default
    @param selstart: only display strings that occur within this range
    @param selend: only display strings that occur within this range
    @returns pointer to resulting window

ida_kernwin.open_threads_window() -> "TWidget *"
    Open the threads window (ui_open_builtin). 
            
    @returns pointer to resulting window

ida_kernwin.open_til_view_window(tif: "tinfo_t", cursor: "tif_cursor_t const *" = None) -> "TWidget *"
    Open the sub-til window (ui_open_builtin2). 
            
    @param tif: tif to open
    @param cursor: cursor to the type member
    @returns pointer to resulting window

ida_kernwin.open_tils_window() -> "TWidget *"
    Open the type libraries window (ui_open_builtin). 
            
    @returns pointer to resulting window

ida_kernwin.open_trace_window() -> "TWidget *"
    Open the tracing window (ui_open_builtin). 
            
    @returns pointer to resulting window

ida_kernwin.open_url(url: str) -> None
    Open the given url (ui_open_url)

ida_kernwin.open_xrefs_window(ea: ida_idaapi.ea_t) -> "TWidget *"
    Open the cross references window (ui_open_builtin). 
            
    @param ea: index of entry to select by default
    @returns pointer to resulting window

ida_kernwin.parse_tagged_line_sections(out: "tagged_line_sections_t", line: str) -> bool
    Collect tagged sections in a color-tagged line (produced by `place_t::generate`)
    
    @param out: sections storage
    @param line: input line
    @returns success

ida_kernwin.place_t

ida_kernwin.place_t.__init__(self, *args, **kwargs)

ida_kernwin.place_t._print(self, ud: "void *") -> None

ida_kernwin.place_t.adjust(self, ud: "void *") -> None
    Adjust the current location to point to a displayable object. This function validates the location and makes sure that it points to an existing object. For example, if the location points to the middle of an instruction, it will be adjusted to point to the beginning of the instruction. 
            
    @param ud: pointer to user-defined context data. Is supplied by linearray_t

ida_kernwin.place_t.as_idaplace_t(p: "place_t") -> "idaplace_t *"

ida_kernwin.place_t.as_simpleline_place_t(p: "place_t") -> "simpleline_place_t *"

ida_kernwin.place_t.as_tiplace_t(p: "place_t") -> "tiplace_t *"

ida_kernwin.place_t.beginning(self, ud: "void *") -> bool
    Are we at the first displayable object?. 
            
    @param ud: pointer to user-defined context data. Is supplied by linearray_t
    @returns true if the current location points to the first displayable object

ida_kernwin.place_t.clone(self) -> "place_t *"
    Clone the location. 
            
    @returns a pointer to a copy of the current location in dynamic memory

ida_kernwin.place_t.compare(self, t2: "place_t") -> int
    Deprecated. Please consider compare2(const place_t *, void *) instead.

ida_kernwin.place_t.compare2(self, t2: "place_t", arg3: "void *") -> int
    Compare two locations except line numbers (lnnum). This function is used to organize loops. For example, if the user has selected an range, its boundaries are remembered as location objects. Any operation within the selection will have the following look: for ( loc=starting_location; loc < ending_location; loc.next() ) In this loop, the comparison function is used. 
            
    @param t2: the place to compare this one to.
    @retval -1: if the current location is less than 't2'
    @retval 0: if the current location is equal to than 't2'
    @retval 1: if the current location is greater than 't2'

ida_kernwin.place_t.copyfrom(self, _from: "place_t") -> None
    Copy the specified location object to the current object.

ida_kernwin.place_t.deserialize(self, _in: "bytevec_t const &") -> bool
    De-serialize into this instance. 'pptr' should be incremented by as many bytes as de-serialization consumed. 
            
    @returns whether de-serialization was successful

ida_kernwin.place_t.ending(self, ud: "void *") -> bool
    Are we at the last displayable object?. 
            
    @param ud: pointer to user-defined context data. Is supplied by linearray_t
    @returns true if the current location points to the last displayable object

ida_kernwin.place_t.enter(self, arg2: "uint32 *") -> "place_t *"
    Visit this place, possibly 'unhiding' a section of text. If entering that place required some expanding, a place_t should be returned that represents that section, plus some flags for later use by 'leave()'. 
            
    @returns a place_t corresponding to the beginning of the section of text that had to be expanded. That place_t's leave() will be called with the flags contained in 'out_flags' when the user navigates away from it.

ida_kernwin.place_t.generate(self, ud, maxsize: int) -> Tuple[List[str], int, int, int]
    Generate text lines for the current location.
    
    @param ud The user data object
    @param maxsize The maximum number of lines to generate
    @return a tuple (lines-of-text, default-line-number, prefix-color, background-color)

ida_kernwin.place_t.id(self) -> int
    Get the place's ID (i.e., the value returned by register_place_class()) 
            
    @returns the id

ida_kernwin.place_t.leave(self, arg2: int) -> None
    Leave this place, possibly 'hiding' a section of text that was previously expanded (at enter()-time.) 
            

ida_kernwin.place_t.lnnum
    Number of line within the current object.

ida_kernwin.place_t.makeplace(self, ud: "void *", x: int, lnnum: int) -> "place_t *"
    Map a number to a location. When the user clicks on the scrollbar and drags it, we need to determine the location corresponding to the new scrollbar position. This function is used to determine it. It builds a location object for the specified 'x' and returns a pointer to it. 
            
    @param ud: pointer to user-defined context data. Is supplied by linearray_t
    @param x: number to map
    @param lnnum: line number to initialize 'lnnum'
    @returns a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES

ida_kernwin.place_t.name(self) -> str
    Get this place type name. All instances of a given class must return the same string. 
            
    @returns the place type name. Please try and pick something that is not too generic, as it might clash w/ other plugins. A good practice is to prefix the class name with the name of your plugin. E.g., "myplugin:srcplace_t".

ida_kernwin.place_t.next(self, ud: "void *") -> bool
    Move to the next displayable location. 
            
    @param ud: pointer to user-defined context data. Is supplied by linearray_t
    @returns success

ida_kernwin.place_t.prev(self, ud: "void *") -> bool
    Move to the previous displayable location. 
            
    @param ud: pointer to user-defined context data. Is supplied by linearray_t
    @returns success

ida_kernwin.place_t.rebase(self, arg2: "segm_move_infos_t const &") -> bool
    Rebase the place instance 
            
    @returns true if place was rebased, false otherwise

ida_kernwin.place_t.serialize(self) -> None
    Serialize this instance. It is fundamental that all instances of a particular subclass of of place_t occupy the same number of bytes when serialized. 
            

ida_kernwin.place_t.toea(self) -> ida_idaapi.ea_t
    Map the location to an ea_t. 
            
    @returns the corresponding ea_t, or BADADDR;

ida_kernwin.place_t.touval(self, ud: "void *") -> int
    Map the location to a number. This mapping is used to draw the vertical scrollbar. 
            
    @param ud: pointer to user-defined context data. Is supplied by linearray_t

ida_kernwin.plgform_close(py_link: "PyObject *", options: int) -> None

ida_kernwin.plgform_get_widget(py_link: "PyObject *") -> "TWidget *"

ida_kernwin.plgform_new() -> "PyObject *"

ida_kernwin.plgform_show(*args) -> bool

ida_kernwin.process_ui_action(name: str, flags: int = 0)
    Invokes an IDA UI action by name
    
    @param name:  action name
    @param flags: reserved
    @return: Boolean

ida_kernwin.prompt_function_prototype(out_tif: "tinfo_t", pfn: "func_t *", tif: "tinfo_t", name: str) -> str
    Open function prototype editor to edit function type and create new type. Allows to change the function prototype either in the "old" one-liner mode or in the new multi-line editor, which supports shortcuts, etc. Note: changes will not apply! It is the caller's job to apply the resulting out_tif. Parameters: 
            
    @param out_tif: - (tinfo_t *) tif for created type
    @param pfn: - (func_t *) editing function
    @param tif: - (tinfo_t *) current function type
    @param name: - (const char *) function name
    @returns true if new type created successfully

ida_kernwin.py_chooser_base_t_get_row(chobj: "chooser_base_t", n: "size_t") -> "PyObject *"

ida_kernwin.py_get_ask_form() -> "size_t"

ida_kernwin.py_get_open_form() -> "size_t"

ida_kernwin.py_load_custom_icon_data(data: "PyObject *", format: str) -> int

ida_kernwin.py_load_custom_icon_fn(filename: str) -> int

ida_kernwin.py_register_compiled_form(py_form: "PyObject *") -> None

ida_kernwin.py_unregister_compiled_form(py_form: "PyObject *") -> None

ida_kernwin.pyidag_bind(_self: "PyObject *") -> bool

ida_kernwin.pyidag_unbind(_self: "PyObject *") -> bool

ida_kernwin.pyscv_add_line(py_this: "PyObject *", py_sl: "PyObject *") -> bool

ida_kernwin.pyscv_clear_lines(py_this: "PyObject *") -> "PyObject *"

ida_kernwin.pyscv_close(py_this: "PyObject *") -> None

ida_kernwin.pyscv_count(py_this: "PyObject *") -> "size_t"

ida_kernwin.pyscv_del_line(py_this: "PyObject *", nline: "size_t") -> bool

ida_kernwin.pyscv_edit_line(py_this: "PyObject *", nline: "size_t", py_sl: "PyObject *") -> bool

ida_kernwin.pyscv_get_current_line(py_this: "PyObject *", mouse: bool, notags: bool) -> "PyObject *"

ida_kernwin.pyscv_get_current_word(py_this: "PyObject *", mouse: bool) -> "PyObject *"

ida_kernwin.pyscv_get_line(py_this: "PyObject *", nline: "size_t") -> "PyObject *"

ida_kernwin.pyscv_get_pos(py_this: "PyObject *", mouse: bool) -> "PyObject *"

ida_kernwin.pyscv_get_selection(py_this: "PyObject *") -> "PyObject *"

ida_kernwin.pyscv_get_widget(py_this: "PyObject *") -> "TWidget *"

ida_kernwin.pyscv_init(py_link: "PyObject *", title: str) -> "PyObject *"

ida_kernwin.pyscv_insert_line(py_this: "PyObject *", nline: "size_t", py_sl: "PyObject *") -> bool

ida_kernwin.pyscv_is_focused(py_this: "PyObject *") -> bool

ida_kernwin.pyscv_jumpto(py_this: "PyObject *", ln: "size_t", x: int, y: int) -> bool

ida_kernwin.pyscv_patch_line(py_this: "PyObject *", nline: "size_t", offs: "size_t", value: int) -> bool

ida_kernwin.pyscv_refresh(py_this: "PyObject *") -> bool

ida_kernwin.pyscv_show(py_this: "PyObject *") -> bool

ida_kernwin.qcleanline(*args) -> str
    Performs some cleanup operations to a line. 
            
    @param buf: string to modify
    @param cmt_char: character that denotes the start of a comment:
    * the entire text is removed if the line begins with this character (ignoring leading spaces)
    * all text after (and including) this character is removed if flag CLNL_FINDCMT is set
    @param flags: a combination of line cleanup flags. defaults to CLNL_TRIM
    @returns length of line

ida_kernwin.quick_widget_commands_t

ida_kernwin.quick_widget_commands_t.__init__(self, callback)

ida_kernwin.quick_widget_commands_t._ah_t

ida_kernwin.quick_widget_commands_t._ah_t.__init__(self, parent, cmd_id)

ida_kernwin.quick_widget_commands_t._ah_t.activate(self, ctx)

ida_kernwin.quick_widget_commands_t._ah_t.update(self, ctx)

ida_kernwin.quick_widget_commands_t._cmd_t

ida_kernwin.quick_widget_commands_t._cmd_t.__init__(self, caption, flags, menu_index, icon, emb, shortcut)

ida_kernwin.quick_widget_commands_t.add(self, caption, flags, menu_index, icon, emb, shortcut)

ida_kernwin.quick_widget_commands_t.populate_popup(self, widget, popup)

ida_kernwin.read_range_selection(v: "TWidget *") -> "ea_t *, ea_t *"
    Get the address range for the selected range boundaries, this is the convenient function for read_selection() 
            
    @param v: view, nullptr means the last active window containing addresses
    @retval 0: no range is selected
    @retval 1: ok, start ea and end ea are filled

ida_kernwin.read_selection(v, p1, p2)
    Read the user selection, and store its information in p1 (from) and p2 (to).
    
    This can be used as follows:
    
    
    >>> p1 = ida_kernwin.twinpos_t()
    p2 = ida_kernwin.twinpos_t()
    view = ida_kernwin.get_current_viewer()
    ida_kernwin.read_selection(view, p1, p2)
    
    
    At that point, p1 and p2 hold information for the selection.
    But, the 'at' property of p1 and p2 is not properly typed.
    To specialize it, call #place() on it, passing it the view
    they were retrieved from. Like so:
    
    
    >>> place0 = p1.place(view)
    place1 = p2.place(view)
    
    
    This will effectively "cast" the place into a specialized type,
    holding proper information, depending on the view type (e.g.,
    disassembly, structures, enums, ...)
    
    @param v: The view to retrieve the selection for.
    @param p1: Storage for the "from" part of the selection.
    @param p2: Storage for the "to" part of the selection.
    @return: a bool value indicating success.

ida_kernwin.refresh_chooser(title: str) -> bool
    Mark a non-modal custom chooser for a refresh (ui_refresh_chooser). 
            
    @param title: title of chooser
    @returns success

ida_kernwin.refresh_choosers() -> None

ida_kernwin.refresh_custom_viewer(custom_viewer: "TWidget *") -> None
    Refresh custom ida viewer (ui_refresh_custom_viewer)

ida_kernwin.refresh_idaview() -> None
    Refresh marked windows (ui_refreshmarked)

ida_kernwin.refresh_idaview_anyway() -> None
    Refresh all disassembly views (ui_refresh), forces an immediate refresh. Please consider request_refresh() instead 
            

ida_kernwin.refresh_navband(force: bool) -> None
    Refresh navigation band if changed (ui_refresh_navband). 
            
    @param force: refresh regardless

ida_kernwin.register_action(desc: "action_desc_t") -> bool
    Create a new action (ui_register_action). After an action has been created, it is possible to attach it to menu items (attach_action_to_menu()), or to popup menus (attach_action_to_popup()).
    Because the actions will need to call the handler's activate() and update() methods at any time, you shouldn't build your action handler on the stack.
    Please see the SDK's "ht_view" plugin for an example how to register actions. 
            
    @param desc: action to register
    @returns success

ida_kernwin.register_addon(info: "addon_info_t") -> int
    Register an add-on. Show its info in the About box. For plugins, should be called from init() function (repeated calls with the same product code overwrite previous entries) returns: index of the add-on in the list, or -1 on error 
            

ida_kernwin.register_and_attach_to_menu(menupath: str, name: str, label: str, shortcut: str, flags: int, handler: "action_handler_t *", owner: "void *", action_desc_t_flags: int) -> bool
    Helper.
    You are not encouraged to use this, as it mixes flags for both register_action(), and attach_action_to_menu().
    The only reason for its existence is to make it simpler to port existing plugins to the new actions API. 
            

ida_kernwin.register_timer(interval, callback)
    Register a timer
    
    @param interval: Interval in milliseconds
    @param callback: A Python callable that takes no parameters and returns an integer.
                     The callback may return:
                     -1   : to unregister the timer
                     >= 0 : the new or same timer interval
    @return: None or a timer object

ida_kernwin.remove_command_interpreter(cli_idx: int) -> None
    Remove command line interpreter (ui_install_cli)

ida_kernwin.renderer_pos_info_t

ida_kernwin.renderer_pos_info_t.__eq__(self, r: "renderer_pos_info_t") -> bool

ida_kernwin.renderer_pos_info_t.__init__(self)

ida_kernwin.renderer_pos_info_t.__ne__(self, r: "renderer_pos_info_t") -> bool

ida_kernwin.renderer_pos_info_t.cx
    the X coords of the character in the current line. When in graph mode: X coords of the character in 'node'. 
    When in flat mode: X coords of the character in the line, w/o 
    taking scrolling into consideration. 
            

ida_kernwin.renderer_pos_info_t.cy
    the Y coords of the character. When in graph mode: Y coords of the character in 'node'. 
    When in flat mode: Line number, starting from the top. 
            

ida_kernwin.renderer_pos_info_t.node
    the node, or -1 if the current renderer is not a graph renderer. 
            

ida_kernwin.renderer_pos_info_t.sx
    the number of chars that are scrolled (flat mode only)

ida_kernwin.repaint_custom_viewer(custom_viewer: "TWidget *") -> None
    Repaint the given widget immediately (ui_repaint_qwidget)

ida_kernwin.replace_wait_box(*args) -> None
    Replace the label of "Please wait dialog box".

ida_kernwin.request_refresh(mask: "uint64", cnd: bool = True) -> None
    Request a refresh of a builtin window. 
            
    @param mask: Window refresh flags
    @param cnd: set if true or clear flag otherwise

ida_kernwin.restore_database_snapshot(snapshot, callback, userdata) -> bool
    Restore a database snapshot.
    
    Note: This call is asynchronous. When it is completed, the callback will be triggered.
    
    @param snapshot the snapshot object
    @param callback a callback function
    @param userdata payload to pass to the callback
    @return success

ida_kernwin.section_lines_refs_t

ida_kernwin.section_lines_refs_t.__eq__(self, r: "section_lines_refs_t") -> bool

ida_kernwin.section_lines_refs_t.__getitem__(self, i: "size_t") -> "twinline_t const *const &"

ida_kernwin.section_lines_refs_t.__init__(self, *args)

ida_kernwin.section_lines_refs_t.__len__(self) -> "size_t"

ida_kernwin.section_lines_refs_t.__ne__(self, r: "section_lines_refs_t") -> bool

ida_kernwin.section_lines_refs_t.__setitem__(self, i: "size_t", v: "twinline_t") -> None

ida_kernwin.section_lines_refs_t._del(self, x: "twinline_t") -> bool

ida_kernwin.section_lines_refs_t.add_unique(self, x: "twinline_t") -> bool

ida_kernwin.section_lines_refs_t.append(self, x: "twinline_t") -> None

ida_kernwin.section_lines_refs_t.at(self, _idx: "size_t") -> "twinline_t const *const &"

ida_kernwin.section_lines_refs_t.begin(self, *args) -> "qvector< twinline_t const * >::const_iterator"

ida_kernwin.section_lines_refs_t.capacity(self) -> "size_t"

ida_kernwin.section_lines_refs_t.clear(self) -> None

ida_kernwin.section_lines_refs_t.empty(self) -> bool

ida_kernwin.section_lines_refs_t.end(self, *args) -> "qvector< twinline_t const * >::const_iterator"

ida_kernwin.section_lines_refs_t.erase(self, *args) -> "qvector< twinline_t const * >::iterator"

ida_kernwin.section_lines_refs_t.extend(self, x: "section_lines_refs_t") -> None

ida_kernwin.section_lines_refs_t.extract(self) -> "twinline_t const **"

ida_kernwin.section_lines_refs_t.find(self, *args) -> "qvector< twinline_t const * >::const_iterator"

ida_kernwin.section_lines_refs_t.has(self, x: "twinline_t") -> bool

ida_kernwin.section_lines_refs_t.inject(self, s: "twinline_t const **", len: "size_t") -> None

ida_kernwin.section_lines_refs_t.insert(self, it: "qvector< twinline_t const * >::iterator", x: "twinline_t") -> "qvector< twinline_t const * >::iterator"

ida_kernwin.section_lines_refs_t.pop_back(self) -> None

ida_kernwin.section_lines_refs_t.push_back(self, *args) -> "twinline_t const *&"

ida_kernwin.section_lines_refs_t.qclear(self) -> None

ida_kernwin.section_lines_refs_t.reserve(self, cnt: "size_t") -> None

ida_kernwin.section_lines_refs_t.resize(self, *args) -> None

ida_kernwin.section_lines_refs_t.size(self) -> "size_t"

ida_kernwin.section_lines_refs_t.swap(self, r: "section_lines_refs_t") -> None

ida_kernwin.section_lines_refs_t.truncate(self) -> None

ida_kernwin.sections_lines_refs_t

ida_kernwin.sections_lines_refs_t.__eq__(self, r: "sections_lines_refs_t") -> bool

ida_kernwin.sections_lines_refs_t.__getitem__(self, i: "size_t") -> "section_lines_refs_t const &"

ida_kernwin.sections_lines_refs_t.__init__(self, *args)

ida_kernwin.sections_lines_refs_t.__len__(self) -> "size_t"

ida_kernwin.sections_lines_refs_t.__ne__(self, r: "sections_lines_refs_t") -> bool

ida_kernwin.sections_lines_refs_t.__setitem__(self, i: "size_t", v: "section_lines_refs_t") -> None

ida_kernwin.sections_lines_refs_t._del(self, x: "section_lines_refs_t") -> bool

ida_kernwin.sections_lines_refs_t.add_unique(self, x: "section_lines_refs_t") -> bool

ida_kernwin.sections_lines_refs_t.append(self, x: "section_lines_refs_t") -> None

ida_kernwin.sections_lines_refs_t.at(self, _idx: "size_t") -> "section_lines_refs_t const &"

ida_kernwin.sections_lines_refs_t.begin(self, *args) -> "qvector< section_lines_refs_t >::const_iterator"

ida_kernwin.sections_lines_refs_t.capacity(self) -> "size_t"

ida_kernwin.sections_lines_refs_t.clear(self) -> None

ida_kernwin.sections_lines_refs_t.empty(self) -> bool

ida_kernwin.sections_lines_refs_t.end(self, *args) -> "qvector< section_lines_refs_t >::const_iterator"

ida_kernwin.sections_lines_refs_t.erase(self, *args) -> "qvector< section_lines_refs_t >::iterator"

ida_kernwin.sections_lines_refs_t.extend(self, x: "sections_lines_refs_t") -> None

ida_kernwin.sections_lines_refs_t.extract(self) -> "section_lines_refs_t *"

ida_kernwin.sections_lines_refs_t.find(self, *args) -> "qvector< section_lines_refs_t >::const_iterator"

ida_kernwin.sections_lines_refs_t.grow(self, *args) -> None

ida_kernwin.sections_lines_refs_t.has(self, x: "section_lines_refs_t") -> bool

ida_kernwin.sections_lines_refs_t.inject(self, s: "section_lines_refs_t", len: "size_t") -> None

ida_kernwin.sections_lines_refs_t.insert(self, it: "qvector< section_lines_refs_t >::iterator", x: "section_lines_refs_t") -> "qvector< section_lines_refs_t >::iterator"

ida_kernwin.sections_lines_refs_t.pop_back(self) -> None

ida_kernwin.sections_lines_refs_t.push_back(self, *args) -> "section_lines_refs_t &"

ida_kernwin.sections_lines_refs_t.qclear(self) -> None

ida_kernwin.sections_lines_refs_t.reserve(self, cnt: "size_t") -> None

ida_kernwin.sections_lines_refs_t.resize(self, *args) -> None

ida_kernwin.sections_lines_refs_t.size(self) -> "size_t"

ida_kernwin.sections_lines_refs_t.swap(self, r: "sections_lines_refs_t") -> None

ida_kernwin.sections_lines_refs_t.truncate(self) -> None

ida_kernwin.set_cancelled() -> None
    Set "Cancelled" flag (ui_set_cancelled)

ida_kernwin.set_code_viewer_handler(code_viewer: "TWidget *", handler_id: "custom_viewer_handler_id_t", handler_or_data: "void *") -> "void *"
    Set a handler for a code viewer event (ui_set_custom_viewer_handler). 
            
    @param code_viewer: the code viewer
    @param handler_id: one of CDVH_ in custom_viewer_handler_id_t
    @param handler_or_data: can be a handler or data. see examples in Functions: custom viewer handlers
    @returns old value of the handler or data

ida_kernwin.set_code_viewer_is_source(code_viewer: "TWidget *") -> bool
    Specify that the given code viewer is used to display source code (ui_set_custom_viewer_handler).

ida_kernwin.set_code_viewer_line_handlers(code_viewer: "TWidget *", click_handler: "code_viewer_lines_click_t *", popup_handler: "code_viewer_lines_click_t *", dblclick_handler: "code_viewer_lines_click_t *", drawicon_handler: "code_viewer_lines_icon_t *", linenum_handler: "code_viewer_lines_linenum_t *") -> None
    Set handlers for code viewer line events. Any of these handlers may be nullptr 
            

ida_kernwin.set_code_viewer_lines_alignment(code_viewer: "TWidget *", align: int) -> bool
    Set alignment for lines in a code viewer (ui_set_custom_viewer_handler).

ida_kernwin.set_code_viewer_lines_icon_margin(code_viewer: "TWidget *", margin: int) -> bool
    Set space allowed for icons in the margin of a code viewer (ui_set_custom_viewer_handler).

ida_kernwin.set_code_viewer_lines_radix(code_viewer: "TWidget *", radix: int) -> bool
    Set radix for values displayed in a code viewer (ui_set_custom_viewer_handler).

ida_kernwin.set_code_viewer_user_data(code_viewer: "TWidget *", ud: "void *") -> bool
    Set the user data on a code viewer (ui_set_custom_viewer_handler).

ida_kernwin.set_custom_viewer_qt_aware(custom_viewer: "TWidget *") -> bool
    Allow the given viewer to interpret Qt events (ui_set_custom_viewer_handler)

ida_kernwin.set_dock_pos(src_ctrl, dest_ctrl, orient, left = 0, top = 0, right = 0, bottom = 0)
    Sets the dock orientation of a window relatively to another window.
    
    Use the left, top, right, bottom parameters if DP_FLOATING is used,
    or if you want to specify the width of docked windows.
    
    @param src_ctrl: Source docking control
    @param dest_ctrl: Destination docking control
    @param orient: One of DP_XXXX constants
    @return: Boolean
    
    Example:
        set_dock_pos('Structures', 'Enums', DP_RIGHT) <- docks the Structures window to the right of Enums window

ida_kernwin.set_execute_sync_availability(tid: "__qthread_t", availability: "execute_sync_availability_t") -> "execute_sync_availability_t"
    Set the availability of the execute_sync functionality for the given thread
    Setting it to `esa_unavailable` will cause the existing requests for this thread to be cancelled. Setting it to `esa_release` will clear the status for this thread, and should be issued right before a call to `qthread_free` is issued.
    
    @param tid: thread id
    @param availability: the availability
    @returns the previous availability

ida_kernwin.set_highlight(viewer: "TWidget *", str: str, flags: int) -> bool
    Set the highlighted identifier in the viewer (ui_set_highlight). 
            
    @param viewer: the viewer
    @param str: the text to match, or nullptr to remove current
    @param flags: combination of HIF_... bits (see set_highlight flags)
    @returns false if an error occurred

ida_kernwin.set_nav_colorizer(callback)
    Set a new colorizer for the navigation band.
    
    The 'callback' is a function of 2 arguments:
       - ea (the EA to colorize for)
       - nbytes (the number of bytes at that EA)
    and must return a 'long' value.
    
    The previous colorizer is returned, allowing
    the new 'callback' to use 'call_nav_colorizer'
    with it.
    
    Note that the previous colorizer is returned
    only the first time set_nav_colorizer() is called:
    due to the way the colorizers API is defined in C,
    it is impossible to chain more than 2 colorizers
    in IDAPython: the original, IDA-provided colorizer,
    and a user-provided one.
    
    Example: colorizer inverting the color provided by the IDA colorizer:
        def my_colorizer(ea, nbytes):
            global ida_colorizer
            orig = ida_kernwin.call_nav_colorizer(ida_colorizer, ea, nbytes)
            return long(~orig)
    
        ida_colorizer = ida_kernwin.set_nav_colorizer(my_colorizer)
    
    @param callback: the new colorizer

ida_kernwin.set_view_renderer_type(v: "TWidget *", rt: "tcc_renderer_type_t") -> None
    Set the type of renderer to use in a view (ui_set_renderer_type)

ida_kernwin.show_wait_box(message: str) -> None
    Display a dialog box with "Please wait...". The behavior of the dialog box can be configured with well-known 
    tokens, that should be placed at the start of the format string: 
     "NODELAY\n": the dialog will show immediately, instead of 
     appearing after usual grace threshold 
     "HIDECANCEL\n": the cancel button won't be added to the dialog box 
     and user_cancelled() will always return false (but 
     can be called to refresh UI) 
     Using "HIDECANCEL" implies "NODELAY" 
    Plugins must call hide_wait_box() to close the dialog box, otherwise 
    the user interface will remain disabled. 
     Note that, if the wait dialog is already visible, show_wait_box() will 
     1) push the currently-displayed text on a stack 
     2) display the new text 
    Then, when hide_wait_box() is called, if that stack isn't empty its top 
    label will be popped and restored in the wait dialog. 
    This implies that a plugin should call hide_wait_box() exactly as many 
    times as it called show_wait_box(), or the wait dialog might remain 
    visible and block the UI. 
    Also, in case the plugin knows the wait dialog is currently displayed, 
    alternatively it can call replace_wait_box(), to replace the text of the
    dialog without pushing the currently-displayed text on the stack. 
            

ida_kernwin.simplecustviewer_t
    The base class for implementing simple custom viewers

ida_kernwin.simplecustviewer_t.AddLine(self, line, fgcolor = None, bgcolor = None)
    Adds a colored line to the view
    @return: Boolean

ida_kernwin.simplecustviewer_t.ClearLines(self)
    Clears all the lines

ida_kernwin.simplecustviewer_t.Close(self)
    Destroys the view.
    One has to call Create() afterwards.
    Show() can be called and it will call Create() internally.
    @return: Boolean

ida_kernwin.simplecustviewer_t.Count(self)
    Returns the number of lines in the view

ida_kernwin.simplecustviewer_t.Create(self, title)
    Creates the custom view. This should be the first method called after instantiation
    
    @param title: The title of the view
    @return: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
             In this case better close existing windows

ida_kernwin.simplecustviewer_t.DelLine(self, lineno)
    Deletes an existing line
    @return: Boolean

ida_kernwin.simplecustviewer_t.EditLine(self, lineno, line, fgcolor = None, bgcolor = None)
    Edits an existing line.
    @return: Boolean

ida_kernwin.simplecustviewer_t.GetCurrentLine(self, mouse = 0, notags = 0)
    Returns the current line.
    @param mouse: Current line at mouse pos
    @param notags: If True then tag_remove() will be called before returning the line
    @return: Returns the current line (colored or uncolored) or None on failure

ida_kernwin.simplecustviewer_t.GetCurrentWord(self, mouse = 0)
    Returns the current word
    @param mouse: Use mouse position or cursor position
    @return: None if failed or a String containing the current word at mouse or cursor

ida_kernwin.simplecustviewer_t.GetLine(self, lineno)
    Returns a line
    @param lineno: The line number
    @return:
        Returns a tuple (colored_line, fgcolor, bgcolor) or None

ida_kernwin.simplecustviewer_t.GetLineNo(self, mouse = 0)
    Calls GetPos() and returns the current line number or -1 on failure

ida_kernwin.simplecustviewer_t.GetPos(self, mouse = 0)
    Returns the current cursor or mouse position.
    @param mouse: return mouse position
    @return: Returns a tuple (lineno, x, y)

ida_kernwin.simplecustviewer_t.GetSelection(self)
    Returns the selected range or None
    @return:
        - tuple(x1, y1, x2, y2)
        - None if no selection

ida_kernwin.simplecustviewer_t.GetWidget(self)
    Return the TWidget underlying this view.
    
    @return: The TWidget underlying this view, or None.

ida_kernwin.simplecustviewer_t.InsertLine(self, lineno, line, fgcolor = None, bgcolor = None)
    Inserts a line in the given position
    @return: Boolean

ida_kernwin.simplecustviewer_t.IsFocused(self)
    Returns True if the current view is the focused view

ida_kernwin.simplecustviewer_t.Jump(self, lineno, x = 0, y = 0)

ida_kernwin.simplecustviewer_t.OnPopup(self, form, popup_handle)
    Context menu popup is about to be shown. Create items dynamically if you wish
    @return: Boolean. True if you handled the event

ida_kernwin.simplecustviewer_t.PatchLine(self, lineno, offs, value)
    Patches an existing line character at the given offset. This is a low level function. You must know what you're doing

ida_kernwin.simplecustviewer_t.Refresh(self)

ida_kernwin.simplecustviewer_t.RefreshCurrent(self)
    Refreshes the current line only

ida_kernwin.simplecustviewer_t.Show(self)
    Shows an already created view. It the view was closed, then it will call Create() for you
    @return: Boolean

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.__init__(self, v)

ida_kernwin.simplecustviewer_t.UI_Hooks_Trampoline.populating_widget_popup(self, form, popup_handle)

ida_kernwin.simplecustviewer_t.__init__(self)

ida_kernwin.simplecustviewer_t.__make_sl_arg(line, fgcolor = None, bgcolor = None)

ida_kernwin.simpleline_place_t

ida_kernwin.simpleline_place_t.__init__(self, *args, **kwargs)

ida_kernwin.simpleline_place_t.n
    line number

ida_kernwin.simpleline_t

ida_kernwin.simpleline_t.__init__(self, *args)

ida_kernwin.simpleline_t.bgcolor
    line background color

ida_kernwin.simpleline_t.color
    line prefix color

ida_kernwin.simpleline_t.line
    line text

ida_kernwin.str2ea(*args) -> "uint64 *"
    Convert string to linear address. Tries to interpret the string as: 
    1) "current IP" keyword if supported by assembler (e.g. "$" in x86) 
    2) segment:offset expression, where "segment" may be a name or a fixed segment register (e.g. cs, ds) 
    3) just segment name/register (translated to segment's start address) 
    4) a name in the database (or debug name during debugging) 
    5) hexadecimal value without prefix or suffix 
    6) +delta or -delta, where numerical 'delta' is added to or subtracted from 'screen_ea' 
    7) register name (only during debugging) 
    8) if all else fails, try to evaluate 'str' as an IDC expression
    
    @param str: string to parse
    @param screen_ea: the current address in the disassembly/pseudocode view
    @returns success

ida_kernwin.str2ea_ex(*args) -> "uint64 *"
    Same as str2ea() but possibly with some steps skipped. 
            
    @param out: the buffer to put the result
    @param str: string to parse
    @param screen_ea: the current address in the disassembly/pseudocode view
    @param flags: see String to address conversion flags
    @returns success

ida_kernwin.strarray(array: "strarray_t", array_size: "size_t", code: int) -> str
    Find a line with the specified code in the strarray_t array. If the last element of the array has code==0 then it is considered as the default entry. 
    If no default entry exists and the code is not found, strarray() returns "". 
            

ida_kernwin.strarray_t

ida_kernwin.strarray_t.__init__(self)

ida_kernwin.sync_source_t

ida_kernwin.sync_source_t.__eq__(self, _o: "sync_source_t") -> bool

ida_kernwin.sync_source_t.__init__(self, *args)

ida_kernwin.sync_source_t.__ne__(self, _o: "sync_source_t") -> bool

ida_kernwin.sync_source_t.get_register(self) -> str

ida_kernwin.sync_source_t.get_widget(self) -> "TWidget const *"

ida_kernwin.sync_source_t.is_register(self) -> bool

ida_kernwin.sync_source_t.is_widget(self) -> bool

ida_kernwin.sync_source_vec_t

ida_kernwin.sync_source_vec_t.__eq__(self, r: "sync_source_vec_t") -> bool

ida_kernwin.sync_source_vec_t.__getitem__(self, i: "size_t") -> "sync_source_t const &"

ida_kernwin.sync_source_vec_t.__init__(self, *args)

ida_kernwin.sync_source_vec_t.__len__(self) -> "size_t"

ida_kernwin.sync_source_vec_t.__ne__(self, r: "sync_source_vec_t") -> bool

ida_kernwin.sync_source_vec_t.__setitem__(self, i: "size_t", v: "sync_source_t") -> None

ida_kernwin.sync_source_vec_t._del(self, x: "sync_source_t") -> bool

ida_kernwin.sync_source_vec_t.add_unique(self, x: "sync_source_t") -> bool

ida_kernwin.sync_source_vec_t.append(self, x: "sync_source_t") -> None

ida_kernwin.sync_source_vec_t.at(self, _idx: "size_t") -> "sync_source_t const &"

ida_kernwin.sync_source_vec_t.begin(self, *args) -> "qvector< sync_source_t >::const_iterator"

ida_kernwin.sync_source_vec_t.capacity(self) -> "size_t"

ida_kernwin.sync_source_vec_t.clear(self) -> None

ida_kernwin.sync_source_vec_t.empty(self) -> bool

ida_kernwin.sync_source_vec_t.end(self, *args) -> "qvector< sync_source_t >::const_iterator"

ida_kernwin.sync_source_vec_t.erase(self, *args) -> "qvector< sync_source_t >::iterator"

ida_kernwin.sync_source_vec_t.extend(self, x: "sync_source_vec_t") -> None

ida_kernwin.sync_source_vec_t.extract(self) -> "sync_source_t *"

ida_kernwin.sync_source_vec_t.find(self, *args) -> "qvector< sync_source_t >::const_iterator"

ida_kernwin.sync_source_vec_t.has(self, x: "sync_source_t") -> bool

ida_kernwin.sync_source_vec_t.inject(self, s: "sync_source_t", len: "size_t") -> None

ida_kernwin.sync_source_vec_t.insert(self, it: "sync_source_t", x: "sync_source_t") -> "qvector< sync_source_t >::iterator"

ida_kernwin.sync_source_vec_t.pop_back(self) -> None

ida_kernwin.sync_source_vec_t.push_back(self, x: "sync_source_t") -> None

ida_kernwin.sync_source_vec_t.qclear(self) -> None

ida_kernwin.sync_source_vec_t.reserve(self, cnt: "size_t") -> None

ida_kernwin.sync_source_vec_t.size(self) -> "size_t"

ida_kernwin.sync_source_vec_t.swap(self, r: "sync_source_vec_t") -> None

ida_kernwin.sync_source_vec_t.truncate(self) -> None

ida_kernwin.sync_sources(what: "sync_source_t", _with: "sync_source_t", sync: bool) -> bool
    [Un]synchronize sources 
            
    @returns success

ida_kernwin.synced_group_t

ida_kernwin.synced_group_t.__init__(self)

ida_kernwin.synced_group_t.has(self, ss: "sync_source_t") -> bool

ida_kernwin.synced_group_t.has_register(self, r: str) -> bool

ida_kernwin.synced_group_t.has_widget(self, v: "TWidget const *") -> bool

ida_kernwin.tagged_line_section_t

ida_kernwin.tagged_line_section_t.__eq__(self, r: "tagged_line_section_t") -> bool

ida_kernwin.tagged_line_section_t.__init__(self)

ida_kernwin.tagged_line_section_t.__ne__(self, r: "tagged_line_section_t") -> bool

ida_kernwin.tagged_line_section_t.__str__(self) -> str

ida_kernwin.tagged_line_section_t.substr(self, _in: str, end: "tagged_line_section_t" = None) -> bool

ida_kernwin.tagged_line_section_t.valid(self) -> bool

ida_kernwin.tagged_line_section_t.valid_in(self, _in: str) -> bool

ida_kernwin.tagged_line_section_vec_t

ida_kernwin.tagged_line_section_vec_t.__eq__(self, r: "tagged_line_section_vec_t") -> bool

ida_kernwin.tagged_line_section_vec_t.__getitem__(self, i: "size_t") -> "tagged_line_section_t const &"

ida_kernwin.tagged_line_section_vec_t.__init__(self, *args)

ida_kernwin.tagged_line_section_vec_t.__len__(self) -> "size_t"

ida_kernwin.tagged_line_section_vec_t.__ne__(self, r: "tagged_line_section_vec_t") -> bool

ida_kernwin.tagged_line_section_vec_t.__setitem__(self, i: "size_t", v: "tagged_line_section_t") -> None

ida_kernwin.tagged_line_section_vec_t._del(self, x: "tagged_line_section_t") -> bool

ida_kernwin.tagged_line_section_vec_t.add_unique(self, x: "tagged_line_section_t") -> bool

ida_kernwin.tagged_line_section_vec_t.append(self, x: "tagged_line_section_t") -> None

ida_kernwin.tagged_line_section_vec_t.at(self, _idx: "size_t") -> "tagged_line_section_t const &"

ida_kernwin.tagged_line_section_vec_t.begin(self, *args) -> "qvector< tagged_line_section_t >::const_iterator"

ida_kernwin.tagged_line_section_vec_t.capacity(self) -> "size_t"

ida_kernwin.tagged_line_section_vec_t.clear(self) -> None

ida_kernwin.tagged_line_section_vec_t.empty(self) -> bool

ida_kernwin.tagged_line_section_vec_t.end(self, *args) -> "qvector< tagged_line_section_t >::const_iterator"

ida_kernwin.tagged_line_section_vec_t.erase(self, *args) -> "qvector< tagged_line_section_t >::iterator"

ida_kernwin.tagged_line_section_vec_t.extend(self, x: "tagged_line_section_vec_t") -> None

ida_kernwin.tagged_line_section_vec_t.extract(self) -> "tagged_line_section_t *"

ida_kernwin.tagged_line_section_vec_t.find(self, *args) -> "qvector< tagged_line_section_t >::const_iterator"

ida_kernwin.tagged_line_section_vec_t.grow(self, *args) -> None

ida_kernwin.tagged_line_section_vec_t.has(self, x: "tagged_line_section_t") -> bool

ida_kernwin.tagged_line_section_vec_t.inject(self, s: "tagged_line_section_t", len: "size_t") -> None

ida_kernwin.tagged_line_section_vec_t.insert(self, it: "tagged_line_section_t", x: "tagged_line_section_t") -> "qvector< tagged_line_section_t >::iterator"

ida_kernwin.tagged_line_section_vec_t.pop_back(self) -> None

ida_kernwin.tagged_line_section_vec_t.push_back(self, *args) -> "tagged_line_section_t &"

ida_kernwin.tagged_line_section_vec_t.qclear(self) -> None

ida_kernwin.tagged_line_section_vec_t.reserve(self, cnt: "size_t") -> None

ida_kernwin.tagged_line_section_vec_t.resize(self, *args) -> None

ida_kernwin.tagged_line_section_vec_t.size(self) -> "size_t"

ida_kernwin.tagged_line_section_vec_t.swap(self, r: "tagged_line_section_vec_t") -> None

ida_kernwin.tagged_line_section_vec_t.truncate(self) -> None

ida_kernwin.tagged_line_sections_t

ida_kernwin.tagged_line_sections_t.__init__(self)

ida_kernwin.tagged_line_sections_t.first(self, tag: "color_t") -> "tagged_line_section_t const *"

ida_kernwin.tagged_line_sections_t.nearest_after(self, range: "tagged_line_section_t", start: "cpidx_t", tag: "color_t" = 0) -> "tagged_line_section_t const *"

ida_kernwin.tagged_line_sections_t.nearest_at(self, x: "cpidx_t", tag: "color_t" = 0) -> "tagged_line_section_t const *"

ida_kernwin.tagged_line_sections_t.nearest_before(self, range: "tagged_line_section_t", start: "cpidx_t", tag: "color_t" = 0) -> "tagged_line_section_t const *"

ida_kernwin.tagged_line_sections_t.sections_at(self, out: "tagged_line_sections_t", x: "cpidx_t", tag: "color_t" = 0) -> None

ida_kernwin.take_database_snapshot(snapshot) -> Tuple[bool, str]
    Take a database snapshot.
    
    @param snapshot the snapshot object
    @return a tuple (success, error-message)

ida_kernwin.text_t

ida_kernwin.text_t.__getitem__(self, i: "size_t") -> "twinline_t const &"

ida_kernwin.text_t.__init__(self, *args)

ida_kernwin.text_t.__len__(self) -> "size_t"

ida_kernwin.text_t.__setitem__(self, i: "size_t", v: "twinline_t") -> None

ida_kernwin.text_t.append(self, x: "twinline_t") -> None

ida_kernwin.text_t.at(self, _idx: "size_t") -> "twinline_t const &"

ida_kernwin.text_t.begin(self, *args) -> "qvector< twinline_t >::const_iterator"

ida_kernwin.text_t.capacity(self) -> "size_t"

ida_kernwin.text_t.clear(self) -> None

ida_kernwin.text_t.empty(self) -> bool

ida_kernwin.text_t.end(self, *args) -> "qvector< twinline_t >::const_iterator"

ida_kernwin.text_t.erase(self, *args) -> "qvector< twinline_t >::iterator"

ida_kernwin.text_t.extend(self, x: "text_t") -> None

ida_kernwin.text_t.extract(self) -> "twinline_t *"

ida_kernwin.text_t.grow(self, *args) -> None

ida_kernwin.text_t.inject(self, s: "twinline_t", len: "size_t") -> None

ida_kernwin.text_t.insert(self, it: "twinline_t", x: "twinline_t") -> "qvector< twinline_t >::iterator"

ida_kernwin.text_t.pop_back(self) -> None

ida_kernwin.text_t.push_back(self, *args) -> "twinline_t &"

ida_kernwin.text_t.qclear(self) -> None

ida_kernwin.text_t.reserve(self, cnt: "size_t") -> None

ida_kernwin.text_t.resize(self, *args) -> None

ida_kernwin.text_t.size(self) -> "size_t"

ida_kernwin.text_t.swap(self, r: "text_t") -> None

ida_kernwin.text_t.truncate(self) -> None

ida_kernwin.textctrl_info_t
    Flags value

ida_kernwin.textctrl_info_t.TXTF_ACCEPTTABS
    Tab key inserts 'tabsize' spaces

ida_kernwin.textctrl_info_t.TXTF_AUTOINDENT
    Auto-indent on new line

ida_kernwin.textctrl_info_t.TXTF_FIXEDFONT
    The control uses IDA's fixed font

ida_kernwin.textctrl_info_t.TXTF_MODIFIED
    Gets/sets the modified status

ida_kernwin.textctrl_info_t.TXTF_READONLY
    Text cannot be edited (but can be selected and copied)

ida_kernwin.textctrl_info_t.TXTF_SELECTED
    Shows the field with its text selected

ida_kernwin.textctrl_info_t.__get_flags__(self)
    Returns the flags value

ida_kernwin.textctrl_info_t.__get_tabsize__(self)
    Returns the tabsize value

ida_kernwin.textctrl_info_t.__get_text(self)
    Sets the text value

ida_kernwin.textctrl_info_t.__init__(self, text = "", flags = 0, tabsize = 0)

ida_kernwin.textctrl_info_t.__set_flags__(self, flags)
    Sets the flags value

ida_kernwin.textctrl_info_t.__set_tabsize__(self, tabsize)
    Sets the tabsize value

ida_kernwin.textctrl_info_t.__set_text(self, s)
    Sets the text value

ida_kernwin.textctrl_info_t._create_clink(self)

ida_kernwin.textctrl_info_t._del_clink(self, lnk)

ida_kernwin.textctrl_info_t._get_clink_ptr(self)

ida_kernwin.textctrl_info_t.assign(self, other)
    Copies the contents of 'other' to 'self'

ida_kernwin.textctrl_info_t.flags
    Text control property bits 
            

ida_kernwin.textctrl_info_t.tabsize
    how many spaces a single tab will indent

ida_kernwin.textctrl_info_t.text
    in, out: text control value

ida_kernwin.textctrl_info_t.value
    Alias for the text property

ida_kernwin.textctrl_info_t_assign(_self: "PyObject *", other: "PyObject *") -> bool

ida_kernwin.textctrl_info_t_create() -> "PyObject *"

ida_kernwin.textctrl_info_t_destroy(py_obj: "PyObject *") -> bool

ida_kernwin.textctrl_info_t_get_clink(_self: "PyObject *") -> "textctrl_info_t *"

ida_kernwin.textctrl_info_t_get_clink_ptr(_self: "PyObject *") -> "PyObject *"

ida_kernwin.textctrl_info_t_get_flags(_self: "PyObject *") -> "unsigned int"

ida_kernwin.textctrl_info_t_get_tabsize(_self: "PyObject *") -> "unsigned int"

ida_kernwin.textctrl_info_t_get_text(_self: "PyObject *") -> str

ida_kernwin.textctrl_info_t_set_flags(_self: "PyObject *", flags: "unsigned int") -> bool

ida_kernwin.textctrl_info_t_set_tabsize(_self: "PyObject *", tabsize: "unsigned int") -> bool

ida_kernwin.textctrl_info_t_set_text(_self: "PyObject *", s: str) -> bool

ida_kernwin.tiplace_t

ida_kernwin.tiplace_t.__init__(self, *args, **kwargs)

ida_kernwin.tiplace_t.calc_udm_offset(self, ud: "void const *", p_udmidx: "ssize_t *" = None, p_bitoff: "int *" = None) -> "uint64"
    for structs: calculate the offset that corresponds to the tiplace. 
            
    @param ud: pointer to user-defined context data. Is supplied by linearray_t
    @param p_udmidx: place to return the index of the current udt member, if any. if there is no member at the current offset, return -1
    @param p_bitoff: place to return the bit offset of the item from the beginning of the bit bucket if there no bitfields, return -1
    @returns the current offset or uint64(-1)

ida_kernwin.tiplace_t.fill_type_ref(self, out: "til_type_ref_t", ud: "void const *") -> bool
    fill the type information for use in actions 
            
    @param out: pointer to storage
    @param ud: pointer to user-defined context data. Is supplied by linearray_t
    @returns success

ida_kernwin.tiplace_t.get_kind(self, ud: "void const *") -> "type_t"
    get the kind of type this place represents 
            
    @param ud: pointer to user-defined context data. Is supplied by linearray_t
    @returns one of BTF_TYPEDEF, BTF_STRUCT, BTF_UNION, BTF_ENUM or BT_UNK

ida_kernwin.tiplace_t.is_footer(self) -> bool

ida_kernwin.tiplace_t.is_header(self) -> bool

ida_kernwin.tiplace_t.is_index(self) -> bool

ida_kernwin.tiplace_t.reset(self) -> None

ida_kernwin.tiplace_t.set_footer(self) -> None

ida_kernwin.tiplace_t.set_header(self) -> None

ida_kernwin.tiplace_t.set_index_by_offset(self, ud: "void *", offset: "uint64") -> None
    for structs: calculate the index that corresponds to the offset and set it. 
            
    @param ud: pointer to user-defined context data. Is supplied by linearray_t
    @param offset: offset of udt member

ida_kernwin.tiplace_t.valid_ord(self) -> bool

ida_kernwin.twinline_t

ida_kernwin.twinline_t.__init__(self, *args)

ida_kernwin.twinline_t.at
    location in view

ida_kernwin.twinline_t.bg_color
    line background color

ida_kernwin.twinline_t.is_default
    is this the default line of the current location?

ida_kernwin.twinline_t.line
    line contents

ida_kernwin.twinline_t.prefix_color
    line prefix color

ida_kernwin.twinpos_t

ida_kernwin.twinpos_t.__init__(self, *args)

ida_kernwin.twinpos_t.at
    location in view

ida_kernwin.twinpos_t.place(self, view)

ida_kernwin.twinpos_t.place_as_idaplace_t(self)

ida_kernwin.twinpos_t.place_as_simpleline_place_t(self)

ida_kernwin.twinpos_t.place_as_tiplace_t(self)

ida_kernwin.twinpos_t.x
    cursor x

ida_kernwin.ui_load_new_file(temp_file: str, filename: str, pli: "linput_t **", neflags: "ushort", ploaders: "load_info_t **") -> bool
    Display a load file dialog and load file (ui_load_file). 
            
    @param temp_file: name of the file with the extracted archive member.
    @param filename: the name of input file as is, library or archive name
    @param pli: loader input source, may be changed to point to temp_file
    @param neflags: combination of NEF_... bits (see Load file flags)
    @param ploaders: list of loaders which accept file, may be changed for loaders of temp_file
    @retval true: file was successfully loaded
    @retval false: otherwise

ida_kernwin.ui_requests_t

ida_kernwin.ui_requests_t.__init__(self)

ida_kernwin.ui_run_debugger(dbgopts: str, exename: str, argc: int, argv: "char const *const *") -> bool
    Load a debugger plugin and run the specified program (ui_run_dbg). 
            
    @param dbgopts: value of the -r command line switch
    @param exename: name of the file to run
    @param argc: number of arguments for the executable
    @param argv: argument vector
    @returns success

ida_kernwin.unmark_selection() -> None
    Unmark selection (ui_unmarksel)

ida_kernwin.unregister_action(name: str) -> bool
    Delete a previously-registered action (ui_unregister_action). 
            
    @param name: name of action
    @returns success

ida_kernwin.unregister_timer(timer_obj)
    Unregister a timer
    
    @param timer_obj: a timer object previously returned by a register_timer()
    @return: Boolean
    @note: After the timer has been deleted, the timer_obj will become invalid.

ida_kernwin.update_action_checkable(name: str, checkable: bool) -> bool
    Update an action's checkability (ui_update_action_attr). 
            
    @param name: action name
    @param checkable: new checkability
    @returns success

ida_kernwin.update_action_checked(name: str, checked: bool) -> bool
    Update an action's checked state (ui_update_action_attr). 
            
    @param name: action name
    @param checked: new checked state
    @returns success

ida_kernwin.update_action_icon(name: str, icon: int) -> bool
    Update an action's icon (ui_update_action_attr). 
            
    @param name: action name
    @param icon: new icon id
    @returns success

ida_kernwin.update_action_label(name: str, label: str) -> bool
    Update an action's label (ui_update_action_attr). 
            
    @param name: action name
    @param label: new label
    @returns success

ida_kernwin.update_action_shortcut(name: str, shortcut: str) -> bool
    Update an action's shortcut (ui_update_action_attr). 
            
    @param name: action name
    @param shortcut: new shortcut
    @returns success

ida_kernwin.update_action_state(name: str, state: "action_state_t") -> bool
    Update an action's state (ui_update_action_attr). 
            
    @param name: action name
    @param state: new state
    @returns success

ida_kernwin.update_action_tooltip(name: str, tooltip: str) -> bool
    Update an action's tooltip (ui_update_action_attr). 
            
    @param name: action name
    @param tooltip: new tooltip
    @returns success

ida_kernwin.update_action_visibility(name: str, visible: bool) -> bool
    Update an action's visibility (ui_update_action_attr). 
            
    @param name: action name
    @param visible: new visibility
    @returns success

ida_kernwin.user_cancelled() -> bool
    Test the ctrl-break flag (ui_test_cancelled). 
            
    @retval 1: Ctrl-Break is detected, a message is displayed
    @retval 2: Ctrl-Break is detected again, a message is not displayed
    @retval 0: Ctrl-Break is not detected

ida_kernwin.view_activated
    A view is activated 
              

ida_kernwin.view_click
    Click event 
              

ida_kernwin.view_close
    View closed 
              

ida_kernwin.view_created
    A view is being created. 
              

ida_kernwin.view_curpos
    Cursor position changed 
              

ida_kernwin.view_dblclick
    Double click event 
              

ida_kernwin.view_deactivated
    A view is deactivated 
              

ida_kernwin.view_keydown
    Key down event 
              

ida_kernwin.view_loc_changed
    The location for the view has changed (can be either the place_t, the renderer_info_t, or both.) 
              

ida_kernwin.view_mouse_event_location_t

ida_kernwin.view_mouse_event_location_t.__init__(self)

ida_kernwin.view_mouse_event_location_t.ea
    flat view (rtype == TCCRT_FLAT)

ida_kernwin.view_mouse_event_location_t.item
    graph views (rtype != TCCRT_FLAT). nullptr if mouse is not currently over an item. 
            

ida_kernwin.view_mouse_event_t

ida_kernwin.view_mouse_event_t.__init__(self)

ida_kernwin.view_mouse_event_t.button
    represents which mouse button was responsible for generating the event. This field does not care about the current state of the mouse. 
            

ida_kernwin.view_mouse_event_t.location
    location where event was generated

ida_kernwin.view_mouse_event_t.renderer_pos
    position where event was generated, relative to the renderer

ida_kernwin.view_mouse_event_t.rtype
    type of renderer that received the event

ida_kernwin.view_mouse_event_t.state
    contains information about what buttons are CURRENTLY pressed on the keyboard and mouse. view_mouse_event_t instances created in functions like mouseReleaseEvent() won't contain any information about the mouse, because it has been released. 
            

ida_kernwin.view_mouse_event_t.x
    screen x coordinate

ida_kernwin.view_mouse_event_t.y
    screen y coordinate

ida_kernwin.view_mouse_moved
    The mouse moved on the view 
              

ida_kernwin.view_mouse_over
    The user moved the mouse over (or out of) a node or an edge. This is only relevant in a graph view. 
              

ida_kernwin.view_switched
    A view's renderer has changed. 
              

ida_kernwin.warning(message)
    Display a message in a warning message box
    
    @param message: message to print

ida_libfuncs

ida_libfuncs.get_idasgn_header_by_short_name(out_header: "idasgn_header_t", name: str) -> str
    Get idasgn header by a short signature name. 
            
    @param out_header: buffer for the signature file header
    @param name: short name of a signature
    @returns true in case of success

ida_libfuncs.get_idasgn_path_by_short_name(name: str) -> str
    Get idasgn full path by a short signature name. 
            
    @param name: short name of a signature
    @returns true in case of success

ida_libfuncs.idasgn_header_t

ida_libfuncs.idasgn_header_t.__init__(self)

ida_lines
    High level functions that deal with the generation of the disassembled text lines.
    
    This file also contains definitions for the syntax highlighting.
    Finally there are functions that deal with anterior/posterior user-defined lines. 
        

ida_lines.COLOR_ADDR
    hidden address marks. the address is represented as 8digit hex number: 01234567. it doesn't have COLOR_OFF pair. NB: for 64-bit IDA, the address is 16digit. 
            

ida_lines.COLOR_ADDR_SIZE
    Size of a tagged address (see COLOR_ADDR)

ida_lines.COLOR_ALTOP
    Alternative operand.

ida_lines.COLOR_ASMDIR
    Assembler directive.

ida_lines.COLOR_AUTOCMT
    Automatic comment.

ida_lines.COLOR_BG_MAX
    Max color number.

ida_lines.COLOR_BINPREF
    Binary line prefix bytes.

ida_lines.COLOR_CHAR
    Char constant in instruction.

ida_lines.COLOR_CNAME
    Regular code name.

ida_lines.COLOR_CODE
    Single instruction.

ida_lines.COLOR_CODNAME
    Dummy code name.

ida_lines.COLOR_COLLAPSED
    Collapsed line.

ida_lines.COLOR_CREF
    Code reference.

ida_lines.COLOR_CREFTAIL
    Code reference to tail byte.

ida_lines.COLOR_CURITEM
    Current item.

ida_lines.COLOR_CURLINE
    Current line.

ida_lines.COLOR_DATA
    Data bytes.

ida_lines.COLOR_DATNAME
    Dummy Data Name.

ida_lines.COLOR_DCHAR
    Char constant in data directive.

ida_lines.COLOR_DEFAULT
    Default.

ida_lines.COLOR_DEMNAME
    Demangled Name.

ida_lines.COLOR_DNAME
    Regular Data Name.

ida_lines.COLOR_DNUM
    Numeric constant in data directive.

ida_lines.COLOR_DREF
    Data reference.

ida_lines.COLOR_DREFTAIL
    Data reference to tail byte.

ida_lines.COLOR_DSTR
    String constant in data directive.

ida_lines.COLOR_ERROR
    Error or problem.

ida_lines.COLOR_ESC
    Escape character (Quote next character). This is needed to output '\1' and '\2' characters. 
            

ida_lines.COLOR_EXTERN
    External name definition segment.

ida_lines.COLOR_EXTRA
    Extra line.

ida_lines.COLOR_FG_MAX
    Max color number.

ida_lines.COLOR_HIDLINE
    Hidden line.

ida_lines.COLOR_HIDNAME
    Hidden name.

ida_lines.COLOR_IMPNAME
    Imported name.

ida_lines.COLOR_INSN
    Instruction.

ida_lines.COLOR_INV
    Escape character (Inverse foreground and background colors). This escape character has no corresponding COLOR_OFF. Its action continues until the next COLOR_INV or end of line. 
            

ida_lines.COLOR_KEYWORD
    Keywords.

ida_lines.COLOR_LIBFUNC
    Library function.

ida_lines.COLOR_LIBNAME
    Library function name.

ida_lines.COLOR_LOCNAME
    Local variable name.

ida_lines.COLOR_LUMFUNC
    Lumina function.

ida_lines.COLOR_LUMINA
    Lumina-related, only for the navigation band.

ida_lines.COLOR_MACRO
    Macro.

ida_lines.COLOR_NUMBER
    Numeric constant in instruction.

ida_lines.COLOR_OFF
    Escape character (OFF). Followed by a color code (color_t). 
            

ida_lines.COLOR_ON
    Escape character (ON). Followed by a color code (color_t). 
            

ida_lines.COLOR_OPND1
    Instruction operand 1.

ida_lines.COLOR_OPND2
    Instruction operand 2.

ida_lines.COLOR_OPND3
    Instruction operand 3.

ida_lines.COLOR_OPND4
    Instruction operand 4.

ida_lines.COLOR_OPND5
    Instruction operand 5.

ida_lines.COLOR_OPND6
    Instruction operand 6.

ida_lines.COLOR_OPND7
    Instruction operand 7.

ida_lines.COLOR_OPND8
    Instruction operand 8.

ida_lines.COLOR_PREFIX
    Line prefix.

ida_lines.COLOR_REG
    Register name.

ida_lines.COLOR_REGCMT
    Regular comment.

ida_lines.COLOR_REGFUNC
    Regular function.

ida_lines.COLOR_RESERVED1
    This tag is reserved for internal IDA use.

ida_lines.COLOR_RPTCMT
    Repeatable comment (comment defined somewhere else)

ida_lines.COLOR_SEGNAME
    Segment name.

ida_lines.COLOR_SELECTED
    Selected.

ida_lines.COLOR_STRING
    String constant in instruction.

ida_lines.COLOR_SYMBOL
    Punctuation.

ida_lines.COLOR_UNAME
    Regular unknown name.

ida_lines.COLOR_UNKNAME
    Dummy unknown name.

ida_lines.COLOR_UNKNOWN
    Unexplored byte.

ida_lines.COLOR_VOIDOP
    Void operand.

ida_lines.COLSTR(str, tag)
    Utility function to create a colored line
    @param str: The string
    @param tag: Color tag constant. One of SCOLOR_XXXX

ida_lines.SCOLOR_ADDR
    Hidden address mark.

ida_lines.SCOLOR_ALTOP
    Alternative operand.

ida_lines.SCOLOR_ASMDIR
    Assembler directive.

ida_lines.SCOLOR_AUTOCMT
    Automatic comment.

ida_lines.SCOLOR_BINPREF
    Binary line prefix bytes.

ida_lines.SCOLOR_CHAR
    Char constant in instruction.

ida_lines.SCOLOR_CNAME
    Regular code name.

ida_lines.SCOLOR_CODNAME
    Dummy code name.

ida_lines.SCOLOR_COLLAPSED
    Collapsed line.

ida_lines.SCOLOR_CREF
    Code reference.

ida_lines.SCOLOR_CREFTAIL
    Code reference to tail byte.

ida_lines.SCOLOR_DATNAME
    Dummy Data Name.

ida_lines.SCOLOR_DCHAR
    Char constant in data directive.

ida_lines.SCOLOR_DEFAULT
    Default.

ida_lines.SCOLOR_DEMNAME
    Demangled Name.

ida_lines.SCOLOR_DNAME
    Regular Data Name.

ida_lines.SCOLOR_DNUM
    Numeric constant in data directive.

ida_lines.SCOLOR_DREF
    Data reference.

ida_lines.SCOLOR_DREFTAIL
    Data reference to tail byte.

ida_lines.SCOLOR_DSTR
    String constant in data directive.

ida_lines.SCOLOR_ERROR
    Error or problem.

ida_lines.SCOLOR_ESC
    Escape character (Quote next character)

ida_lines.SCOLOR_EXTRA
    Extra line.

ida_lines.SCOLOR_HIDNAME
    Hidden name.

ida_lines.SCOLOR_IMPNAME
    Imported name.

ida_lines.SCOLOR_INSN
    Instruction.

ida_lines.SCOLOR_INV
    Escape character (Inverse colors)

ida_lines.SCOLOR_KEYWORD
    Keywords.

ida_lines.SCOLOR_LIBNAME
    Library function name.

ida_lines.SCOLOR_LOCNAME
    Local variable name.

ida_lines.SCOLOR_MACRO
    Macro.

ida_lines.SCOLOR_NUMBER
    Numeric constant in instruction.

ida_lines.SCOLOR_OFF
    Escape character (OFF)

ida_lines.SCOLOR_ON
    Escape character (ON)

ida_lines.SCOLOR_PREFIX
    Line prefix.

ida_lines.SCOLOR_REG
    Register name.

ida_lines.SCOLOR_REGCMT
    Regular comment.

ida_lines.SCOLOR_RPTCMT
    Repeatable comment (defined not here)

ida_lines.SCOLOR_SEGNAME
    Segment name.

ida_lines.SCOLOR_STRING
    String constant in instruction.

ida_lines.SCOLOR_SYMBOL
    Punctuation.

ida_lines.SCOLOR_UNAME
    Regular unknown name.

ida_lines.SCOLOR_UNKNAME
    Dummy unknown name.

ida_lines.SCOLOR_VOIDOP
    Void operand.

ida_lines.VEL_CMT
    append comment line

ida_lines.VEL_POST
    append posterior line

ida_lines.add_extra_cmt(*args) -> bool

ida_lines.add_extra_line(*args) -> bool

ida_lines.add_pgm_cmt(*args) -> bool

ida_lines.add_sourcefile(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, filename: str) -> bool

ida_lines.calc_bg_color(ea: ida_idaapi.ea_t) -> "bgcolor_t"
    Get background color for line at 'ea' 
            
    @returns RGB color

ida_lines.calc_prefix_color(ea: ida_idaapi.ea_t) -> "color_t"
    Get prefix color for line at 'ea' 
            
    @returns Line prefix colors

ida_lines.create_encoding_helper(*args) -> "encoder_t *"

ida_lines.del_extra_cmt(ea: ida_idaapi.ea_t, what: int) -> bool

ida_lines.del_sourcefile(ea: ida_idaapi.ea_t) -> bool

ida_lines.delete_extra_cmts(ea: ida_idaapi.ea_t, what: int) -> None

ida_lines.generate_disasm_line(ea: ida_idaapi.ea_t, flags: int = 0) -> str

ida_lines.generate_disassembly(ea, max_lines, as_stack, notags)
    Generate disassembly lines (many lines) and put them into a buffer
    
    @param ea: address to generate disassembly for
    @param max_lines: how many lines max to generate
    @param as_stack: Display undefined items as 2/4/8 bytes
    @return:
        - None on failure
        - tuple(most_important_line_number, list(lines)) : Returns a tuple containing
          the most important line number and a list of generated lines

ida_lines.get_extra_cmt(ea: ida_idaapi.ea_t, what: int) -> int

ida_lines.get_first_free_extra_cmtidx(ea: ida_idaapi.ea_t, start: int) -> int

ida_lines.get_sourcefile(ea: ida_idaapi.ea_t, bounds: "range_t" = None) -> str

ida_lines.install_user_defined_prefix(*args) -> bool

ida_lines.requires_color_esc(c)
    Is the given char a color escape character?

ida_lines.tag_addr(ea: ida_idaapi.ea_t) -> str
    Insert an address mark into a string. 
            
    @param ea: address to include

ida_lines.tag_advance(line: str, cnt: int) -> int
    Move pointer to a 'line' to 'cnt' positions right. Take into account escape sequences. 
            
    @param line: pointer to string
    @param cnt: number of positions to move right
    @returns moved pointer

ida_lines.tag_remove(nonnul_instr: str) -> str
    Remove color escape sequences from a string. 
            
    @returns length of resulting string, -1 if error

ida_lines.tag_skipcode(line: str) -> int
    Skip one color code. This function should be used if you are interested in color codes and want to analyze all of them. Otherwise tag_skipcodes() function is better since it will skip all colors at once. This function will skip the current color code if there is one. If the current symbol is not a color code, it will return the input. 
            
    @returns moved pointer

ida_lines.tag_skipcodes(line: str) -> int
    Move the pointer past all color codes. 
            
    @param line: can't be nullptr
    @returns moved pointer, can't be nullptr

ida_lines.tag_strlen(line: str) -> "ssize_t"
    Calculate length of a colored string This function computes the length in unicode codepoints of a line 
            
    @returns the number of codepoints in the line, or -1 on error

ida_lines.update_extra_cmt(ea: ida_idaapi.ea_t, what: int, str: str) -> bool

ida_lines.user_defined_prefix_t

ida_lines.user_defined_prefix_t.__disown__(self)

ida_lines.user_defined_prefix_t.__init__(self, *args)

ida_lines.user_defined_prefix_t.get_user_defined_prefix(self, ea: ida_idaapi.ea_t, insn: "insn_t const &", lnnum: int, indent: int, line: str) -> None
    This callback must be overridden by the derived class. 
            
    @param ea: the current address
    @param insn: the current instruction. if the current item is not an instruction, then insn.itype is zero.
    @param lnnum: number of the current line (each address may have several listing lines for it). 0 means the very first line for the current address.
    @param indent: see explanations for gen_printf()
    @param line: the line to be generated. the line usually contains color tags. this argument can be examined to decide whether to generate the prefix.

ida_loader
    Definitions of IDP, LDR, PLUGIN module interfaces.
    
    This file also contains:
    * functions to load files into the database
    * functions to generate output files
    * high level functions to work with the database (open, save, close)
    
    
    The LDR interface consists of one structure: loader_t 
    The IDP interface consists of one structure: processor_t 
    The PLUGIN interface consists of one structure: plugin_t
    Modules can't use standard FILE* functions. They must use functions from <fpro.h>
    Modules can't use standard memory allocation functions. They must use functions from <pro.h>
    The exported entry #1 in the module should point to the the appropriate structure. (loader_t for LDR module, for example) 
        

ida_loader.ACCEPT_ARCHIVE
    Specify that a file format is served by archive loader See loader_t::accept_file 
            

ida_loader.ACCEPT_CONTINUE
    Specify that the function must be called another time See loader_t::accept_file 
            

ida_loader.ACCEPT_FIRST
    Specify that a file format should be place first in "load file" dialog box. See loader_t::accept_file 
            

ida_loader.DBFL_BAK
    create backup file (if !DBFL_KILL)

ida_loader.DBFL_COMP
    collect garbage

ida_loader.DBFL_KILL
    delete unpacked database

ida_loader.DBFL_TEMP
    temporary database

ida_loader.FILEREG_NOTPATCHABLE
    the data is kept in some encoded form in the file. 
            

ida_loader.FILEREG_PATCHABLE
    means that the input file may be patched (i.e. no compression, no iterated data, etc) 
            

ida_loader.GENFLG_ASMINC
    OFILE_ASM,OFILE_LST: gen information only about types

ida_loader.GENFLG_ASMTYPE
    OFILE_ASM,OFILE_LST: gen information about types too

ida_loader.GENFLG_GENHTML
    OFILE_ASM,OFILE_LST: generate html (ui_genfile_callback will be used)

ida_loader.GENFLG_IDCTYPE
    OFILE_IDC: gen only information about types

ida_loader.GENFLG_MAPDMNG
    OFILE_MAP: demangle names

ida_loader.GENFLG_MAPLOC
    OFILE_MAP: include local names

ida_loader.GENFLG_MAPNAME
    OFILE_MAP: include dummy names

ida_loader.GENFLG_MAPSEG
    OFILE_MAP: generate map of segments

ida_loader.LDRF_RELOAD
    loader recognizes NEF_RELOAD flag

ida_loader.LDRF_REQ_PROC
    Requires a processor to be set. if this bit is not set, load_file() must call set_processor_type(..., SETPROC_LOADER) 
            

ida_loader.MAX_DATABASE_DESCRIPTION
    Maximum database snapshot description length.

ida_loader.NEF_CODE
    for load_binary_file(): load as a code segment 
            

ida_loader.NEF_FILL
    Fill segment gaps.

ida_loader.NEF_FIRST
    This is the first file loaded into the database. 
            

ida_loader.NEF_FLAT
    Autocreate FLAT group (PE)

ida_loader.NEF_IMPS
    Create import segment.

ida_loader.NEF_LALL
    Load all segments without questions.

ida_loader.NEF_LOPT
    Display additional loader options dialog.

ida_loader.NEF_MAN
    Manual load.

ida_loader.NEF_MINI
    Create mini database (do not copy segment bytes from the input file; use only the file header metadata) 
            

ida_loader.NEF_NAME
    Rename entries.

ida_loader.NEF_RELOAD
    reload the file at the same place:
    * don't create segments
    * don't create fixup info
    * don't import segments
    * etc.
    
    
    Load only the bytes into the base. A loader should have the LDRF_RELOAD bit set. 
            

ida_loader.NEF_RSCS
    Load resources.

ida_loader.NEF_SEGS
    Create segments.

ida_loader.OFILE_ASM
    Assembly.

ida_loader.OFILE_DIF
    Difference.

ida_loader.OFILE_EXE
    Executable file.

ida_loader.OFILE_IDC
    IDC file.

ida_loader.OFILE_LST
    Disassembly listing.

ida_loader.OFILE_MAP
    MAP file.

ida_loader.PATH_TYPE_CMD
    full path to the file specified in the command line

ida_loader.PATH_TYPE_ID0
    full path of ID0 file

ida_loader.PATH_TYPE_IDB
    full path of IDB file

ida_loader.PLUGIN_DLL
    Pattern to find plugin files.

ida_loader.SSF_AUTOMATIC
    automatic snapshot

ida_loader.SSUF_DESC
    Update the description.

ida_loader.SSUF_FLAGS
    Update the flags.

ida_loader.SSUF_PATH
    Update the path.

ida_loader.base2file(fp: "FILE *", pos: "qoff64_t", ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> int
    Unload database to a binary file. This function works for wide byte processors too. 
            
    @param fp: pointer to file
    @param pos: position in the file
    @param ea1: range of source linear addresses
    @param ea2: range of source linear addresses
    @returns 1-ok(always), write error leads to immediate exit

ida_loader.build_snapshot_tree(root: "snapshot_t") -> bool
    Build the snapshot tree. 
            
    @param root: snapshot root that will contain the snapshot tree elements.
    @returns success

ida_loader.clr_database_flag(dbfl: int) -> None

ida_loader.extract_module_from_archive(fname: str, is_remote: bool = False) -> "PyObject *"
    Extract a module for an archive file. Parse an archive file, show the list of modules to the user, allow him to select a module, extract the selected module to a file (if the extract module is an archive, repeat the process). This function can handle ZIP, AR, AIXAR, OMFLIB files. The temporary file will be automatically deleted by IDA at the end. 
            
    @param is_remote: is the input file remote?
    @retval true: ok
    @retval false: something bad happened (error message has been displayed to the user)

ida_loader.file2base(li: "linput_t *", pos: "qoff64_t", ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, patchable: int) -> int
    Load portion of file into the database. This function will include (ea1..ea2) into the addressing space of the program (make it enabled). 
            
    @param li: pointer of input source
    @param pos: position in the file
    @param ea1: range of destination linear addresses
    @param ea2: range of destination linear addresses
    @param patchable: should the kernel remember correspondence of file offsets to linear addresses.
    @retval 1: ok
    @retval 0: read error, a warning is displayed

ida_loader.find_plugin(name: str, load_if_needed: bool = False) -> "plugin_t *"
    Find a user-defined plugin and optionally load it. 
            
    @param name: short plugin name without path and extension, or absolute path to the file name
    @param load_if_needed: if the plugin is not present in the memory, try to load it
    @returns pointer to plugin description block

ida_loader.flush_buffers() -> int
    Flush buffers to the disk.

ida_loader.gen_exe_file(fp: "FILE *") -> int
    Generate an exe file (unload the database in binary form). 
            
    @returns fp the output file handle. if fp == nullptr then return:
    * 1: can generate an executable file
    * 0: can't generate an executable file
    @retval 1: ok
    @retval 0: failed

ida_loader.gen_file(otype: "ofile_type_t", fp: "FILE *", ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, flags: int) -> int
    Generate an output file. OFILE_EXE: 
            
    @param otype: type of output file.
    @param fp: the output file handle
    @param ea1: start address. For some file types this argument is ignored
    @param ea2: end address. For some file types this argument is ignored as usual in ida, the end address of the range is not included
    @param flags: Generate file flags
    @returns number of the generated lines. -1 if an error occurred
    @retval 0: can't generate exe file
    @retval 1: ok

ida_loader.get_basic_file_type(li: "linput_t *") -> "filetype_t"
    Get the input file type. This function can recognize libraries and zip files. 
            

ida_loader.get_elf_debug_file_directory() -> str
    Get the value of the ELF_DEBUG_FILE_DIRECTORY configuration directive. 
            

ida_loader.get_file_type_name() -> str
    Get name of the current file type. The current file type is kept in idainfo::filetype. 
            
    @returns size of answer, this function always succeeds

ida_loader.get_fileregion_ea(offset: "qoff64_t") -> ida_idaapi.ea_t
    Get linear address which corresponds to the specified input file offset. If can't be found, return BADADDR 
            

ida_loader.get_fileregion_offset(ea: ida_idaapi.ea_t) -> "qoff64_t"
    Get offset in the input file which corresponds to the given ea. If the specified ea can't be mapped into the input file offset, return -1. 
            

ida_loader.get_path(pt: "path_type_t") -> str
    Get the file path 
            
    @param pt: file path type Types of the file pathes
    @returns file path, never returns nullptr

ida_loader.get_plugin_options(plugin: str) -> str
    Get plugin options from the command line. If the user has specified the options in the -Oplugin_name:options format, them this function will return the 'options' part of it The 'plugin' parameter should denote the plugin name Returns nullptr if there we no options specified 
            

ida_loader.idp_desc_t

ida_loader.idp_desc_t.__init__(self)

ida_loader.idp_desc_t.checked
    internal, for cache management

ida_loader.idp_desc_t.family
    processor's family

ida_loader.idp_desc_t.is_script
    the processor module is a script

ida_loader.idp_desc_t.mtime
    time of last modification

ida_loader.idp_desc_t.names
    processor names

ida_loader.idp_desc_t.path
    module file name

ida_loader.idp_name_t

ida_loader.idp_name_t.__init__(self)

ida_loader.idp_name_t.hidden
    is hidden

ida_loader.idp_name_t.lname
    long processor name

ida_loader.idp_name_t.sname
    short processor name

ida_loader.is_database_flag(dbfl: int) -> bool
    Get the current database flag 
            
    @param dbfl: flag Database flags
    @returns the state of the flag (set or cleared)

ida_loader.is_trusted_idb() -> bool
    Is the database considered as trusted?

ida_loader.load_and_run_plugin(name: str, arg: "size_t") -> bool
    Load & run a plugin.

ida_loader.load_binary_file(filename: str, li: "linput_t *", _neflags: "ushort", fileoff: "qoff64_t", basepara: ida_idaapi.ea_t, binoff: ida_idaapi.ea_t, nbytes: "uint64") -> bool
    Load a binary file into the database. This function usually is called from ui. 
            
    @param filename: the name of input file as is (if the input file is from library, then this is the name from the library)
    @param li: loader input source
    @param _neflags: Load file flags. For the first file, the flag NEF_FIRST must be set.
    @param fileoff: Offset in the input file
    @param basepara: Load address in paragraphs
    @param binoff: Load offset (load_address=(basepara<<4)+binoff)
    @param nbytes: Number of bytes to load from the file.
    * 0: up to the end of the file
    @retval true: ok
    @retval false: failed (couldn't open the file)

ida_loader.load_ids_module(fname: "char *") -> int
    Load and apply IDS file. This function loads the specified IDS file and applies it to the database. If the program imports functions from a module with the same name as the name of the ids file being loaded, then only functions from this module will be affected. Otherwise (i.e. when the program does not import a module with this name) any function in the program may be affected. 
            
    @param fname: name of file to apply
    @retval 1: ok
    @retval 0: some error (a message is displayed). if the ids file does not exist, no message is displayed

ida_loader.load_plugin(name)
    Loads a plugin
    
    @param name: short plugin name without path and extension,
                 or absolute path to the file name
    @return:
        - None if plugin could not be loaded
        - An opaque object representing the loaded plugin

ida_loader.loader_t

ida_loader.loader_t.__init__(self)

ida_loader.loader_t.flags
    Loader flags 
            

ida_loader.loader_t.version
    api version, should be IDP_INTERFACE_VERSION

ida_loader.mem2base(mem, ea, fpos)
    Load database from the memory.
    
    @param mem: the buffer
    @param ea: start linear addresses
    @param fpos: position in the input file the data is taken from.
                 if == -1, then no file position correspond to the data.
    @return:
        - Returns zero if the passed buffer was not a string
        - Otherwise 1 is returned

ida_loader.plugin_info_t

ida_loader.plugin_info_t.__init__(self)

ida_loader.plugin_info_t.arg
    argument used to call the plugin

ida_loader.plugin_info_t.comment
    a copy of plugin_t::comment

ida_loader.plugin_info_t.entry
    pointer to the plugin if it is already loaded

ida_loader.plugin_info_t.flags
    a copy of plugin_t::flags

ida_loader.plugin_info_t.hotkey
    current hotkey to run the plugin

ida_loader.plugin_info_t.idaplg_name
    "name" provided by ida-plugin.json or basename of path (without extension)

ida_loader.plugin_info_t.name
    short name of the plugin it will appear in the menu 
            

ida_loader.plugin_info_t.next
    next plugin information

ida_loader.plugin_info_t.org_hotkey
    original hotkey to run the plugin

ida_loader.plugin_info_t.org_name
    original short name of the plugin

ida_loader.plugin_info_t.path
    full path to the plugin

ida_loader.process_archive(temp_file: str, li: "linput_t *", module_name: str, neflags: "ushort *", defmember: str, loader: "load_info_t const *") -> str
    Calls loader_t::process_archive() For parameters and return value description look at loader_t::process_archive(). Additional parameter 'loader' is a pointer to load_info_t structure. 
            

ida_loader.qvector_snapshotvec_t

ida_loader.qvector_snapshotvec_t.__eq__(self, r: "qvector_snapshotvec_t") -> bool

ida_loader.qvector_snapshotvec_t.__getitem__(self, i: "size_t") -> "snapshot_t *const &"

ida_loader.qvector_snapshotvec_t.__init__(self, *args)

ida_loader.qvector_snapshotvec_t.__len__(self) -> "size_t"

ida_loader.qvector_snapshotvec_t.__ne__(self, r: "qvector_snapshotvec_t") -> bool

ida_loader.qvector_snapshotvec_t.__setitem__(self, i: "size_t", v: "snapshot_t") -> None

ida_loader.qvector_snapshotvec_t._del(self, x: "snapshot_t") -> bool

ida_loader.qvector_snapshotvec_t.add_unique(self, x: "snapshot_t") -> bool

ida_loader.qvector_snapshotvec_t.append(self, x: "snapshot_t") -> None

ida_loader.qvector_snapshotvec_t.at(self, _idx: "size_t") -> "snapshot_t *const &"

ida_loader.qvector_snapshotvec_t.begin(self, *args) -> "qvector< snapshot_t * >::const_iterator"

ida_loader.qvector_snapshotvec_t.capacity(self) -> "size_t"

ida_loader.qvector_snapshotvec_t.clear(self) -> None

ida_loader.qvector_snapshotvec_t.empty(self) -> bool

ida_loader.qvector_snapshotvec_t.end(self, *args) -> "qvector< snapshot_t * >::const_iterator"

ida_loader.qvector_snapshotvec_t.erase(self, *args) -> "qvector< snapshot_t * >::iterator"

ida_loader.qvector_snapshotvec_t.extend(self, x: "qvector_snapshotvec_t") -> None

ida_loader.qvector_snapshotvec_t.extract(self) -> "snapshot_t **"

ida_loader.qvector_snapshotvec_t.find(self, *args) -> "qvector< snapshot_t * >::const_iterator"

ida_loader.qvector_snapshotvec_t.has(self, x: "snapshot_t") -> bool

ida_loader.qvector_snapshotvec_t.inject(self, s: "snapshot_t **", len: "size_t") -> None

ida_loader.qvector_snapshotvec_t.insert(self, it: "qvector< snapshot_t * >::iterator", x: "snapshot_t") -> "qvector< snapshot_t * >::iterator"

ida_loader.qvector_snapshotvec_t.pop_back(self) -> None

ida_loader.qvector_snapshotvec_t.push_back(self, *args) -> "snapshot_t *&"

ida_loader.qvector_snapshotvec_t.qclear(self) -> None

ida_loader.qvector_snapshotvec_t.reserve(self, cnt: "size_t") -> None

ida_loader.qvector_snapshotvec_t.resize(self, *args) -> None

ida_loader.qvector_snapshotvec_t.size(self) -> "size_t"

ida_loader.qvector_snapshotvec_t.swap(self, r: "qvector_snapshotvec_t") -> None

ida_loader.qvector_snapshotvec_t.truncate(self) -> None

ida_loader.reload_file(file: str, is_remote: bool) -> bool
    Reload the input file. This function reloads the byte values from the input file. It doesn't modify the segmentation, names, comments, etc. 
            
    @param file: name of the input file. if file == nullptr then returns:
    * 1: can reload the input file
    * 0: can't reload the input file
    @param is_remote: is the file located on a remote computer with the debugger server?
    @returns success

ida_loader.run_plugin(plg, arg)
    Runs a plugin
    
    @param plg: A plugin object (returned by load_plugin())
    @param arg: the code to pass to the plugin's "run()" function
    @return: Boolean

ida_loader.save_database(outfile: str = None, flags: int = -1, root: "snapshot_t" = None, attr: "snapshot_t" = None) -> bool
    Save current database using a new file name. 
            
    @param outfile: output database file name; nullptr means the current path
    @param flags: Database flags; -1 means the current flags
    @param root: optional: snapshot tree root.
    @param attr: optional: snapshot attributes
    @returns success

ida_loader.set_database_flag(dbfl: int, cnd: bool = True) -> None
    Set or clear database flag 
            
    @param dbfl: flag Database flags
    @param cnd: set if true or clear flag otherwise

ida_loader.set_import_name(modnode: int, ea: ida_idaapi.ea_t, name: str) -> None
    Set information about the named import entry. This function performs 'modnode.supset_ea(ea, name);' 
            
    @param modnode: node with information about imported entries
    @param ea: linear address of the entry
    @param name: name of the entry

ida_loader.set_import_ordinal(modnode: int, ea: ida_idaapi.ea_t, ord: int) -> None
    Set information about the ordinal import entry. This function performs 'modnode.altset(ord, ea2node(ea));' 
            
    @param modnode: node with information about imported entries
    @param ea: linear address of the entry
    @param ord: ordinal number of the entry

ida_loader.set_path(pt: "path_type_t", path: str) -> None
    Set the file path 
            
    @param pt: file path type Types of the file pathes
    @param path: new file path, use nullptr or empty string to clear the file path

ida_loader.snapshot_t

ida_loader.snapshot_t.__eq__(self, r: "snapshot_t") -> bool

ida_loader.snapshot_t.__ge__(self, r: "snapshot_t") -> bool

ida_loader.snapshot_t.__gt__(self, r: "snapshot_t") -> bool

ida_loader.snapshot_t.__init__(self)

ida_loader.snapshot_t.__le__(self, r: "snapshot_t") -> bool

ida_loader.snapshot_t.__lt__(self, r: "snapshot_t") -> bool

ida_loader.snapshot_t.__ne__(self, r: "snapshot_t") -> bool

ida_loader.snapshot_t.children
    snapshot children

ida_loader.snapshot_t.clear(self) -> None

ida_loader.snapshot_t.desc
    snapshot description

ida_loader.snapshot_t.filename
    snapshot file name

ida_loader.snapshot_t.flags
    Snapshot flags 
            

ida_loader.snapshot_t.id
    snapshot ID. This value is computed using qgettimeofday()

ida_lumina

ida_lumina.AMDF_FORCE
    apply kvps regardless of what's currently in the IDB, possibly removing some attributes currently present (e.g., name, or prototype could be lost) 
            

ida_lumina.AMDF_UPGRADE
    apply kvps that seem to be of higher "quality" than what's currently in the IDB 
            

ida_lumina.apply_metadata(ea: ida_idaapi.ea_t, fi: "func_info_t", flags: int = 0) -> None

ida_lumina.backup_metadata(ea: ida_idaapi.ea_t) -> bool

ida_lumina.calc_func_metadata(out_fi: "func_info_t", pfn: "func_t const *", append_metadata: "metadata_appender_t *" = None) -> "md5_t *"

ida_lumina.diff_metadata(handler: "func_md_diff_handler_t", left: "func_info_t", right: "func_info_t", flags: int = 0) -> bool

ida_lumina.extra_cmt_t

ida_lumina.extra_cmt_t.__init__(self)

ida_lumina.extra_cmts_t

ida_lumina.extra_cmts_t.__getitem__(self, i: "size_t") -> "extra_cmt_t const &"

ida_lumina.extra_cmts_t.__init__(self, *args)

ida_lumina.extra_cmts_t.__len__(self) -> "size_t"

ida_lumina.extra_cmts_t.__setitem__(self, i: "size_t", v: "extra_cmt_t") -> None

ida_lumina.extra_cmts_t.append(self, x: "extra_cmt_t") -> None

ida_lumina.extra_cmts_t.at(self, _idx: "size_t") -> "extra_cmt_t const &"

ida_lumina.extra_cmts_t.begin(self, *args) -> "qvector< extra_cmt_t >::const_iterator"

ida_lumina.extra_cmts_t.capacity(self) -> "size_t"

ida_lumina.extra_cmts_t.clear(self) -> None

ida_lumina.extra_cmts_t.empty(self) -> bool

ida_lumina.extra_cmts_t.end(self, *args) -> "qvector< extra_cmt_t >::const_iterator"

ida_lumina.extra_cmts_t.erase(self, *args) -> "qvector< extra_cmt_t >::iterator"

ida_lumina.extra_cmts_t.extend(self, x: "extra_cmts_t") -> None

ida_lumina.extra_cmts_t.extract(self) -> "extra_cmt_t *"

ida_lumina.extra_cmts_t.grow(self, *args) -> None

ida_lumina.extra_cmts_t.inject(self, s: "extra_cmt_t", len: "size_t") -> None

ida_lumina.extra_cmts_t.insert(self, it: "extra_cmt_t", x: "extra_cmt_t") -> "qvector< extra_cmt_t >::iterator"

ida_lumina.extra_cmts_t.pop_back(self) -> None

ida_lumina.extra_cmts_t.push_back(self, *args) -> "extra_cmt_t &"

ida_lumina.extra_cmts_t.qclear(self) -> None

ida_lumina.extra_cmts_t.reserve(self, cnt: "size_t") -> None

ida_lumina.extra_cmts_t.resize(self, *args) -> None

ida_lumina.extra_cmts_t.size(self) -> "size_t"

ida_lumina.extra_cmts_t.swap(self, r: "extra_cmts_t") -> None

ida_lumina.extra_cmts_t.truncate(self) -> None

ida_lumina.extract_extra_cmts_from_metadata(out: "extra_cmts_t", ptr: "uchar const *") -> None

ida_lumina.extract_frame_desc_from_metadata(out: "frame_desc_t", ptr: "uchar const *") -> None

ida_lumina.extract_insn_cmts_from_metadata(out: "insn_cmts_t", ptr: "uchar const *") -> None

ida_lumina.extract_insn_opreprs_from_metadata(out: "insn_ops_reprs_t", ptr: "uchar const *") -> None

ida_lumina.extract_insn_opreprs_from_metadata_ex(out: "insn_ops_reprs_t", ptr: "uchar const *") -> None

ida_lumina.extract_type_from_metadata(out: "tinfo_t", _in: "bytevec_t const &") -> bool

ida_lumina.extract_user_stkpnts_from_metadata(out: "user_stkpnts_t", ptr: "uchar const *") -> None

ida_lumina.frame_desc_t

ida_lumina.frame_desc_t.__init__(self, *args)

ida_lumina.frame_mem_t

ida_lumina.frame_mem_t.__init__(self, *args)

ida_lumina.frame_mems_t

ida_lumina.frame_mems_t.__getitem__(self, i: "size_t") -> "frame_mem_t const &"

ida_lumina.frame_mems_t.__init__(self, *args)

ida_lumina.frame_mems_t.__len__(self) -> "size_t"

ida_lumina.frame_mems_t.__setitem__(self, i: "size_t", v: "frame_mem_t") -> None

ida_lumina.frame_mems_t.append(self, x: "frame_mem_t") -> None

ida_lumina.frame_mems_t.at(self, _idx: "size_t") -> "frame_mem_t const &"

ida_lumina.frame_mems_t.begin(self, *args) -> "qvector< frame_mem_t >::const_iterator"

ida_lumina.frame_mems_t.capacity(self) -> "size_t"

ida_lumina.frame_mems_t.clear(self) -> None

ida_lumina.frame_mems_t.empty(self) -> bool

ida_lumina.frame_mems_t.end(self, *args) -> "qvector< frame_mem_t >::const_iterator"

ida_lumina.frame_mems_t.erase(self, *args) -> "qvector< frame_mem_t >::iterator"

ida_lumina.frame_mems_t.extend(self, x: "frame_mems_t") -> None

ida_lumina.frame_mems_t.extract(self) -> "frame_mem_t *"

ida_lumina.frame_mems_t.grow(self, *args) -> None

ida_lumina.frame_mems_t.inject(self, s: "frame_mem_t", len: "size_t") -> None

ida_lumina.frame_mems_t.insert(self, it: "frame_mem_t", x: "frame_mem_t") -> "qvector< frame_mem_t >::iterator"

ida_lumina.frame_mems_t.pop_back(self) -> None

ida_lumina.frame_mems_t.push_back(self, *args) -> "frame_mem_t &"

ida_lumina.frame_mems_t.qclear(self) -> None

ida_lumina.frame_mems_t.reserve(self, cnt: "size_t") -> None

ida_lumina.frame_mems_t.resize(self, *args) -> None

ida_lumina.frame_mems_t.size(self) -> "size_t"

ida_lumina.frame_mems_t.swap(self, r: "frame_mems_t") -> None

ida_lumina.frame_mems_t.truncate(self) -> None

ida_lumina.func_info_and_frequency_t

ida_lumina.func_info_and_frequency_t.__init__(self, __frequency: int = 0)

ida_lumina.func_info_and_frequency_vec_t

ida_lumina.func_info_and_frequency_vec_t.__getitem__(self, i: "size_t") -> "func_info_and_frequency_t const &"

ida_lumina.func_info_and_frequency_vec_t.__init__(self, *args)

ida_lumina.func_info_and_frequency_vec_t.__len__(self) -> "size_t"

ida_lumina.func_info_and_frequency_vec_t.__setitem__(self, i: "size_t", v: "func_info_and_frequency_t") -> None

ida_lumina.func_info_and_frequency_vec_t.append(self, x: "func_info_and_frequency_t") -> None

ida_lumina.func_info_and_frequency_vec_t.at(self, _idx: "size_t") -> "func_info_and_frequency_t const &"

ida_lumina.func_info_and_frequency_vec_t.begin(self, *args) -> "qvector< func_info_and_frequency_t >::const_iterator"

ida_lumina.func_info_and_frequency_vec_t.capacity(self) -> "size_t"

ida_lumina.func_info_and_frequency_vec_t.clear(self) -> None

ida_lumina.func_info_and_frequency_vec_t.empty(self) -> bool

ida_lumina.func_info_and_frequency_vec_t.end(self, *args) -> "qvector< func_info_and_frequency_t >::const_iterator"

ida_lumina.func_info_and_frequency_vec_t.erase(self, *args) -> "qvector< func_info_and_frequency_t >::iterator"

ida_lumina.func_info_and_frequency_vec_t.extend(self, x: "func_info_and_frequency_vec_t") -> None

ida_lumina.func_info_and_frequency_vec_t.extract(self) -> "func_info_and_frequency_t *"

ida_lumina.func_info_and_frequency_vec_t.grow(self, *args) -> None

ida_lumina.func_info_and_frequency_vec_t.inject(self, s: "func_info_and_frequency_t", len: "size_t") -> None

ida_lumina.func_info_and_frequency_vec_t.insert(self, it: "func_info_and_frequency_t", x: "func_info_and_frequency_t") -> "qvector< func_info_and_frequency_t >::iterator"

ida_lumina.func_info_and_frequency_vec_t.pop_back(self) -> None

ida_lumina.func_info_and_frequency_vec_t.push_back(self, *args) -> "func_info_and_frequency_t &"

ida_lumina.func_info_and_frequency_vec_t.qclear(self) -> None

ida_lumina.func_info_and_frequency_vec_t.reserve(self, cnt: "size_t") -> None

ida_lumina.func_info_and_frequency_vec_t.resize(self, *args) -> None

ida_lumina.func_info_and_frequency_vec_t.size(self) -> "size_t"

ida_lumina.func_info_and_frequency_vec_t.swap(self, r: "func_info_and_frequency_vec_t") -> None

ida_lumina.func_info_and_frequency_vec_t.truncate(self) -> None

ida_lumina.func_info_and_pattern_t

ida_lumina.func_info_and_pattern_t.__init__(self, *args)

ida_lumina.func_info_and_pattern_vec_t

ida_lumina.func_info_and_pattern_vec_t.__getitem__(self, i: "size_t") -> "func_info_and_pattern_t const &"

ida_lumina.func_info_and_pattern_vec_t.__init__(self, *args)

ida_lumina.func_info_and_pattern_vec_t.__len__(self) -> "size_t"

ida_lumina.func_info_and_pattern_vec_t.__setitem__(self, i: "size_t", v: "func_info_and_pattern_t") -> None

ida_lumina.func_info_and_pattern_vec_t.append(self, x: "func_info_and_pattern_t") -> None

ida_lumina.func_info_and_pattern_vec_t.at(self, _idx: "size_t") -> "func_info_and_pattern_t const &"

ida_lumina.func_info_and_pattern_vec_t.begin(self, *args) -> "qvector< func_info_and_pattern_t >::const_iterator"

ida_lumina.func_info_and_pattern_vec_t.capacity(self) -> "size_t"

ida_lumina.func_info_and_pattern_vec_t.clear(self) -> None

ida_lumina.func_info_and_pattern_vec_t.empty(self) -> bool

ida_lumina.func_info_and_pattern_vec_t.end(self, *args) -> "qvector< func_info_and_pattern_t >::const_iterator"

ida_lumina.func_info_and_pattern_vec_t.erase(self, *args) -> "qvector< func_info_and_pattern_t >::iterator"

ida_lumina.func_info_and_pattern_vec_t.extend(self, x: "func_info_and_pattern_vec_t") -> None

ida_lumina.func_info_and_pattern_vec_t.extract(self) -> "func_info_and_pattern_t *"

ida_lumina.func_info_and_pattern_vec_t.grow(self, *args) -> None

ida_lumina.func_info_and_pattern_vec_t.inject(self, s: "func_info_and_pattern_t", len: "size_t") -> None

ida_lumina.func_info_and_pattern_vec_t.insert(self, it: "func_info_and_pattern_t", x: "func_info_and_pattern_t") -> "qvector< func_info_and_pattern_t >::iterator"

ida_lumina.func_info_and_pattern_vec_t.pop_back(self) -> None

ida_lumina.func_info_and_pattern_vec_t.push_back(self, *args) -> "func_info_and_pattern_t &"

ida_lumina.func_info_and_pattern_vec_t.qclear(self) -> None

ida_lumina.func_info_and_pattern_vec_t.reserve(self, cnt: "size_t") -> None

ida_lumina.func_info_and_pattern_vec_t.resize(self, *args) -> None

ida_lumina.func_info_and_pattern_vec_t.size(self) -> "size_t"

ida_lumina.func_info_and_pattern_vec_t.swap(self, r: "func_info_and_pattern_vec_t") -> None

ida_lumina.func_info_and_pattern_vec_t.truncate(self) -> None

ida_lumina.func_info_base_t

ida_lumina.func_info_base_t.__init__(self, *args)

ida_lumina.func_info_pattern_and_frequency_t

ida_lumina.func_info_pattern_and_frequency_t.__init__(self, __frequency: int = 0)

ida_lumina.func_info_pattern_and_frequency_vec_t

ida_lumina.func_info_pattern_and_frequency_vec_t.__getitem__(self, i: "size_t") -> "func_info_pattern_and_frequency_t const &"

ida_lumina.func_info_pattern_and_frequency_vec_t.__init__(self, *args)

ida_lumina.func_info_pattern_and_frequency_vec_t.__len__(self) -> "size_t"

ida_lumina.func_info_pattern_and_frequency_vec_t.__setitem__(self, i: "size_t", v: "func_info_pattern_and_frequency_t") -> None

ida_lumina.func_info_pattern_and_frequency_vec_t.append(self, x: "func_info_pattern_and_frequency_t") -> None

ida_lumina.func_info_pattern_and_frequency_vec_t.at(self, _idx: "size_t") -> "func_info_pattern_and_frequency_t const &"

ida_lumina.func_info_pattern_and_frequency_vec_t.begin(self, *args) -> "qvector< func_info_pattern_and_frequency_t >::const_iterator"

ida_lumina.func_info_pattern_and_frequency_vec_t.capacity(self) -> "size_t"

ida_lumina.func_info_pattern_and_frequency_vec_t.clear(self) -> None

ida_lumina.func_info_pattern_and_frequency_vec_t.empty(self) -> bool

ida_lumina.func_info_pattern_and_frequency_vec_t.end(self, *args) -> "qvector< func_info_pattern_and_frequency_t >::const_iterator"

ida_lumina.func_info_pattern_and_frequency_vec_t.erase(self, *args) -> "qvector< func_info_pattern_and_frequency_t >::iterator"

ida_lumina.func_info_pattern_and_frequency_vec_t.extend(self, x: "func_info_pattern_and_frequency_vec_t") -> None

ida_lumina.func_info_pattern_and_frequency_vec_t.extract(self) -> "func_info_pattern_and_frequency_t *"

ida_lumina.func_info_pattern_and_frequency_vec_t.grow(self, *args) -> None

ida_lumina.func_info_pattern_and_frequency_vec_t.inject(self, s: "func_info_pattern_and_frequency_t", len: "size_t") -> None

ida_lumina.func_info_pattern_and_frequency_vec_t.insert(self, it: "func_info_pattern_and_frequency_t", x: "func_info_pattern_and_frequency_t") -> "qvector< func_info_pattern_and_frequency_t >::iterator"

ida_lumina.func_info_pattern_and_frequency_vec_t.pop_back(self) -> None

ida_lumina.func_info_pattern_and_frequency_vec_t.push_back(self, *args) -> "func_info_pattern_and_frequency_t &"

ida_lumina.func_info_pattern_and_frequency_vec_t.qclear(self) -> None

ida_lumina.func_info_pattern_and_frequency_vec_t.reserve(self, cnt: "size_t") -> None

ida_lumina.func_info_pattern_and_frequency_vec_t.resize(self, *args) -> None

ida_lumina.func_info_pattern_and_frequency_vec_t.size(self) -> "size_t"

ida_lumina.func_info_pattern_and_frequency_vec_t.swap(self, r: "func_info_pattern_and_frequency_vec_t") -> None

ida_lumina.func_info_pattern_and_frequency_vec_t.truncate(self) -> None

ida_lumina.func_info_t

ida_lumina.func_info_t.__init__(self, *args)

ida_lumina.func_info_vec_t

ida_lumina.func_info_vec_t.__getitem__(self, i: "size_t") -> "func_info_t const &"

ida_lumina.func_info_vec_t.__init__(self, *args)

ida_lumina.func_info_vec_t.__len__(self) -> "size_t"

ida_lumina.func_info_vec_t.__setitem__(self, i: "size_t", v: "func_info_t") -> None

ida_lumina.func_info_vec_t.append(self, x: "func_info_t") -> None

ida_lumina.func_info_vec_t.at(self, _idx: "size_t") -> "func_info_t const &"

ida_lumina.func_info_vec_t.begin(self, *args) -> "qvector< func_info_t >::const_iterator"

ida_lumina.func_info_vec_t.capacity(self) -> "size_t"

ida_lumina.func_info_vec_t.clear(self) -> None

ida_lumina.func_info_vec_t.empty(self) -> bool

ida_lumina.func_info_vec_t.end(self, *args) -> "qvector< func_info_t >::const_iterator"

ida_lumina.func_info_vec_t.erase(self, *args) -> "qvector< func_info_t >::iterator"

ida_lumina.func_info_vec_t.extend(self, x: "func_info_vec_t") -> None

ida_lumina.func_info_vec_t.extract(self) -> "func_info_t *"

ida_lumina.func_info_vec_t.grow(self, *args) -> None

ida_lumina.func_info_vec_t.inject(self, s: "func_info_t", len: "size_t") -> None

ida_lumina.func_info_vec_t.insert(self, it: "func_info_t", x: "func_info_t") -> "qvector< func_info_t >::iterator"

ida_lumina.func_info_vec_t.pop_back(self) -> None

ida_lumina.func_info_vec_t.push_back(self, *args) -> "func_info_t &"

ida_lumina.func_info_vec_t.qclear(self) -> None

ida_lumina.func_info_vec_t.reserve(self, cnt: "size_t") -> None

ida_lumina.func_info_vec_t.resize(self, *args) -> None

ida_lumina.func_info_vec_t.size(self) -> "size_t"

ida_lumina.func_info_vec_t.swap(self, r: "func_info_vec_t") -> None

ida_lumina.func_info_vec_t.truncate(self) -> None

ida_lumina.func_md_diff_handler_t

ida_lumina.func_md_diff_handler_t.__disown__(self)

ida_lumina.func_md_diff_handler_t.__init__(self)

ida_lumina.func_md_diff_handler_t.on_comment_changed(self, fchunk_nr: int, fchunk_off: int, l: str, r: str, rep: bool) -> None

ida_lumina.func_md_diff_handler_t.on_extra_comment_changed(self, fchunk_nr: int, fchunk_off: int, l: str, r: str, is_prev: bool) -> None

ida_lumina.func_md_diff_handler_t.on_frame_member_changed(self, offset: int, l: "frame_mem_t", r: "frame_mem_t") -> None

ida_lumina.func_md_diff_handler_t.on_function_comment_changed(self, l: str, r: str, rep: bool) -> None

ida_lumina.func_md_diff_handler_t.on_insn_ops_repr_changed(self, fchunk_nr: int, fchunk_off: int, l: "insn_ops_repr_t", r: "insn_ops_repr_t") -> None

ida_lumina.func_md_diff_handler_t.on_name_changed(self, l: str, r: str) -> None

ida_lumina.func_md_diff_handler_t.on_proto_changed(self, l: "md_type_parts_t", r: "md_type_parts_t") -> None

ida_lumina.func_md_diff_handler_t.on_score_changed(self, l: int, r: int) -> None

ida_lumina.func_md_diff_handler_t.on_user_stkpnt_changed(self, fchunk_nr: int, fchunk_off: int, l: "int64 const *", r: "int64 const *") -> None

ida_lumina.get_lumina_rpc_packet_t_index_from_base(code: "lumina_rpc_packet_t") -> "uchar"

ida_lumina.get_server_connection() -> "lumina_client_t *"

ida_lumina.get_server_connection2(flags: int) -> "lumina_client_t *"

ida_lumina.has_backup_metadata(ea: ida_idaapi.ea_t) -> bool

ida_lumina.input_file_t

ida_lumina.input_file_t.__init__(self, *args)

ida_lumina.insn_cmt_t

ida_lumina.insn_cmt_t.__init__(self)

ida_lumina.insn_cmts_t

ida_lumina.insn_cmts_t.__getitem__(self, i: "size_t") -> "insn_cmt_t const &"

ida_lumina.insn_cmts_t.__init__(self, *args)

ida_lumina.insn_cmts_t.__len__(self) -> "size_t"

ida_lumina.insn_cmts_t.__setitem__(self, i: "size_t", v: "insn_cmt_t") -> None

ida_lumina.insn_cmts_t.append(self, x: "insn_cmt_t") -> None

ida_lumina.insn_cmts_t.at(self, _idx: "size_t") -> "insn_cmt_t const &"

ida_lumina.insn_cmts_t.begin(self, *args) -> "qvector< insn_cmt_t >::const_iterator"

ida_lumina.insn_cmts_t.capacity(self) -> "size_t"

ida_lumina.insn_cmts_t.clear(self) -> None

ida_lumina.insn_cmts_t.empty(self) -> bool

ida_lumina.insn_cmts_t.end(self, *args) -> "qvector< insn_cmt_t >::const_iterator"

ida_lumina.insn_cmts_t.erase(self, *args) -> "qvector< insn_cmt_t >::iterator"

ida_lumina.insn_cmts_t.extend(self, x: "insn_cmts_t") -> None

ida_lumina.insn_cmts_t.extract(self) -> "insn_cmt_t *"

ida_lumina.insn_cmts_t.grow(self, *args) -> None

ida_lumina.insn_cmts_t.inject(self, s: "insn_cmt_t", len: "size_t") -> None

ida_lumina.insn_cmts_t.insert(self, it: "insn_cmt_t", x: "insn_cmt_t") -> "qvector< insn_cmt_t >::iterator"

ida_lumina.insn_cmts_t.pop_back(self) -> None

ida_lumina.insn_cmts_t.push_back(self, *args) -> "insn_cmt_t &"

ida_lumina.insn_cmts_t.qclear(self) -> None

ida_lumina.insn_cmts_t.reserve(self, cnt: "size_t") -> None

ida_lumina.insn_cmts_t.resize(self, *args) -> None

ida_lumina.insn_cmts_t.size(self) -> "size_t"

ida_lumina.insn_cmts_t.swap(self, r: "insn_cmts_t") -> None

ida_lumina.insn_cmts_t.truncate(self) -> None

ida_lumina.insn_ops_repr_t

ida_lumina.insn_ops_repr_t.__init__(self)

ida_lumina.insn_ops_reprs_t

ida_lumina.insn_ops_reprs_t.__getitem__(self, i: "size_t") -> "insn_ops_repr_t const &"

ida_lumina.insn_ops_reprs_t.__init__(self, *args)

ida_lumina.insn_ops_reprs_t.__len__(self) -> "size_t"

ida_lumina.insn_ops_reprs_t.__setitem__(self, i: "size_t", v: "insn_ops_repr_t") -> None

ida_lumina.insn_ops_reprs_t.append(self, x: "insn_ops_repr_t") -> None

ida_lumina.insn_ops_reprs_t.at(self, _idx: "size_t") -> "insn_ops_repr_t const &"

ida_lumina.insn_ops_reprs_t.begin(self, *args) -> "qvector< insn_ops_repr_t >::const_iterator"

ida_lumina.insn_ops_reprs_t.capacity(self) -> "size_t"

ida_lumina.insn_ops_reprs_t.clear(self) -> None

ida_lumina.insn_ops_reprs_t.empty(self) -> bool

ida_lumina.insn_ops_reprs_t.end(self, *args) -> "qvector< insn_ops_repr_t >::const_iterator"

ida_lumina.insn_ops_reprs_t.erase(self, *args) -> "qvector< insn_ops_repr_t >::iterator"

ida_lumina.insn_ops_reprs_t.extend(self, x: "insn_ops_reprs_t") -> None

ida_lumina.insn_ops_reprs_t.extract(self) -> "insn_ops_repr_t *"

ida_lumina.insn_ops_reprs_t.grow(self, *args) -> None

ida_lumina.insn_ops_reprs_t.inject(self, s: "insn_ops_repr_t", len: "size_t") -> None

ida_lumina.insn_ops_reprs_t.insert(self, it: "insn_ops_repr_t", x: "insn_ops_repr_t") -> "qvector< insn_ops_repr_t >::iterator"

ida_lumina.insn_ops_reprs_t.pop_back(self) -> None

ida_lumina.insn_ops_reprs_t.push_back(self, *args) -> "insn_ops_repr_t &"

ida_lumina.insn_ops_reprs_t.qclear(self) -> None

ida_lumina.insn_ops_reprs_t.reserve(self, cnt: "size_t") -> None

ida_lumina.insn_ops_reprs_t.resize(self, *args) -> None

ida_lumina.insn_ops_reprs_t.size(self) -> "size_t"

ida_lumina.insn_ops_reprs_t.swap(self, r: "insn_ops_reprs_t") -> None

ida_lumina.insn_ops_reprs_t.truncate(self) -> None

ida_lumina.insn_site_t

ida_lumina.insn_site_t.__init__(self)

ida_lumina.insn_site_t.toea(self, pfn: "func_t const *") -> ida_idaapi.ea_t

ida_lumina.lumina_client_t

ida_lumina.lumina_client_t.__init__(self, *args, **kwargs)

ida_lumina.lumina_client_t.del_history(self, funcs: "eavec_t const &") -> bool

ida_lumina.lumina_client_t.get_pop(self, nresults: int = 10) -> "pkt_get_pop_result_t *"

ida_lumina.lumina_client_t.is_pattern_id(self, pid: "pattern_id_t", md5: "md5_t const &") -> bool

ida_lumina.lumina_client_t.pull_md(self, *args) -> "pkt_pull_md_result_t *"
    This function has the following signatures:
    
        0. pull_md(pattern_ids: pattern_ids_t &, errbuf: str, pull_md_flags: int=0) -> pkt_pull_md_result_t *
        1. pull_md(funcs: eavec_t *, errbuf: str, pull_md_flags: int=0) -> pkt_pull_md_result_t *
    
    # 0: pull_md(pattern_ids: pattern_ids_t &, errbuf: str, pull_md_flags: int=0) -> pkt_pull_md_result_t *
    
    
    # 1: pull_md(funcs: eavec_t *, errbuf: str, pull_md_flags: int=0) -> pkt_pull_md_result_t *

ida_lumina.lumina_client_t.push_md(self, result: "push_md_result_t", opts: "push_md_opts_t", append_metadata: "metadata_appender_t *" = None, flags: int = 0) -> bool

ida_lumina.lumina_client_t.set_pattern_id_md5(self, out: "pattern_id_t", md5: "md5_t const &") -> None

ida_lumina.lumina_info_t

ida_lumina.lumina_info_t.__init__(self, *args)

ida_lumina.lumina_op_res_vec_t

ida_lumina.lumina_op_res_vec_t.__eq__(self, r: "lumina_op_res_vec_t") -> bool

ida_lumina.lumina_op_res_vec_t.__getitem__(self, i: "size_t") -> "lumina_op_res_t const &"

ida_lumina.lumina_op_res_vec_t.__init__(self, *args)

ida_lumina.lumina_op_res_vec_t.__len__(self) -> "size_t"

ida_lumina.lumina_op_res_vec_t.__ne__(self, r: "lumina_op_res_vec_t") -> bool

ida_lumina.lumina_op_res_vec_t.__setitem__(self, i: "size_t", v: "lumina_op_res_t const &") -> None

ida_lumina.lumina_op_res_vec_t._del(self, x: "lumina_op_res_t const &") -> bool

ida_lumina.lumina_op_res_vec_t.add_unique(self, x: "lumina_op_res_t const &") -> bool

ida_lumina.lumina_op_res_vec_t.append(self, x: "lumina_op_res_t const &") -> None

ida_lumina.lumina_op_res_vec_t.at(self, _idx: "size_t") -> "lumina_op_res_t const &"

ida_lumina.lumina_op_res_vec_t.begin(self, *args) -> "qvector< lumina_op_res_t >::const_iterator"

ida_lumina.lumina_op_res_vec_t.capacity(self) -> "size_t"

ida_lumina.lumina_op_res_vec_t.clear(self) -> None

ida_lumina.lumina_op_res_vec_t.empty(self) -> bool

ida_lumina.lumina_op_res_vec_t.end(self, *args) -> "qvector< lumina_op_res_t >::const_iterator"

ida_lumina.lumina_op_res_vec_t.erase(self, *args) -> "qvector< lumina_op_res_t >::iterator"

ida_lumina.lumina_op_res_vec_t.extend(self, x: "lumina_op_res_vec_t") -> None

ida_lumina.lumina_op_res_vec_t.extract(self) -> "lumina_op_res_t *"

ida_lumina.lumina_op_res_vec_t.find(self, *args) -> "qvector< lumina_op_res_t >::const_iterator"

ida_lumina.lumina_op_res_vec_t.grow(self, *args) -> None

ida_lumina.lumina_op_res_vec_t.has(self, x: "lumina_op_res_t const &") -> bool

ida_lumina.lumina_op_res_vec_t.inject(self, s: "lumina_op_res_t *", len: "size_t") -> None

ida_lumina.lumina_op_res_vec_t.insert(self, it: "qvector< lumina_op_res_t >::iterator", x: "lumina_op_res_t const &") -> "qvector< lumina_op_res_t >::iterator"

ida_lumina.lumina_op_res_vec_t.pop_back(self) -> None

ida_lumina.lumina_op_res_vec_t.push_back(self, *args) -> "lumina_op_res_t &"

ida_lumina.lumina_op_res_vec_t.qclear(self) -> None

ida_lumina.lumina_op_res_vec_t.reserve(self, cnt: "size_t") -> None

ida_lumina.lumina_op_res_vec_t.resize(self, *args) -> None

ida_lumina.lumina_op_res_vec_t.size(self) -> "size_t"

ida_lumina.lumina_op_res_vec_t.swap(self, r: "lumina_op_res_vec_t") -> None

ida_lumina.lumina_op_res_vec_t.truncate(self) -> None

ida_lumina.lumina_server_info_t

ida_lumina.lumina_server_info_t.__init__(self, __macaddr: str = None, __verstr: str = None, __start_time: "utc_timestamp_t" = 0, __current_time: "utc_timestamp_t" = 0)

ida_lumina.lumina_user_t

ida_lumina.lumina_user_t.__init__(self, *args)

ida_lumina.lumina_user_t.can_del_history(self) -> bool

ida_lumina.lumina_user_t.is_admin(self) -> bool

ida_lumina.lumina_user_t.set_can_del_history(self, v: bool = True) -> None

ida_lumina.lumina_user_t.set_is_admin(self, v: bool = True) -> None

ida_lumina.md_type_parts_t

ida_lumina.md_type_parts_t.__eq__(self, r: "md_type_parts_t") -> bool

ida_lumina.md_type_parts_t.__init__(self)

ida_lumina.md_type_parts_t.__ne__(self, r: "md_type_parts_t") -> bool

ida_lumina.metadata_iterator_t

ida_lumina.metadata_iterator_t.__init__(self, _md: "metadata_t const &")

ida_lumina.metadata_iterator_t.data_end(self) -> "uchar const *"

ida_lumina.metadata_iterator_t.next(self) -> bool

ida_lumina.new_packet(code: "uchar", ptr: "uchar const *" = None, len: "size_t" = 0, version: int = -1) -> "rpc_packet_data_t *"

ida_lumina.oprepr_t

ida_lumina.oprepr_t.__init__(self)

ida_lumina.pattern_id_t

ida_lumina.pattern_id_t.__init__(self, *args)

ida_lumina.peer_conn_t

ida_lumina.peer_conn_t.__init__(self, *args)

ida_lumina.pkt_get_lumina_info_result_t

ida_lumina.pkt_get_lumina_info_result_t.__init__(self)

ida_lumina.pkt_get_lumina_info_t

ida_lumina.pkt_get_lumina_info_t.__init__(self)

ida_lumina.pkt_get_pop_result_t

ida_lumina.pkt_get_pop_result_t.__init__(self)

ida_lumina.pkt_get_pop_t

ida_lumina.pkt_get_pop_t.__init__(self)

ida_lumina.pkt_helo_result_t

ida_lumina.pkt_helo_result_t.__init__(self)

ida_lumina.pkt_helo_t

ida_lumina.pkt_helo_t.__init__(self)

ida_lumina.pkt_pull_md_result_t

ida_lumina.pkt_pull_md_result_t.__init__(self)

ida_lumina.pkt_pull_md_t

ida_lumina.pkt_pull_md_t.__init__(self)

ida_lumina.pkt_push_md_result_t

ida_lumina.pkt_push_md_result_t.__init__(self)

ida_lumina.pkt_push_md_t

ida_lumina.pkt_push_md_t.__init__(self)

ida_lumina.pkt_rpc_fail_t

ida_lumina.pkt_rpc_fail_t.__init__(self)

ida_lumina.pkt_rpc_notify_t

ida_lumina.pkt_rpc_notify_t.__init__(self)

ida_lumina.pkt_rpc_ok_t

ida_lumina.pkt_rpc_ok_t.__init__(self)

ida_lumina.pop_fun_t

ida_lumina.pop_fun_t.__init__(self, *args)

ida_lumina.push_md_opts_t

ida_lumina.push_md_opts_t.__init__(self, *args)

ida_lumina.push_md_result_t

ida_lumina.push_md_result_t.__init__(self)

ida_lumina.revert_metadata(ea: ida_idaapi.ea_t) -> bool

ida_lumina.score_metadata(fi: "func_info_t") -> int

ida_lumina.serialized_tinfo

ida_lumina.serialized_tinfo.__init__(self, __type: "type_t const *" = None, __fields: "type_t const *" = None)

ida_lumina.simple_idb_diff_handler_t

ida_lumina.simple_idb_diff_handler_t.__init__(self, pfn)

ida_lumina.simple_idb_diff_handler_t.ensure_header_generated(self)

ida_lumina.simple_idb_diff_handler_t.format_extra_cmt(self, cmt)

ida_lumina.simple_idb_diff_handler_t.format_frame_member(self, m)

ida_lumina.simple_idb_diff_handler_t.format_insn_ops(self, ro)

ida_lumina.simple_idb_diff_handler_t.format_stkpnt(self, stkpnt)

ida_lumina.simple_idb_diff_handler_t.format_type(self, type_parts)

ida_lumina.simple_idb_diff_handler_t.indenter_t

ida_lumina.simple_idb_diff_handler_t.indenter_t.__del__(self)

ida_lumina.simple_idb_diff_handler_t.indenter_t.__init__(self, handler)

ida_lumina.simple_idb_diff_handler_t.on_comment_changed(self, fchunk_nr, fchunk_off, l, r, rep)

ida_lumina.simple_idb_diff_handler_t.on_extra_comment_changed(self, fchunk_nr, fchunk_off, l, r, is_prev)

ida_lumina.simple_idb_diff_handler_t.on_frame_member_changed(self, offset, l, r)

ida_lumina.simple_idb_diff_handler_t.on_function_comment_changed(self, l, r, rep)

ida_lumina.simple_idb_diff_handler_t.on_insn_ops_repr_changed(self, fchunk_nr, fchunk_off, l, r)

ida_lumina.simple_idb_diff_handler_t.on_name_changed(self, l, r)

ida_lumina.simple_idb_diff_handler_t.on_proto_changed(self, l, r)

ida_lumina.simple_idb_diff_handler_t.on_score_changed(self, l, r)

ida_lumina.simple_idb_diff_handler_t.on_user_stkpnt_changed(self, fchunk_nr, fchunk_off, l, r)

ida_lumina.simple_idb_diff_handler_t.put(self, msg)

ida_lumina.simple_idb_diff_handler_t.put2(self, l, r, topic)

ida_lumina.simple_idb_diff_handler_t.where(self, fchunk_nr, fchunk_off)

ida_lumina.skipped_func_t

ida_lumina.skipped_func_t.__init__(self, *args)

ida_lumina.skipped_funcs_t

ida_lumina.skipped_funcs_t.__getitem__(self, i: "size_t") -> "skipped_func_t const &"

ida_lumina.skipped_funcs_t.__init__(self, *args)

ida_lumina.skipped_funcs_t.__len__(self) -> "size_t"

ida_lumina.skipped_funcs_t.__setitem__(self, i: "size_t", v: "skipped_func_t") -> None

ida_lumina.skipped_funcs_t.append(self, x: "skipped_func_t") -> None

ida_lumina.skipped_funcs_t.at(self, _idx: "size_t") -> "skipped_func_t const &"

ida_lumina.skipped_funcs_t.begin(self, *args) -> "qvector< skipped_func_t >::const_iterator"

ida_lumina.skipped_funcs_t.capacity(self) -> "size_t"

ida_lumina.skipped_funcs_t.clear(self) -> None

ida_lumina.skipped_funcs_t.empty(self) -> bool

ida_lumina.skipped_funcs_t.end(self, *args) -> "qvector< skipped_func_t >::const_iterator"

ida_lumina.skipped_funcs_t.erase(self, *args) -> "qvector< skipped_func_t >::iterator"

ida_lumina.skipped_funcs_t.extend(self, x: "skipped_funcs_t") -> None

ida_lumina.skipped_funcs_t.extract(self) -> "skipped_func_t *"

ida_lumina.skipped_funcs_t.grow(self, *args) -> None

ida_lumina.skipped_funcs_t.inject(self, s: "skipped_func_t", len: "size_t") -> None

ida_lumina.skipped_funcs_t.insert(self, it: "skipped_func_t", x: "skipped_func_t") -> "qvector< skipped_func_t >::iterator"

ida_lumina.skipped_funcs_t.pop_back(self) -> None

ida_lumina.skipped_funcs_t.push_back(self, *args) -> "skipped_func_t &"

ida_lumina.skipped_funcs_t.qclear(self) -> None

ida_lumina.skipped_funcs_t.reserve(self, cnt: "size_t") -> None

ida_lumina.skipped_funcs_t.resize(self, *args) -> None

ida_lumina.skipped_funcs_t.size(self) -> "size_t"

ida_lumina.skipped_funcs_t.swap(self, r: "skipped_funcs_t") -> None

ida_lumina.skipped_funcs_t.truncate(self) -> None

ida_lumina.split_metadata(metadata: bytes) -> dict
    Split the metadata blob into a set of KVP's
    
    @param metadata a metadata blob
    @return a set of KVP's

ida_lumina.user_license_info_t

ida_lumina.user_license_info_t.__init__(self, __id: str = None, __name: str = None, __email: str = None)

ida_lumina.user_stkpnt_t

ida_lumina.user_stkpnt_t.__init__(self)

ida_lumina.user_stkpnts_t

ida_lumina.user_stkpnts_t.__getitem__(self, i: "size_t") -> "user_stkpnt_t const &"

ida_lumina.user_stkpnts_t.__init__(self, *args)

ida_lumina.user_stkpnts_t.__len__(self) -> "size_t"

ida_lumina.user_stkpnts_t.__setitem__(self, i: "size_t", v: "user_stkpnt_t") -> None

ida_lumina.user_stkpnts_t.append(self, x: "user_stkpnt_t") -> None

ida_lumina.user_stkpnts_t.at(self, _idx: "size_t") -> "user_stkpnt_t const &"

ida_lumina.user_stkpnts_t.begin(self, *args) -> "qvector< user_stkpnt_t >::const_iterator"

ida_lumina.user_stkpnts_t.capacity(self) -> "size_t"

ida_lumina.user_stkpnts_t.clear(self) -> None

ida_lumina.user_stkpnts_t.empty(self) -> bool

ida_lumina.user_stkpnts_t.end(self, *args) -> "qvector< user_stkpnt_t >::const_iterator"

ida_lumina.user_stkpnts_t.erase(self, *args) -> "qvector< user_stkpnt_t >::iterator"

ida_lumina.user_stkpnts_t.extend(self, x: "user_stkpnts_t") -> None

ida_lumina.user_stkpnts_t.extract(self) -> "user_stkpnt_t *"

ida_lumina.user_stkpnts_t.grow(self, *args) -> None

ida_lumina.user_stkpnts_t.inject(self, s: "user_stkpnt_t", len: "size_t") -> None

ida_lumina.user_stkpnts_t.insert(self, it: "user_stkpnt_t", x: "user_stkpnt_t") -> "qvector< user_stkpnt_t >::iterator"

ida_lumina.user_stkpnts_t.pop_back(self) -> None

ida_lumina.user_stkpnts_t.push_back(self, *args) -> "user_stkpnt_t &"

ida_lumina.user_stkpnts_t.qclear(self) -> None

ida_lumina.user_stkpnts_t.reserve(self, cnt: "size_t") -> None

ida_lumina.user_stkpnts_t.resize(self, *args) -> None

ida_lumina.user_stkpnts_t.size(self) -> "size_t"

ida_lumina.user_stkpnts_t.swap(self, r: "user_stkpnts_t") -> None

ida_lumina.user_stkpnts_t.truncate(self) -> None

ida_moves

ida_moves.UNHID_FUNC
    unhid a function at 'target'

ida_moves.UNHID_RANGE
    unhid an range at 'target'

ida_moves.UNHID_SEGM
    unhid a segment at 'target'

ida_moves.bookmarks_t

ida_moves.bookmarks_t.__getitem__(self, idx)
    Get the n-th bookmark for the widget.

ida_moves.bookmarks_t.__init__(self, *args, **kwargs)

ida_moves.bookmarks_t.__init__(self, w)
    Build an object suitable for iterating bookmarks
    associated with the specified widget.
    
    Note: all ea_t-based widgets (e.g., "IDA View-*",
    "Pseudocode-*", "Hex View-*", ...) share a common storage,
    so bookmarks can be re-used interchangeably between them

ida_moves.bookmarks_t.__iter__(self)
    Iterate on bookmarks present for the widget.

ida_moves.bookmarks_t.__len__(self)
    Get the number of bookmarks for the widget.

ida_moves.bookmarks_t.erase(e: "lochist_entry_t", index: int, ud: "void *") -> bool

ida_moves.bookmarks_t.find_index(e: "lochist_entry_t", ud: "void *") -> int

ida_moves.bookmarks_t.get(out: "lochist_entry_t", _index: int, ud: "void *") -> "PyObject *"

ida_moves.bookmarks_t.get_desc(e: "lochist_entry_t", index: int, ud: "void *") -> str

ida_moves.bookmarks_t.get_dirtree_id(e: "lochist_entry_t", ud: "void *") -> "dirtree_id_t"

ida_moves.bookmarks_t.mark(e: "lochist_entry_t", index: int, title: str, desc: str, ud: "void *") -> int

ida_moves.bookmarks_t.size(e: "lochist_entry_t", ud: "void *") -> int

ida_moves.graph_location_info_t

ida_moves.graph_location_info_t.__eq__(self, r: "graph_location_info_t") -> bool

ida_moves.graph_location_info_t.__init__(self)

ida_moves.graph_location_info_t.__ne__(self, r: "graph_location_info_t") -> bool

ida_moves.lochist_entry_t

ida_moves.lochist_entry_t.__init__(self, *args)

ida_moves.lochist_entry_t.acquire_place(self, in_p: "place_t") -> None

ida_moves.lochist_entry_t.is_valid(self) -> bool

ida_moves.lochist_entry_t.place(self) -> "place_t *"

ida_moves.lochist_entry_t.renderer_info(self) -> "renderer_info_t &"

ida_moves.lochist_entry_t.set_place(self, p: "place_t") -> None

ida_moves.lochist_t

ida_moves.lochist_t.__init__(self)

ida_moves.lochist_t.back(self, cnt: int, try_to_unhide: bool) -> bool

ida_moves.lochist_t.clear(self) -> None

ida_moves.lochist_t.current_index(self) -> int

ida_moves.lochist_t.fwd(self, cnt: int, try_to_unhide: bool) -> bool

ida_moves.lochist_t.get(self, out: "lochist_entry_t", index: int) -> bool

ida_moves.lochist_t.get_current(self) -> "lochist_entry_t const &"

ida_moves.lochist_t.get_place_id(self) -> int

ida_moves.lochist_t.get_template_place(self) -> "place_t const *"

ida_moves.lochist_t.init(self, stream_name: str, _defpos: "place_t", _ud: "void *", _flags: int) -> bool

ida_moves.lochist_t.is_history_enabled(self) -> bool

ida_moves.lochist_t.jump(self, try_to_unhide: bool, e: "lochist_entry_t") -> None

ida_moves.lochist_t.netcode(self) -> "nodeidx_t"

ida_moves.lochist_t.save(self) -> None

ida_moves.lochist_t.seek(self, index: int, try_to_unhide: bool) -> bool

ida_moves.lochist_t.set(self, index: int, e: "lochist_entry_t") -> None

ida_moves.lochist_t.set_current(self, e: "lochist_entry_t") -> None

ida_moves.lochist_t.size(self) -> int

ida_moves.renderer_info_pos_t

ida_moves.renderer_info_pos_t.__eq__(self, r: "renderer_info_pos_t") -> bool

ida_moves.renderer_info_pos_t.__init__(self)

ida_moves.renderer_info_pos_t.__ne__(self, r: "renderer_info_pos_t") -> bool

ida_moves.renderer_info_t

ida_moves.renderer_info_t.__eq__(self, r: "renderer_info_t") -> bool

ida_moves.renderer_info_t.__init__(self, *args)

ida_moves.renderer_info_t.__ne__(self, r: "renderer_info_t") -> bool

ida_moves.segm_move_info_t

ida_moves.segm_move_info_t.__eq__(self, r: "segm_move_info_t") -> bool

ida_moves.segm_move_info_t.__init__(self, _from: ida_idaapi.ea_t = 0, _to: ida_idaapi.ea_t = 0, _sz: "size_t" = 0)

ida_moves.segm_move_info_t.__ne__(self, r: "segm_move_info_t") -> bool

ida_moves.segm_move_info_vec_t

ida_moves.segm_move_info_vec_t.__eq__(self, r: "segm_move_info_vec_t") -> bool

ida_moves.segm_move_info_vec_t.__getitem__(self, i: "size_t") -> "segm_move_info_t const &"

ida_moves.segm_move_info_vec_t.__init__(self, *args)

ida_moves.segm_move_info_vec_t.__len__(self) -> "size_t"

ida_moves.segm_move_info_vec_t.__ne__(self, r: "segm_move_info_vec_t") -> bool

ida_moves.segm_move_info_vec_t.__setitem__(self, i: "size_t", v: "segm_move_info_t") -> None

ida_moves.segm_move_info_vec_t._del(self, x: "segm_move_info_t") -> bool

ida_moves.segm_move_info_vec_t.add_unique(self, x: "segm_move_info_t") -> bool

ida_moves.segm_move_info_vec_t.append(self, x: "segm_move_info_t") -> None

ida_moves.segm_move_info_vec_t.at(self, _idx: "size_t") -> "segm_move_info_t const &"

ida_moves.segm_move_info_vec_t.begin(self, *args) -> "qvector< segm_move_info_t >::const_iterator"

ida_moves.segm_move_info_vec_t.capacity(self) -> "size_t"

ida_moves.segm_move_info_vec_t.clear(self) -> None

ida_moves.segm_move_info_vec_t.empty(self) -> bool

ida_moves.segm_move_info_vec_t.end(self, *args) -> "qvector< segm_move_info_t >::const_iterator"

ida_moves.segm_move_info_vec_t.erase(self, *args) -> "qvector< segm_move_info_t >::iterator"

ida_moves.segm_move_info_vec_t.extend(self, x: "segm_move_info_vec_t") -> None

ida_moves.segm_move_info_vec_t.extract(self) -> "segm_move_info_t *"

ida_moves.segm_move_info_vec_t.find(self, *args) -> "qvector< segm_move_info_t >::const_iterator"

ida_moves.segm_move_info_vec_t.grow(self, *args) -> None

ida_moves.segm_move_info_vec_t.has(self, x: "segm_move_info_t") -> bool

ida_moves.segm_move_info_vec_t.inject(self, s: "segm_move_info_t", len: "size_t") -> None

ida_moves.segm_move_info_vec_t.insert(self, it: "segm_move_info_t", x: "segm_move_info_t") -> "qvector< segm_move_info_t >::iterator"

ida_moves.segm_move_info_vec_t.pop_back(self) -> None

ida_moves.segm_move_info_vec_t.push_back(self, *args) -> "segm_move_info_t &"

ida_moves.segm_move_info_vec_t.qclear(self) -> None

ida_moves.segm_move_info_vec_t.reserve(self, cnt: "size_t") -> None

ida_moves.segm_move_info_vec_t.resize(self, *args) -> None

ida_moves.segm_move_info_vec_t.size(self) -> "size_t"

ida_moves.segm_move_info_vec_t.swap(self, r: "segm_move_info_vec_t") -> None

ida_moves.segm_move_info_vec_t.truncate(self) -> None

ida_moves.segm_move_infos_t

ida_moves.segm_move_infos_t.__init__(self)

ida_moves.segm_move_infos_t.find(self, ea: ida_idaapi.ea_t) -> "segm_move_info_t const *"

ida_nalt
    Definitions of various information kept in netnodes.
    
    Each address in the program has a corresponding netnode: netnode(ea).
    If we have no information about an address, the corresponding netnode is not created. Otherwise we will create a netnode and save information in it. All variable length information (names, comments, offset information, etc) is stored in the netnode.
    Don't forget that some information is already stored in the flags (bytes.hpp)
    netnode. 
        

ida_nalt.AFL_ALIGNFLOW
    the previous insn was created for alignment purposes only

ida_nalt.AFL_BNOT0
    the 1st operand is bitwise negated

ida_nalt.AFL_BNOT1
    the 2nd operand is bitwise negated

ida_nalt.AFL_COLORED
    has user defined instruction color?

ida_nalt.AFL_FIXEDSPD
    sp delta value is fixed by analysis. should not be modified by modules 
            

ida_nalt.AFL_HIDDEN
    the item is hidden completely

ida_nalt.AFL_HR_DETERMINED
    the type is definitely guessed by the decompiler

ida_nalt.AFL_HR_GUESSED_DATA
    the data type is guessed by the decompiler

ida_nalt.AFL_HR_GUESSED_FUNC
    the function type is guessed by the decompiler

ida_nalt.AFL_IDA_GUESSED
    the type is guessed by IDA

ida_nalt.AFL_LIB
    item from the standard library. low level flag, is used to set FUNC_LIB of func_t 
            

ida_nalt.AFL_LINNUM
    has line number info

ida_nalt.AFL_LNAME
    has local name too (FF_NAME should be set)

ida_nalt.AFL_LZERO0
    toggle leading zeroes for the 1st operand

ida_nalt.AFL_LZERO1
    toggle leading zeroes for the 2nd operand

ida_nalt.AFL_MANUAL
    the instruction/data is specified by the user

ida_nalt.AFL_NOBRD
    the code/data border is hidden

ida_nalt.AFL_NORET
    for imported function pointers: doesn't return. this flag can also be used for any instruction which halts or finishes the program execution 
            

ida_nalt.AFL_NOTCODE
    autoanalysis should not create code here

ida_nalt.AFL_NOTPROC
    autoanalysis should not create proc here

ida_nalt.AFL_PUBNAM
    name is public (inter-file linkage)

ida_nalt.AFL_RETFP
    function returns a floating point value

ida_nalt.AFL_SIGN0
    code: toggle sign of the 1st operand

ida_nalt.AFL_SIGN1
    code: toggle sign of the 2nd operand

ida_nalt.AFL_TERSESTR
    terse structure variable display?

ida_nalt.AFL_TI
    has typeinfo? (NSUP_TYPEINFO); used only for addresses, not for member_t

ida_nalt.AFL_TI0
    has typeinfo for operand 0? (NSUP_OPTYPES)

ida_nalt.AFL_TI1
    has typeinfo for operand 1? (NSUP_OPTYPES+1)

ida_nalt.AFL_TILCMT
    has type comment? (such a comment may be changed by IDA)

ida_nalt.AFL_TYPE_GUESSED
    who guessed the type information?

ida_nalt.AFL_USEMODSP
    insn modifes SP and uses the modified value; example: pop [rsp+N] 
            

ida_nalt.AFL_USERSP
    user-defined SP value

ida_nalt.AFL_USERTI
    the type information is definitive. (comes from the user or type library) if not set see AFL_TYPE_GUESSED 
            

ida_nalt.AFL_WEAKNAM
    name is weak

ida_nalt.AFL_ZSTROFF
    display struct field name at 0 offset when displaying an offset. example: `offset somestruct.field_0 ` if this flag is clear, then `offset somestruct ` 
            

ida_nalt.AP_ALLOWDUPS
    use 'dup' construct

ida_nalt.AP_ARRAY
    create as array (this flag is not stored in database)

ida_nalt.AP_IDXBASEMASK
    mask for number base of the indexes

ida_nalt.AP_IDXBIN
    display indexes in binary

ida_nalt.AP_IDXDEC
    display indexes in decimal

ida_nalt.AP_IDXHEX
    display indexes in hex

ida_nalt.AP_IDXOCT
    display indexes in octal

ida_nalt.AP_INDEX
    display array element indexes as comments

ida_nalt.AP_SIGNED
    treats numbers as signed

ida_nalt.GOTEA_NODE_NAME
    node containing address of .got section

ida_nalt.IDB_DESKTOPS_NODE_NAME
    hash indexed by desktop name with dekstop netnode

ida_nalt.IDB_DESKTOPS_TAG
    tag to store desktop blob & timestamp

ida_nalt.MAXSTRUCPATH
    maximal inclusion depth of unions

ida_nalt.NALT_ABSBASE
    absolute segment location

ida_nalt.NALT_AFLAGS
    additional flags for an item

ida_nalt.NALT_ALIGN
    alignment value if the item is FF_ALIGN (should by equal to power of 2) 
            

ida_nalt.NALT_COLOR
    instruction/data background color

ida_nalt.NALT_CREF_FROM
    code xref from, idx: source address

ida_nalt.NALT_CREF_TO
    code xref to, idx: target address

ida_nalt.NALT_DREF_FROM
    data xref from, idx: source address

ida_nalt.NALT_DREF_TO
    data xref to, idx: target address

ida_nalt.NALT_ENUM0
    enum id for the first operand

ida_nalt.NALT_ENUM1
    enum id for the second operand

ida_nalt.NALT_GR_LAYX
    group layout ptrs, hash: md5 of 'belongs'

ida_nalt.NALT_LINNUM
    source line number

ida_nalt.NALT_PURGE
    number of bytes purged from the stack when a function is called indirectly

ida_nalt.NALT_STRTYPE
    type of string item

ida_nalt.NALT_STRUCT
    struct id

ida_nalt.NALT_SWITCH
    switch idiom address (used at jump targets)

ida_nalt.NSUP_ARGEAS
    instructions that initialize call arguments

ida_nalt.NSUP_ARRAY
    array parameters

ida_nalt.NSUP_CMT
    regular comment

ida_nalt.NSUP_CUSTDT
    custom data type id

ida_nalt.NSUP_EX_FLAGS
    Extended flags.

ida_nalt.NSUP_FOP1
    forced operand 1

ida_nalt.NSUP_FOP2
    forced operand 2

ida_nalt.NSUP_FOP3
    forced operand 3

ida_nalt.NSUP_FOP4
    forced operand 4

ida_nalt.NSUP_FOP5
    forced operand 5

ida_nalt.NSUP_FOP6
    forced operand 6

ida_nalt.NSUP_FOP7
    forced operand 7

ida_nalt.NSUP_FOP8
    forced operand 8

ida_nalt.NSUP_FRAME
    function frame type values NSUP_FRAME..NSUP_FRAME+0x10000 are reserved 
            

ida_nalt.NSUP_FTAILS
    function tails or tail referers values NSUP_FTAILS..NSUP_FTAILS+0x1000 are reserved 
            

ida_nalt.NSUP_GROUP
    graph group information values NSUP_GROUP..NSUP_GROUP+0x1000 are reserved 
            

ida_nalt.NSUP_GROUPS
    SEG_GRP: pack_dd encoded list of selectors.

ida_nalt.NSUP_GR_INFO
    group node info: color, ea, text

ida_nalt.NSUP_GR_LAYT
    group layouts, idx: layout pointer

ida_nalt.NSUP_JINFO
    jump table info

ida_nalt.NSUP_LLABEL
    local labels. values NSUP_LLABEL..NSUP_LLABEL+0x1000 are reserved 
            

ida_nalt.NSUP_MANUAL
    manual instruction. values NSUP_MANUAL..NSUP_MANUAL+0x1000 are reserved 
            

ida_nalt.NSUP_OMFGRP
    OMF: group of segments (not used anymore)

ida_nalt.NSUP_OPTYPES
    operand type information. values NSUP_OPTYPES..NSUP_OPTYPES+0x100000 are reserved 
            

ida_nalt.NSUP_OREF0
    outer complex reference information for operand 1

ida_nalt.NSUP_OREF1
    outer complex reference information for operand 2

ida_nalt.NSUP_OREF2
    outer complex reference information for operand 3

ida_nalt.NSUP_OREF3
    outer complex reference information for operand 4

ida_nalt.NSUP_OREF4
    outer complex reference information for operand 5

ida_nalt.NSUP_OREF5
    outer complex reference information for operand 6

ida_nalt.NSUP_OREF6
    outer complex reference information for operand 7

ida_nalt.NSUP_OREF7
    outer complex reference information for operand 8

ida_nalt.NSUP_ORIGFMD
    function metadata before lumina information was applied values NSUP_ORIGFMD..NSUP_ORIGFMD+0x1000 are reserved 
            

ida_nalt.NSUP_POINTS
    SP change points blob (see funcs.cpp). values NSUP_POINTS..NSUP_POINTS+0x1000 are reserved 
            

ida_nalt.NSUP_REF0
    complex reference information for operand 1

ida_nalt.NSUP_REF1
    complex reference information for operand 2

ida_nalt.NSUP_REF2
    complex reference information for operand 3

ida_nalt.NSUP_REF3
    complex reference information for operand 4

ida_nalt.NSUP_REF4
    complex reference information for operand 5

ida_nalt.NSUP_REF5
    complex reference information for operand 6

ida_nalt.NSUP_REF6
    complex reference information for operand 7

ida_nalt.NSUP_REF7
    complex reference information for operand 8

ida_nalt.NSUP_REGARG
    register argument type/name descriptions values NSUP_REGARG..NSUP_REGARG+0x1000 are reserved 
            

ida_nalt.NSUP_REGVAR
    register variables. values NSUP_REGVAR..NSUP_REGVAR+0x1000 are reserved 
            

ida_nalt.NSUP_REPCMT
    repeatable comment

ida_nalt.NSUP_SEGTRANS
    segment translations

ida_nalt.NSUP_STROFF0
    stroff: struct path for the first operand

ida_nalt.NSUP_STROFF1
    stroff: struct path for the second operand

ida_nalt.NSUP_SWITCH
    switch information

ida_nalt.NSUP_TYPEINFO
    type information. values NSUP_TYPEINFO..NSUP_TYPEINFO+0x1000 are reserved 
            

ida_nalt.NSUP_XREFPOS
    saved xref address and type in the xrefs window

ida_nalt.PATCH_TAG
    Patch netnode tag.

ida_nalt.REFINFO_CUSTOM
    a custom reference. see custom_refinfo_handler_t. the id of the custom refinfo is stored under the REFINFO_TYPE mask. 
            

ida_nalt.REFINFO_NOBASE
    don't create the base xref; implies that the base can be any value. nb: base xrefs are created only if the offset base points to the middle of a segment 
            

ida_nalt.REFINFO_NO_ONES
    an opval of ~0 will be considered invalid

ida_nalt.REFINFO_NO_ZEROS
    an opval of 0 will be considered invalid

ida_nalt.REFINFO_PASTEND
    reference past an item; it may point to an nonexistent address; do not destroy alignment dirs 
            

ida_nalt.REFINFO_RVAOFF
    based reference (rva); refinfo_t::base will be forced to get_imagebase(); such a reference is displayed with the asm_t::a_rva keyword 
            

ida_nalt.REFINFO_SELFREF
    the self-based reference; refinfo_t::base will be forced to the reference address 
            

ida_nalt.REFINFO_SIGNEDOP
    the operand value is sign-extended (only supported for REF_OFF8/16/32/64)

ida_nalt.REFINFO_SUBTRACT
    the reference value is subtracted from the base value instead of (as usual) being added to it

ida_nalt.REFINFO_TYPE
    reference type (reftype_t), or custom reference ID if REFINFO_CUSTOM set 
            

ida_nalt.REF_HIGH16
    high 16bits of 32bit offset

ida_nalt.REF_HIGH8
    high 8bits of 16bit offset

ida_nalt.REF_LOW16
    low 16bits of 32bit offset

ida_nalt.REF_LOW8
    low 8bits of 16bit offset

ida_nalt.REF_OFF16
    16bit full offset

ida_nalt.REF_OFF32
    32bit full offset

ida_nalt.REF_OFF64
    64bit full offset

ida_nalt.REF_OFF8
    8bit full offset

ida_nalt.RIDX_ABINAME
    ABI name (processor specific)

ida_nalt.RIDX_ARCHIVE_PATH
    archive file path

ida_nalt.RIDX_C_MACROS
    C predefined macros.

ida_nalt.RIDX_DBG_BINPATHS
    unused (20 indexes)

ida_nalt.RIDX_DUALOP_GRAPH
    Graph text representation options.

ida_nalt.RIDX_DUALOP_TEXT
    Text text representation options.

ida_nalt.RIDX_FILE_FORMAT_NAME
    file format name for loader modules

ida_nalt.RIDX_GROUPS
    segment group information (see init_groups())

ida_nalt.RIDX_H_PATH
    C header path.

ida_nalt.RIDX_IDA_VERSION
    version of ida which created the database

ida_nalt.RIDX_INCLUDE
    assembler include file name

ida_nalt.RIDX_MD5
    MD5 of the input file.

ida_nalt.RIDX_NOTEPAD
    notepad blob, occupies 1000 indexes (1MB of text)

ida_nalt.RIDX_PROBLEMS
    problem lists

ida_nalt.RIDX_SELECTORS
    2..63 are for selector_t blob (see init_selectors())

ida_nalt.RIDX_SHA256
    SHA256 of the input file.

ida_nalt.RIDX_SMALL_IDC
    Instant IDC statements, blob.

ida_nalt.RIDX_SMALL_IDC_OLD
    Instant IDC statements (obsolete)

ida_nalt.RIDX_SRCDBG_PATHS
    source debug paths, occupies 20 indexes

ida_nalt.RIDX_SRCDBG_UNDESIRED
    user-closed source files, occupies 20 indexes

ida_nalt.RIDX_STR_ENCODINGS
    a list of encodings for the program strings

ida_nalt.STRENC_DEFAULT
    use default encoding for this type (see get_default_encoding_idx())

ida_nalt.STRENC_NONE
    force no-conversion encoding

ida_nalt.STRTYPE_C
    Zero-terminated 16bit chars.

ida_nalt.STRTYPE_C_16
    Zero-terminated 32bit chars.

ida_nalt.STRTYPE_C_32
    Pascal-style, one-byte length prefix.

ida_nalt.STRTYPE_LEN2
    Pascal-style, 16bit chars, two-byte length prefix.

ida_nalt.STRTYPE_LEN2_16
    Pascal-style, 32bit chars, two-byte length prefix.

ida_nalt.STRTYPE_LEN2_32
    Pascal-style, four-byte length prefix.

ida_nalt.STRTYPE_LEN4
    Pascal-style, 16bit chars, four-byte length prefix.

ida_nalt.STRTYPE_LEN4_16
    Pascal-style, 32bit chars, four-byte length prefix.

ida_nalt.STRTYPE_PASCAL
    Pascal-style, 16bit chars, one-byte length prefix.

ida_nalt.STRTYPE_PASCAL_16
    Pascal-style, 32bit chars, one-byte length prefix.

ida_nalt.STRTYPE_PASCAL_32
    Pascal-style, two-byte length prefix.

ida_nalt.STRTYPE_TERMCHR
    C-style string.

ida_nalt.SWI_CUSTOM
    custom jump table. processor_t::create_switch_xrefs will be called to create code xrefs for the table. Custom jump table must be created by the module (see also SWI_STDTBL) 
            

ida_nalt.SWI_DEFRET
    return in the default case (defjump==BADADDR)

ida_nalt.SWI_DEF_IN_TBL
    default case is an entry in the jump table. This flag is applicable in 2 cases:
    * The sparse indirect switch (i.e. a switch with a values table) {jump table size} == {value table size} + 1. The default case entry is the last one in the table (or the first one in the case of an inversed jump table).
    * The switch with insns in the jump table. The default case entry is before the first entry of the table. 
     See also the find_defjump_from_table() helper function. 
    
    
            

ida_nalt.SWI_ELBASE
    elbase is present (otherwise the base of the switch segment will be used) 
            

ida_nalt.SWI_HXNOLOWCASE
    lowcase value should not be used by the decompiler (internal flag)

ida_nalt.SWI_INDIRECT
    value table elements are used as indexes into the jump table (for sparse switches) 
            

ida_nalt.SWI_J32
    32-bit jump offsets

ida_nalt.SWI_JMPINSN
    jump table entries are insns. For such entries SHIFT has a different meaning. It denotes the number of insns in the entry. For example, 0 - the entry contains the jump to the case, 1 - the entry contains one insn like a 'mov' and jump to the end of case, and so on. 
            

ida_nalt.SWI_JMP_INV
    jumptable is inversed. (last entry is for first entry in values table) 
            

ida_nalt.SWI_JSIZE
    jump offset expansion bit

ida_nalt.SWI_SELFREL
    jump address is relative to the element not to ELBASE

ida_nalt.SWI_SEPARATE
    create an array of individual elements (otherwise separate items)

ida_nalt.SWI_SHIFT_MASK
    use formula (element<<shift) + elbase to find jump targets

ida_nalt.SWI_SIGNED
    jump table entries are signed

ida_nalt.SWI_SPARSE
    sparse switch (value table present), otherwise lowcase present 
            

ida_nalt.SWI_STDTBL
    custom jump table with standard table formatting. ATM IDA doesn't use SWI_CUSTOM for switches with standard table formatting. So this flag can be considered as obsolete. 
            

ida_nalt.SWI_SUBTRACT
    table values are subtracted from the elbase instead of being added

ida_nalt.SWI_USER
    user specified switch (starting from version 2)

ida_nalt.SWI_V32
    32-bit values in table

ida_nalt.SWI_VERSION
    the structure contains the VERSION member

ida_nalt.SWI_VSIZE
    value table element size expansion bit

ida_nalt.SWI_VSPLIT
    value table is split (only for 32-bit values)

ida_nalt.V695_REF_OFF8
    reserved

ida_nalt.V695_REF_VHIGH
    obsolete

ida_nalt.V695_REF_VLOW
    obsolete

ida_nalt.add_encoding(encname: str) -> int

ida_nalt.array_parameters_t

ida_nalt.array_parameters_t.__init__(self, _f: int = 1, _l: int = 0, _a: int = -1)

ida_nalt.array_parameters_t.alignment
    -1 - don't align. 0 - align automatically. else item width 
            

ida_nalt.array_parameters_t.is_default(self) -> bool

ida_nalt.array_parameters_t.lineitems
    number of items on a line

ida_nalt.clr__bnot0(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr__bnot1(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr__invsign0(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr__invsign1(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_abits(ea: ida_idaapi.ea_t, bits: "aflags_t") -> None

ida_nalt.clr_align_flow(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_colored_item(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_fixed_spd(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_has_lname(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_has_ti(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_has_ti0(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_has_ti1(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_libitem(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_lzero0(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_lzero1(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_noret(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_notcode(ea: ida_idaapi.ea_t) -> None
    Clear not-code mark.

ida_nalt.clr_notproc(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_retfp(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_terse_struc(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_tilcmt(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_usemodsp(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_usersp(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_userti(ea: ida_idaapi.ea_t) -> None

ida_nalt.clr_zstroff(ea: ida_idaapi.ea_t) -> None

ida_nalt.custom_data_type_ids_fids_array

ida_nalt.custom_data_type_ids_fids_array.__getitem__(self, i: "size_t") -> "short const &"

ida_nalt.custom_data_type_ids_fids_array.__init__(self, data: "short (&)[8]")

ida_nalt.custom_data_type_ids_fids_array.__len__(self) -> "size_t"

ida_nalt.custom_data_type_ids_fids_array.__setitem__(self, i: "size_t", v: "short const &") -> None

ida_nalt.custom_data_type_ids_fids_array._get_bytes(self) -> "bytevec_t"

ida_nalt.custom_data_type_ids_fids_array._set_bytes(self, bts: "bytevec_t const &") -> None

ida_nalt.custom_data_type_ids_t

ida_nalt.custom_data_type_ids_t.__getFids(self) -> "wrapped_array_t< int16,8 >"

ida_nalt.custom_data_type_ids_t.__init__(self)

ida_nalt.custom_data_type_ids_t.dtid
    data type id

ida_nalt.custom_data_type_ids_t.fids
    data format ids

ida_nalt.custom_data_type_ids_t.fids
    data format ids

ida_nalt.custom_data_type_ids_t.get_dtid(self) -> "tid_t"

ida_nalt.custom_data_type_ids_t.set(self, tid: "tid_t") -> None

ida_nalt.dbg_get_input_path() -> str
    Get debugger input file name/path (see LFLG_DBG_NOPATH)

ida_nalt.del_absbase(ea: ida_idaapi.ea_t) -> None

ida_nalt.del_aflags(ea: ida_idaapi.ea_t) -> None

ida_nalt.del_alignment(ea: ida_idaapi.ea_t) -> None

ida_nalt.del_array_parameters(ea: ida_idaapi.ea_t) -> None

ida_nalt.del_custom_data_type_ids(ea: ida_idaapi.ea_t) -> None

ida_nalt.del_encoding(idx: int) -> bool

ida_nalt.del_ind_purged(ea: ida_idaapi.ea_t) -> None

ida_nalt.del_item_color(ea: ida_idaapi.ea_t) -> bool

ida_nalt.del_op_tinfo(ea: ida_idaapi.ea_t, n: int) -> None

ida_nalt.del_refinfo(ea: ida_idaapi.ea_t, n: int) -> bool

ida_nalt.del_source_linnum(ea: ida_idaapi.ea_t) -> None

ida_nalt.del_str_type(ea: ida_idaapi.ea_t) -> None

ida_nalt.del_switch_info(ea: ida_idaapi.ea_t) -> None

ida_nalt.del_switch_parent(ea: ida_idaapi.ea_t) -> None

ida_nalt.del_tinfo(ea: ida_idaapi.ea_t) -> None

ida_nalt.delete_imports() -> None

ida_nalt.ea2node(ea: ida_idaapi.ea_t) -> "nodeidx_t"
    Get netnode for the specified address.

ida_nalt.encoding_from_strtype(strtype: int) -> str

ida_nalt.end_ea2node(ea: ida_idaapi.ea_t) -> "nodeidx_t"

ida_nalt.enum_const_t

ida_nalt.enum_const_t.__init__(self)

ida_nalt.enum_import_names(mod_index, callback)
    Enumerate imports from a specific module.
    Please refer to list_imports.py example.
    
    @param mod_index: The module index
    @param callback: A callable object that will be invoked with an ea, name (could be None) and ordinal.
    @return: 1-finished ok, -1 on error, otherwise callback return value (<=0)

ida_nalt.find_custom_refinfo(name: str) -> int
    Get id of a custom refinfo type.

ida_nalt.get_abi_name()

ida_nalt.get_absbase(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_nalt.get_aflags(ea: ida_idaapi.ea_t) -> "aflags_t"

ida_nalt.get_alignment(ea: ida_idaapi.ea_t) -> int

ida_nalt.get_archive_path() -> str
    Get archive file path from which input file was extracted.

ida_nalt.get_array_parameters(out: "array_parameters_t", ea: ida_idaapi.ea_t) -> "ssize_t"

ida_nalt.get_asm_inc_file() -> str
    Get name of the include file.

ida_nalt.get_custom_data_type_ids(cdis: "custom_data_type_ids_t", ea: ida_idaapi.ea_t) -> int

ida_nalt.get_custom_refinfo(crid: int) -> "custom_refinfo_handler_t const *"
    Get definition of a registered custom refinfo type.

ida_nalt.get_default_encoding_idx(bpu: int) -> int

ida_nalt.get_elapsed_secs() -> "size_t"
    Get seconds database stayed open.

ida_nalt.get_encoding_bpu(idx: int) -> int

ida_nalt.get_encoding_bpu_by_name(encname: str) -> int

ida_nalt.get_encoding_name(idx: int) -> str

ida_nalt.get_encoding_qty() -> int

ida_nalt.get_gotea() -> ida_idaapi.ea_t

ida_nalt.get_ida_notepad_text() -> str
    Get notepad text.

ida_nalt.get_idb_ctime() -> "time_t"
    Get database creation timestamp.

ida_nalt.get_idb_nopens() -> "size_t"
    Get number of times the database is opened.

ida_nalt.get_ids_modnode() -> "netnode"
    Get ids modnode.

ida_nalt.get_imagebase() -> ida_idaapi.ea_t
    Get image base address.

ida_nalt.get_import_module_name(mod_index)
    Returns the name of an imported module given its index
    
    @param mod_index: the module index
    @return: None or the module name

ida_nalt.get_import_module_qty() -> "uint"

ida_nalt.get_ind_purged(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_nalt.get_initial_ida_version() -> str
    Get version of ida which created the database (string format like "7.5")

ida_nalt.get_initial_idb_version() -> "ushort"
    Get initial version of the database (numeric format like 700)

ida_nalt.get_input_file_path() -> str
    Get full path of the input file.

ida_nalt.get_item_color(ea: ida_idaapi.ea_t) -> "bgcolor_t"

ida_nalt.get_loader_format_name() -> str
    Get file format name for loader modules.

ida_nalt.get_op_tinfo(tif: "tinfo_t", ea: ida_idaapi.ea_t, n: int) -> bool

ida_nalt.get_outfile_encoding_idx() -> int

ida_nalt.get_refinfo(ri: "refinfo_t", ea: ida_idaapi.ea_t, n: int) -> bool

ida_nalt.get_reftype_by_size(size: "size_t") -> "reftype_t"
    Get REF_... constant from size Supported sizes: 1,2,4,8,16 For other sizes returns reftype_t(-1) 
            

ida_nalt.get_root_filename() -> str
    Get file name only of the input file.

ida_nalt.get_source_linnum(ea: ida_idaapi.ea_t) -> int

ida_nalt.get_srcdbg_paths() -> str
    Get source debug paths.

ida_nalt.get_srcdbg_undesired_paths() -> str
    Get user-closed source files.

ida_nalt.get_str_encoding_idx(strtype: int) -> "uchar"

ida_nalt.get_str_term1(strtype: int) -> "char"

ida_nalt.get_str_term2(strtype: int) -> "char"

ida_nalt.get_str_type(ea: ida_idaapi.ea_t) -> int

ida_nalt.get_str_type_code(strtype: int) -> "uchar"

ida_nalt.get_str_type_prefix_length(strtype: int) -> "size_t"

ida_nalt.get_strid(ea: ida_idaapi.ea_t) -> "tid_t"

ida_nalt.get_strtype_bpu(strtype: int) -> int

ida_nalt.get_switch_info(out: "switch_info_t", ea: ida_idaapi.ea_t) -> "ssize_t"

ida_nalt.get_switch_info(*args)

ida_nalt.get_switch_parent(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_nalt.get_tinfo(tif: "tinfo_t", ea: ida_idaapi.ea_t) -> bool

ida_nalt.getnode(ea: ida_idaapi.ea_t) -> "netnode"

ida_nalt.has_aflag_linnum(flags: "aflags_t") -> bool

ida_nalt.has_aflag_lname(flags: "aflags_t") -> bool

ida_nalt.has_aflag_ti(flags: "aflags_t") -> bool

ida_nalt.has_aflag_ti0(flags: "aflags_t") -> bool

ida_nalt.has_aflag_ti1(flags: "aflags_t") -> bool

ida_nalt.has_lname(ea: ida_idaapi.ea_t) -> bool

ida_nalt.has_ti(ea: ida_idaapi.ea_t) -> bool

ida_nalt.has_ti0(ea: ida_idaapi.ea_t) -> bool

ida_nalt.has_ti1(ea: ida_idaapi.ea_t) -> bool

ida_nalt.hide_border(ea: ida_idaapi.ea_t) -> None

ida_nalt.hide_item(ea: ida_idaapi.ea_t) -> None

ida_nalt.is__bnot0(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is__bnot1(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is__invsign0(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is__invsign1(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_aflag__bnot0(flags: "aflags_t") -> bool

ida_nalt.is_aflag__bnot1(flags: "aflags_t") -> bool

ida_nalt.is_aflag__invsign0(flags: "aflags_t") -> bool

ida_nalt.is_aflag__invsign1(flags: "aflags_t") -> bool

ida_nalt.is_aflag_align_flow(flags: "aflags_t") -> bool

ida_nalt.is_aflag_colored_item(flags: "aflags_t") -> bool

ida_nalt.is_aflag_data_guessed_by_hexrays(flags: "aflags_t") -> bool

ida_nalt.is_aflag_fixed_spd(flags: "aflags_t") -> bool

ida_nalt.is_aflag_func_guessed_by_hexrays(flags: "aflags_t") -> bool

ida_nalt.is_aflag_hidden_border(flags: "aflags_t") -> bool

ida_nalt.is_aflag_hidden_item(flags: "aflags_t") -> bool

ida_nalt.is_aflag_libitem(flags: "aflags_t") -> bool

ida_nalt.is_aflag_lzero0(flags: "aflags_t") -> bool

ida_nalt.is_aflag_lzero1(flags: "aflags_t") -> bool

ida_nalt.is_aflag_manual_insn(flags: "aflags_t") -> bool

ida_nalt.is_aflag_noret(flags: "aflags_t") -> bool

ida_nalt.is_aflag_notcode(flags: "aflags_t") -> bool

ida_nalt.is_aflag_notproc(flags: "aflags_t") -> bool

ida_nalt.is_aflag_public_name(flags: "aflags_t") -> bool

ida_nalt.is_aflag_retfp(flags: "aflags_t") -> bool

ida_nalt.is_aflag_terse_struc(flags: "aflags_t") -> bool

ida_nalt.is_aflag_tilcmt(flags: "aflags_t") -> bool

ida_nalt.is_aflag_type_determined_by_hexrays(flags: "aflags_t") -> bool

ida_nalt.is_aflag_type_guessed_by_hexrays(flags: "aflags_t") -> bool

ida_nalt.is_aflag_type_guessed_by_ida(flags: "aflags_t") -> bool

ida_nalt.is_aflag_usersp(flags: "aflags_t") -> bool

ida_nalt.is_aflag_userti(flags: "aflags_t") -> bool

ida_nalt.is_aflag_weak_name(flags: "aflags_t") -> bool

ida_nalt.is_aflag_zstroff(flags: "aflags_t") -> bool

ida_nalt.is_align_flow(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_colored_item(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_data_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_finally_visible_item(ea: ida_idaapi.ea_t) -> bool
    Is instruction visible?

ida_nalt.is_fixed_spd(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_func_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_hidden_border(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_hidden_item(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_libitem(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_lzero0(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_lzero1(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_noret(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_notcode(ea: ida_idaapi.ea_t) -> bool
    Is the address marked as not-code?

ida_nalt.is_notproc(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_pascal(strtype: int) -> bool

ida_nalt.is_reftype_target_optional(type: "reftype_t") -> bool
    Can the target be calculated using operand value?

ida_nalt.is_retfp(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_terse_struc(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_tilcmt(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_type_determined_by_hexrays(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_type_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_type_guessed_by_ida(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_usersp(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_userti(ea: ida_idaapi.ea_t) -> bool

ida_nalt.is_visible_item(ea: ida_idaapi.ea_t) -> bool
    Test visibility of item at given ea.

ida_nalt.is_zstroff(ea: ida_idaapi.ea_t) -> bool

ida_nalt.make_str_type(type_code: "uchar", encoding_idx: int, term1: "uchar" = 0, term2: "uchar" = 0) -> int

ida_nalt.node2ea(ndx: "nodeidx_t") -> ida_idaapi.ea_t

ida_nalt.opinfo_t

ida_nalt.opinfo_t.__init__(self)

ida_nalt.opinfo_t.cd
    for custom data

ida_nalt.opinfo_t.ec
    for enums

ida_nalt.opinfo_t.path
    for stroff

ida_nalt.opinfo_t.ri
    for offset members

ida_nalt.opinfo_t.strtype
    for strings (String type codes)

ida_nalt.opinfo_t.tid
    for struct, etc. members

ida_nalt.printop_t

ida_nalt.printop_t.__init__(self)

ida_nalt.printop_t.get_ti(self) -> "opinfo_t const *"

ida_nalt.printop_t.is_aflags_initialized(self) -> bool

ida_nalt.printop_t.is_f64(self) -> bool

ida_nalt.printop_t.is_ti_initialized(self) -> bool

ida_nalt.printop_t.set_aflags_initialized(self, v: bool = True) -> None

ida_nalt.printop_t.set_ti_initialized(self, v: bool = True) -> None

ida_nalt.refinfo_t

ida_nalt.refinfo_t.__init__(self)

ida_nalt.refinfo_t.base
    base of reference (may be BADADDR)

ida_nalt.refinfo_t.flags
    Reference info flags 
            

ida_nalt.refinfo_t.init(self, *args) -> None

ida_nalt.refinfo_t.is_custom(self) -> bool

ida_nalt.refinfo_t.is_no_ones(self) -> bool

ida_nalt.refinfo_t.is_no_zeros(self) -> bool

ida_nalt.refinfo_t.is_pastend(self) -> bool

ida_nalt.refinfo_t.is_rvaoff(self) -> bool

ida_nalt.refinfo_t.is_selfref(self) -> bool

ida_nalt.refinfo_t.is_signed(self) -> bool

ida_nalt.refinfo_t.is_subtract(self) -> bool

ida_nalt.refinfo_t.is_target_optional(self) -> bool
    < is_reftype_target_optional()

ida_nalt.refinfo_t.no_base_xref(self) -> bool

ida_nalt.refinfo_t.set_type(self, rt: "reftype_t") -> None

ida_nalt.refinfo_t.target
    reference target (BADADDR-none)

ida_nalt.refinfo_t.tdelta
    offset from the target

ida_nalt.refinfo_t.type(self) -> "reftype_t"

ida_nalt.rename_encoding(idx: int, encname: str) -> bool

ida_nalt.retrieve_input_file_crc32() -> int
    Get input file crc32 stored in the database. it can be used to check that the input file has not been changed. 
            

ida_nalt.retrieve_input_file_md5() -> bytes
    Get input file md5.

ida_nalt.retrieve_input_file_sha256() -> bytes
    Get input file sha256.

ida_nalt.retrieve_input_file_size() -> "size_t"
    Get size of input file in bytes.

ida_nalt.set__bnot0(ea: ida_idaapi.ea_t) -> None

ida_nalt.set__bnot1(ea: ida_idaapi.ea_t) -> None

ida_nalt.set__invsign0(ea: ida_idaapi.ea_t) -> None

ida_nalt.set__invsign1(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_abits(ea: ida_idaapi.ea_t, bits: "aflags_t") -> None

ida_nalt.set_absbase(ea: ida_idaapi.ea_t, x: ida_idaapi.ea_t) -> None

ida_nalt.set_aflags(ea: ida_idaapi.ea_t, flags: "aflags_t") -> None

ida_nalt.set_align_flow(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_alignment(ea: ida_idaapi.ea_t, x: int) -> None

ida_nalt.set_archive_path(file: str) -> bool
    Set archive file path from which input file was extracted.

ida_nalt.set_array_parameters(ea: ida_idaapi.ea_t, _in: "array_parameters_t") -> None

ida_nalt.set_asm_inc_file(file: str) -> bool
    Set name of the include file.

ida_nalt.set_colored_item(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_custom_data_type_ids(ea: ida_idaapi.ea_t, cdis: "custom_data_type_ids_t") -> None

ida_nalt.set_data_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_default_encoding_idx(bpu: int, idx: int) -> bool

ida_nalt.set_fixed_spd(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_func_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_gotea(gotea: ida_idaapi.ea_t) -> None

ida_nalt.set_has_lname(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_has_ti(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_has_ti0(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_has_ti1(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_ida_notepad_text(text: str, size: "size_t" = 0) -> None
    Set notepad text.

ida_nalt.set_ids_modnode(id: "netnode") -> None
    Set ids modnode.

ida_nalt.set_imagebase(base: ida_idaapi.ea_t) -> None
    Set image base address.

ida_nalt.set_item_color(ea: ida_idaapi.ea_t, color: "bgcolor_t") -> None

ida_nalt.set_libitem(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_loader_format_name(name: str) -> None
    Set file format name for loader modules.

ida_nalt.set_lzero0(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_lzero1(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_noret(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_notcode(ea: ida_idaapi.ea_t) -> None
    Mark address so that it cannot be converted to instruction.

ida_nalt.set_notproc(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_op_tinfo(ea: ida_idaapi.ea_t, n: int, tif: "tinfo_t") -> bool

ida_nalt.set_outfile_encoding_idx(idx: int) -> bool

ida_nalt.set_refinfo(*args) -> bool

ida_nalt.set_refinfo_ex(ea: ida_idaapi.ea_t, n: int, ri: "refinfo_t") -> bool

ida_nalt.set_retfp(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_root_filename(file: str) -> None
    Set full path of the input file.

ida_nalt.set_source_linnum(ea: ida_idaapi.ea_t, lnnum: int) -> None

ida_nalt.set_srcdbg_paths(paths: str) -> None
    Set source debug paths.

ida_nalt.set_srcdbg_undesired_paths(paths: str) -> None
    Set user-closed source files.

ida_nalt.set_str_encoding_idx(strtype: int, encoding_idx: int) -> int

ida_nalt.set_str_type(ea: ida_idaapi.ea_t, x: int) -> None

ida_nalt.set_switch_info(ea: ida_idaapi.ea_t, _in: "switch_info_t") -> None

ida_nalt.set_switch_parent(ea: ida_idaapi.ea_t, x: ida_idaapi.ea_t) -> None

ida_nalt.set_terse_struc(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_tilcmt(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_tinfo(ea: ida_idaapi.ea_t, tif: "tinfo_t") -> bool

ida_nalt.set_type_determined_by_hexrays(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_type_guessed_by_ida(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_usemodsp(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_usersp(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_userti(ea: ida_idaapi.ea_t) -> None

ida_nalt.set_visible_item(ea: ida_idaapi.ea_t, visible: bool) -> None
    Change visibility of item at given ea.

ida_nalt.set_zstroff(ea: ida_idaapi.ea_t) -> None

ida_nalt.strpath_ids_array

ida_nalt.strpath_ids_array.__getitem__(self, i: "size_t") -> "unsigned long long const &"

ida_nalt.strpath_ids_array.__init__(self, data: "unsigned long long (&)[32]")

ida_nalt.strpath_ids_array.__len__(self) -> "size_t"

ida_nalt.strpath_ids_array.__setitem__(self, i: "size_t", v: "unsigned long long const &") -> None

ida_nalt.strpath_ids_array._get_bytes(self) -> "bytevec_t"

ida_nalt.strpath_ids_array._set_bytes(self, bts: "bytevec_t const &") -> None

ida_nalt.strpath_t

ida_nalt.strpath_t.__getIds(self) -> "wrapped_array_t< tid_t,32 >"

ida_nalt.strpath_t.__init__(self)

ida_nalt.switch_info_t

ida_nalt.switch_info_t.__init__(self)

ida_nalt.switch_info_t._get_values_lowcase(self) -> ida_idaapi.ea_t

ida_nalt.switch_info_t._set_values_lowcase(self, values: ida_idaapi.ea_t) -> None

ida_nalt.switch_info_t.assign(self, other: "switch_info_t") -> None

ida_nalt.switch_info_t.clear(self) -> None

ida_nalt.switch_info_t.custom
    information for custom tables (filled and used by modules)

ida_nalt.switch_info_t.defjump
    default jump address (BADADDR if no default case)

ida_nalt.switch_info_t.elbase
    element base

ida_nalt.switch_info_t.expr_ea
    the address before that the switch expression is in REGNUM. If BADADDR, then the first insn marked as IM_SWITCH after STARTEA is used. 
            

ida_nalt.switch_info_t.flags
    Switch info flags 
            

ida_nalt.switch_info_t.get_jrange_vrange(self, jrange: "range_t" = None, vrange: "range_t" = None) -> bool
    get separate parts of the switch

ida_nalt.switch_info_t.get_jtable_element_size(self) -> int

ida_nalt.switch_info_t.get_jtable_size(self) -> int

ida_nalt.switch_info_t.get_lowcase(self) -> int

ida_nalt.switch_info_t.get_shift(self) -> int
    See SWI_SHIFT_MASK. possible answers: 0..3. 
            

ida_nalt.switch_info_t.get_version(self) -> int

ida_nalt.switch_info_t.get_vtable_element_size(self) -> int

ida_nalt.switch_info_t.has_default(self) -> bool

ida_nalt.switch_info_t.has_elbase(self) -> bool

ida_nalt.switch_info_t.is_custom(self) -> bool

ida_nalt.switch_info_t.is_indirect(self) -> bool

ida_nalt.switch_info_t.is_nolowcase(self) -> bool

ida_nalt.switch_info_t.is_sparse(self) -> bool

ida_nalt.switch_info_t.is_subtract(self) -> bool

ida_nalt.switch_info_t.is_user_defined(self) -> bool

ida_nalt.switch_info_t.jcases
    number of entries in the jump table (SWI_INDIRECT)

ida_nalt.switch_info_t.jumps
    jump table start address

ida_nalt.switch_info_t.lowcase
    the lowest value in cases

ida_nalt.switch_info_t.lowcase
    the lowest value in cases

ida_nalt.switch_info_t.marks
    the insns marked as IM_SWITCH. They are used to delete the switch.

ida_nalt.switch_info_t.ncases
    number of cases (excluding default)

ida_nalt.switch_info_t.regdtype
    size of the switch expression register as dtype

ida_nalt.switch_info_t.regnum
    the switch expression as a value of the REGNUM register before the instruction at EXPR_EA. -1 means 'unknown' 
            

ida_nalt.switch_info_t.set_elbase(self, base: ida_idaapi.ea_t) -> None

ida_nalt.switch_info_t.set_expr(self, r: int, dt: "op_dtype_t") -> None

ida_nalt.switch_info_t.set_jtable_element_size(self, size: int) -> None

ida_nalt.switch_info_t.set_jtable_size(self, size: int) -> None

ida_nalt.switch_info_t.set_shift(self, shift: int) -> None
    See SWI_SHIFT_MASK.

ida_nalt.switch_info_t.set_vtable_element_size(self, size: int) -> None

ida_nalt.switch_info_t.startea
    start of the switch idiom

ida_nalt.switch_info_t.use_std_table(self) -> bool

ida_nalt.switch_info_t.values
    values table address (if SWI_SPARSE is set)

ida_nalt.switch_info_t.values
    values table address (if SWI_SPARSE is set)

ida_nalt.switch_info_t__from_ptrval__(ptrval: "size_t") -> "switch_info_t *"

ida_nalt.unhide_border(ea: ida_idaapi.ea_t) -> None

ida_nalt.unhide_item(ea: ida_idaapi.ea_t) -> None

ida_nalt.upd_abits(ea: ida_idaapi.ea_t, clr_bits: "aflags_t", set_bits: "aflags_t") -> None

ida_nalt.uses_aflag_modsp(flags: "aflags_t") -> bool

ida_nalt.uses_modsp(ea: ida_idaapi.ea_t) -> bool

ida_name
    Functions that deal with names.
    
    A non-tail address of the program may have a name. Tail addresses (i.e. the addresses in the middle of an instruction or data item) cannot have names. 
        

ida_name.CN_KEEP_TRAILING_DIGITS
    do not remove "_\d+" at the end of name

ida_name.CN_KEEP_UNDERSCORES
    do not remove leading underscores. but it is ok to remove __imp_. 
            

ida_name.DEBNAME_EXACT
    find a name at exactly the specified address

ida_name.DEBNAME_LOWER
    find a name with the address >= the specified address

ida_name.DEBNAME_NICE
    find a name with the address <= the specified address

ida_name.DEBNAME_UPPER
    find a name with the address > the specified address

ida_name.DQT_COMPILER
    only detect compiler that generated the name

ida_name.DQT_FULL
    really demangle

ida_name.DQT_NAME_TYPE
    only detect the name type (data/code)

ida_name.DQT_NPURGED_2
    only calculate number of purged bytes (sizeof(arg)==2)

ida_name.DQT_NPURGED_4
    only calculate number of purged bytes (sizeof(arg)==4)

ida_name.DQT_NPURGED_8
    only calculate number of purged bytes (sizeof(arg)==8)

ida_name.FUNC_IMPORT_PREFIX
    Name prefix used by IDA for the imported functions.

ida_name.GETN_APPZERO
    meaningful only if the name refers to a structure. append a struct field name if the field offset is zero? 
            

ida_name.GETN_NODUMMY
    do not create a new dummy name but pretend it exists

ida_name.GETN_NOFIXUP
    ignore the fixup information when producing the name

ida_name.GNCN_NOCOLOR
    generate an uncolored name

ida_name.GNCN_NODBGNM
    don't use debug names

ida_name.GNCN_NOFUNC
    don't generate funcname+... expressions

ida_name.GNCN_NOLABEL
    don't generate labels

ida_name.GNCN_NOSEG
    ignore the segment prefix when producing the name

ida_name.GNCN_PREFDBG
    if using debug names, prefer debug names over function names

ida_name.GNCN_REQFUNC
    return 0 if the address does not belong to a function

ida_name.GNCN_REQNAME
    return 0 if the address can only be represented as a hex number

ida_name.GNCN_SEGNUM
    segment part is displayed as a hex number

ida_name.GNCN_SEG_FUNC
    generate both segment and function names (default is to omit segment name if a function name is present)

ida_name.GN_COLORED
    return colored name

ida_name.GN_DEMANGLED
    return demangled name

ida_name.GN_ISRET
    for dummy names: use retloc

ida_name.GN_LOCAL
    try to get local name first; if failed, get global

ida_name.GN_LONG
    use long form of demangled name

ida_name.GN_NOT_DUMMY
    do not return a dummy name

ida_name.GN_NOT_ISRET
    for dummy names: do not use retloc

ida_name.GN_SHORT
    use short form of demangled name

ida_name.GN_STRICT
    fail if cannot demangle

ida_name.GN_VISIBLE
    replace forbidden characters by SUBSTCHAR

ida_name.MAXNAMELEN
    Maximum length of a name in IDA (with the trailing zero)

ida_name.NT_ABS
    name is absolute symbol (SEG_ABSSYM)

ida_name.NT_BMASK
    name is a bit group mask name

ida_name.NT_BYTE
    name is byte name (regular name)

ida_name.NT_ENUM
    name is symbolic constant

ida_name.NT_LOCAL
    name is local label

ida_name.NT_NONE
    name doesn't exist or has no value

ida_name.NT_REGVAR
    name is a renamed register (*value is idx into pfn->regvars)

ida_name.NT_SEG
    name is segment or segment register name

ida_name.NT_STKVAR
    name is stack variable name

ida_name.NT_STROFF
    name is structure member

ida_name.NearestName
    Utility class to help find the nearest name in a given ea/name dictionary

ida_name.NearestName.__getitem__(self, index)
    Returns the tupple (ea, name, index)

ida_name.NearestName.__init__(self, ea_names)

ida_name.NearestName.__iter__(self)

ida_name.NearestName._get_item(self, index)

ida_name.NearestName.find(self, ea)
    Returns a tupple (ea, name, pos) that is the nearest to the passed ea
    If no name is matched then None is returned

ida_name.NearestName.update(self, ea_names)
    Updates the ea/names map

ida_name.SN_AUTO
    if set, make name autogenerated

ida_name.SN_CHECK
    Fail if the name contains invalid characters.

ida_name.SN_DELTAIL
    if name cannot be set because of a tail byte, delete the hindering item 
            

ida_name.SN_FORCE
    if the specified name is already present in the database, try variations with a numerical suffix like "_123" 
            

ida_name.SN_IDBENC
    the name is given in the IDB encoding; non-ASCII bytes will be decoded accordingly. Specifying SN_IDBENC also implies SN_NODUMMY 
            

ida_name.SN_LOCAL
    create local name. a function should exist. local names can't be public or weak. also they are not included into the list of names they can't have dummy prefixes. 
            

ida_name.SN_NOCHECK
    Replace invalid characters silently. If this bit is set, all invalid chars (not in NameChars or MangleChars) will be replaced by '_' List of valid characters is defined in ida.cfg 
            

ida_name.SN_NODUMMY
    automatically prepend the name with '_' if it begins with a dummy suffix such as 'sub_'. See also SN_IDBENC 
            

ida_name.SN_NOLIST
    if set, exclude name from the list. if not set, then include the name into the list (however, if other bits are set, the name might be immediately excluded from the list). 
            

ida_name.SN_NON_AUTO
    if set, make name non-autogenerated

ida_name.SN_NON_PUBLIC
    if set, make name non-public

ida_name.SN_NON_WEAK
    if set, make name non-weak

ida_name.SN_NOWARN
    don't display a warning if failed

ida_name.SN_PUBLIC
    if set, make name public

ida_name.SN_WEAK
    if set, make name weak

ida_name.UCDR_MANGLED
    mangled names

ida_name.UCDR_NAME
    regular (unmangled) names

ida_name.UCDR_STRLIT
    string literals

ida_name.UCDR_TYPE
    type names

ida_name.VNT_IDENT
    identifier (e.g., function name)

ida_name.VNT_STRLIT
    string literal

ida_name.VNT_TYPE
    type name (can contain '<', '>', ...)

ida_name.VNT_UDTMEM
    UDT (structure, union, enum) member.

ida_name.VNT_VISIBLE
    visible cp (obsolete; will be deleted)

ida_name.append_struct_fields(disp: "adiff_t *", n: int, path: "tid_t const *", flags: "flags64_t", delta: "adiff_t", appzero: bool) -> str
    Append names of struct fields to a name if the name is a struct name. 
            
    @param disp: displacement from the name
    @param n: operand number in which the name appears
    @param path: path in the struct. path is an array of id's. maximal length of array is MAXSTRUCPATH. the first element of the array is the structure id. consecutive elements are id's of used union members (if any).
    @param flags: the input flags. they will be returned if the struct cannot be found.
    @param delta: delta to add to displacement
    @param appzero: should append a struct field name if the displacement is zero?
    @returns flags of the innermost struct member or the input flags

ida_name.calc_gtn_flags(fromaddr, ea)
    Calculate flags for get_ea_name() function
    
    @param fromaddr: the referring address. May be BADADDR.
    @param ea: linear address
    
    @return: flags

ida_name.cleanup_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> str

ida_name.del_debug_names(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None

ida_name.del_global_name(ea: ida_idaapi.ea_t) -> bool

ida_name.del_local_name(ea: ida_idaapi.ea_t) -> bool

ida_name.demangle_name(name: str, disable_mask: int, demreq: "demreq_type_t" = DQT_FULL) -> str
    Demangle a name. 
            
    @param name: name to demangle
    @param disable_mask: bits to inhibit parts of demangled name (see MNG_). by the M_COMPILER bits a specific compiler can be selected (see MT_).
    @param demreq: the request type demreq_type_t
    @returns ME_... or MT__ bitmasks from demangle.hpp

ida_name.ea_name_t

ida_name.ea_name_t.__init__(self, *args)

ida_name.ea_name_vec_t

ida_name.ea_name_vec_t.__getitem__(self, i: "size_t") -> "ea_name_t const &"

ida_name.ea_name_vec_t.__init__(self, *args)

ida_name.ea_name_vec_t.__len__(self) -> "size_t"

ida_name.ea_name_vec_t.__setitem__(self, i: "size_t", v: "ea_name_t") -> None

ida_name.ea_name_vec_t.append(self, x: "ea_name_t") -> None

ida_name.ea_name_vec_t.at(self, _idx: "size_t") -> "ea_name_t const &"

ida_name.ea_name_vec_t.begin(self, *args) -> "qvector< ea_name_t >::const_iterator"

ida_name.ea_name_vec_t.capacity(self) -> "size_t"

ida_name.ea_name_vec_t.clear(self) -> None

ida_name.ea_name_vec_t.empty(self) -> bool

ida_name.ea_name_vec_t.end(self, *args) -> "qvector< ea_name_t >::const_iterator"

ida_name.ea_name_vec_t.erase(self, *args) -> "qvector< ea_name_t >::iterator"

ida_name.ea_name_vec_t.extend(self, x: "ea_name_vec_t") -> None

ida_name.ea_name_vec_t.extract(self) -> "ea_name_t *"

ida_name.ea_name_vec_t.grow(self, *args) -> None

ida_name.ea_name_vec_t.inject(self, s: "ea_name_t", len: "size_t") -> None

ida_name.ea_name_vec_t.insert(self, it: "ea_name_t", x: "ea_name_t") -> "qvector< ea_name_t >::iterator"

ida_name.ea_name_vec_t.pop_back(self) -> None

ida_name.ea_name_vec_t.push_back(self, *args) -> "ea_name_t &"

ida_name.ea_name_vec_t.qclear(self) -> None

ida_name.ea_name_vec_t.reserve(self, cnt: "size_t") -> None

ida_name.ea_name_vec_t.resize(self, *args) -> None

ida_name.ea_name_vec_t.size(self) -> "size_t"

ida_name.ea_name_vec_t.swap(self, r: "ea_name_vec_t") -> None

ida_name.ea_name_vec_t.truncate(self) -> None

ida_name.extract_name(line: str, x: int) -> str
    Extract a name or address from the specified string. 
            
    @param line: input string
    @param x: x coordinate of cursor
    @returns -1 if cannot extract. otherwise length of the name

ida_name.force_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> bool

ida_name.get_colored_demangled_name(ea: ida_idaapi.ea_t, inhibitor: int, demform: int, gtn_flags: int = 0) -> str

ida_name.get_colored_long_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str

ida_name.get_colored_name(ea: ida_idaapi.ea_t) -> str

ida_name.get_colored_short_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str

ida_name.get_cp_validity(*args) -> bool
    Is the given codepoint (or range) acceptable in the given context? If 'endcp' is not BADCP, it is considered to be the end of the range: [cp, endcp), and is not included in the range 
            

ida_name.get_debug_name(ea_ptr: "ea_t *", how: "debug_name_how_t") -> str

ida_name.get_debug_name_ea(name: str) -> ida_idaapi.ea_t

ida_name.get_debug_names(*args) -> "PyObject *"

ida_name.get_demangled_name(ea: ida_idaapi.ea_t, inhibitor: int, demform: int, gtn_flags: int = 0) -> str

ida_name.get_ea_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str
    Get name at the specified address. 
            
    @param ea: linear address
    @param gtn_flags: how exactly the name should be retrieved. combination of bits for get_ea_name() function. There is a convenience bits
    @returns success

ida_name.get_long_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str

ida_name.get_mangled_name_type(name: str) -> "mangled_name_type_t"

ida_name.get_name(ea: ida_idaapi.ea_t) -> str

ida_name.get_name_base_ea(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get address of the name used in the expression for the address 
            
    @param to: the referenced address
    @returns address of the name used to represent the operand

ida_name.get_name_color(_from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t) -> "color_t"
    Calculate flags for get_ea_name() function.
    
    Get name color. 
            
    @param ea: linear address

ida_name.get_name_ea(_from: ida_idaapi.ea_t, name: str) -> ida_idaapi.ea_t
    Get the address of a name. This function resolves a name into an address. It can handle regular global and local names, as well as debugger names. 
            
    @param name: any name in the program or nullptr
    @returns address of the name or BADADDR

ida_name.get_name_expr(_from: ida_idaapi.ea_t, n: int, ea: ida_idaapi.ea_t, off: int, flags: int = 1) -> str
    Convert address to name expression (name with a displacement). This function takes into account fixup information and returns a colored name expression (in the form <name> +/- <offset>). It also knows about structure members and arrays. If the specified address doesn't have a name, a dummy name is generated. 
            
    @param n: number of referencing operand. for data items specify 0
    @param ea: address to convert to name expression
    @param off: the value of name expression. this parameter is used only to check that the name expression will have the wanted value. 'off' may be equal to BADADDR but this is discouraged because it prohibits checks.
    @param flags: Name expression flags
    @returns < 0 if address is not valid, no segment or other failure. otherwise the length of the name expression in characters.

ida_name.get_name_value(_from: ida_idaapi.ea_t, name: str) -> "uval_t *"
    Get value of the name. This function knows about: regular names, enums, special segments, etc. 
            
    @param name: any name in the program or nullptr
    @returns Name value result codes

ida_name.get_nice_colored_name(ea: ida_idaapi.ea_t, flags: int = 0) -> str
    Get a nice colored name at the specified address. Ex:
    * segment:sub+offset
    * segment:sub:local_label
    * segment:label
    * segment:address
    * segment:address+offset
    
    
    
    @param ea: linear address
    @param flags: Nice colored name flags
    @returns the length of the generated name in bytes.

ida_name.get_nlist_ea(idx: "size_t") -> ida_idaapi.ea_t

ida_name.get_nlist_idx(ea: ida_idaapi.ea_t) -> "size_t"

ida_name.get_nlist_name(idx: "size_t") -> str

ida_name.get_nlist_size() -> "size_t"

ida_name.get_short_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str

ida_name.get_visible_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str

ida_name.hide_name(ea: ida_idaapi.ea_t) -> None
    Remove name from the list of names 
            
    @param ea: address of the name

ida_name.is_ident(name: str) -> bool
    Is a valid name? (including ::MangleChars)

ida_name.is_ident_cp(cp: "wchar32_t") -> bool
    Can a character appear in a name? (present in ::NameChars or ::MangleChars)

ida_name.is_in_nlist(ea: ida_idaapi.ea_t) -> bool

ida_name.is_name_defined_locally(*args) -> bool
    Is the name defined locally in the specified function? 
            
    @param pfn: pointer to function
    @param name: name to check
    @param ignore_name_def: which names to ignore when checking
    @param ea1: the starting address of the range inside the function (optional)
    @param ea2: the ending address of the range inside the function (optional)
    @returns true if the name has been defined

ida_name.is_public_name(ea: ida_idaapi.ea_t) -> bool

ida_name.is_strlit_cp(cp: "wchar32_t", specific_ranges: "rangeset_crefvec_t const *" = None) -> bool
    Can a character appear in a string literal (present in ::StrlitChars) If 'specific_ranges' are specified, those will be used instead of the ones corresponding to the current culture (only if ::StrlitChars is configured to use the current culture) 
            

ida_name.is_uname(name: str) -> bool
    Is valid user-specified name? (valid name & !dummy prefix). 
            
    @param name: name to test. may be nullptr.
    @retval 1: yes
    @retval 0: no

ida_name.is_valid_cp(cp: "wchar32_t", kind: "nametype_t", data: "void *" = None) -> bool
    Is the given codepoint acceptable in the given context?

ida_name.is_valid_typename(name: str) -> bool
    Is valid type name? 
            
    @param name: name to test. may be nullptr.
    @retval 1: yes
    @retval 0: no

ida_name.is_visible_cp(cp: "wchar32_t") -> bool
    Can a character be displayed in a name? (present in ::NameChars)

ida_name.is_weak_name(ea: ida_idaapi.ea_t) -> bool

ida_name.make_name_auto(ea: ida_idaapi.ea_t) -> bool

ida_name.make_name_non_public(ea: ida_idaapi.ea_t) -> None

ida_name.make_name_non_weak(ea: ida_idaapi.ea_t) -> None

ida_name.make_name_public(ea: ida_idaapi.ea_t) -> None

ida_name.make_name_user(ea: ida_idaapi.ea_t) -> bool

ida_name.make_name_weak(ea: ida_idaapi.ea_t) -> None

ida_name.rebuild_nlist() -> None

ida_name.reorder_dummy_names() -> None
    Renumber dummy names.

ida_name.set_cp_validity(*args) -> None
    Mark the given codepoint (or range) as acceptable or unacceptable in the given context If 'endcp' is not BADCP, it is considered to be the end of the range: [cp, endcp), and is not included in the range 
            

ida_name.set_debug_name(ea: ida_idaapi.ea_t, name: str) -> bool

ida_name.set_dummy_name(_from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t) -> bool
    Give an autogenerated (dummy) name. Autogenerated names have special prefixes (loc_...). 
            
    @param ea: linear address
    @retval 1: ok, dummy name is generated or the byte already had a name
    @retval 0: failure, invalid address or tail byte

ida_name.set_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> bool
    Set or delete name of an item at the specified address. An item can be anything: instruction, function, data byte, word, string, structure, etc... Include name into the list of names. 
            
    @param ea: linear address. do nothing if ea is not valid (return 0). tail bytes can't have names.
    @param name: new name.
    * nullptr: do nothing (return 0).
    * "" : delete name.
    * otherwise this is a new name.
    @param flags: Set name flags. If a bit is not specified, then the corresponding action is not performed and the name will retain the same bits as before calling this function. For new names, default is: non-public, non-weak, non-auto.
    @retval 1: ok, name is changed
    @retval 0: failure, a warning is displayed

ida_name.show_name(ea: ida_idaapi.ea_t) -> None
    Insert name to the list of names.

ida_name.validate_name(name: str, type: "nametype_t", flags: int = 1) -> "PyObject *"
    Validate a name. If SN_NOCHECK is specified, this function replaces all invalid characters in the name with SUBSTCHAR. However, it will return false if name is valid but not allowed to be an identifier (is a register name).
    
    @param name: ptr to name. the name will be modified
    @param type: the type of name we want to validate
    @param flags: see SN_*
    @returns success

ida_netnode
    Functions that provide the lowest level public interface to the database. Namely, we use Btree. To learn more about BTree:
    
    [https://en.wikipedia.org/wiki/B-tree](https://en.wikipedia.org/wiki/B-tree)
    We do not use Btree directly. Instead, we have another layer built on the top of Btree. Here is a brief explanation of this layer.
    An object called "netnode" is modeled on the top of Btree. Each netnode has a unique id: a 32-bit value (64-bit for ida64). Initially there is a trivial mapping of the linear addresses used in the program to netnodes (later this mapping may be modified using ea2node and node2ea functions; this is used for fast database rebasings). If we have additional information about an address (for example, a comment is attached to it), this information is stored in the corresponding netnode. See nalt.hpp to see how the kernel uses netnodes. Also, some netnodes have no corresponding linear address (however, they still have an id). They are used to store information not related to a particular address.
    Each netnode _may_ have the following attributes:
    
    * a name: an arbitrary non-empty string, up to 255KB-1 bytes
    * a value: arbitrary sized object, max size is MAXSPECSIZE
    * altvals: a sparse array of 32-bit values. indexes in this array may be 8-bit or 32-bit values
    * supvals: an array of arbitrary sized objects. (size of each object is limited by MAXSPECSIZE) indexes in this array may be 8-bit or 32-bit values
    * charvals: a sparse array of 8-bit values. indexes in this array may be 8-bit or 32-bit values
    * hashvals: a hash (an associative array). indexes in this array are strings values are arbitrary sized (max size is MAXSPECSIZE)
    
    
    Initially a new netnode contains no information at all so no disk space is used for it. As you add new information, the netnode grows.
    All arrays that are attached to the netnode behave in the same manner. Initially:
    * all members of altvals/charvals array are zeroes
    * all members of supvals/hashvals array are undefined
    
    
    If you need to store objects bigger that MAXSPECSIZE, please note that there are high-level functions to store arbitrary sized objects in supvals. See setblob/getblob and other blob-related functions.
    You may use netnodes to store additional information about the program. Limitations on the use of netnodes are the following:
    
    * use netnodes only if you could not find a kernel service to store your type of information
    * do not create netnodes with valid identifier names. Use the "$ " prefix (or any other prefix with characters not allowed in the identifiers for the names of your netnodes. Although you will probably not destroy anything by accident, using already defined names for the names of your netnodes is still discouraged.
    * you may create as many netnodes as you want (creation of an unnamed netnode does not increase the size of the database). however, since each netnode has a number, creating too many netnodes could lead to the exhaustion of the netnode numbers (the numbering starts at 0xFF000000)
    * remember that netnodes are automatically saved to the disk by the kernel.
    
    
    Advanced info:
    In fact a netnode may contain up to 256 arrays of arbitrary sized objects (not only the 4 listed above). Each array has an 8-bit tag. Usually tags are represented by character constants. For example, altvals and supvals are simply 2 of 256 arrays, with the tags 'A' and 'S' respectively. 
        

ida_netnode.BADNODE
    A number to represent a bad netnode reference.

ida_netnode.MAXNAMESIZE
    Maximum length of a netnode name. WILL BE REMOVED IN THE FUTURE.

ida_netnode.MAXSPECSIZE
    Maximum length of strings or objects stored in a supval array element.

ida_netnode.MAX_NODENAME_SIZE
    Maximum length of a name. We permit names up to 32KB-1 bytes.

ida_netnode.atag
    Array of altvals.

ida_netnode.exist(n: "netnode") -> bool

ida_netnode.htag
    Array of hashvals.

ida_netnode.ltag
    Links between netnodes.

ida_netnode.netnode

ida_netnode.netnode.__eq__(self, *args) -> bool

ida_netnode.netnode.__init__(self, *args)

ida_netnode.netnode.__ne__(self, *args) -> bool

ida_netnode.netnode.altdel(self, *args) -> bool

ida_netnode.netnode.altdel_all(self, *args) -> bool

ida_netnode.netnode.altdel_ea(self, *args) -> bool

ida_netnode.netnode.altdel_idx8(self, alt: "uchar", tag: "uchar") -> bool

ida_netnode.netnode.altfirst(self, *args) -> "nodeidx_t"

ida_netnode.netnode.altfirst_idx8(self, tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.altlast(self, *args) -> "nodeidx_t"

ida_netnode.netnode.altlast_idx8(self, tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.altnext(self, *args) -> "nodeidx_t"

ida_netnode.netnode.altnext_idx8(self, cur: "uchar", tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.altprev(self, *args) -> "nodeidx_t"

ida_netnode.netnode.altprev_idx8(self, cur: "uchar", tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.altset(self, *args) -> bool

ida_netnode.netnode.altset_ea(self, *args) -> bool

ida_netnode.netnode.altset_idx8(self, alt: "uchar", val: "nodeidx_t", tag: "uchar") -> bool

ida_netnode.netnode.altshift(self, *args) -> "size_t"

ida_netnode.netnode.altval(self, *args) -> "nodeidx_t"

ida_netnode.netnode.altval_ea(self, *args) -> "nodeidx_t"

ida_netnode.netnode.altval_idx8(self, alt: "uchar", tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.blobshift(self, _from: "nodeidx_t", to: "nodeidx_t", size: "nodeidx_t", tag: "uchar") -> "size_t"

ida_netnode.netnode.blobsize(self, _start: "nodeidx_t", tag: "uchar") -> "size_t"

ida_netnode.netnode.blobsize_ea(self, ea: ida_idaapi.ea_t, tag: "uchar") -> "size_t"

ida_netnode.netnode.chardel(self, alt: "nodeidx_t", tag: "uchar") -> bool

ida_netnode.netnode.chardel_ea(self, ea: ida_idaapi.ea_t, tag: "uchar") -> bool

ida_netnode.netnode.chardel_idx8(self, alt: "uchar", tag: "uchar") -> bool

ida_netnode.netnode.charfirst(self, tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.charfirst_idx8(self, tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.charlast(self, tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.charlast_idx8(self, tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.charnext(self, cur: "nodeidx_t", tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.charnext_idx8(self, cur: "uchar", tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.charprev(self, cur: "nodeidx_t", tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.charprev_idx8(self, cur: "uchar", tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.charset(self, alt: "nodeidx_t", val: "uchar", tag: "uchar") -> bool

ida_netnode.netnode.charset_ea(self, ea: ida_idaapi.ea_t, val: "uchar", tag: "uchar") -> bool

ida_netnode.netnode.charset_idx8(self, alt: "uchar", val: "uchar", tag: "uchar") -> bool

ida_netnode.netnode.charshift(self, _from: "nodeidx_t", to: "nodeidx_t", size: "nodeidx_t", tag: "uchar") -> "size_t"

ida_netnode.netnode.charval(self, alt: "nodeidx_t", tag: "uchar") -> "uchar"

ida_netnode.netnode.charval_ea(self, ea: ida_idaapi.ea_t, tag: "uchar") -> "uchar"

ida_netnode.netnode.charval_idx8(self, alt: "uchar", tag: "uchar") -> "uchar"

ida_netnode.netnode.copyto(self, destnode: "netnode", count: "nodeidx_t" = 1) -> "size_t"

ida_netnode.netnode.create(self, *args) -> bool

ida_netnode.netnode.delblob(self, _start: "nodeidx_t", tag: "uchar") -> int

ida_netnode.netnode.delblob_ea(self, ea: ida_idaapi.ea_t, tag: "uchar") -> int

ida_netnode.netnode.delvalue(self) -> bool

ida_netnode.netnode.eadel(self, ea: ida_idaapi.ea_t, tag: "uchar") -> bool

ida_netnode.netnode.eadel_idx8(self, idx: "uchar", tag: "uchar") -> bool

ida_netnode.netnode.eaget(self, ea: ida_idaapi.ea_t, tag: "uchar") -> ida_idaapi.ea_t

ida_netnode.netnode.eaget_idx(self, idx: "nodeidx_t", tag: "uchar") -> ida_idaapi.ea_t

ida_netnode.netnode.eaget_idx8(self, idx: "uchar", tag: "uchar") -> ida_idaapi.ea_t

ida_netnode.netnode.easet(self, ea: ida_idaapi.ea_t, addr: ida_idaapi.ea_t, tag: "uchar") -> bool

ida_netnode.netnode.easet_idx(self, idx: "nodeidx_t", addr: ida_idaapi.ea_t, tag: "uchar") -> bool

ida_netnode.netnode.easet_idx8(self, idx: "uchar", addr: ida_idaapi.ea_t, tag: "uchar") -> bool

ida_netnode.netnode.end(self) -> bool

ida_netnode.netnode.exist(_name: str) -> bool
    Does the netnode with the specified name exist?

ida_netnode.netnode.get_name(self) -> "ssize_t"

ida_netnode.netnode.getblob(self, start, tag) -> Union[bytes, None]
    Get a blob from a netnode.
    
    @param start the index where the blob starts (it may span on multiple indexes)
    @param tag the netnode tag
    @return a blob, or None

ida_netnode.netnode.getblob_ea(self, ea: ida_idaapi.ea_t, tag: "char") -> "PyObject *"

ida_netnode.netnode.getclob(self, start, tag) -> Union[str, None]
    Get a large amount of text from a netnode.
    
    @param start the index where the clob starts (it may span on multiple indexes)
    @param tag the netnode tag
    @return a clob, or None

ida_netnode.netnode.hashdel(self, *args) -> bool

ida_netnode.netnode.hashdel_all(self, *args) -> bool

ida_netnode.netnode.hashfirst(self, *args) -> "ssize_t"

ida_netnode.netnode.hashlast(self, *args) -> "ssize_t"

ida_netnode.netnode.hashnext(self, *args) -> "ssize_t"

ida_netnode.netnode.hashprev(self, *args) -> "ssize_t"

ida_netnode.netnode.hashset(self, *args) -> bool

ida_netnode.netnode.hashset_buf(self, *args) -> bool

ida_netnode.netnode.hashset_idx(self, *args) -> bool

ida_netnode.netnode.hashstr(self, *args) -> "ssize_t"

ida_netnode.netnode.hashstr_buf(self, *args) -> "PyObject *"

ida_netnode.netnode.hashval(self, *args) -> "ssize_t"

ida_netnode.netnode.hashval_long(self, *args) -> "nodeidx_t"

ida_netnode.netnode.index(self) -> "nodeidx_t"

ida_netnode.netnode.kill(self) -> None

ida_netnode.netnode.long_value(self) -> "nodeidx_t"

ida_netnode.netnode.lower_bound(self, *args) -> "nodeidx_t"

ida_netnode.netnode.lower_bound_ea(self, *args) -> "nodeidx_t"

ida_netnode.netnode.lower_bound_idx8(self, alt: "uchar", tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.moveto(self, destnode: "netnode", count: "nodeidx_t" = 1) -> "size_t"

ida_netnode.netnode.next(self) -> bool

ida_netnode.netnode.prev(self) -> bool

ida_netnode.netnode.rename(self, newname: str, namlen: "size_t" = 0) -> bool

ida_netnode.netnode.set(self, value: "void const *") -> bool

ida_netnode.netnode.set_long(self, x: "nodeidx_t") -> bool

ida_netnode.netnode.setblob(self, buf: "void const *", _start: "nodeidx_t", tag: "uchar") -> bool

ida_netnode.netnode.setblob_ea(self, buf: "void const *", ea: ida_idaapi.ea_t, tag: "uchar") -> bool

ida_netnode.netnode.start(self) -> bool

ida_netnode.netnode.supdel(self, *args) -> bool

ida_netnode.netnode.supdel_all(self, tag: "uchar") -> bool

ida_netnode.netnode.supdel_ea(self, *args) -> bool

ida_netnode.netnode.supdel_idx8(self, alt: "uchar", tag: "uchar") -> bool

ida_netnode.netnode.supdel_range(self, idx1: "nodeidx_t", idx2: "nodeidx_t", tag: "uchar") -> int

ida_netnode.netnode.supdel_range_idx8(self, idx1: "uchar", idx2: "uchar", tag: "uchar") -> int

ida_netnode.netnode.supfirst(self, *args) -> "nodeidx_t"

ida_netnode.netnode.supfirst_idx8(self, tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.suplast(self, *args) -> "nodeidx_t"

ida_netnode.netnode.suplast_idx8(self, tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.supnext(self, *args) -> "nodeidx_t"

ida_netnode.netnode.supnext_idx8(self, alt: "uchar", tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.supprev(self, *args) -> "nodeidx_t"

ida_netnode.netnode.supprev_idx8(self, alt: "uchar", tag: "uchar") -> "nodeidx_t"

ida_netnode.netnode.supset(self, *args) -> bool

ida_netnode.netnode.supset_ea(self, *args) -> bool

ida_netnode.netnode.supset_idx8(self, alt: "uchar", value: "void const *", tag: "uchar") -> bool

ida_netnode.netnode.supshift(self, *args) -> "size_t"

ida_netnode.netnode.supstr(self, *args) -> "ssize_t"

ida_netnode.netnode.supstr_ea(self, *args) -> "ssize_t"

ida_netnode.netnode.supstr_idx8(self, alt: "uchar", tag: "uchar") -> "ssize_t"

ida_netnode.netnode.supval(self, *args) -> "ssize_t"

ida_netnode.netnode.supval_ea(self, *args) -> "ssize_t"

ida_netnode.netnode.supval_idx8(self, *args) -> "ssize_t"

ida_netnode.netnode.valobj(self, *args) -> "ssize_t"

ida_netnode.netnode.valstr(self) -> "ssize_t"

ida_netnode.netnode.value_exists(self) -> bool

ida_netnode.ntag
    Name of netnode.

ida_netnode.stag
    Array of supvals.

ida_netnode.vtag
    Value of netnode.

ida_offset
    Functions that deal with offsets.
    
    "Being an offset" is a characteristic of an operand. This means that operand or its part represent offset from some address in the program. This linear address is called "offset base". Some operands may have 2 offsets simultaneously. Generally, IDA doesn't handle this except for Motorola outer offsets. Thus there may be two offset values in an operand: simple offset and outer offset.
    Outer offsets are handled by specifying special operand number: it should be ORed with OPND_OUTER value.
    See bytes.hpp for further explanation of operand numbers. 
        

ida_offset.add_refinfo_dref(insn: "insn_t const &", _from: ida_idaapi.ea_t, ri: "refinfo_t", opval: "adiff_t", type: "dref_t", opoff: int) -> ida_idaapi.ea_t
    Add xrefs for a reference from the given instruction ( insn_t::ea). This function creates a cross references to the target and the base. insn_t::add_off_drefs() calls this function to create xrefs for 'offset' operand. 
            
    @param insn: the referencing instruction
    @param ri: reference info block from the database
    @param opval: operand value (usually op_t::value or op_t::addr)
    @param type: type of xref
    @param opoff: offset of the operand from the start of instruction
    @returns the target address of the reference

ida_offset.calc_basevalue(target: ida_idaapi.ea_t, base: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Calculate the value of the reference base.

ida_offset.calc_offset_base(ea: ida_idaapi.ea_t, n: int) -> ida_idaapi.ea_t
    Try to calculate the offset base This function takes into account the fixup information, current ds and cs values. 
            
    @param ea: the referencing instruction/data address
    @param n: operand number
    * 0: first operand
    * 1: second operand
    * ...
    * 7: eighth operand
    @returns output base address or BADADDR

ida_offset.calc_probable_base_by_value(ea: ida_idaapi.ea_t, off: int) -> ida_idaapi.ea_t
    Try to calculate the offset base. 2 bases are checked: current ds and cs. If fails, return BADADDR 
            

ida_offset.calc_reference_data(target: "ea_t *", base: "ea_t *", _from: ida_idaapi.ea_t, ri: "refinfo_t", opval: "adiff_t") -> bool
    Calculate the target and base addresses of an offset expression. The calculated target and base addresses are returned in the locations pointed by 'base' and 'target'. In case 'ri.base' is BADADDR, the function calculates the offset base address from the referencing instruction/data address. The target address is copied from ri.target. If ri.target is BADADDR then the target is calculated using the base address and 'opval'. This function also checks if 'opval' matches the full value of the reference and takes in account the memory-mapping. 
            
    @param target: output target address
    @param base: output base address
    @param ri: reference info block from the database
    @param opval: operand value (usually op_t::value or op_t::addr)
    @returns success

ida_offset.calc_target(*args) -> ida_idaapi.ea_t
    This function has the following signatures:
    
        0. calc_target(from: ida_idaapi.ea_t, opval: adiff_t, ri: const refinfo_t &) -> ida_idaapi.ea_t
        1. calc_target(from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t, n: int, opval: adiff_t) -> ida_idaapi.ea_t
    
    # 0: calc_target(from: ida_idaapi.ea_t, opval: adiff_t, ri: const refinfo_t &) -> ida_idaapi.ea_t
    
    Calculate the target using the provided refinfo_t.
    
    
    # 1: calc_target(from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t, n: int, opval: adiff_t) -> ida_idaapi.ea_t
    
    Retrieve refinfo_t structure and calculate the target.

ida_offset.can_be_off32(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Does the specified address contain a valid OFF32 value?. For symbols in special segments the displacement is not taken into account. If yes, then the target address of OFF32 will be returned. If not, then BADADDR is returned. 
            

ida_offset.get_default_reftype(ea: ida_idaapi.ea_t) -> "reftype_t"
    Get default reference type depending on the segment. 
            
    @returns one of REF_OFF8, REF_OFF16, REF_OFF32, REF_OFF64

ida_offset.get_offbase(ea: ida_idaapi.ea_t, n: int) -> ida_idaapi.ea_t
    Get offset base value 
            
    @param ea: linear address
    @param n: 0..UA_MAXOP-1 operand number
    @returns offset base or BADADDR

ida_offset.get_offset_expr(ea: ida_idaapi.ea_t, n: int, ri: "refinfo_t", _from: ida_idaapi.ea_t, offset: "adiff_t", getn_flags: int = 0) -> str
    See get_offset_expression()

ida_offset.get_offset_expression(ea: ida_idaapi.ea_t, n: int, _from: ida_idaapi.ea_t, offset: "adiff_t", getn_flags: int = 0) -> str
    Get offset expression (in the form "offset name+displ"). This function uses offset translation function ( processor_t::translate) if your IDP module has such a function. Translation function is used to map linear addresses in the program (only for offsets).
    Example: suppose we have instruction at linear address 0x00011000: `mov     ax, [bx+7422h] ` and at ds:7422h: `array   dw      ... ` We want to represent the second operand with an offset expression, so then we call: `get_offset_expresion(0x001100, 1, 0x001102, 0x7422, buf);
                         |         |  |         |       |
                         |         |  |         |       +output buffer
                         |         |  |         +value of offset expression
                         |         |  +address offset value in the instruction
                         |         +the second operand
                         +address of instruction` and the function will return a colored string: `offset array ` 
            
    @param ea: start of instruction or data with the offset expression
    @param n: operand number (may be ORed with OPND_OUTER)
    * 0: first operand
    * 1: second operand
    * ...
    * 7: eighth operand
    @param offset: value of operand or its part. The function will return text representation of this value as offset expression.
    @param getn_flags: combination of:
    * GETN_APPZERO: meaningful only if the name refers to a structure. appends the struct field name if the field offset is zero
    * GETN_NODUMMY: do not generate dummy names for the expression but pretend they already exist (useful to verify that the offset expression can be represented)
    @retval 0: can't convert to offset expression
    @retval 1: ok, a simple offset expression
    @retval 2: ok, a complex offset expression

ida_offset.op_offset(*args) -> bool
    See op_offset_ex()

ida_offset.op_offset_ex(ea: ida_idaapi.ea_t, n: int, ri: "refinfo_t") -> bool
    Convert operand to a reference. To delete an offset, use clr_op_type() function. 
            
    @param ea: linear address. if 'ea' has unexplored bytes, try to convert them to
    * no segment: fail
    * 16bit segment: to 16bit word data
    * 32bit segment: to dword
    @param n: operand number (may be ORed with OPND_OUTER)
    * 0: first
    * 1: second
    * ...
    * 7: eighth operand
    
    
    * OPND_MASK: all operands
    @param ri: reference information
    @returns success

ida_offset.op_plain_offset(ea: ida_idaapi.ea_t, n: int, base: ida_idaapi.ea_t) -> bool
    Convert operand to a reference with the default reference type.

ida_pro
    This is the first header included in the IDA project.
    
    It defines the most common types, functions and data. Also, it tries to make system dependent definitions.
    The following preprocessor macros are used in the project (the list may be incomplete)
    Platform must be specified as one of:
    __NT__ - MS Windows (all platforms) 
     __LINUX__ - Linux 
     __MAC__ - MAC OS X
    __EA64__ - 64-bit address size (sizeof(ea_t)==8) 
     __X86__ - 32-bit debug servers (sizeof(void*)==4) 
     __X64__ - x64 processor (sizeof(void*)==8) default 
     __PPC__ - PowerPC 
     __ARM__ - ARM 
        

ida_pro.CP_UTF16
    UTF-16 codepage.

ida_pro.IDA_SDK_VERSION
    IDA SDK v9.1.

ida_pro.IDBDEC_ESCAPE
    convert non-printable characters to C escapes (
    , \xNN, \uNNNN)

ida_pro.IOREDIR_APPEND
    append, do not overwrite the output file

ida_pro.IOREDIR_INPUT
    input redirection

ida_pro.IOREDIR_OUTPUT
    output redirection

ida_pro.IOREDIR_QUOTED
    the file name was quoted

ida_pro.MAXSTR
    maximum string size

ida_pro.SUBSTCHAR
    default char, used if a char cannot be represented in a codepage

ida_pro.__MF__
    byte sex of our platform (Most significant byte First). 0: little endian (Intel 80x86). 1: big endian (PowerPC). 
            

ida_pro.__qmutex_t

ida_pro.__qmutex_t.__init__(self)

ida_pro.__qsemaphore_t

ida_pro.__qsemaphore_t.__init__(self)

ida_pro.__qthread_t

ida_pro.__qthread_t.__init__(self)

ida_pro._qstrvec_t
    WARNING: It is very unlikely an IDAPython user should ever, ever
    have to use this type. It should only be used for IDAPython internals.
    
    For example, in py_askusingform.py, we ctypes-expose to the IDA
    kernel & UI a qstrvec instance, in case a DropdownListControl is
    constructed.
    That's because that's what ask_form expects, and we have no
    choice but to make a DropdownListControl hold a qstrvec_t.
    This is, afaict, the only situation where a Python
    _qstrvec_t is required.

ida_pro._qstrvec_t.__get_size(self)

ida_pro._qstrvec_t.__getitem__(self, idx)
    Gets the string at the given index

ida_pro._qstrvec_t.__init__(self, items = None)

ida_pro._qstrvec_t.__setitem__(self, idx, s)
    Sets string at the given index

ida_pro._qstrvec_t._create_clink(self)

ida_pro._qstrvec_t._del_clink(self, lnk)

ida_pro._qstrvec_t._get_clink_ptr(self)

ida_pro._qstrvec_t.add(self, s)
    Add a string to the vector

ida_pro._qstrvec_t.addressof(self, idx)
    Returns the address (as number) of the qstring at the given index

ida_pro._qstrvec_t.assign(self, other)
    Copies the contents of 'other' to 'self'

ida_pro._qstrvec_t.clear(self, qclear = False)
    Clears all strings from the vector.
    @param qclear: Just reset the size but do not actually free the memory

ida_pro._qstrvec_t.from_list(self, lst)
    Populates the vector from a Python string list

ida_pro._qstrvec_t.insert(self, idx, s)
    Insert a string into the vector

ida_pro._qstrvec_t.remove(self, idx)
    Removes a string from the vector

ida_pro._qstrvec_t.size
    Returns the count of elements

ida_pro.adiff_pointer

ida_pro.adiff_pointer.__init__(self)

ida_pro.adiff_pointer.assign(self, value: "adiff_t") -> None

ida_pro.adiff_pointer.cast(self) -> "adiff_t *"

ida_pro.adiff_pointer.frompointer(t: "adiff_t *") -> "adiff_pointer *"

ida_pro.adiff_pointer.value(self) -> "adiff_t"

ida_pro.asize_pointer

ida_pro.asize_pointer.__init__(self)

ida_pro.asize_pointer.assign(self, value: "asize_t") -> None

ida_pro.asize_pointer.cast(self) -> "asize_t *"

ida_pro.asize_pointer.frompointer(t: "asize_t *") -> "asize_pointer *"

ida_pro.asize_pointer.value(self) -> "asize_t"

ida_pro.bool_pointer

ida_pro.bool_pointer.__init__(self)

ida_pro.bool_pointer.assign(self, value: bool) -> None

ida_pro.bool_pointer.cast(self) -> "bool *"

ida_pro.bool_pointer.frompointer(t: "bool *") -> "bool_pointer *"

ida_pro.bool_pointer.value(self) -> bool

ida_pro.boolvec_t

ida_pro.boolvec_t.__eq__(self, r: "boolvec_t") -> bool

ida_pro.boolvec_t.__getitem__(self, i: "size_t") -> "bool const &"

ida_pro.boolvec_t.__init__(self, *args)

ida_pro.boolvec_t.__len__(self) -> "size_t"

ida_pro.boolvec_t.__ne__(self, r: "boolvec_t") -> bool

ida_pro.boolvec_t.__setitem__(self, i: "size_t", v: "bool const &") -> None

ida_pro.boolvec_t._del(self, x: "bool const &") -> bool

ida_pro.boolvec_t.add_unique(self, x: "bool const &") -> bool

ida_pro.boolvec_t.append(self, x: "bool const &") -> None

ida_pro.boolvec_t.at(self, _idx: "size_t") -> "bool const &"

ida_pro.boolvec_t.begin(self, *args) -> "qvector< bool >::const_iterator"

ida_pro.boolvec_t.capacity(self) -> "size_t"

ida_pro.boolvec_t.clear(self) -> None

ida_pro.boolvec_t.empty(self) -> bool

ida_pro.boolvec_t.end(self, *args) -> "qvector< bool >::const_iterator"

ida_pro.boolvec_t.erase(self, *args) -> "qvector< bool >::iterator"

ida_pro.boolvec_t.extend(self, x: "boolvec_t") -> None

ida_pro.boolvec_t.extract(self) -> "bool *"

ida_pro.boolvec_t.find(self, *args) -> "qvector< bool >::const_iterator"

ida_pro.boolvec_t.grow(self, *args) -> None

ida_pro.boolvec_t.has(self, x: "bool const &") -> bool

ida_pro.boolvec_t.inject(self, s: "bool *", len: "size_t") -> None

ida_pro.boolvec_t.insert(self, it: "qvector< bool >::iterator", x: "bool const &") -> "qvector< bool >::iterator"

ida_pro.boolvec_t.pop_back(self) -> None

ida_pro.boolvec_t.push_back(self, *args) -> "bool &"

ida_pro.boolvec_t.qclear(self) -> None

ida_pro.boolvec_t.reserve(self, cnt: "size_t") -> None

ida_pro.boolvec_t.resize(self, *args) -> None

ida_pro.boolvec_t.size(self) -> "size_t"

ida_pro.boolvec_t.swap(self, r: "boolvec_t") -> None

ida_pro.boolvec_t.truncate(self) -> None

ida_pro.channel_redir_t

ida_pro.channel_redir_t.__init__(self)

ida_pro.channel_redir_t.fd
    channel number

ida_pro.channel_redir_t.file
    file name to redirect to/from. if empty, the channel must be closed. 
            

ida_pro.channel_redir_t.flags
    i/o redirection flags 
            

ida_pro.channel_redir_t.is_append(self) -> bool

ida_pro.channel_redir_t.is_input(self) -> bool

ida_pro.channel_redir_t.is_output(self) -> bool

ida_pro.channel_redir_t.is_quoted(self) -> bool

ida_pro.channel_redir_t.length
    length of the redirection string in the command line

ida_pro.channel_redir_t.start
    begin of the redirection string in the command line

ida_pro.char_pointer

ida_pro.char_pointer.__init__(self)

ida_pro.char_pointer.assign(self, value: "char") -> None

ida_pro.char_pointer.cast(self) -> "char *"

ida_pro.char_pointer.frompointer(t: "char *") -> "char_pointer *"

ida_pro.char_pointer.value(self) -> "char"

ida_pro.check_process_exit(handle: "void *", exit_code: "int *", msecs: int = -1) -> int
    Check whether process has terminated or not. 
            
    @param handle: process handle to wait for
    @param exit_code: pointer to the buffer for the exit code
    @retval 0: process has exited, and the exit code is available. if *exit_code < 0: the process was killed with a signal -*exit_code
    @retval 1: process has not exited yet
    @retval -1: error happened, see error code for winerr() in *exit_code

ida_pro.ea32_pointer

ida_pro.ea32_pointer.__init__(self)

ida_pro.ea32_pointer.assign(self, value: "ea32_t") -> None

ida_pro.ea32_pointer.cast(self) -> "ea32_t *"

ida_pro.ea32_pointer.frompointer(t: "ea32_t *") -> "ea32_pointer *"

ida_pro.ea32_pointer.value(self) -> "ea32_t"

ida_pro.ea64_pointer

ida_pro.ea64_pointer.__init__(self)

ida_pro.ea64_pointer.assign(self, value: "ea64_t") -> None

ida_pro.ea64_pointer.cast(self) -> "ea64_t *"

ida_pro.ea64_pointer.frompointer(t: "ea64_t *") -> "ea64_pointer *"

ida_pro.ea64_pointer.value(self) -> "ea64_t"

ida_pro.ea_array

ida_pro.ea_array.__getitem__(self, index: "size_t") -> ida_idaapi.ea_t

ida_pro.ea_array.__init__(self, nelements: "size_t")

ida_pro.ea_array.__setitem__(self, index: "size_t", value: ida_idaapi.ea_t) -> None

ida_pro.ea_array.cast(self) -> "ea_t *"

ida_pro.ea_array.frompointer(t: "ea_t *") -> "ea_array *"

ida_pro.ea_pointer

ida_pro.ea_pointer.__init__(self)

ida_pro.ea_pointer.assign(self, value: ida_idaapi.ea_t) -> None

ida_pro.ea_pointer.cast(self) -> "ea_t *"

ida_pro.ea_pointer.frompointer(t: "ea_t *") -> "ea_pointer *"

ida_pro.ea_pointer.value(self) -> ida_idaapi.ea_t

ida_pro.extend_sign(v: "uint64", nbytes: int, sign_extend: bool) -> "uint64"
    Sign-, or zero-extend the value 'v' to occupy 64 bits. The value 'v' is considered to be of size 'nbytes'. 
            

ida_pro.flags64_pointer

ida_pro.flags64_pointer.__init__(self)

ida_pro.flags64_pointer.assign(self, value: "flags64_t") -> None

ida_pro.flags64_pointer.cast(self) -> "flags64_t *"

ida_pro.flags64_pointer.frompointer(t: "flags64_t *") -> "flags64_pointer *"

ida_pro.flags64_pointer.value(self) -> "flags64_t"

ida_pro.flags_pointer

ida_pro.flags_pointer.__init__(self)

ida_pro.flags_pointer.assign(self, value: "flags_t") -> None

ida_pro.flags_pointer.cast(self) -> "flags_t *"

ida_pro.flags_pointer.frompointer(t: "flags_t *") -> "flags_pointer *"

ida_pro.flags_pointer.value(self) -> "flags_t"

ida_pro.get_available_core_count() -> int
    Get the number of logical CPU cores available to the current process if supported by the OS. 
            
    @returns the logical core count available for the process, or -1 on error

ida_pro.get_logical_core_count() -> int
    Get the total CPU logical core count 
            
    @returns the logical core count, or -1 on error

ida_pro.get_login_name() -> str
    Get the user name for the current desktop session 
            
    @returns success

ida_pro.get_physical_core_count() -> int
    Get the total CPU physical core count 
            
    @returns the physical core count, or -1 on error

ida_pro.instant_dbgopts_t

ida_pro.instant_dbgopts_t.__init__(self)

ida_pro.instant_dbgopts_t.attach
    should attach to a process?

ida_pro.instant_dbgopts_t.debmod
    name of debugger module

ida_pro.instant_dbgopts_t.env
    config variables for debmod. example: DEFAULT_CPU=13;MAXPACKETSIZE=-1

ida_pro.instant_dbgopts_t.event_id
    event to trigger upon attaching

ida_pro.instant_dbgopts_t.host
    remote hostname (if remote debugging)

ida_pro.instant_dbgopts_t.pid
    process to attach to (-1: ask the user)

ida_pro.instant_dbgopts_t.port
    port number for the remote debugger server

ida_pro.int16_pointer

ida_pro.int16_pointer.__init__(self)

ida_pro.int16_pointer.assign(self, value: "int16") -> None

ida_pro.int16_pointer.cast(self) -> "int16 *"

ida_pro.int16_pointer.frompointer(t: "int16 *") -> "int16_pointer *"

ida_pro.int16_pointer.value(self) -> "int16"

ida_pro.int32_pointer

ida_pro.int32_pointer.__init__(self)

ida_pro.int32_pointer.assign(self, value: int) -> None

ida_pro.int32_pointer.cast(self) -> "int32 *"

ida_pro.int32_pointer.frompointer(t: "int32 *") -> "int32_pointer *"

ida_pro.int32_pointer.value(self) -> int

ida_pro.int64_pointer

ida_pro.int64_pointer.__init__(self)

ida_pro.int64_pointer.assign(self, value: "int64") -> None

ida_pro.int64_pointer.cast(self) -> "int64 *"

ida_pro.int64_pointer.frompointer(t: "int64 *") -> "int64_pointer *"

ida_pro.int64_pointer.value(self) -> "int64"

ida_pro.int64vec_t

ida_pro.int64vec_t.__eq__(self, r: "int64vec_t") -> bool

ida_pro.int64vec_t.__getitem__(self, i: "size_t") -> "long long const &"

ida_pro.int64vec_t.__init__(self, *args)

ida_pro.int64vec_t.__len__(self) -> "size_t"

ida_pro.int64vec_t.__ne__(self, r: "int64vec_t") -> bool

ida_pro.int64vec_t.__setitem__(self, i: "size_t", v: "long long const &") -> None

ida_pro.int64vec_t._del(self, x: "long long const &") -> bool

ida_pro.int64vec_t.add_unique(self, x: "long long const &") -> bool

ida_pro.int64vec_t.append(self, x: "long long const &") -> None

ida_pro.int64vec_t.at(self, _idx: "size_t") -> "long long const &"

ida_pro.int64vec_t.begin(self, *args) -> "qvector< long long >::const_iterator"

ida_pro.int64vec_t.capacity(self) -> "size_t"

ida_pro.int64vec_t.clear(self) -> None

ida_pro.int64vec_t.empty(self) -> bool

ida_pro.int64vec_t.end(self, *args) -> "qvector< long long >::const_iterator"

ida_pro.int64vec_t.erase(self, *args) -> "qvector< long long >::iterator"

ida_pro.int64vec_t.extend(self, x: "int64vec_t") -> None

ida_pro.int64vec_t.extract(self) -> "long long *"

ida_pro.int64vec_t.find(self, *args) -> "qvector< long long >::const_iterator"

ida_pro.int64vec_t.has(self, x: "long long const &") -> bool

ida_pro.int64vec_t.inject(self, s: "long long *", len: "size_t") -> None

ida_pro.int64vec_t.insert(self, it: "qvector< long long >::iterator", x: "long long const &") -> "qvector< long long >::iterator"

ida_pro.int64vec_t.pop_back(self) -> None

ida_pro.int64vec_t.push_back(self, *args) -> "long long &"

ida_pro.int64vec_t.qclear(self) -> None

ida_pro.int64vec_t.reserve(self, cnt: "size_t") -> None

ida_pro.int64vec_t.resize(self, *args) -> None

ida_pro.int64vec_t.size(self) -> "size_t"

ida_pro.int64vec_t.swap(self, r: "int64vec_t") -> None

ida_pro.int64vec_t.truncate(self) -> None

ida_pro.int8_pointer

ida_pro.int8_pointer.__init__(self)

ida_pro.int8_pointer.assign(self, value: "int8") -> None

ida_pro.int8_pointer.cast(self) -> "int8 *"

ida_pro.int8_pointer.frompointer(t: "int8 *") -> "int8_pointer *"

ida_pro.int8_pointer.value(self) -> "int8"

ida_pro.int_pointer

ida_pro.int_pointer.__init__(self)

ida_pro.int_pointer.assign(self, value: int) -> None

ida_pro.int_pointer.cast(self) -> "int *"

ida_pro.int_pointer.frompointer(t: "int *") -> "int_pointer *"

ida_pro.int_pointer.value(self) -> int

ida_pro.intvec_t

ida_pro.intvec_t.__eq__(self, r: "intvec_t") -> bool

ida_pro.intvec_t.__getitem__(self, i: "size_t") -> "int const &"

ida_pro.intvec_t.__init__(self, *args)

ida_pro.intvec_t.__len__(self) -> "size_t"

ida_pro.intvec_t.__ne__(self, r: "intvec_t") -> bool

ida_pro.intvec_t.__setitem__(self, i: "size_t", v: "int const &") -> None

ida_pro.intvec_t._del(self, x: "int const &") -> bool

ida_pro.intvec_t.add_unique(self, x: "int const &") -> bool

ida_pro.intvec_t.append(self, x: "int const &") -> None

ida_pro.intvec_t.at(self, _idx: "size_t") -> "int const &"

ida_pro.intvec_t.begin(self, *args) -> "qvector< int >::const_iterator"

ida_pro.intvec_t.capacity(self) -> "size_t"

ida_pro.intvec_t.clear(self) -> None

ida_pro.intvec_t.empty(self) -> bool

ida_pro.intvec_t.end(self, *args) -> "qvector< int >::const_iterator"

ida_pro.intvec_t.erase(self, *args) -> "qvector< int >::iterator"

ida_pro.intvec_t.extend(self, x: "intvec_t") -> None

ida_pro.intvec_t.extract(self) -> "int *"

ida_pro.intvec_t.find(self, *args) -> "qvector< int >::const_iterator"

ida_pro.intvec_t.has(self, x: "int const &") -> bool

ida_pro.intvec_t.inject(self, s: "int *", len: "size_t") -> None

ida_pro.intvec_t.insert(self, it: "qvector< int >::iterator", x: "int const &") -> "qvector< int >::iterator"

ida_pro.intvec_t.pop_back(self) -> None

ida_pro.intvec_t.push_back(self, *args) -> "int &"

ida_pro.intvec_t.qclear(self) -> None

ida_pro.intvec_t.reserve(self, cnt: "size_t") -> None

ida_pro.intvec_t.resize(self, *args) -> None

ida_pro.intvec_t.size(self) -> "size_t"

ida_pro.intvec_t.swap(self, r: "intvec_t") -> None

ida_pro.intvec_t.truncate(self) -> None

ida_pro.is_control_tty(fd: int) -> "enum tty_control_t"
    Check if the current process is the owner of the TTY specified by 'fd' (typically an opened descriptor to /dev/tty). 
            

ida_pro.is_cvt64() -> bool
    is IDA converting IDB into I64?

ida_pro.is_main_thread() -> bool
    Are we running in the main thread?

ida_pro.log2ceil(d64: "uint64") -> int
    calculate ceil(log2(d64)) or floor(log2(d64)), it returns 0 if d64 == 0 
            

ida_pro.log2floor(d64: "uint64") -> int

ida_pro.parse_dbgopts(ido: "instant_dbgopts_t", r_switch: str) -> bool
    Parse the -r command line switch (for instant debugging). r_switch points to the value of the -r switch. Example: win32@localhost+ 
            
    @returns true-ok, false-parse error

ida_pro.plugin_options_t

ida_pro.plugin_options_t.__init__(self)

ida_pro.plugin_options_t.erase(self, name: str) -> bool

ida_pro.plugin_options_t.find(self, name: str) -> "plugin_option_t const *"

ida_pro.qatoll(nptr: str) -> "int64"

ida_pro.qcontrol_tty() -> None
    Make the current terminal the controlling terminal of the calling process. 
            

ida_pro.qdetach_tty() -> None
    If the current terminal is the controlling terminal of the calling process, give up this controlling terminal. 
            

ida_pro.qexit(code: int) -> None
    Call qatexit functions, shut down UI and kernel, and exit. 
            
    @param code: exit code

ida_pro.qmutex_locker_t

ida_pro.qmutex_locker_t.__init__(self, _lock: "__qmutex_t")

ida_pro.qrefcnt_obj_t

ida_pro.qrefcnt_obj_t.__init__(self, *args, **kwargs)

ida_pro.qrefcnt_obj_t.refcnt
    counter 
            

ida_pro.qrefcnt_obj_t.release(self) -> None
    Call destructor. We use release() instead of operator delete() to maintain binary compatibility with all compilers (vc and gcc use different vtable layouts for operator delete) 
            

ida_pro.qstrvec_t_add(_self: "PyObject *", s: str) -> bool

ida_pro.qstrvec_t_addressof(_self: "PyObject *", idx: "size_t") -> "PyObject *"

ida_pro.qstrvec_t_assign(_self: "PyObject *", other: "PyObject *") -> bool

ida_pro.qstrvec_t_clear(_self: "PyObject *", qclear: bool) -> bool

ida_pro.qstrvec_t_create() -> "PyObject *"

ida_pro.qstrvec_t_destroy(py_obj: "PyObject *") -> bool

ida_pro.qstrvec_t_from_list(_self: "PyObject *", py_list: "PyObject *") -> bool

ida_pro.qstrvec_t_get(_self: "PyObject *", idx: "size_t") -> "PyObject *"

ida_pro.qstrvec_t_get_clink(_self: "PyObject *") -> "qstrvec_t *"

ida_pro.qstrvec_t_get_clink_ptr(_self: "PyObject *") -> "PyObject *"

ida_pro.qstrvec_t_insert(_self: "PyObject *", idx: "size_t", s: str) -> bool

ida_pro.qstrvec_t_remove(_self: "PyObject *", idx: "size_t") -> bool

ida_pro.qstrvec_t_set(_self: "PyObject *", idx: "size_t", s: str) -> bool

ida_pro.qstrvec_t_size(_self: "PyObject *") -> "size_t"

ida_pro.qthread_equal(q1: "__qthread_t", q2: "__qthread_t") -> bool
    Are two threads equal?

ida_pro.quote_cmdline_arg(arg: str) -> bool
    Quote a command line argument if it contains escape characters. For example, *.c will be converted into "*.c" because * may be inadvertently expanded by the shell 
            
    @returns true: modified 'arg'

ida_pro.qvector_reserve(vec: "void *", old: "void *", cnt: "size_t", elsize: "size_t") -> "void *"
    Change capacity of given qvector. 
            
    @param vec: a pointer to a qvector
    @param old: a pointer to the qvector's array
    @param cnt: number of elements to reserve
    @param elsize: size of each element
    @returns a pointer to the newly allocated array

ida_pro.readbytes(h: int, res: "uint32 *", size: int, mf: bool) -> int
    Read at most 4 bytes from file. 
            
    @param h: file handle
    @param res: value read from file
    @param size: size of value in bytes (1,2,4)
    @param mf: is MSB first?
    @returns 0 on success, nonzero otherwise

ida_pro.reloc_value(value: "void *", size: int, delta: "adiff_t", mf: bool) -> None

ida_pro.relocate_relobj(_relobj: "relobj_t *", ea: ida_idaapi.ea_t, mf: bool) -> bool

ida_pro.sel_array

ida_pro.sel_array.__getitem__(self, index: "size_t") -> "sel_t"

ida_pro.sel_array.__init__(self, nelements: "size_t")

ida_pro.sel_array.__setitem__(self, index: "size_t", value: "sel_t") -> None

ida_pro.sel_array.cast(self) -> "sel_t *"

ida_pro.sel_array.frompointer(t: "sel_t *") -> "sel_array *"

ida_pro.sel_pointer

ida_pro.sel_pointer.__init__(self)

ida_pro.sel_pointer.assign(self, value: "sel_t") -> None

ida_pro.sel_pointer.cast(self) -> "sel_t *"

ida_pro.sel_pointer.frompointer(t: "sel_t *") -> "sel_pointer *"

ida_pro.sel_pointer.value(self) -> "sel_t"

ida_pro.short_pointer

ida_pro.short_pointer.__init__(self)

ida_pro.short_pointer.assign(self, value: "short") -> None

ida_pro.short_pointer.cast(self) -> "short *"

ida_pro.short_pointer.frompointer(t: "short *") -> "short_pointer *"

ida_pro.short_pointer.value(self) -> "short"

ida_pro.sint8_pointer

ida_pro.sint8_pointer.__init__(self)

ida_pro.sint8_pointer.assign(self, value: "sint8") -> None

ida_pro.sint8_pointer.cast(self) -> "sint8 *"

ida_pro.sint8_pointer.frompointer(t: "sint8 *") -> "sint8_pointer *"

ida_pro.sint8_pointer.value(self) -> "sint8"

ida_pro.sizevec_t

ida_pro.sizevec_t.__eq__(self, r: "sizevec_t") -> bool

ida_pro.sizevec_t.__getitem__(self, i: "size_t") -> "size_t const &"

ida_pro.sizevec_t.__init__(self, *args)

ida_pro.sizevec_t.__len__(self) -> "size_t"

ida_pro.sizevec_t.__ne__(self, r: "sizevec_t") -> bool

ida_pro.sizevec_t.__setitem__(self, i: "size_t", v: "size_t const &") -> None

ida_pro.sizevec_t._del(self, x: "size_t const &") -> bool

ida_pro.sizevec_t.add_unique(self, x: "size_t const &") -> bool

ida_pro.sizevec_t.append(self, x: "size_t const &") -> None

ida_pro.sizevec_t.at(self, _idx: "size_t") -> "size_t const &"

ida_pro.sizevec_t.begin(self, *args) -> "qvector< size_t >::const_iterator"

ida_pro.sizevec_t.capacity(self) -> "size_t"

ida_pro.sizevec_t.clear(self) -> None

ida_pro.sizevec_t.empty(self) -> bool

ida_pro.sizevec_t.end(self, *args) -> "qvector< size_t >::const_iterator"

ida_pro.sizevec_t.erase(self, *args) -> "qvector< size_t >::iterator"

ida_pro.sizevec_t.extend(self, x: "sizevec_t") -> None

ida_pro.sizevec_t.extract(self) -> "size_t *"

ida_pro.sizevec_t.find(self, *args) -> "qvector< size_t >::const_iterator"

ida_pro.sizevec_t.grow(self, *args) -> None

ida_pro.sizevec_t.has(self, x: "size_t const &") -> bool

ida_pro.sizevec_t.inject(self, s: "size_t *", len: "size_t") -> None

ida_pro.sizevec_t.insert(self, it: "qvector< size_t >::iterator", x: "size_t const &") -> "qvector< size_t >::iterator"

ida_pro.sizevec_t.pop_back(self) -> None

ida_pro.sizevec_t.push_back(self, *args) -> "size_t &"

ida_pro.sizevec_t.qclear(self) -> None

ida_pro.sizevec_t.reserve(self, cnt: "size_t") -> None

ida_pro.sizevec_t.resize(self, *args) -> None

ida_pro.sizevec_t.size(self) -> "size_t"

ida_pro.sizevec_t.swap(self, r: "sizevec_t") -> None

ida_pro.sizevec_t.truncate(self) -> None

ida_pro.ssize_pointer

ida_pro.ssize_pointer.__init__(self)

ida_pro.ssize_pointer.assign(self, value: "ssize_t") -> None

ida_pro.ssize_pointer.cast(self) -> "ssize_t *"

ida_pro.ssize_pointer.frompointer(t: "ssize_t *") -> "ssize_pointer *"

ida_pro.ssize_pointer.value(self) -> "ssize_t"

ida_pro.str2user(str)
    Insert C-style escape characters to string
    
    @param str: the input string
    @return: new string with escape characters inserted, or None

ida_pro.strvec_t

ida_pro.strvec_t.__getitem__(self, i: "size_t") -> "simpleline_t const &"

ida_pro.strvec_t.__init__(self, *args)

ida_pro.strvec_t.__len__(self) -> "size_t"

ida_pro.strvec_t.__setitem__(self, i: "size_t", v: "simpleline_t const &") -> None

ida_pro.strvec_t.append(self, x: "simpleline_t const &") -> None

ida_pro.strvec_t.at(self, _idx: "size_t") -> "simpleline_t const &"

ida_pro.strvec_t.begin(self, *args) -> "qvector< simpleline_t >::const_iterator"

ida_pro.strvec_t.capacity(self) -> "size_t"

ida_pro.strvec_t.clear(self) -> None

ida_pro.strvec_t.empty(self) -> bool

ida_pro.strvec_t.end(self, *args) -> "qvector< simpleline_t >::const_iterator"

ida_pro.strvec_t.erase(self, *args) -> "qvector< simpleline_t >::iterator"

ida_pro.strvec_t.extend(self, x: "strvec_t") -> None

ida_pro.strvec_t.extract(self) -> "simpleline_t *"

ida_pro.strvec_t.grow(self, *args) -> None

ida_pro.strvec_t.inject(self, s: "simpleline_t *", len: "size_t") -> None

ida_pro.strvec_t.insert(self, it: "qvector< simpleline_t >::iterator", x: "simpleline_t const &") -> "qvector< simpleline_t >::iterator"

ida_pro.strvec_t.pop_back(self) -> None

ida_pro.strvec_t.push_back(self, *args) -> "simpleline_t &"

ida_pro.strvec_t.qclear(self) -> None

ida_pro.strvec_t.reserve(self, cnt: "size_t") -> None

ida_pro.strvec_t.resize(self, *args) -> None

ida_pro.strvec_t.size(self) -> "size_t"

ida_pro.strvec_t.swap(self, r: "strvec_t") -> None

ida_pro.strvec_t.truncate(self) -> None

ida_pro.sval_pointer

ida_pro.sval_pointer.__init__(self)

ida_pro.sval_pointer.assign(self, value: int) -> None

ida_pro.sval_pointer.cast(self) -> "sval_t *"

ida_pro.sval_pointer.frompointer(t: "sval_t *") -> "sval_pointer *"

ida_pro.sval_pointer.value(self) -> int

ida_pro.tid_array

ida_pro.tid_array.__getitem__(self, index: "size_t") -> "tid_t"

ida_pro.tid_array.__init__(self, nelements: "size_t")

ida_pro.tid_array.__setitem__(self, index: "size_t", value: "tid_t") -> None

ida_pro.tid_array.cast(self) -> "tid_t *"

ida_pro.tid_array.frompointer(t: "tid_t *") -> "tid_array *"

ida_pro.tid_pointer

ida_pro.tid_pointer.__init__(self)

ida_pro.tid_pointer.assign(self, value: "tid_t") -> None

ida_pro.tid_pointer.cast(self) -> "tid_t *"

ida_pro.tid_pointer.frompointer(t: "tid_t *") -> "tid_pointer *"

ida_pro.tid_pointer.value(self) -> "tid_t"

ida_pro.uchar_array

ida_pro.uchar_array.__getitem__(self, index: "size_t") -> "uchar"

ida_pro.uchar_array.__init__(self, nelements: "size_t")

ida_pro.uchar_array.__setitem__(self, index: "size_t", value: "uchar") -> None

ida_pro.uchar_array.cast(self) -> "uchar *"

ida_pro.uchar_array.frompointer(t: "uchar *") -> "uchar_array *"

ida_pro.uchar_pointer

ida_pro.uchar_pointer.__init__(self)

ida_pro.uchar_pointer.assign(self, value: "uchar") -> None

ida_pro.uchar_pointer.cast(self) -> "uchar *"

ida_pro.uchar_pointer.frompointer(t: "uchar *") -> "uchar_pointer *"

ida_pro.uchar_pointer.value(self) -> "uchar"

ida_pro.uint16_pointer

ida_pro.uint16_pointer.__init__(self)

ida_pro.uint16_pointer.assign(self, value: "uint16") -> None

ida_pro.uint16_pointer.cast(self) -> "uint16 *"

ida_pro.uint16_pointer.frompointer(t: "uint16 *") -> "uint16_pointer *"

ida_pro.uint16_pointer.value(self) -> "uint16"

ida_pro.uint32_pointer

ida_pro.uint32_pointer.__init__(self)

ida_pro.uint32_pointer.assign(self, value: int) -> None

ida_pro.uint32_pointer.cast(self) -> "uint32 *"

ida_pro.uint32_pointer.frompointer(t: "uint32 *") -> "uint32_pointer *"

ida_pro.uint32_pointer.value(self) -> int

ida_pro.uint64_pointer

ida_pro.uint64_pointer.__init__(self)

ida_pro.uint64_pointer.assign(self, value: "uint64") -> None

ida_pro.uint64_pointer.cast(self) -> "uint64 *"

ida_pro.uint64_pointer.frompointer(t: "uint64 *") -> "uint64_pointer *"

ida_pro.uint64_pointer.value(self) -> "uint64"

ida_pro.uint64vec_t

ida_pro.uint64vec_t.__eq__(self, r: "uint64vec_t") -> bool

ida_pro.uint64vec_t.__getitem__(self, i: "size_t") -> "unsigned long long const &"

ida_pro.uint64vec_t.__init__(self, *args)

ida_pro.uint64vec_t.__len__(self) -> "size_t"

ida_pro.uint64vec_t.__ne__(self, r: "uint64vec_t") -> bool

ida_pro.uint64vec_t.__setitem__(self, i: "size_t", v: "unsigned long long const &") -> None

ida_pro.uint64vec_t._del(self, x: "unsigned long long const &") -> bool

ida_pro.uint64vec_t.add_unique(self, x: "unsigned long long const &") -> bool

ida_pro.uint64vec_t.append(self, x: "unsigned long long const &") -> None

ida_pro.uint64vec_t.at(self, _idx: "size_t") -> "unsigned long long const &"

ida_pro.uint64vec_t.begin(self, *args) -> "qvector< unsigned long long >::const_iterator"

ida_pro.uint64vec_t.capacity(self) -> "size_t"

ida_pro.uint64vec_t.clear(self) -> None

ida_pro.uint64vec_t.empty(self) -> bool

ida_pro.uint64vec_t.end(self, *args) -> "qvector< unsigned long long >::const_iterator"

ida_pro.uint64vec_t.erase(self, *args) -> "qvector< unsigned long long >::iterator"

ida_pro.uint64vec_t.extend(self, x: "uint64vec_t") -> None

ida_pro.uint64vec_t.extract(self) -> "unsigned long long *"

ida_pro.uint64vec_t.find(self, *args) -> "qvector< unsigned long long >::const_iterator"

ida_pro.uint64vec_t.has(self, x: "unsigned long long const &") -> bool

ida_pro.uint64vec_t.inject(self, s: "unsigned long long *", len: "size_t") -> None

ida_pro.uint64vec_t.insert(self, it: "qvector< unsigned long long >::iterator", x: "unsigned long long const &") -> "qvector< unsigned long long >::iterator"

ida_pro.uint64vec_t.pop_back(self) -> None

ida_pro.uint64vec_t.push_back(self, *args) -> "unsigned long long &"

ida_pro.uint64vec_t.qclear(self) -> None

ida_pro.uint64vec_t.reserve(self, cnt: "size_t") -> None

ida_pro.uint64vec_t.resize(self, *args) -> None

ida_pro.uint64vec_t.size(self) -> "size_t"

ida_pro.uint64vec_t.swap(self, r: "uint64vec_t") -> None

ida_pro.uint64vec_t.truncate(self) -> None

ida_pro.uint8_pointer

ida_pro.uint8_pointer.__init__(self)

ida_pro.uint8_pointer.assign(self, value: "uint8") -> None

ida_pro.uint8_pointer.cast(self) -> "uint8 *"

ida_pro.uint8_pointer.frompointer(t: "uint8 *") -> "uint8_pointer *"

ida_pro.uint8_pointer.value(self) -> "uint8"

ida_pro.uint_pointer

ida_pro.uint_pointer.__init__(self)

ida_pro.uint_pointer.assign(self, value: "uint") -> None

ida_pro.uint_pointer.cast(self) -> "uint *"

ida_pro.uint_pointer.frompointer(t: "uint *") -> "uint_pointer *"

ida_pro.uint_pointer.value(self) -> "uint"

ida_pro.uintvec_t

ida_pro.uintvec_t.__eq__(self, r: "uintvec_t") -> bool

ida_pro.uintvec_t.__getitem__(self, i: "size_t") -> "unsigned int const &"

ida_pro.uintvec_t.__init__(self, *args)

ida_pro.uintvec_t.__len__(self) -> "size_t"

ida_pro.uintvec_t.__ne__(self, r: "uintvec_t") -> bool

ida_pro.uintvec_t.__setitem__(self, i: "size_t", v: "unsigned int const &") -> None

ida_pro.uintvec_t._del(self, x: "unsigned int const &") -> bool

ida_pro.uintvec_t.add_unique(self, x: "unsigned int const &") -> bool

ida_pro.uintvec_t.append(self, x: "unsigned int const &") -> None

ida_pro.uintvec_t.at(self, _idx: "size_t") -> "unsigned int const &"

ida_pro.uintvec_t.begin(self, *args) -> "qvector< unsigned int >::const_iterator"

ida_pro.uintvec_t.capacity(self) -> "size_t"

ida_pro.uintvec_t.clear(self) -> None

ida_pro.uintvec_t.empty(self) -> bool

ida_pro.uintvec_t.end(self, *args) -> "qvector< unsigned int >::const_iterator"

ida_pro.uintvec_t.erase(self, *args) -> "qvector< unsigned int >::iterator"

ida_pro.uintvec_t.extend(self, x: "uintvec_t") -> None

ida_pro.uintvec_t.extract(self) -> "unsigned int *"

ida_pro.uintvec_t.find(self, *args) -> "qvector< unsigned int >::const_iterator"

ida_pro.uintvec_t.has(self, x: "unsigned int const &") -> bool

ida_pro.uintvec_t.inject(self, s: "unsigned int *", len: "size_t") -> None

ida_pro.uintvec_t.insert(self, it: "qvector< unsigned int >::iterator", x: "unsigned int const &") -> "qvector< unsigned int >::iterator"

ida_pro.uintvec_t.pop_back(self) -> None

ida_pro.uintvec_t.push_back(self, *args) -> "unsigned int &"

ida_pro.uintvec_t.qclear(self) -> None

ida_pro.uintvec_t.reserve(self, cnt: "size_t") -> None

ida_pro.uintvec_t.resize(self, *args) -> None

ida_pro.uintvec_t.size(self) -> "size_t"

ida_pro.uintvec_t.swap(self, r: "uintvec_t") -> None

ida_pro.uintvec_t.truncate(self) -> None

ida_pro.ushort_pointer

ida_pro.ushort_pointer.__init__(self)

ida_pro.ushort_pointer.assign(self, value: "ushort") -> None

ida_pro.ushort_pointer.cast(self) -> "ushort *"

ida_pro.ushort_pointer.frompointer(t: "ushort *") -> "ushort_pointer *"

ida_pro.ushort_pointer.value(self) -> "ushort"

ida_pro.uval_array

ida_pro.uval_array.__getitem__(self, index: "size_t") -> int

ida_pro.uval_array.__init__(self, nelements: "size_t")

ida_pro.uval_array.__setitem__(self, index: "size_t", value: int) -> None

ida_pro.uval_array.cast(self) -> "uval_t *"

ida_pro.uval_array.frompointer(t: "uval_t *") -> "uval_array *"

ida_pro.uval_pointer

ida_pro.uval_pointer.__init__(self)

ida_pro.uval_pointer.assign(self, value: int) -> None

ida_pro.uval_pointer.cast(self) -> "uval_t *"

ida_pro.uval_pointer.frompointer(t: "uval_t *") -> "uval_pointer *"

ida_pro.uval_pointer.value(self) -> int

ida_pro.writebytes(h: int, l: int, size: int, mf: bool) -> int
    Write at most 4 bytes to file. 
            
    @param h: file handle
    @param l: value to write
    @param size: size of value in bytes (1,2,4)
    @param mf: is MSB first?
    @returns 0 on success, nonzero otherwise

ida_problems
    Functions that deal with the list of problems.
    
    There are several problem lists. An address may be inserted to any list. The kernel simply maintains these lists, no additional processing is done.
    The problem lists are accessible for the user from the View->Subviews->Problems menu item.
    Addresses in the lists are kept sorted. In general IDA just maintains these lists without using them during analysis (except PR_ROLLED). 
        

ida_problems.PR_ATTN
    Attention! Probably erroneous situation.

ida_problems.PR_BADSTACK
    Failed to trace the value of the stack pointer.

ida_problems.PR_COLLISION
    FLAIR collision: the function with the given name already exists.

ida_problems.PR_DECIMP
    FLAIR match indecision: the patterns matched, but not the function(s) being referenced.

ida_problems.PR_DISASM
    Can't disasm.

ida_problems.PR_END
    Number of problem types.

ida_problems.PR_FINAL
    Decision to convert to instruction/data is made by IDA.

ida_problems.PR_HEAD
    Already head.

ida_problems.PR_ILLADDR
    Exec flows beyond limits.

ida_problems.PR_JUMP
    Jump by table !!!! ignored.

ida_problems.PR_MANYLINES
    Too many lines.

ida_problems.PR_NOBASE
    Can't find offset base.

ida_problems.PR_NOCMT
    Can't find comment (not used anymore)

ida_problems.PR_NOFOP
    Can't find forced op (not used anymore)

ida_problems.PR_NONAME
    Can't find name.

ida_problems.PR_NOXREFS
    Can't find references.

ida_problems.PR_ROLLED
    The decision made by IDA was wrong and rolled back.

ida_problems.forget_problem(type: "problist_id_t", ea: ida_idaapi.ea_t) -> bool
    Remove an address from a problem list 
            
    @param type: problem list type
    @param ea: linear address
    @returns success

ida_problems.get_problem(type: "problist_id_t", lowea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get an address from the specified problem list. The address is not removed from the list. 
            
    @param type: problem list type
    @param lowea: the returned address will be higher or equal than the specified address
    @returns linear address or BADADDR

ida_problems.get_problem_desc(t: "problist_id_t", ea: ida_idaapi.ea_t) -> str
    Get the human-friendly description of the problem, if one was provided to remember_problem. 
            
    @param t: problem list type.
    @param ea: linear address.
    @returns the message length or -1 if none

ida_problems.get_problem_name(type: "problist_id_t", longname: bool = True) -> str
    Get problem list description.

ida_problems.is_problem_present(t: "problist_id_t", ea: ida_idaapi.ea_t) -> bool
    Check if the specified address is present in the problem list.

ida_problems.remember_problem(type: "problist_id_t", ea: ida_idaapi.ea_t, msg: str = None) -> None
    Insert an address to a list of problems. Display a message saying about the problem (except of PR_ATTN,PR_FINAL) PR_JUMP is temporarily ignored. 
            
    @param type: problem list type
    @param ea: linear address
    @param msg: a user-friendly message to be displayed instead of the default more generic one associated with the type of problem. Defaults to nullptr.

ida_problems.was_ida_decision(ea: ida_idaapi.ea_t) -> bool

ida_range
    Contains the definition of range_t.
    
    A range is a non-empty continuous range of addresses (specified by its start and end addresses, the end address is excluded from the range).
    Ranges are stored in the Btree part of the IDA database. To learn more about Btrees (Balanced Trees): [http://www.bluerwhite.org/btree/](http://www.bluerwhite.org/btree/) 
        

ida_range.RANGE_KIND_FUNC
    func_t

ida_range.RANGE_KIND_HIDDEN_RANGE
    hidden_range_t

ida_range.RANGE_KIND_SEGMENT
    segment_t

ida_range.array_of_rangesets

ida_range.array_of_rangesets.__eq__(self, r: "array_of_rangesets") -> bool

ida_range.array_of_rangesets.__getitem__(self, i: "size_t") -> "rangeset_t const &"

ida_range.array_of_rangesets.__init__(self, *args)

ida_range.array_of_rangesets.__len__(self) -> "size_t"

ida_range.array_of_rangesets.__ne__(self, r: "array_of_rangesets") -> bool

ida_range.array_of_rangesets.__setitem__(self, i: "size_t", v: "rangeset_t") -> None

ida_range.array_of_rangesets._del(self, x: "rangeset_t") -> bool

ida_range.array_of_rangesets.add_unique(self, x: "rangeset_t") -> bool

ida_range.array_of_rangesets.append(self, x: "rangeset_t") -> None

ida_range.array_of_rangesets.at(self, _idx: "size_t") -> "rangeset_t const &"

ida_range.array_of_rangesets.begin(self, *args) -> "qvector< rangeset_t >::const_iterator"

ida_range.array_of_rangesets.capacity(self) -> "size_t"

ida_range.array_of_rangesets.clear(self) -> None

ida_range.array_of_rangesets.empty(self) -> bool

ida_range.array_of_rangesets.end(self, *args) -> "qvector< rangeset_t >::const_iterator"

ida_range.array_of_rangesets.erase(self, *args) -> "qvector< rangeset_t >::iterator"

ida_range.array_of_rangesets.extend(self, x: "array_of_rangesets") -> None

ida_range.array_of_rangesets.extract(self) -> "rangeset_t *"

ida_range.array_of_rangesets.find(self, *args) -> "qvector< rangeset_t >::const_iterator"

ida_range.array_of_rangesets.grow(self, *args) -> None

ida_range.array_of_rangesets.has(self, x: "rangeset_t") -> bool

ida_range.array_of_rangesets.inject(self, s: "rangeset_t", len: "size_t") -> None

ida_range.array_of_rangesets.insert(self, it: "rangeset_t", x: "rangeset_t") -> "qvector< rangeset_t >::iterator"

ida_range.array_of_rangesets.pop_back(self) -> None

ida_range.array_of_rangesets.push_back(self, *args) -> "rangeset_t &"

ida_range.array_of_rangesets.qclear(self) -> None

ida_range.array_of_rangesets.reserve(self, cnt: "size_t") -> None

ida_range.array_of_rangesets.resize(self, *args) -> None

ida_range.array_of_rangesets.size(self) -> "size_t"

ida_range.array_of_rangesets.swap(self, r: "array_of_rangesets") -> None

ida_range.array_of_rangesets.truncate(self) -> None

ida_range.range_t

ida_range.range_t.__eq__(self, r: "range_t") -> bool

ida_range.range_t.__ge__(self, r: "range_t") -> bool

ida_range.range_t.__gt__(self, r: "range_t") -> bool

ida_range.range_t.__init__(self, ea1: ida_idaapi.ea_t = 0, ea2: ida_idaapi.ea_t = 0)

ida_range.range_t.__le__(self, r: "range_t") -> bool

ida_range.range_t.__lt__(self, r: "range_t") -> bool

ida_range.range_t.__ne__(self, r: "range_t") -> bool

ida_range.range_t._print(self, *args) -> "size_t"

ida_range.range_t.clear(self) -> None
    Set start_ea, end_ea to 0.

ida_range.range_t.compare(self, r: "range_t") -> int

ida_range.range_t.contains(self, *args) -> bool
    This function has the following signatures:
    
        0. contains(ea: ida_idaapi.ea_t) -> bool
        1. contains(r: const range_t &) -> bool
    
    # 0: contains(ea: ida_idaapi.ea_t) -> bool
    
    Compare two range_t instances, based on the start_ea.
    
    Is 'ea' in the address range? 
            
    
    # 1: contains(r: const range_t &) -> bool
    
    Is every ea in 'r' also in this range_t?

ida_range.range_t.empty(self) -> bool
    Is the size of the range_t <= 0?

ida_range.range_t.end_ea
    end_ea excluded

ida_range.range_t.extend(self, ea: ida_idaapi.ea_t) -> None
    Ensure that the range_t includes 'ea'.

ida_range.range_t.intersect(self, r: "range_t") -> None
    Assign the range_t to the intersection between the range_t and 'r'.

ida_range.range_t.overlaps(self, r: "range_t") -> bool
    Is there an ea in 'r' that is also in this range_t?

ida_range.range_t.size(self) -> "asize_t"
    Get end_ea - start_ea.

ida_range.range_t.start_ea
    start_ea included

ida_range.range_t_print(cb: "range_t") -> str
    Helper function. Should not be called directly!

ida_range.rangeset_t

ida_range.rangeset_t.__eq__(self, aset: "rangeset_t") -> bool

ida_range.rangeset_t.__getitem__(self, idx)

ida_range.rangeset_t.__init__(self, *args)

ida_range.rangeset_t.__ne__(self, aset: "rangeset_t") -> bool

ida_range.rangeset_t._print(self, *args) -> "size_t"

ida_range.rangeset_t.add(self, *args) -> bool
    This function has the following signatures:
    
        0. add(range: const range_t &) -> bool
        1. add(start: ida_idaapi.ea_t, _end: ida_idaapi.ea_t) -> bool
        2. add(aset: const rangeset_t &) -> bool
    
    # 0: add(range: const range_t &) -> bool
    
    Add an address range to the set. If 'range' intersects an existing element e, then e is extended to include 'range', and any superfluous elements (subsets of e) are removed. 
            
    @returns false if 'range' was not added (the set was unchanged)
    
    # 1: add(start: ida_idaapi.ea_t, _end: ida_idaapi.ea_t) -> bool
    
    Create a new range_t from 'start' and 'end' and add it to the set.
    
    
    # 2: add(aset: const rangeset_t &) -> bool
    
    Add each element of 'aset' to the set. 
            
    @returns false if no elements were added (the set was unchanged)

ida_range.rangeset_t.begin(self) -> "rangeset_t::iterator"
    Get an iterator that points to the first element in the set.

ida_range.rangeset_t.cached_range(self) -> "range_t const *"
    When searching the rangeset, we keep a cached element to help speed up searches. 
            
    @returns a pointer to the cached element

ida_range.rangeset_t.clear(self) -> None
    Delete all elements from the set. See qvector::clear()

ida_range.rangeset_t.contains(self, *args) -> bool
    This function has the following signatures:
    
        0. contains(ea: ida_idaapi.ea_t) -> bool
        1. contains(aset: const rangeset_t &) -> bool
    
    # 0: contains(ea: ida_idaapi.ea_t) -> bool
    
    Does an element of the rangeset contain 'ea'? See range_t::contains(ea_t)
    
    
    # 1: contains(aset: const rangeset_t &) -> bool
    
    Is every element in 'aset' contained in an element of this rangeset?. See range_t::contains(range_t)

ida_range.rangeset_t.empty(self) -> bool
    Does the set have zero elements.

ida_range.rangeset_t.end(self) -> "rangeset_t::iterator"
    Get an iterator that points to the end of the set. (This is NOT the last element)

ida_range.rangeset_t.find_range(self, ea: ida_idaapi.ea_t) -> "range_t const *"
    Get the element from the set that contains 'ea'. 
            
    @returns nullptr if there is no such element

ida_range.rangeset_t.getrange(self, idx: int) -> "range_t const &"
    Get the range_t at index 'idx'.

ida_range.rangeset_t.has_common(self, *args) -> bool
    This function has the following signatures:
    
        0. has_common(range: const range_t &) -> bool
        1. has_common(aset: const rangeset_t &) -> bool
    
    # 0: has_common(range: const range_t &) -> bool
    
    Is there an ea in 'range' that is also in the rangeset?
    
    
    # 1: has_common(aset: const rangeset_t &) -> bool
    
    Does any element of 'aset' overlap with an element in this rangeset?. See range_t::overlaps()

ida_range.rangeset_t.includes(self, range: "range_t") -> bool
    Is every ea in 'range' contained in the rangeset?

ida_range.rangeset_t.intersect(self, aset: "rangeset_t") -> bool
    Set the rangeset to its intersection with 'aset'. 
            
    @returns false if the set was unchanged

ida_range.rangeset_t.is_equal(self, aset: "rangeset_t") -> bool
    Do this rangeset and 'aset' have identical elements?

ida_range.rangeset_t.is_subset_of(self, aset: "rangeset_t") -> bool
    Is every element in the rangeset contained in an element of 'aset'?

ida_range.rangeset_t.lastrange(self) -> "range_t const &"
    Get the last range_t in the set.

ida_range.rangeset_t.next_addr(self, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get the smallest ea_t value greater than 'ea' contained in the rangeset.

ida_range.rangeset_t.next_range(self, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get the smallest ea_t value greater than 'ea' that is not in the same range as 'ea'.

ida_range.rangeset_t.nranges(self) -> "size_t"
    Get the number of range_t elements in the set.

ida_range.rangeset_t.prev_addr(self, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get the largest ea_t value less than 'ea' contained in the rangeset.

ida_range.rangeset_t.prev_range(self, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get the largest ea_t value less than 'ea' that is not in the same range as 'ea'.

ida_range.rangeset_t.sub(self, *args) -> bool
    This function has the following signatures:
    
        0. sub(range: const range_t &) -> bool
        1. sub(ea: ida_idaapi.ea_t) -> bool
        2. sub(aset: const rangeset_t &) -> bool
    
    # 0: sub(range: const range_t &) -> bool
    
    Subtract an address range from the set. All subsets of 'range' will be removed, and all elements that intersect 'range' will be truncated/split so they do not include 'range'. 
            
    @returns false if 'range' was not subtracted (the set was unchanged)
    
    # 1: sub(ea: ida_idaapi.ea_t) -> bool
    
    Subtract an ea (an range of size 1) from the set. See sub(const range_t &)
    
    
    # 2: sub(aset: const rangeset_t &) -> bool
    
    Subtract each range in 'aset' from the set 
            
    @returns false if nothing was subtracted (the set was unchanged)

ida_range.rangeset_t.swap(self, r: "rangeset_t") -> None
    Set this = 'r' and 'r' = this. See qvector::swap()

ida_range.rangevec_base_t

ida_range.rangevec_base_t.__eq__(self, r: "rangevec_base_t") -> bool

ida_range.rangevec_base_t.__getitem__(self, i: "size_t") -> "range_t const &"

ida_range.rangevec_base_t.__init__(self, *args)

ida_range.rangevec_base_t.__len__(self) -> "size_t"

ida_range.rangevec_base_t.__ne__(self, r: "rangevec_base_t") -> bool

ida_range.rangevec_base_t.__setitem__(self, i: "size_t", v: "range_t") -> None

ida_range.rangevec_base_t._del(self, x: "range_t") -> bool

ida_range.rangevec_base_t.add_unique(self, x: "range_t") -> bool

ida_range.rangevec_base_t.append(self, x: "range_t") -> None

ida_range.rangevec_base_t.at(self, _idx: "size_t") -> "range_t const &"

ida_range.rangevec_base_t.begin(self, *args) -> "qvector< range_t >::const_iterator"

ida_range.rangevec_base_t.capacity(self) -> "size_t"

ida_range.rangevec_base_t.clear(self) -> None

ida_range.rangevec_base_t.empty(self) -> bool

ida_range.rangevec_base_t.end(self, *args) -> "qvector< range_t >::const_iterator"

ida_range.rangevec_base_t.erase(self, *args) -> "qvector< range_t >::iterator"

ida_range.rangevec_base_t.extend(self, x: "rangevec_base_t") -> None

ida_range.rangevec_base_t.extract(self) -> "range_t *"

ida_range.rangevec_base_t.find(self, *args) -> "qvector< range_t >::const_iterator"

ida_range.rangevec_base_t.grow(self, *args) -> None

ida_range.rangevec_base_t.has(self, x: "range_t") -> bool

ida_range.rangevec_base_t.inject(self, s: "range_t", len: "size_t") -> None

ida_range.rangevec_base_t.insert(self, it: "range_t", x: "range_t") -> "qvector< range_t >::iterator"

ida_range.rangevec_base_t.pop_back(self) -> None

ida_range.rangevec_base_t.push_back(self, *args) -> "range_t &"

ida_range.rangevec_base_t.qclear(self) -> None

ida_range.rangevec_base_t.reserve(self, cnt: "size_t") -> None

ida_range.rangevec_base_t.resize(self, *args) -> None

ida_range.rangevec_base_t.size(self) -> "size_t"

ida_range.rangevec_base_t.swap(self, r: "rangevec_base_t") -> None

ida_range.rangevec_base_t.truncate(self) -> None

ida_range.rangevec_t

ida_range.rangevec_t.__init__(self)

ida_registry
    Registry related functions.
    
    IDA uses the registry to store global configuration options that must persist after IDA has been closed.
    On Windows, IDA uses the Windows registry directly. On Unix systems, the registry is stored in a file (typically ~/.idapro/ida.reg).
    The root key for accessing IDA settings in the registry is defined by ROOT_KEY_NAME. 
        

ida_registry.ROOT_KEY_NAME
    Default key used to store IDA settings in registry (Windows version). 
            

ida_registry.reg_binary
    binary data

ida_registry.reg_data_type(name: str, subkey: str = None) -> "regval_type_t"
    Get data type of a given value. 
            
    @param name: value name
    @param subkey: key name
    @returns false if the [key+]value doesn't exist

ida_registry.reg_delete(name: str, subkey: str = None) -> bool
    Delete a value from the registry. 
            
    @param name: value name
    @param subkey: parent key
    @returns success

ida_registry.reg_delete_subkey(name: str) -> bool
    Delete a key from the registry.

ida_registry.reg_delete_tree(name: str) -> bool
    Delete a subtree from the registry.

ida_registry.reg_dword
    32-bit number

ida_registry.reg_exists(name: str, subkey: str = None) -> bool
    Is there already a value with the given name? 
            
    @param name: value name
    @param subkey: parent key

ida_registry.reg_read_binary(name: str, subkey: str = None) -> "PyObject *"
    Read binary data from the registry. 
            
    @param name: value name
    @param subkey: key name
    @returns false if 'data' is not large enough to hold all data present. in this case 'data' is left untouched.

ida_registry.reg_read_bool(name: str, defval: bool, subkey: str = None) -> bool
    Read boolean value from the registry. 
            
    @param name: value name
    @param defval: default value
    @param subkey: key name
    @returns boolean read from registry, or 'defval' if the read failed

ida_registry.reg_read_int(name: str, defval: int, subkey: str = None) -> int
    Read integer value from the registry. 
            
    @param name: value name
    @param defval: default value
    @param subkey: key name
    @returns the value read from the registry, or 'defval' if the read failed

ida_registry.reg_read_string(name: str, subkey: str = None, _def: str = None) -> "PyObject *"
    Read a string from the registry. 
            
    @param name: value name
    @param subkey: key name
    @returns success

ida_registry.reg_read_strlist(subkey: str) -> "qstrvec_t *"
    Retrieve all string values associated with the given key. Also see reg_update_strlist(), reg_write_strlist() 
            

ida_registry.reg_subkey_exists(name: str) -> bool
    Is there already a key with the given name?

ida_registry.reg_subkey_subkeys(name: str) -> "PyObject *"
    Get all subkey names of given key.

ida_registry.reg_subkey_values(name: str) -> "PyObject *"
    Get all value names under given key.

ida_registry.reg_sz
    utf8 string

ida_registry.reg_unknown
    unknown

ida_registry.reg_update_filestrlist(subkey: str, add: str, maxrecs: "size_t", rem: str = None) -> None
    Update registry with a file list. Case sensitivity will vary depending on the target OS. 
            

ida_registry.reg_update_strlist(subkey: str, add: str, maxrecs: "size_t", rem: str = None, ignorecase: bool = False) -> None
    Update list of strings associated with given key. 
            
    @param subkey: key name
    @param add: string to be added to list, can be nullptr
    @param maxrecs: limit list to this size
    @param rem: string to be removed from list, can be nullptr
    @param ignorecase: ignore case for 'add' and 'rem'

ida_registry.reg_write_binary(name: str, py_bytes: "PyObject *", subkey: str = None) -> "PyObject *"
    Write binary data to the registry. 
            
    @param name: value name
    @param subkey: key name

ida_registry.reg_write_bool(name: str, value: int, subkey: str = None) -> None
    Write boolean value to the registry. 
            
    @param name: value name
    @param value: boolean to write (nonzero = true)
    @param subkey: key name

ida_registry.reg_write_int(name: str, value: int, subkey: str = None) -> None
    Write integer value to the registry. 
            
    @param name: value name
    @param value: value to write
    @param subkey: key name

ida_registry.reg_write_string(name: str, utf8: str, subkey: str = None) -> None
    Write a string to the registry. 
            
    @param name: value name
    @param utf8: utf8-encoded string
    @param subkey: key name

ida_registry.reg_write_strlist(_in: "qstrvec_t const &", subkey: str) -> None
    Write string values associated with the given key. Also see reg_read_strlist(), reg_update_strlist() 
            

ida_registry.set_registry_name(name: str) -> bool

ida_regfinder

ida_regfinder.find_nearest_rvi(rvi: "reg_value_info_t", ea: ida_idaapi.ea_t, reg: "int const [2]") -> int
    Find the value of any of the two registers using the register tracker. First, this function tries to find the registers in the basic block of EA, and if it could not do this, then it tries to find in the entire function. 
            
    @param rvi: the found value with additional attributes
    @param ea: the address to find a value at
    @param reg: the registers to find
    @returns the index of the found register or -1

ida_regfinder.find_reg_value(ea: ida_idaapi.ea_t, reg: int) -> "uint64 *"
    Find register value using the register tracker. 
            
    @param ea: the address to find a value at
    @param reg: the register to find
    @retval 0: no value (the value is varying or the find depth is not enough to find a value)
    @retval 1: the found value is in VAL
    @retval -1: the processor module does not support a register tracker

ida_regfinder.find_reg_value_info(rvi: "reg_value_info_t", ea: ida_idaapi.ea_t, reg: int, max_depth: int = 0) -> bool
    Find register value using the register tracker. 
            
    @param rvi: the found value with additional attributes
    @param ea: the address to find a value at
    @param reg: the register to find
    @param max_depth: the number of basic blocks to look before aborting the search and returning the unknown value. 0 means the value of REGTRACK_MAX_DEPTH from ida.cfg for ordinal registers or REGTRACK_FUNC_MAX_DEPTH for the function-wide registers, -1 means the value of REGTRACK_FUNC_MAX_DEPTH from ida.cfg.
    @retval 'false': the processor module does not support a register tracker
    @retval 'true': the found value is in RVI

ida_regfinder.find_sp_value(ea: ida_idaapi.ea_t, reg: int = -1) -> "int64 *"
    Find a value of the SP based register using the register tracker. 
            
    @param ea: the address to find a value at
    @param reg: the register to find. by default the SP register is used.
    @retval 0: no value (the value is varying or the find depth is not enough to find a value)
    @retval 1: the found value is in VAL
    @retval -1: the processor module does not support a register tracker

ida_regfinder.invalidate_regfinder_cache(*args) -> None
    The control flow from FROM to TO has changed. Remove from the register tracker cache all values at TO and all dependent values. if TO == BADADDR then clear the entire cache. 
            

ida_regfinder.reg_value_def_t

ida_regfinder.reg_value_def_t.LIKE_GOT
    the value is like GOT only for numbers 
            

ida_regfinder.reg_value_def_t.NOVAL
    without a value

ida_regfinder.reg_value_def_t.PC_BASED
    the value depends on DEF_EA only for numbers 
            

ida_regfinder.reg_value_def_t.SHORT_INSN
    like 'addi reg, imm'

ida_regfinder.reg_value_def_t.SPVAL
    as a SP delta

ida_regfinder.reg_value_def_t.UVAL
    as a number

ida_regfinder.reg_value_def_t.__eq__(self, r: "reg_value_def_t") -> bool

ida_regfinder.reg_value_def_t.__init__(self, *args)

ida_regfinder.reg_value_def_t.__lt__(self, r: "reg_value_def_t") -> bool

ida_regfinder.reg_value_def_t.def_ea
    the instruction address

ida_regfinder.reg_value_def_t.def_itype
    the instruction code (processor specific)

ida_regfinder.reg_value_def_t.dstr(self, how: "reg_value_def_t::dstr_val_t", pm: "procmod_t" = None) -> str
    Return the string representation.

ida_regfinder.reg_value_def_t.flags
    additional info about the value

ida_regfinder.reg_value_def_t.is_like_got(self) -> bool

ida_regfinder.reg_value_def_t.is_pc_based(self) -> bool

ida_regfinder.reg_value_def_t.is_short_insn(self, *args) -> bool
    This function has the following signatures:
    
        0. is_short_insn() -> bool
        1. is_short_insn(insn: const insn_t &) -> bool
    
    # 0: is_short_insn() -> bool
    
    
    # 1: is_short_insn(insn: const insn_t &) -> bool

ida_regfinder.reg_value_def_t.val
    the value

ida_regfinder.reg_value_info_t

ida_regfinder.reg_value_info_t.CONTAINED
    L is contained in R (i.e. L\R is empty)

ida_regfinder.reg_value_info_t.CONTAINS
    L contains R (i.e. R\L is empty)

ida_regfinder.reg_value_info_t.EQUAL
    L==R.

ida_regfinder.reg_value_info_t.NOT_COMPARABLE
    L\R is not empty and R\L is not empty.

ida_regfinder.reg_value_info_t.__getitem__(self, i: "size_t") -> "reg_value_def_t const &"

ida_regfinder.reg_value_info_t.__init__(self)

ida_regfinder.reg_value_info_t.__len__(self) -> "size_t"

ida_regfinder.reg_value_info_t.__str__(self) -> str

ida_regfinder.reg_value_info_t.aborted(self) -> bool
    Return 'true' if the tracking process was aborted.

ida_regfinder.reg_value_info_t.add(self, r: "reg_value_info_t", insn: "insn_t const &") -> None
    Add R to the value, save INSN as a defining instruction. 
            

ida_regfinder.reg_value_info_t.add_num(self, *args) -> None
    This function has the following signatures:
    
        0. add_num(r: int, insn: const insn_t &) -> None
        1. add_num(r: int) -> None
    
    # 0: add_num(r: int, insn: const insn_t &) -> None
    
    Add R to the value, save INSN as a defining instruction. 
            
    
    # 1: add_num(r: int) -> None
    
    Add R to the value, do not change the defining instructions. 
            

ida_regfinder.reg_value_info_t.band(self, r: "reg_value_info_t", insn: "insn_t const &") -> None
    Make bitwise AND of R to the value, save INSN as a defining instruction. 
            

ida_regfinder.reg_value_info_t.bandnot(self, r: "reg_value_info_t", insn: "insn_t const &") -> None
    Make bitwise AND of the inverse of R to the value, save INSN as a defining instruction. 
            

ida_regfinder.reg_value_info_t.bnot(self, insn: "insn_t const &") -> None
    Make bitwise inverse of the value, save INSN as a defining instruction. 
            

ida_regfinder.reg_value_info_t.bor(self, r: "reg_value_info_t", insn: "insn_t const &") -> None
    Make bitwise OR of R to the value, save INSN as a defining instruction. 
            

ida_regfinder.reg_value_info_t.bxor(self, r: "reg_value_info_t", insn: "insn_t const &") -> None
    Make bitwise eXclusive OR of R to the value, save INSN as a defining instruction. 
            

ida_regfinder.reg_value_info_t.clear(self) -> None
    Undefine the value.

ida_regfinder.reg_value_info_t.empty(self) -> bool
    Return 'true' if we know nothing about a value.

ida_regfinder.reg_value_info_t.extend(self, pm: "procmod_t", width: int, is_signed: bool) -> None
    Sign-, or zero-extend the number or SP delta value to full size. The initial value is considered to be of size WIDTH. 
            

ida_regfinder.reg_value_info_t.get_def_ea(self) -> ida_idaapi.ea_t
    Return the defining address.

ida_regfinder.reg_value_info_t.get_def_itype(self) -> "uint16"
    Return the defining instruction code (processor specific).

ida_regfinder.reg_value_info_t.get_num(self) -> bool
    Return the number if the value is a constant. 
            

ida_regfinder.reg_value_info_t.get_spd(self) -> bool
    Return the SP delta if the value depends on the stack pointer. 
            

ida_regfinder.reg_value_info_t.has_any_vals_flag(self, val_flags: "uint16") -> bool

ida_regfinder.reg_value_info_t.have_all_vals_flag(self, val_flags: "uint16") -> bool
    Check the given flag for each value.

ida_regfinder.reg_value_info_t.is_all_vals_like_got(self) -> bool

ida_regfinder.reg_value_info_t.is_all_vals_pc_based(self) -> bool

ida_regfinder.reg_value_info_t.is_any_vals_like_got(self) -> bool

ida_regfinder.reg_value_info_t.is_any_vals_pc_based(self) -> bool

ida_regfinder.reg_value_info_t.is_badinsn(self) -> bool
    Return 'true' if the value is unknown because of a bad insn.

ida_regfinder.reg_value_info_t.is_dead_end(self) -> bool
    Return 'true' if the value is undefined because of a dead end.

ida_regfinder.reg_value_info_t.is_known(self) -> bool
    Return 'true' if the value is known (i.e. it is a number or SP delta).

ida_regfinder.reg_value_info_t.is_num(self) -> bool
    Return 'true' if the value is a constant.

ida_regfinder.reg_value_info_t.is_spd(self) -> bool
    Return 'true' if the value depends on the stack pointer.

ida_regfinder.reg_value_info_t.is_special(self) -> bool
    Return 'true' if the value requires special handling.

ida_regfinder.reg_value_info_t.is_unkfunc(self) -> bool
    Return 'true' if the value is unknown from the function start.

ida_regfinder.reg_value_info_t.is_unkinsn(self) -> bool
    Return 'true' if the value is unknown after executing the insn.

ida_regfinder.reg_value_info_t.is_unkloop(self) -> bool
    Return 'true' if the value is unknown because it changes in a loop.

ida_regfinder.reg_value_info_t.is_unkmult(self) -> bool
    Return 'true' if the value is unknown because the register has incompatible values (a number and SP delta). 
            

ida_regfinder.reg_value_info_t.is_unknown(self) -> bool
    Return 'true' if the value is unknown.

ida_regfinder.reg_value_info_t.is_unkvals(self) -> bool
    Return 'true' if the value is unknown because the register has too many values. 
            

ida_regfinder.reg_value_info_t.is_unkxref(self) -> bool
    Return 'true' if the value is unknown because there are too many xrefs.

ida_regfinder.reg_value_info_t.is_value_unique(self) -> bool
    Check that the value is unique.

ida_regfinder.reg_value_info_t.make_aborted(bblk_ea: ida_idaapi.ea_t) -> "reg_value_info_t"
    Return the value after aborting. 
            

ida_regfinder.reg_value_info_t.make_badinsn(insn_ea: ida_idaapi.ea_t) -> "reg_value_info_t"
    Return the unknown value after a bad insn. 
            

ida_regfinder.reg_value_info_t.make_dead_end(dead_end_ea: ida_idaapi.ea_t) -> "reg_value_info_t"
    Return the undefined value because of a dead end. 
            

ida_regfinder.reg_value_info_t.make_initial_sp(func_ea: ida_idaapi.ea_t) -> "reg_value_info_t"
    Return the value that is the initial stack pointer. 
            

ida_regfinder.reg_value_info_t.make_num(*args) -> "reg_value_info_t"
    This function has the following signatures:
    
        0. make_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> reg_value_info_t
        1. make_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> reg_value_info_t
    
    # 0: make_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> reg_value_info_t
    
    Return the value that is the RVAL number. 
            
    
    # 1: make_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> reg_value_info_t
    
    Return the value that is the RVAL number. 
            

ida_regfinder.reg_value_info_t.make_unkfunc(func_ea: ida_idaapi.ea_t) -> "reg_value_info_t"
    Return the unknown value from the function start. 
            

ida_regfinder.reg_value_info_t.make_unkinsn(insn: "insn_t const &") -> "reg_value_info_t"
    Return the unknown value after executing the insn. 
            

ida_regfinder.reg_value_info_t.make_unkloop(bblk_ea: ida_idaapi.ea_t) -> "reg_value_info_t"
    Return the unknown value if it changes in a loop. 
            

ida_regfinder.reg_value_info_t.make_unkmult(bblk_ea: ida_idaapi.ea_t) -> "reg_value_info_t"
    Return the unknown value if the register has incompatible values. 
            

ida_regfinder.reg_value_info_t.make_unkvals(bblk_ea: ida_idaapi.ea_t) -> "reg_value_info_t"
    Return the unknown value if the register has too many values. 
            

ida_regfinder.reg_value_info_t.make_unkxref(bblk_ea: ida_idaapi.ea_t) -> "reg_value_info_t"
    Return the unknown value if there are too many xrefs. 
            

ida_regfinder.reg_value_info_t.movt(self, r: "reg_value_info_t", insn: "insn_t const &") -> None
    Replace the top 16 bits with bottom 16 bits of R, leaving the bottom 16 bits untouched, save INSN as a defining instruction. 
            

ida_regfinder.reg_value_info_t.neg(self, insn: "insn_t const &") -> None
    Negate the value, save INSN as a defining instruction.

ida_regfinder.reg_value_info_t.set_aborted(self, bblk_ea: ida_idaapi.ea_t) -> None
    Set the value after aborting. 
            

ida_regfinder.reg_value_info_t.set_all_vals_flag(self, val_flags: "uint16") -> None
    Set the given flag for each value.

ida_regfinder.reg_value_info_t.set_all_vals_got_based(self) -> None

ida_regfinder.reg_value_info_t.set_all_vals_pc_based(self) -> None

ida_regfinder.reg_value_info_t.set_badinsn(self, insn_ea: ida_idaapi.ea_t) -> None
    Set the value to be unknown after a bad insn. 
            

ida_regfinder.reg_value_info_t.set_dead_end(self, dead_end_ea: ida_idaapi.ea_t) -> None
    Set the value to be undefined because of a dead end. 
            

ida_regfinder.reg_value_info_t.set_num(self, *args) -> None
    This function has the following signatures:
    
        0. set_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> None
        1. set_num(rvals: uvalvec_t *, insn: const insn_t &) -> None
        2. set_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> None
    
    # 0: set_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> None
    
    Set the value to be a number after executing an insn. 
            
    
    # 1: set_num(rvals: uvalvec_t *, insn: const insn_t &) -> None
    
    Set the value to be numbers after executing an insn. 
            
    
    # 2: set_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> None
    
    Set the value to be a number before an address. 
            

ida_regfinder.reg_value_info_t.set_unkfunc(self, func_ea: ida_idaapi.ea_t) -> None
    Set the value to be unknown from the function start. 
            

ida_regfinder.reg_value_info_t.set_unkinsn(self, insn: "insn_t const &") -> None
    Set the value to be unknown after executing the insn. 
            

ida_regfinder.reg_value_info_t.set_unkloop(self, bblk_ea: ida_idaapi.ea_t) -> None
    Set the value to be unknown because it changes in a loop. 
            

ida_regfinder.reg_value_info_t.set_unkmult(self, bblk_ea: ida_idaapi.ea_t) -> None
    Set the value to be unknown because the register has incompatible values. 
            

ida_regfinder.reg_value_info_t.set_unkvals(self, bblk_ea: ida_idaapi.ea_t) -> None
    Set the value to be unknown because the register has too many values. 
            

ida_regfinder.reg_value_info_t.set_unkxref(self, bblk_ea: ida_idaapi.ea_t) -> None
    Set the value to be unknown because there are too many xrefs. 
            

ida_regfinder.reg_value_info_t.shift_left(self, r: int) -> None
    Shift the value left by R, do not change the defining instructions. 
            

ida_regfinder.reg_value_info_t.shift_right(self, r: int) -> None
    Shift the value right by R, do not change the defining instructions. 
            

ida_regfinder.reg_value_info_t.sll(self, r: "reg_value_info_t", insn: "insn_t const &") -> None
    Shift the value left by R, save INSN as a defining instruction. 
            

ida_regfinder.reg_value_info_t.slr(self, r: "reg_value_info_t", insn: "insn_t const &") -> None
    Shift the value right by R, save INSN as a defining instruction. 
            

ida_regfinder.reg_value_info_t.sub(self, r: "reg_value_info_t", insn: "insn_t const &") -> None
    Subtract R from the value, save INSN as a defining instruction. 
            

ida_regfinder.reg_value_info_t.swap(self, r: "reg_value_info_t") -> None

ida_regfinder.reg_value_info_t.trunc_uval(self, pm: "procmod_t") -> None
    Truncate the number to the application bitness. 
            

ida_regfinder.reg_value_info_t.vals_union(self, r: "reg_value_info_t") -> "reg_value_info_t::set_compare_res_t"
    Add values from R into THIS ignoring duplicates. 
            
    @retval EQUAL: THIS is not changed
    @retval CONTAINS: THIS is not changed
    @retval CONTAINED: THIS is a copy of R
    @retval NOT_COMPARABLE: values from R are added to THIS

ida_search
    Middle-level search functions.
    
    They all are controlled by Search flags 
        

ida_search.SEARCH_BRK
    return BADADDR if the search was cancelled.

ida_search.SEARCH_CASE
    case-sensitive search (case-insensitive otherwise)

ida_search.SEARCH_DEF
    find_reg_access: search for a definition (write access)

ida_search.SEARCH_DOWN
    search towards higher addresses

ida_search.SEARCH_IDENT
    search for an identifier (text search). it means that the characters before and after the match cannot be is_visible_char(). 
            

ida_search.SEARCH_NEXT
    skip the starting address when searching. this bit is useful only for search(), bin_search(), find_reg_access(). find_.. functions skip the starting address automatically. 
            

ida_search.SEARCH_NOBRK
    do not test if the user clicked cancel to interrupt the search

ida_search.SEARCH_NOSHOW
    do not display the search progress/refresh screen

ida_search.SEARCH_REGEX
    regular expressions in search string (supported only for the text search)

ida_search.SEARCH_UP
    search towards lower addresses

ida_search.SEARCH_USE
    find_reg_access: search for a use (read access)

ida_search.SEARCH_USESEL
    query the UI for a possible current selection to limit the search to 
            

ida_search.find_code(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t

ida_search.find_data(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t

ida_search.find_defined(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t

ida_search.find_error(ea: ida_idaapi.ea_t, sflag: int) -> "int *"

ida_search.find_imm(ea: ida_idaapi.ea_t, sflag: int, search_value: int) -> "int *"

ida_search.find_not_func(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t

ida_search.find_notype(ea: ida_idaapi.ea_t, sflag: int) -> "int *"

ida_search.find_reg_access(out: "reg_access_t", start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, regname: str, sflag: int) -> ida_idaapi.ea_t

ida_search.find_suspop(ea: ida_idaapi.ea_t, sflag: int) -> "int *"

ida_search.find_text(start_ea: ida_idaapi.ea_t, y: int, x: int, ustr: str, sflag: int) -> ida_idaapi.ea_t

ida_search.find_unknown(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t

ida_search.search_down(sflag: int) -> bool
    Is the SEARCH_DOWN bit set?

ida_segment
    Functions that deal with segments.
    
    IDA requires that all program addresses belong to segments (each address must belong to exactly one segment). The situation when an address doesn't belong to any segment is allowed as a temporary situation only when the user changes program segmentation. Bytes outside a segment can't be converted to instructions, have names, comments, etc. Each segment has its start address, ending address and represents a contiguous range of addresses. There might be unused holes between segments.
    Each segment has its unique segment selector. This selector is used to distinguish the segment from other segments. For 16-bit programs the selector is equal to the segment base paragraph. For 32-bit programs there is special array to translate the selectors to the segment base paragraphs. A selector is a 32/64 bit value.
    The segment base paragraph determines the offsets in the segment. If the start address of the segment == (base << 4) then the first offset in the segment will be 0. The start address should be higher or equal to (base << 4). We will call the offsets in the segment 'virtual addresses'. So, the virtual address of the first byte of the segment is
    (start address of segment - segment base linear address)
    For IBM PC, the virtual address corresponds to the offset part of the address. For other processors (Z80, for example), virtual addresses correspond to Z80 addresses and linear addresses are used only internally. For MS Windows programs the segment base paragraph is 0 and therefore the segment virtual addresses are equal to linear addresses. 
        

ida_segment.ADDSEG_FILLGAP
    fill gap between new segment and previous one. i.e. if such a gap exists, and this gap is less than 64K, then fill the gap by extending the previous segment and adding .align directive to it. This way we avoid gaps between segments. too many gaps lead to a virtual array failure. it cannot hold more than ~1000 gaps. 
            

ida_segment.ADDSEG_IDBENC
    'name' and 'sclass' are given in the IDB encoding; non-ASCII bytes will be decoded accordingly 
            

ida_segment.ADDSEG_NOAA
    do not mark new segment for auto-analysis

ida_segment.ADDSEG_NOSREG
    set all default segment register values to BADSEL (undefine all default segment registers) 
            

ida_segment.ADDSEG_NOTRUNC
    don't truncate the new segment at the beginning of the next segment if they overlap. destroy/truncate old segments instead. 
            

ida_segment.ADDSEG_OR_DIE
    qexit() if can't add a segment

ida_segment.ADDSEG_QUIET
    silent mode, no "Adding segment..." in the messages window

ida_segment.ADDSEG_SPARSE
    use sparse storage method for the new ranges of the created segment. please note that the ranges that were already enabled before creating the segment will not change their storage type. 
            

ida_segment.CSS_BREAK
    memory reading process stopped by user

ida_segment.CSS_NODBG
    debugger is not running

ida_segment.CSS_NOMEM
    not enough memory (might be because the segment is too big) 
            

ida_segment.CSS_NORANGE
    could not find corresponding memory range

ida_segment.CSS_OK
    ok

ida_segment.MAX_GROUPS
    max number of segment groups

ida_segment.MAX_SEGM_TRANSLATIONS
    max number of segment translations

ida_segment.MOVE_SEGM_CHUNK
    Too many chunks are defined, can't move.

ida_segment.MOVE_SEGM_DEBUG
    Debugger segments cannot be moved.

ida_segment.MOVE_SEGM_IDP
    IDP module forbids moving the segment.

ida_segment.MOVE_SEGM_INVAL
    Invalid argument (delta/target does not fit the address space)

ida_segment.MOVE_SEGM_LOADER
    The segment has been moved but the loader complained.

ida_segment.MOVE_SEGM_MAPPING
    Memory mapping ranges of addresses hinder segment movement.

ida_segment.MOVE_SEGM_ODD
    Cannot move segments by an odd number of bytes.

ida_segment.MOVE_SEGM_OK
    all ok

ida_segment.MOVE_SEGM_ORPHAN
    Orphan bytes hinder segment movement.

ida_segment.MOVE_SEGM_PARAM
    The specified segment does not exist.

ida_segment.MOVE_SEGM_ROOM
    Not enough free room at the target address.

ida_segment.MOVE_SEGM_SOURCEFILES
    Source files ranges of addresses hinder segment movement.

ida_segment.MSF_FIXONCE
    call loader only once with the special calling method. valid for rebase_program(). see loader_t::move_segm. 
            

ida_segment.MSF_LDKEEP
    keep the loader in the memory (optimization)

ida_segment.MSF_NETNODES
    move netnodes instead of changing inf.netdelta (this is slower); valid for rebase_program() 
            

ida_segment.MSF_NOFIX
    don't call the loader to fix relocations

ida_segment.MSF_PRIORITY
    loader segments will overwrite any existing debugger segments when moved. valid for move_segm() 
            

ida_segment.MSF_SILENT
    don't display a "please wait" box on the screen

ida_segment.SEGMOD_KEEP
    keep information (code & data, etc)

ida_segment.SEGMOD_KEEP0
    flag for internal use, don't set

ida_segment.SEGMOD_KEEPSEL
    do not try to delete unused selector

ida_segment.SEGMOD_KILL
    disable addresses if segment gets shrinked or deleted

ida_segment.SEGMOD_NOMOVE
    don't move info from the start of segment to the new start address (for set_segm_start()) 
            

ida_segment.SEGMOD_SILENT
    be silent

ida_segment.SEGMOD_SPARSE
    use sparse storage if extending the segment (for set_segm_start(), set_segm_end()) 
            

ida_segment.SEGPERM_EXEC
    Execute.

ida_segment.SEGPERM_MAXVAL
    Execute + Write + Read.

ida_segment.SEGPERM_READ
    Read.

ida_segment.SEGPERM_WRITE
    Write.

ida_segment.SEG_ABSSYM
    * segment with definitions of absolute symbols

ida_segment.SEG_BSS
    uninitialized segment

ida_segment.SEG_CODE
    code segment

ida_segment.SEG_COMM
    * segment with communal definitions

ida_segment.SEG_DATA
    data segment

ida_segment.SEG_GRP
    * group of segments

ida_segment.SEG_IMEM
    internal processor memory & sfr (8051)

ida_segment.SEG_IMP
    java: implementation segment

ida_segment.SEG_MAX_BITNESS_CODE
    Maximum segment bitness value.

ida_segment.SEG_MAX_SEGTYPE_CODE
    maximum value segment type can take

ida_segment.SEG_NORM
    unknown type, no assumptions

ida_segment.SEG_NULL
    zero-length segment

ida_segment.SEG_UNDF
    undefined segment type (not used)

ida_segment.SEG_XTRN
    * segment with 'extern' definitions. no instructions are allowed 
            

ida_segment.SFL_COMORG
    IDP dependent field (IBM PC: if set, ORG directive is not commented out) 
            

ida_segment.SFL_DEBUG
    Is the segment created for the debugger?. Such segments are temporary and do not have permanent flags. 
            

ida_segment.SFL_HEADER
    Header segment (do not create offsets to it in the disassembly) 
            

ida_segment.SFL_HIDDEN
    Is the segment hidden? 
            

ida_segment.SFL_HIDETYPE
    Hide segment type (do not print it in the listing) 
            

ida_segment.SFL_LOADER
    Is the segment created by the loader? 
            

ida_segment.SFL_OBOK
    Orgbase is present? (IDP dependent field) 
            

ida_segment.SNAP_ALL_SEG
    Take a snapshot of all segments.

ida_segment.SNAP_CUR_SEG
    Take a snapshot of current segment.

ida_segment.SNAP_LOAD_SEG
    Take a snapshot of loader segments.

ida_segment.SREG_NUM
    Maximum number of segment registers is 16 (see segregs.hpp)

ida_segment.add_segm(para: ida_idaapi.ea_t, start: ida_idaapi.ea_t, end: ida_idaapi.ea_t, name: str, sclass: str, flags: int = 0) -> bool
    Add a new segment, second form. Segment alignment is set to saRelByte. Segment combination is "public" or "stack" (if segment class is "STACK"). Addressing mode of segment is taken as default (16bit or 32bit). Default segment registers are set to BADSEL. If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. 
            
    @param para: segment base paragraph. if paragraph can't fit in 16bit, then a new selector is allocated and mapped to the paragraph.
    @param start: start address of the segment. if start==BADADDR then start <- to_ea(para,0).
    @param end: end address of the segment. end address should be higher than start address. For emulate empty segments, use SEG_NULL segment type. If the end address is lower than start address, then fail. If end==BADADDR, then a segment up to the next segment will be created (if the next segment doesn't exist, then 1 byte segment will be created). If 'end' is too high and the new segment would overlap the next segment, 'end' is adjusted properly.
    @param name: name of new segment. may be nullptr
    @param sclass: class of the segment. may be nullptr. type of the new segment is modified if class is one of predefined names:
    * "CODE" -> SEG_CODE
    * "DATA" -> SEG_DATA
    * "CONST" -> SEG_DATA
    * "STACK" -> SEG_BSS
    * "BSS" -> SEG_BSS
    * "XTRN" -> SEG_XTRN
    * "COMM" -> SEG_COMM
    * "ABS" -> SEG_ABSSYM
    @param flags: Add segment flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

ida_segment.add_segm_ex(NONNULL_s: "segment_t", name: str, sclass: str, flags: int) -> bool
    Add a new segment. If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. 
            
    @param name: name of new segment. may be nullptr. if specified, the segment is immediately renamed
    @param sclass: class of the segment. may be nullptr. if specified, the segment class is immediately changed
    @param flags: Add segment flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

ida_segment.add_segment_translation(segstart: ida_idaapi.ea_t, mappedseg: ida_idaapi.ea_t) -> bool
    Add segment translation. 
            
    @param segstart: start address of the segment to add translation to
    @param mappedseg: start address of the overlayed segment
    @retval 1: ok
    @retval 0: too many translations or bad segstart

ida_segment.allocate_selector(segbase: ida_idaapi.ea_t) -> "sel_t"
    Allocate a selector for a segment unconditionally. You must call this function before calling add_segm_ex(). add_segm() calls this function itself, so you don't need to allocate a selector. This function will allocate a new free selector and setup its mapping using find_free_selector() and set_selector() functions. 
            
    @param segbase: a new segment base paragraph
    @returns the allocated selector number

ida_segment.change_segment_status(s: "segment_t", is_deb_segm: bool) -> int
    Convert a debugger segment to a regular segment and vice versa. When converting debug->regular, the memory contents will be copied to the database. 
            
    @param s: segment to modify
    @param is_deb_segm: new status of the segment
    @returns Change segment status result codes

ida_segment.del_segm(ea: ida_idaapi.ea_t, flags: int) -> bool
    Delete a segment. 
            
    @param ea: any address belonging to the segment
    @param flags: Segment modification flags
    @retval 1: ok
    @retval 0: failed, no segment at 'ea'.

ida_segment.del_segment_translations(segstart: ida_idaapi.ea_t) -> None
    Delete the translation list 
            
    @param segstart: start address of the segment to delete translation list

ida_segment.del_selector(selector: "sel_t") -> None
    Delete mapping of a selector. Be wary of deleting selectors that are being used in the program, this can make a mess in the segments. 
            
    @param selector: number of selector to remove from the translation table

ida_segment.find_free_selector() -> "sel_t"
    Find first unused selector. 
            
    @returns a number >= 1

ida_segment.find_selector(base: ida_idaapi.ea_t) -> "sel_t"
    Find a selector that has mapping to the specified paragraph. 
            
    @param base: paragraph to search in the translation table
    @returns selector value or base

ida_segment.get_defsr(s, reg)
    Deprecated, use instead:
    value = s.defsr[reg]

ida_segment.get_first_seg() -> "segment_t *"
    Get pointer to the first segment.

ida_segment.get_group_selector(grpsel: "sel_t") -> "sel_t"
    Get common selector for a group of segments. 
            
    @param grpsel: selector of group segment
    @returns common selector of the group or 'grpsel' if no such group is found

ida_segment.get_last_seg() -> "segment_t *"
    Get pointer to the last segment.

ida_segment.get_next_seg(ea: ida_idaapi.ea_t) -> "segment_t *"
    Get pointer to the next segment.

ida_segment.get_prev_seg(ea: ida_idaapi.ea_t) -> "segment_t *"
    Get pointer to the previous segment.

ida_segment.get_segm_base(s: "segment_t") -> ida_idaapi.ea_t
    Get segment base linear address. Segment base linear address is used to calculate virtual addresses. The virtual address of the first byte of the segment will be (start address of segment - segment base linear address) 
            
    @param s: pointer to segment
    @returns 0 if s == nullptr, otherwise segment base linear address

ida_segment.get_segm_by_name(name: str) -> "segment_t *"
    Get pointer to segment by its name. If there are several segments with the same name, returns the first of them. 
            
    @param name: segment name. may be nullptr.
    @returns nullptr or pointer to segment structure

ida_segment.get_segm_by_sel(selector: "sel_t") -> "segment_t *"
    Get pointer to segment structure. This function finds a segment by its selector. If there are several segments with the same selectors, the last one will be returned. 
            
    @param selector: a segment with the specified selector will be returned
    @returns pointer to segment or nullptr

ida_segment.get_segm_class(s: "segment_t") -> str
    Get segment class. Segment class is arbitrary text (max 8 characters). 
            
    @param s: pointer to segment
    @returns size of segment class (-1 if s==nullptr or bufsize<=0)

ida_segment.get_segm_name(s: "segment_t", flags: int = 0) -> str
    Get true segment name by pointer to segment. 
            
    @param s: pointer to segment
    @param flags: 0-return name as is; 1-substitute bad symbols with _ 1 corresponds to GN_VISIBLE
    @returns size of segment name (-1 if s==nullptr)

ida_segment.get_segm_num(ea: ida_idaapi.ea_t) -> int
    Get number of segment by address. 
            
    @param ea: linear address belonging to the segment
    @returns -1 if no segment occupies the specified address. otherwise returns number of the specified segment (0..get_segm_qty()-1)

ida_segment.get_segm_para(s: "segment_t") -> ida_idaapi.ea_t
    Get segment base paragraph. Segment base paragraph may be converted to segment base linear address using to_ea() function. In fact, to_ea(get_segm_para(s), 0) == get_segm_base(s). 
            
    @param s: pointer to segment
    @returns 0 if s == nullptr, the segment base paragraph

ida_segment.get_segm_qty() -> int
    Get number of segments.

ida_segment.get_segment_alignment(align: "uchar") -> str
    Get text representation of segment alignment code. 
            
    @returns text digestable by IBM PC assembler.

ida_segment.get_segment_cmt(s: "segment_t", repeatable: bool) -> str
    Get segment comment. 
            
    @param s: pointer to segment structure
    @param repeatable: 0: get regular comment. 1: get repeatable comment.
    @returns size of comment or -1

ida_segment.get_segment_combination(comb: "uchar") -> str
    Get text representation of segment combination code. 
            
    @returns text digestable by IBM PC assembler.

ida_segment.get_segment_translations(transmap: "eavec_t *", segstart: ida_idaapi.ea_t) -> "ssize_t"
    Get segment translation list. 
            
    @param transmap: vector of segment start addresses for the translation list
    @param segstart: start address of the segment to get information about
    @returns -1 if no translation list or bad segstart. otherwise returns size of translation list.

ida_segment.get_selector_qty() -> "size_t"
    Get number of defined selectors.

ida_segment.get_visible_segm_name(s: "segment_t") -> str
    Get segment name by pointer to segment. 
            
    @param s: pointer to segment
    @returns size of segment name (-1 if s==nullptr)

ida_segment.getn_selector(n: int) -> "sel_t *, ea_t *"
    Get description of selector (0..get_selector_qty()-1)

ida_segment.getnseg(n: int) -> "segment_t *"
    Get pointer to segment by its number. 
            
    @param n: segment number in the range (0..get_segm_qty()-1)
    @returns nullptr or pointer to segment structure

ida_segment.getseg(ea: ida_idaapi.ea_t) -> "segment_t *"
    Get pointer to segment by linear address. 
            
    @param ea: linear address belonging to the segment
    @returns nullptr or pointer to segment structure

ida_segment.is_finally_visible_segm(s: "segment_t") -> bool
    See SFL_HIDDEN, SCF_SHHID_SEGM.

ida_segment.is_miniidb() -> bool
    Is the database a miniidb created by the debugger?. 
            
    @returns true if the database contains no segments or only debugger segments

ida_segment.is_segm_locked(segm: "segment_t") -> bool
    Is a segment pointer locked?

ida_segment.is_spec_ea(ea: ida_idaapi.ea_t) -> bool
    Does the address belong to a segment with a special type?. (SEG_XTRN, SEG_GRP, SEG_ABSSYM, SEG_COMM) 
            
    @param ea: linear address

ida_segment.is_spec_segm(seg_type: "uchar") -> bool
    Has segment a special type?. (SEG_XTRN, SEG_GRP, SEG_ABSSYM, SEG_COMM) 
            

ida_segment.is_visible_segm(s: "segment_t") -> bool
    See SFL_HIDDEN.

ida_segment.lock_segm(segm: "segment_t", lock: bool) -> None
    Lock segment pointer Locked pointers are guaranteed to remain valid until they are unlocked. Ranges with locked pointers cannot be deleted or moved. 
            

ida_segment.lock_segment

ida_segment.lock_segment.__init__(self, _segm: "segment_t")

ida_segment.move_segm(s: "segment_t", to: ida_idaapi.ea_t, flags: int = 0) -> "move_segm_code_t"
    This function moves all information to the new address. It fixes up address sensitive information in the kernel. The total effect is equal to reloading the segment to the target address. For the file format dependent address sensitive information, loader_t::move_segm is called. Also IDB notification event idb_event::segm_moved is called. 
            
    @param s: segment to move
    @param to: new segment start address
    @param flags: Move segment flags
    @returns Move segment result codes

ida_segment.move_segm_start(ea: ida_idaapi.ea_t, newstart: ida_idaapi.ea_t, mode: int) -> bool
    Move segment start. The main difference between this function and set_segm_start() is that this function may expand the previous segment while set_segm_start() never does it. So, this function allows to change bounds of two segments simultaneously. If the previous segment and the specified segment have the same addressing mode and segment base, then instructions and data are not destroyed - they simply move from one segment to another. Otherwise all instructions/data which migrate from one segment to another are destroyed. 
            
    @param ea: any address belonging to the segment
    @param newstart: new start address of the segment note that segment start address should be higher than segment base linear address.
    @param mode: policy for destroying defined items
    * 0: if it is necessary to destroy defined items, display a dialog box and ask confirmation
    * 1: if it is necessary to destroy defined items, just destroy them without asking the user
    * -1: if it is necessary to destroy defined items, don't destroy them (i.e. function will fail)
    * -2: don't destroy defined items (function will succeed)
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

ida_segment.move_segm_strerror(code: "move_segm_code_t") -> str
    Return string describing error MOVE_SEGM_... code.

ida_segment.rebase_program(delta: "PyObject *", flags: int) -> int
    Rebase the whole program by 'delta' bytes. 
            
    @param delta: number of bytes to move the program
    @param flags: Move segment flags it is recommended to use MSF_FIXONCE so that the loader takes care of global variables it stored in the database
    @returns Move segment result codes

ida_segment.saAbs
    Absolute segment.

ida_segment.saGroup
    Segment group.

ida_segment.saRel1024Bytes
    1024 bytes

ida_segment.saRel128Bytes
    128 bytes

ida_segment.saRel2048Bytes
    2048 bytes

ida_segment.saRel32Bytes
    32 bytes

ida_segment.saRel4K
    This value is used by the PharLap OMF for page (4K) alignment. It is not supported by LINK. 
            

ida_segment.saRel512Bytes
    512 bytes

ida_segment.saRel64Bytes
    64 bytes

ida_segment.saRelByte
    Relocatable, byte aligned.

ida_segment.saRelDble
    Relocatable, aligned on a double word (4-byte) boundary. 
            

ida_segment.saRelPage
    Relocatable, aligned on 256-byte boundary.

ida_segment.saRelPara
    Relocatable, paragraph (16-byte) aligned.

ida_segment.saRelQword
    8 bytes

ida_segment.saRelWord
    Relocatable, word (2-byte) aligned.

ida_segment.scCommon
    Common. Combine by overlay using maximum size.

ida_segment.scGroup
    Segment group.

ida_segment.scPriv
    Private. Do not combine with any other program segment. 
            

ida_segment.scPub
    Public. Combine by appending at an offset that meets the alignment requirement. 
            

ida_segment.scPub2
    As defined by Microsoft, same as C=2 (public).

ida_segment.scPub3
    As defined by Microsoft, same as C=2 (public).

ida_segment.scStack
    Stack. Combine as for C=2. This combine type forces byte alignment. 
            

ida_segment.segm_adjust_diff(s: "segment_t", delta: "adiff_t") -> "adiff_t"
    Truncate and sign extend a delta depending on the segment.

ida_segment.segm_adjust_ea(s: "segment_t", ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Truncate an address depending on the segment.

ida_segment.segment_defsr_array

ida_segment.segment_defsr_array.__getitem__(self, i: "size_t") -> "unsigned long long const &"

ida_segment.segment_defsr_array.__init__(self, data: "unsigned long long (&)[SREG_NUM]")

ida_segment.segment_defsr_array.__len__(self) -> "size_t"

ida_segment.segment_defsr_array.__setitem__(self, i: "size_t", v: "unsigned long long const &") -> None

ida_segment.segment_defsr_array._get_bytes(self) -> "bytevec_t"

ida_segment.segment_defsr_array._set_bytes(self, bts: "bytevec_t const &") -> None

ida_segment.segment_t

ida_segment.segment_t.__getDefsr(self) -> "wrapped_array_t< sel_t,SREG_NUM >"

ida_segment.segment_t.__init__(self)

ida_segment.segment_t.abits(self) -> int
    Get number of address bits.

ida_segment.segment_t.abytes(self) -> int
    Get number of address bytes.

ida_segment.segment_t.align
    Segment alignment codes 
            

ida_segment.segment_t.bitness
    Number of bits in the segment addressing
    * 0: 16 bits
    * 1: 32 bits
    * 2: 64 bits 
    
    
            

ida_segment.segment_t.clr_comorg(self) -> None

ida_segment.segment_t.clr_ob_ok(self) -> None

ida_segment.segment_t.color
    the segment color

ida_segment.segment_t.comb
    Segment combination codes 
            

ida_segment.segment_t.comorg(self) -> bool

ida_segment.segment_t.defsr
    default segment register values. first element of this array keeps information about value of processor_t::reg_first_sreg 
            

ida_segment.segment_t.defsr
    default segment register values. first element of this array keeps information about value of processor_t::reg_first_sreg 
            

ida_segment.segment_t.flags
    Segment flags

ida_segment.segment_t.is_16bit(self) -> bool
    Is a 16-bit segment?

ida_segment.segment_t.is_32bit(self) -> bool
    Is a 32-bit segment?

ida_segment.segment_t.is_64bit(self) -> bool
    Is a 64-bit segment?

ida_segment.segment_t.is_header_segm(self) -> bool

ida_segment.segment_t.is_hidden_segtype(self) -> bool

ida_segment.segment_t.is_loader_segm(self) -> bool

ida_segment.segment_t.is_visible_segm(self) -> bool

ida_segment.segment_t.name
    use get/set_segm_name() functions

ida_segment.segment_t.ob_ok(self) -> bool

ida_segment.segment_t.orgbase
    this field is IDP dependent. you may keep your information about the segment here 
            

ida_segment.segment_t.perm
    Segment permissions (0 means no information) 
            

ida_segment.segment_t.sclass
    use get/set_segm_class() functions

ida_segment.segment_t.sel
    segment selector - should be unique. You can't change this field after creating the segment. Exception: 16bit OMF files may have several segments with the same selector, but this is not good (no way to denote a segment exactly) so it should be fixed in the future. 
            

ida_segment.segment_t.set_comorg(self) -> None

ida_segment.segment_t.set_debugger_segm(self, debseg: bool) -> None

ida_segment.segment_t.set_header_segm(self, on: bool) -> None

ida_segment.segment_t.set_hidden_segtype(self, hide: bool) -> None

ida_segment.segment_t.set_loader_segm(self, ldrseg: bool) -> None

ida_segment.segment_t.set_ob_ok(self) -> None

ida_segment.segment_t.set_visible_segm(self, visible: bool) -> None

ida_segment.segment_t.type
    segment type (see Segment types). The kernel treats different segment types differently. Segments marked with '*' contain no instructions or data and are not declared as 'segments' in the disassembly. 
            

ida_segment.segment_t.update(self) -> bool
    Update segment information. You must call this function after modification of segment characteristics. Note that not all fields of segment structure may be modified directly, there are special functions to modify some fields. 
            
    @returns success

ida_segment.segtype(ea: ida_idaapi.ea_t) -> "uchar"
    Get segment type. 
            
    @param ea: any linear address within the segment
    @returns Segment types, SEG_UNDF if no segment found at 'ea'

ida_segment.sel2ea(selector: "sel_t") -> ida_idaapi.ea_t
    Get mapping of a selector as a linear address. 
            
    @param selector: number of selector to translate to linear address
    @returns linear address the specified selector is mapped to. if there is no mapping, returns to_ea(selector,0);

ida_segment.sel2para(selector: "sel_t") -> ida_idaapi.ea_t
    Get mapping of a selector. 
            
    @param selector: number of selector to translate
    @returns paragraph the specified selector is mapped to. if there is no mapping, returns 'selector'.

ida_segment.set_defsr(s, reg, value)
    Deprecated, use instead:
    s.defsr[reg] = value

ida_segment.set_group_selector(grp: "sel_t", sel: "sel_t") -> int
    Create a new group of segments (used OMF files). 
            
    @param grp: selector of group segment (segment type is SEG_GRP) You should create an 'empty' (1 byte) group segment It won't contain anything and will be used to redirect references to the group of segments to the common selector.
    @param sel: common selector of all segments belonging to the segment You should create all segments within the group with the same selector value.
    @retval 1: ok
    @retval 0: too many groups (see MAX_GROUPS)

ida_segment.set_segm_addressing(s: "segment_t", bitness: "size_t") -> bool
    Change segment addressing mode (16, 32, 64 bits). You must use this function to change segment addressing, never change the 'bitness' field directly. This function will delete all instructions, comments and names in the segment 
            
    @param s: pointer to segment
    @param bitness: new addressing mode of segment
    * 2: 64bit segment
    * 1: 32bit segment
    * 0: 16bit segment
    @returns success

ida_segment.set_segm_base(s: "segment_t", newbase: ida_idaapi.ea_t) -> bool
    Internal function.

ida_segment.set_segm_class(s: "segment_t", sclass: str, flags: int = 0) -> int
    Set segment class. 
            
    @param s: pointer to segment (may be nullptr)
    @param sclass: segment class (may be nullptr). If segment type is SEG_NORM and segment class is one of predefined names, then segment type is changed to:
    * "CODE" -> SEG_CODE
    * "DATA" -> SEG_DATA
    * "STACK" -> SEG_BSS
    * "BSS" -> SEG_BSS
    * if "UNK" then segment type is reset to SEG_NORM.
    @param flags: Add segment flags
    @retval 1: ok, name is good and segment is renamed
    @retval 0: failure, name is nullptr or bad or segment is nullptr

ida_segment.set_segm_end(ea: ida_idaapi.ea_t, newend: ida_idaapi.ea_t, flags: int) -> bool
    Set segment end address. The next segment is shrinked to allow expansion of the specified segment. The kernel might even delete the next segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. 
            
    @param ea: any address belonging to the segment
    @param newend: new end address of the segment
    @param flags: Segment modification flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

ida_segment.set_segm_name(s: "segment_t", name: str, flags: int = 0) -> int
    Rename segment. The new name is validated (see validate_name). A segment always has a name. If you hadn't specified a name, the kernel will assign it "seg###" name where ### is segment number. 
            
    @param s: pointer to segment (may be nullptr)
    @param name: new segment name
    @param flags: ADDSEG_IDBENC or 0
    @retval 1: ok, name is good and segment is renamed
    @retval 0: failure, name is bad or segment is nullptr

ida_segment.set_segm_start(ea: ida_idaapi.ea_t, newstart: ida_idaapi.ea_t, flags: int) -> bool
    Set segment start address. The previous segment is trimmed to allow expansion of the specified segment. The kernel might even delete the previous segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. 
            
    @param ea: any address belonging to the segment
    @param newstart: new start address of the segment note that segment start address should be higher than segment base linear address.
    @param flags: Segment modification flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

ida_segment.set_segment_cmt(s: "segment_t", cmt: str, repeatable: bool) -> None
    Set segment comment. 
            
    @param s: pointer to segment structure
    @param cmt: comment string, may be multiline (with '
    '). maximal size is 4096 bytes. Use empty str ("") to delete comment
    @param repeatable: 0: set regular comment. 1: set repeatable comment.

ida_segment.set_segment_translations(segstart: ida_idaapi.ea_t, transmap: "eavec_t const &") -> bool
    Set new translation list. 
            
    @param segstart: start address of the segment to add translation to
    @param transmap: vector of segment start addresses for the translation list. If transmap is empty, the translation list is deleted.
    @retval 1: ok
    @retval 0: too many translations or bad segstart

ida_segment.set_selector(selector: "sel_t", paragraph: ida_idaapi.ea_t) -> int
    Set mapping of selector to a paragraph. You should call this function _before_ creating a segment which uses the selector, otherwise the creation of the segment will fail. 
            
    @param selector: number of selector to map
    * if selector == BADSEL, then return 0 (fail)
    * if the selector has had a mapping, old mapping is destroyed
    * if the selector number is equal to paragraph value, then the mapping is destroyed because we don't need to keep trivial mappings.
    @param paragraph: paragraph to map selector
    @retval 1: ok
    @retval 0: failure (bad selector or too many mappings)

ida_segment.set_visible_segm(s: "segment_t", visible: bool) -> None
    See SFL_HIDDEN.

ida_segment.setup_selector(segbase: ida_idaapi.ea_t) -> "sel_t"
    Allocate a selector for a segment if necessary. You must call this function before calling add_segm_ex(). add_segm() calls this function itself, so you don't need to allocate a selector. This function will allocate a selector if 'segbase' requires more than 16 bits and the current processor is IBM PC. Otherwise it will return the segbase value. 
            
    @param segbase: a new segment base paragraph
    @returns the allocated selector number

ida_segment.std_out_segm_footer(ctx: "outctx_t &", seg: "segment_t") -> None
    Generate segment footer line as a comment line. This function may be used in IDP modules to generate segment footer if the target assembler doesn't have 'ends' directive. 
            

ida_segment.take_memory_snapshot(type: int) -> bool
    Take a memory snapshot of the running process. 
            
    @param type: specifies which snapshot we want (see SNAP_ Snapshot types)
    @returns success

ida_segment.update_segm(s: "segment_t") -> bool

ida_segregs
    Functions that deal with the segment registers.
    
    If your processor doesn't use segment registers, then these functions are of no use for you. However, you should define two virtual segment registers - CS and DS (for code segment and data segment) and specify their internal numbers in the LPH structure (processor_t::reg_code_sreg and processor_t::reg_data_sreg). 
        

ida_segregs.SR_auto
    the value is determined by IDA

ida_segregs.SR_autostart
    used as SR_auto for segment starting address

ida_segregs.SR_inherit
    the value is inherited from the previous range

ida_segregs.SR_user
    the value is specified by the user

ida_segregs.copy_sreg_ranges(dst_rg: int, src_rg: int, map_selector: bool = False) -> None
    Duplicate segment register ranges. 
            
    @param dst_rg: number of destination segment register
    @param src_rg: copy ranges from
    @param map_selector: map selectors to linear addresses using sel2ea()

ida_segregs.del_sreg_range(ea: ida_idaapi.ea_t, rg: int) -> bool
    Delete segment register range started at ea. When a segment register range is deleted, the previous range is extended to cover the empty space. The segment register range at the beginning of a segment cannot be deleted. 
            
    @param ea: start_ea of the deleted range
    @param rg: the segment register number
    @returns success

ida_segregs.get_prev_sreg_range(out: "sreg_range_t", ea: ida_idaapi.ea_t, rg: int) -> bool
    Get segment register range previous to one with address. 
            
    @param out: segment register range
    @param ea: any linear address in the program
    @param rg: the segment register number
    @returns success

ida_segregs.get_sreg(ea: ida_idaapi.ea_t, rg: int) -> "sel_t"
    Get value of a segment register. This function uses segment register range and default segment register values stored in the segment structure. 
            
    @param ea: linear address in the program
    @param rg: number of the segment register
    @returns value of the segment register, BADSEL if value is unknown or rg is not a segment register.

ida_segregs.get_sreg_range(out: "sreg_range_t", ea: ida_idaapi.ea_t, rg: int) -> bool
    Get segment register range by linear address. 
            
    @param out: segment register range
    @param ea: any linear address in the program
    @param rg: the segment register number
    @returns success

ida_segregs.get_sreg_range_num(ea: ida_idaapi.ea_t, rg: int) -> int
    Get number of segment register range by address. 
            
    @param ea: any address in the range
    @param rg: the segment register number
    @returns -1 if no range occupies the specified address. otherwise returns number of the specified range (0..get_srranges_qty()-1)

ida_segregs.get_sreg_ranges_qty(rg: int) -> "size_t"
    Get number of segment register ranges. 
            
    @param rg: the segment register number

ida_segregs.getn_sreg_range(out: "sreg_range_t", rg: int, n: int) -> bool
    Get segment register range by its number. 
            
    @param out: segment register range
    @param rg: the segment register number
    @param n: number of range (0..qty()-1)
    @returns success

ida_segregs.set_default_dataseg(ds_sel: "sel_t") -> None
    Set default value of DS register for all segments.

ida_segregs.set_default_sreg_value(sg: "segment_t *", rg: int, value: "sel_t") -> bool
    Set default value of a segment register for a segment. 
            
    @param sg: pointer to segment structure if nullptr, then set the register for all segments
    @param rg: number of segment register
    @param value: its default value. this value will be used by get_sreg() if value of the register is unknown at the specified address.
    @returns success

ida_segregs.set_sreg_at_next_code(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, rg: int, value: "sel_t") -> None
    Set the segment register value at the next instruction. This function is designed to be called from idb_event::sgr_changed handler in order to contain the effect of changing a segment register value only until the next instruction.
    It is useful, for example, in the ARM module: the modification of the T register does not affect existing instructions later in the code. 
            
    @param ea1: address to start to search for an instruction
    @param ea2: the maximal address
    @param rg: the segment register number
    @param value: the segment register value

ida_segregs.split_sreg_range(ea: ida_idaapi.ea_t, rg: int, v: "sel_t", tag: "uchar", silent: bool = False) -> bool
    Create a new segment register range. This function is used when the IDP emulator detects that a segment register changes its value. 
            
    @param ea: linear address where the segment register will have a new value. if ea==BADADDR, nothing to do.
    @param rg: the number of the segment register
    @param v: the new value of the segment register. If the value is unknown, you should specify BADSEL.
    @param tag: the register info tag. see Segment register range tags
    @param silent: if false, display a warning() in the case of failure
    @returns success

ida_segregs.sreg_range_t

ida_segregs.sreg_range_t.__init__(self)

ida_segregs.sreg_range_t.tag
    Segment register range tags

ida_segregs.sreg_range_t.val
    segment register value

ida_srclang
    Third-party compiler support.

ida_srclang.SRCLANG_C
    C.

ida_srclang.SRCLANG_CPP
    C++.

ida_srclang.SRCLANG_GO
    Golang (not supported yet)

ida_srclang.SRCLANG_OBJC
    Objective-C.

ida_srclang.SRCLANG_SWIFT
    Swift (not supported yet)

ida_srclang.parse_decls_for_srclang(lang: "srclang_t", til: "til_t", input: str, is_path: bool) -> int
    Parse type declarations in the specified language 
            
    @param lang: the source language(s) expected in the input
    @param til: type library to store the types
    @param input: input source. can be a file path or decl string
    @param is_path: true if input parameter is a path to a source file, false if the input is an in-memory source snippet
    @retval -1: no parser was found that supports the given source language(s)
    @retval else: the number of errors encountered in the input source

ida_srclang.parse_decls_with_parser(parser_name: str, til: "til_t", input: str, is_path: bool) -> int
    Parse type declarations using the parser with the specified name 
            
    @param parser_name: name of the target parser
    @param til: type library to store the types
    @param input: input source. can be a file path or decl string
    @param is_path: true if input parameter is a path to a source file, false if the input is an in-memory source snippet
    @retval -1: no parser was found with the given name
    @retval else: the number of errors encountered in the input source

ida_srclang.select_parser_by_name(name: str) -> bool
    Set the parser with the given name as the current parser. Pass nullptr or an empty string to select the default parser. 
            
    @returns false if no parser was found with the given name

ida_srclang.select_parser_by_srclang(lang: "srclang_t") -> bool
    Set the parser that supports the given language(s) as the current parser. The selected parser must support all languages specified by the given srclang_t. 
            
    @returns false if no such parser was found

ida_srclang.set_parser_argv(parser_name: str, argv: str) -> int
    Set the command-line args to use for invocations of the parser with the given name 
            
    @param parser_name: name of the target parser
    @param argv: argument list
    @retval -1: no parser was found with the given name
    @retval -2: the operation is not supported by the given parser
    @retval 0: success

ida_strlist
    Functions that deal with the string list.
    
    While the kernel keeps the string list, it does not update it. The string list is not used by the kernel because keeping it up-to-date would slow down IDA without any benefit. If the string list is not cleared using clear_strlist(), the list will be saved to the database and restored on the next startup.
    The users of this list should call build_strlist() if they need an up-to-date version. 
        

ida_strlist.build_strlist() -> None
    Rebuild the string list.

ida_strlist.clear_strlist() -> None
    Clear the string list.

ida_strlist.get_strlist_item(si: "string_info_t", n: "size_t") -> bool
    Get nth element of the string list (n=0..get_strlist_qty()-1)

ida_strlist.get_strlist_options() -> "strwinsetup_t const *"
    Get the static string list options.

ida_strlist.get_strlist_qty() -> "size_t"
    Get number of elements in the string list. The list will be loaded from the database (if saved) or built from scratch. 
            

ida_strlist.string_info_t

ida_strlist.string_info_t.__init__(self, *args)

ida_strlist.string_info_t.__lt__(self, r: "string_info_t") -> bool

ida_strlist.strwinsetup_t

ida_strlist.strwinsetup_t.__init__(self)

ida_strlist.strwinsetup_t._get_strtypes(self) -> "PyObject *"

ida_strlist.strwinsetup_t._set_strtypes(self, py_t: "PyObject *") -> "PyObject *"

ida_tryblks
    Architecture independent exception handling info.
    
    Try blocks have the following general properties:
    * A try block specifies a possibly fragmented guarded code region.
    * Each try block has always at least one catch/except block description
    * Each catch block contains its boundaries and a filter.
    * Additionally a catch block can hold sp adjustment and the offset to the exception object offset (C++).
    * Try blocks can be nested. Nesting is automatically calculated at the retrieval time.
    * There may be (nested) multiple try blocks starting at the same address.
    
    
    See examples in tests/input/src/eh_tests. 
        

ida_tryblks.TBEA_CATCH
    is EA the start of a c++ catch/cleanup block?

ida_tryblks.TBEA_FALLTHRU
    is there a fall through into provided ea from an unwind region

ida_tryblks.TBEA_SEHFILT
    is EA the start of a seh filter?

ida_tryblks.TBEA_SEHLPAD
    is EA the start of a seh finally/except block?

ida_tryblks.TBEA_SEHTRY
    is EA within a seh try block

ida_tryblks.TBEA_TRY
    is EA within a c++ try block?

ida_tryblks.TBERR_EMPTY
    empty try block

ida_tryblks.TBERR_END
    bad end address

ida_tryblks.TBERR_INTERSECT
    range would intersect inner tryblk

ida_tryblks.TBERR_KIND
    illegal try block kind

ida_tryblks.TBERR_NO_CATCHES
    no catch blocks at all

ida_tryblks.TBERR_OK
    ok

ida_tryblks.TBERR_ORDER
    bad address order

ida_tryblks.TBERR_START
    bad start address

ida_tryblks.add_tryblk(tb: "tryblk_t") -> int
    Add one try block information. 
            
    @param tb: try block to add.
    @returns error code; 0 means good

ida_tryblks.catch_t

ida_tryblks.catch_t.__init__(self)

ida_tryblks.catchvec_t

ida_tryblks.catchvec_t.__eq__(self, r: "catchvec_t") -> bool

ida_tryblks.catchvec_t.__getitem__(self, i: "size_t") -> "catch_t const &"

ida_tryblks.catchvec_t.__init__(self, *args)

ida_tryblks.catchvec_t.__len__(self) -> "size_t"

ida_tryblks.catchvec_t.__ne__(self, r: "catchvec_t") -> bool

ida_tryblks.catchvec_t.__setitem__(self, i: "size_t", v: "catch_t") -> None

ida_tryblks.catchvec_t._del(self, x: "catch_t") -> bool

ida_tryblks.catchvec_t.add_unique(self, x: "catch_t") -> bool

ida_tryblks.catchvec_t.append(self, x: "catch_t") -> None

ida_tryblks.catchvec_t.at(self, _idx: "size_t") -> "catch_t const &"

ida_tryblks.catchvec_t.begin(self, *args) -> "qvector< catch_t >::const_iterator"

ida_tryblks.catchvec_t.capacity(self) -> "size_t"

ida_tryblks.catchvec_t.clear(self) -> None

ida_tryblks.catchvec_t.empty(self) -> bool

ida_tryblks.catchvec_t.end(self, *args) -> "qvector< catch_t >::const_iterator"

ida_tryblks.catchvec_t.erase(self, *args) -> "qvector< catch_t >::iterator"

ida_tryblks.catchvec_t.extend(self, x: "catchvec_t") -> None

ida_tryblks.catchvec_t.extract(self) -> "catch_t *"

ida_tryblks.catchvec_t.find(self, *args) -> "qvector< catch_t >::const_iterator"

ida_tryblks.catchvec_t.grow(self, *args) -> None

ida_tryblks.catchvec_t.has(self, x: "catch_t") -> bool

ida_tryblks.catchvec_t.inject(self, s: "catch_t", len: "size_t") -> None

ida_tryblks.catchvec_t.insert(self, it: "catch_t", x: "catch_t") -> "qvector< catch_t >::iterator"

ida_tryblks.catchvec_t.pop_back(self) -> None

ida_tryblks.catchvec_t.push_back(self, *args) -> "catch_t &"

ida_tryblks.catchvec_t.qclear(self) -> None

ida_tryblks.catchvec_t.reserve(self, cnt: "size_t") -> None

ida_tryblks.catchvec_t.resize(self, *args) -> None

ida_tryblks.catchvec_t.size(self) -> "size_t"

ida_tryblks.catchvec_t.swap(self, r: "catchvec_t") -> None

ida_tryblks.catchvec_t.truncate(self) -> None

ida_tryblks.del_tryblks(range: "range_t") -> None
    Delete try block information in the specified range. 
            
    @param range: the range to be cleared

ida_tryblks.find_syseh(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Find the start address of the system eh region including the argument. 
            
    @param ea: search address
    @returns start address of surrounding tryblk, otherwise BADADDR

ida_tryblks.get_tryblks(tbv: "tryblks_t", range: "range_t") -> "size_t"
    ------------------------------------------------------------------------- Retrieve try block information from the specified address range. Try blocks are sorted by starting address and their nest levels calculated. 
            
    @param tbv: output buffer; may be nullptr
    @param range: address range to change
    @returns number of found try blocks

ida_tryblks.is_ea_tryblks(ea: ida_idaapi.ea_t, flags: int) -> bool
    Check if the given address ea is part of tryblks description. 
            
    @param ea: address to check
    @param flags: combination of flags for is_ea_tryblks()

ida_tryblks.seh_t

ida_tryblks.seh_t.__init__(self)

ida_tryblks.seh_t.clear(self) -> None

ida_tryblks.try_handler_t

ida_tryblks.try_handler_t.__init__(self)

ida_tryblks.try_handler_t.clear(self) -> None

ida_tryblks.tryblk_t

ida_tryblks.tryblk_t.__init__(self, *args)

ida_tryblks.tryblk_t.clear(self) -> None

ida_tryblks.tryblk_t.cpp(self) -> "catchvec_t &"

ida_tryblks.tryblk_t.empty(self) -> bool

ida_tryblks.tryblk_t.get_kind(self) -> "uchar"

ida_tryblks.tryblk_t.is_cpp(self) -> bool

ida_tryblks.tryblk_t.is_seh(self) -> bool

ida_tryblks.tryblk_t.seh(self) -> "seh_t &"

ida_tryblks.tryblk_t.set_cpp(self) -> "catchvec_t &"

ida_tryblks.tryblk_t.set_seh(self) -> "seh_t &"

ida_tryblks.tryblks_t

ida_tryblks.tryblks_t.__eq__(self, r: "tryblks_t") -> bool

ida_tryblks.tryblks_t.__getitem__(self, i: "size_t") -> "tryblk_t const &"

ida_tryblks.tryblks_t.__init__(self, *args)

ida_tryblks.tryblks_t.__len__(self) -> "size_t"

ida_tryblks.tryblks_t.__ne__(self, r: "tryblks_t") -> bool

ida_tryblks.tryblks_t.__setitem__(self, i: "size_t", v: "tryblk_t") -> None

ida_tryblks.tryblks_t._del(self, x: "tryblk_t") -> bool

ida_tryblks.tryblks_t.add_unique(self, x: "tryblk_t") -> bool

ida_tryblks.tryblks_t.append(self, x: "tryblk_t") -> None

ida_tryblks.tryblks_t.at(self, _idx: "size_t") -> "tryblk_t const &"

ida_tryblks.tryblks_t.begin(self, *args) -> "qvector< tryblk_t >::const_iterator"

ida_tryblks.tryblks_t.capacity(self) -> "size_t"

ida_tryblks.tryblks_t.clear(self) -> None

ida_tryblks.tryblks_t.empty(self) -> bool

ida_tryblks.tryblks_t.end(self, *args) -> "qvector< tryblk_t >::const_iterator"

ida_tryblks.tryblks_t.erase(self, *args) -> "qvector< tryblk_t >::iterator"

ida_tryblks.tryblks_t.extend(self, x: "tryblks_t") -> None

ida_tryblks.tryblks_t.extract(self) -> "tryblk_t *"

ida_tryblks.tryblks_t.find(self, *args) -> "qvector< tryblk_t >::const_iterator"

ida_tryblks.tryblks_t.grow(self, *args) -> None

ida_tryblks.tryblks_t.has(self, x: "tryblk_t") -> bool

ida_tryblks.tryblks_t.inject(self, s: "tryblk_t", len: "size_t") -> None

ida_tryblks.tryblks_t.insert(self, it: "tryblk_t", x: "tryblk_t") -> "qvector< tryblk_t >::iterator"

ida_tryblks.tryblks_t.pop_back(self) -> None

ida_tryblks.tryblks_t.push_back(self, *args) -> "tryblk_t &"

ida_tryblks.tryblks_t.qclear(self) -> None

ida_tryblks.tryblks_t.reserve(self, cnt: "size_t") -> None

ida_tryblks.tryblks_t.resize(self, *args) -> None

ida_tryblks.tryblks_t.size(self) -> "size_t"

ida_tryblks.tryblks_t.swap(self, r: "tryblks_t") -> None

ida_tryblks.tryblks_t.truncate(self) -> None

ida_typeinf
    Type information in IDA.
    
    In IDA, types are represented by and manipulated through tinfo_t objects.
    A tinfo_t can represent a simple type (e.g., `int`, `float`), a complex type (a structure, enum, union, typedef), or even an array, or a function prototype.
    The key types in this file are:
    
    * til_t - a type info library. Holds type information in serialized form.
    * tinfo_t - information about a type (simple, complex, ...)
    
    
    # Glossary
    All throughout this file, there are certain terms that will keep appearing:
    
    * udt: "user-defined type": a structure or union - but not enums. See udt_type_data_t
    * udm: "udt member": i.e., a structure or union member. See udm_t
    * edm: "enum member": i.e., an enumeration member - i.e., an enumerator. See edm_t
    
    
    # Under the hood
    The tinfo_t type provides a lot of useful methods already, but it's possible to achieve even more by retrieving its contents into the container classes:
    
    * udt_type_data_t - for structures & unions. See tinfo_t::get_udt_details . Essentially, a vector of udm_t
    * enum_type_data_t - for enumerations. See tinfo_t::get_enum_details . Essentially, a vector of edm_t
    * ptr_type_data_t - for pointers. See tinfo_t::get_ptr_details
    * array_type_data_t - for arrays. See tinfo_t::get_array_details
    * func_type_data_t - for function prototypes. See tinfo_t::get_func_details
    * bitfield_type_data_t - for bitfields. See tinfo_t::get_bitfield_details
    
    
    # Attached & detached tinfo_t objects
    tinfo_t objects can be attached to a til_t library, or can be created without using any til_t.
    Here is an example, assigning a function prototype:
    func_type_data_t func_info;
    funcarg_t argc; argc.name = "argc"; argc.type = tinfo_t(BT_INT); func_info.push_back(argc);
    funcarg_t argv; argc.name = "argv"; argc.type = tinfo_t("const char **"); func_info.push_back(argv)
    tinfo_t tif; if ( tif.create_func(func_info) ) { ea_t ea = // get address of "main" apply_tinfo(ea, tif, TINFO_DEFINITE); }
    This code manipulates a "detached" tinfo_t object, which does not depend on any til_t file. However, any complex type will require a til_t file. In IDA, there is always a default til_t file for each idb file. This til_t file can be specified by nullptr.
    On the other hand, the following code manipulates an "attached" tinfo_t object, and any operation that modifies it, will also modify it in the hosting til_t:
    tinfo_t tif; Load type from the "Local Types" til_t. Note: we could have used `get_idati()` instead of nullptr if ( tif.get_named_type(nullptr, "my_struct_t") ) tif.add_udm("extra_field", "unsigned long long");
    You can check if a tinfo_t instance is attached to a type in a til_t file by calling tinfo_t::is_typeref 
        

ida_typeinf.ADDTIL_ABORTED
    til was not loaded (incompatible til rejected by user)

ida_typeinf.ADDTIL_COMP
    ok, but til is not compatible with the current compiler

ida_typeinf.ADDTIL_DEFAULT
    default behavior

ida_typeinf.ADDTIL_FAILED
    something bad, the warning is displayed

ida_typeinf.ADDTIL_INCOMP
    load incompatible tils

ida_typeinf.ADDTIL_OK
    ok, til is loaded

ida_typeinf.ADDTIL_SILENT
    do not ask any questions

ida_typeinf.ALOC_CUSTOM
    custom argloc (7 or higher)

ida_typeinf.ALOC_DIST
    distributed (scattered)

ida_typeinf.ALOC_NONE
    none

ida_typeinf.ALOC_REG1
    one register (and offset within it)

ida_typeinf.ALOC_REG2
    register pair

ida_typeinf.ALOC_RREL
    register relative

ida_typeinf.ALOC_STACK
    stack offset

ida_typeinf.ALOC_STATIC
    global address

ida_typeinf.ARGREGS_BY_SLOTS
    fixed FP/GP register per each slot (like vc64)

ida_typeinf.ARGREGS_FP_MASKS_GP
    FP register also consumes one or more GP regs but not vice versa (aix ppc ABI)

ida_typeinf.ARGREGS_GP_ONLY
    GP registers used for all arguments.

ida_typeinf.ARGREGS_INDEPENDENT
    FP/GP registers used separately (like gcc64)

ida_typeinf.ARGREGS_MIPS_O32
    MIPS ABI o32.

ida_typeinf.ARGREGS_RISCV
    Risc-V API FP arguments are passed in GP registers if FP registers are exhausted and GP ones are not. Wide FP arguments are passed in GP registers. Variadic FP arguments are passed in GP registers. 
              

ida_typeinf.BADSIZE
    bad type size

ida_typeinf.BFA_FUNC_EXT_FORMAT
    This is NOT a real attribute (used internally as marker for extended format)

ida_typeinf.BFA_FUNC_MARKER
    This is NOT a cc! (used internally as a marker)

ida_typeinf.BFA_HIGH
    high level prototype (with possibly hidden args)

ida_typeinf.BFA_NORET
    __noreturn

ida_typeinf.BFA_PURE
    __pure

ida_typeinf.BFA_STATIC
    static

ida_typeinf.BFA_VIRTUAL
    virtual

ida_typeinf.BTE_ALWAYS
    this bit MUST be present

ida_typeinf.BTE_BITMASK
    'subarrays'. In this case ANY record has the following format:
    * 'de' mask (has name)
    * 'dt' cnt
    * cnt records of 'de' values (cnt CAN be 0)

ida_typeinf.BTE_CHAR
    char or hex

ida_typeinf.BTE_HEX
    hex

ida_typeinf.BTE_OUT_MASK
    output style mask

ida_typeinf.BTE_RESERVED
    must be 0, in order to distinguish from a tah-byte 
            

ida_typeinf.BTE_SDEC
    signed decimal

ida_typeinf.BTE_SIZE_MASK
    storage size.
    * if == 0 then inf_get_cc_size_e()
    * else 1 << (n -1) = 1,2,4,8
    * n == 5,6,7 are reserved 
    
    
            

ida_typeinf.BTE_UDEC
    unsigned decimal

ida_typeinf.BTF_BOOL
    boolean

ida_typeinf.BTF_BYTE
    byte

ida_typeinf.BTF_CHAR
    signed char

ida_typeinf.BTF_DOUBLE
    double

ida_typeinf.BTF_ENUM
    enum

ida_typeinf.BTF_FLOAT
    float

ida_typeinf.BTF_INT
    int, unknown signedness

ida_typeinf.BTF_INT128
    signed 128-bit value

ida_typeinf.BTF_INT16
    signed short

ida_typeinf.BTF_INT32
    signed int

ida_typeinf.BTF_INT64
    signed long

ida_typeinf.BTF_INT8
    signed byte

ida_typeinf.BTF_LDOUBLE
    long double

ida_typeinf.BTF_SINT
    singed int

ida_typeinf.BTF_STRUCT
    struct

ida_typeinf.BTF_TBYTE
    see BTMT_SPECFLT

ida_typeinf.BTF_TYPEDEF
    typedef

ida_typeinf.BTF_UCHAR
    unsigned char

ida_typeinf.BTF_UINT
    unsigned int

ida_typeinf.BTF_UINT128
    unsigned 128-bit value

ida_typeinf.BTF_UINT16
    unsigned short

ida_typeinf.BTF_UINT32
    unsigned int

ida_typeinf.BTF_UINT64
    unsigned long

ida_typeinf.BTF_UINT8
    unsigned byte

ida_typeinf.BTF_UNION
    union

ida_typeinf.BTF_UNK
    unknown

ida_typeinf.BTF_VOID
    void

ida_typeinf.BTMT_ARRESERV
    reserved bit

ida_typeinf.BTMT_BFLDI16
    __int16

ida_typeinf.BTMT_BFLDI32
    __int32

ida_typeinf.BTMT_BFLDI64
    __int64

ida_typeinf.BTMT_BFLDI8
    __int8

ida_typeinf.BTMT_BOOL1
    size 1byte

ida_typeinf.BTMT_BOOL2
    size 2bytes - !inf_is_64bit()

ida_typeinf.BTMT_BOOL4
    size 4bytes

ida_typeinf.BTMT_BOOL8
    size 8bytes - inf_is_64bit()

ida_typeinf.BTMT_CHAR
    specify char or segment register
    * BT_INT8 - char
    * BT_INT - segment register
    * other BT_INT... - don't use 
    
    
            

ida_typeinf.BTMT_CLOSURE
    closure.
    * if ptr to BT_FUNC - __closure. in this case next byte MUST be RESERVED_BYTE, and after it BT_FUNC
    * else the next byte contains sizeof(ptr) allowed values are 1 - ph.max_ptr_size
    * if value is bigger than ph.max_ptr_size, based_ptr_name_and_size() is called to find out the typeinfo 
    
    
            

ida_typeinf.BTMT_DEFBOOL
    size is model specific or unknown(?)

ida_typeinf.BTMT_DEFCALL
    call method - default for model or unknown

ida_typeinf.BTMT_DEFPTR
    default for model

ida_typeinf.BTMT_DOUBLE
    double (8 bytes)

ida_typeinf.BTMT_ENUM
    enum: next byte bte_t (see below) N records: de delta(s) OR blocks (see below) 
            

ida_typeinf.BTMT_FAR
    far

ida_typeinf.BTMT_FARCALL
    function returns by retf

ida_typeinf.BTMT_FLOAT
    float (4 bytes)

ida_typeinf.BTMT_INTCALL
    function returns by iret in this case cc MUST be 'unknown' 
            

ida_typeinf.BTMT_LNGDBL
    long double (compiler specific)

ida_typeinf.BTMT_NEAR
    near

ida_typeinf.BTMT_NEARCALL
    function returns by retn

ida_typeinf.BTMT_NONBASED
    set
      array base==0
      format: dt num_elem; [tah-typeattrs]; type_t...
      if num_elem==0 then the array size is unknown
    
      format: da num_elem, base; [tah-typeattrs]; type_t... 
    
    
       

ida_typeinf.BTMT_SIGNED
    signed

ida_typeinf.BTMT_SIZE0
    BT_VOID - normal void; BT_UNK - don't use

ida_typeinf.BTMT_SIZE12
    size = 1 byte if BT_VOID; 2 if BT_UNK

ida_typeinf.BTMT_SIZE128
    size = 16 bytes if BT_VOID; unknown if BT_UNK (IN struct alignment - see below) 
            

ida_typeinf.BTMT_SIZE48
    size = 4 bytes if BT_VOID; 8 if BT_UNK

ida_typeinf.BTMT_SPECFLT
    float (variable size). if processor_t::use_tbyte() then use processor_t::tbyte_size, otherwise 2 bytes 
            

ida_typeinf.BTMT_STRUCT
    struct: MCNT records: type_t; [sdacl-typeattrs]; 
            

ida_typeinf.BTMT_TYPEDEF
    named reference always p_string name 
            

ida_typeinf.BTMT_UNION
    union: MCNT records: type_t... 
            

ida_typeinf.BTMT_UNKSIGN
    unknown signedness

ida_typeinf.BTMT_USIGNED
    unsigned

ida_typeinf.BTM_CONST
    const

ida_typeinf.BTM_VOLATILE
    volatile

ida_typeinf.BT_ARRAY
    array

ida_typeinf.BT_BITFIELD
    bitfield (only in struct) ['bitmasked' enum see below] next byte is dt ((size in bits << 1) | (unsigned ? 1 : 0)) 
            

ida_typeinf.BT_BOOL
    bool

ida_typeinf.BT_COMPLEX
    struct/union/enum/typedef. format: 
    [dt N (N=field count) if !BTMT_TYPEDEF]
    if N == 0:
      p_string name (unnamed types have names "anon_...")
      [sdacl-typeattrs];
    else, for struct & union:
      if N == 0x7FFE   // Support for high (i.e., > 4095) members count
        N = deserialize_de()
      ALPOW = N & 0x7
      MCNT = N >> 3
      if MCNT == 0
        empty struct
      if ALPOW == 0
        ALIGN = get_default_align()
      else
        ALIGN = (1 << (ALPOW - 1))
      [sdacl-typeattrs];
    else, for enums:
      if N == 0x7FFE   // Support for high enum entries count.
        N = deserialize_de()
      [tah-typeattrs];  
     

ida_typeinf.BT_FLOAT
    float

ida_typeinf.BT_FUNC
    function. format: 
    optional: CM_CC_SPOILED | num_of_spoiled_regs
              if num_of_spoiled_reg == BFA_FUNC_MARKER:
                ::bfa_byte
                if (bfa_byte & BFA_FUNC_EXT_FORMAT) != 0
                 ::fti_bits (only low bits: FTI_SPOILED,...,FTI_VIRTUAL)
                 num_of_spoiled_reg times: spoiled reg info (see extract_spoiledreg)
                else
                  bfa_byte is function attribute byte (see Function attribute byte...)
              else:
                num_of_spoiled_reg times: spoiled reg info (see extract_spoiledreg)
    cm_t ... calling convention and memory model
    [tah-typeattrs];
    type_t ... return type;
    [serialized argloc_t of returned value (if CM_CC_SPECIAL{PE} && !return void);
    if !CM_CC_VOIDARG:
      dt N (N=number of parameters)
      if ( N == 0 )
      if CM_CC_ELLIPSIS or CM_CC_SPECIALE
          func(...)
        else
          parameters are unknown
      else
        N records:
          type_t ... (i.e. type of each parameter)
          [serialized argloc_t (if CM_CC_SPECIAL{PE})] (i.e. place of each parameter)
          [FAH_BYTE + de( funcarg_t::flags )]  
      

ida_typeinf.BT_INT
    natural int. (size provided by idp module)

ida_typeinf.BT_INT128
    __int128 (for alpha & future use)

ida_typeinf.BT_INT16
    __int16

ida_typeinf.BT_INT32
    __int32

ida_typeinf.BT_INT64
    __int64

ida_typeinf.BT_INT8
    __int8

ida_typeinf.BT_PTR
    pointer. has the following format: [db sizeof(ptr)]; [tah-typeattrs]; type_t... 
            

ida_typeinf.BT_RESERVED
    RESERVED.

ida_typeinf.BT_SEGREG
    segment register

ida_typeinf.BT_UNK
    unknown

ida_typeinf.BT_UNKNOWN
    unknown size - for parameters

ida_typeinf.BT_UNK_BYTE
    1 byte

ida_typeinf.BT_UNK_DWORD
    4 bytes

ida_typeinf.BT_UNK_OWORD
    16 bytes

ida_typeinf.BT_UNK_QWORD
    8 bytes

ida_typeinf.BT_UNK_WORD
    2 bytes

ida_typeinf.BT_VOID
    void

ida_typeinf.CC_ALLOW_ARGPERM
    disregard argument order?

ida_typeinf.CC_ALLOW_REGHOLES
    allow holes in register argument list?

ida_typeinf.CC_CDECL_OK
    can use __cdecl calling convention?

ida_typeinf.CC_GOLANG_OK
    can use __golang calling convention 
            

ida_typeinf.CC_HAS_ELLIPSIS
    function has a variable list of arguments?

ida_typeinf.CM_CC_CDECL
    stack

ida_typeinf.CM_CC_ELLIPSIS
    cdecl + ellipsis

ida_typeinf.CM_CC_FASTCALL
    stack, purged (x86), first args are in regs (compiler-dependent)

ida_typeinf.CM_CC_GOLANG
    (Go) arguments and return value in stack

ida_typeinf.CM_CC_INVALID
    this value is invalid

ida_typeinf.CM_CC_PASCAL
    stack, purged, reverse order of args

ida_typeinf.CM_CC_SPECIAL
    usercall: locations of all arguments and the return value are explicitly specified 
            

ida_typeinf.CM_CC_SPECIALE
    CM_CC_SPECIAL with ellipsis

ida_typeinf.CM_CC_SPECIALP
    Equal to CM_CC_SPECIAL, but with purged stack.

ida_typeinf.CM_CC_SPOILED
    This is NOT a cc! Mark of __spoil record the low nibble is count and after n {spoilreg_t} present real cm_t byte. if n == BFA_FUNC_MARKER, the next byte is the function attribute byte. 
            

ida_typeinf.CM_CC_STDCALL
    stack, purged

ida_typeinf.CM_CC_SWIFT
    (Swift) arguments and return values in registers (compiler-dependent)

ida_typeinf.CM_CC_THISCALL
    stack, purged (x86), first arg is in reg (compiler-dependent)

ida_typeinf.CM_CC_UNKNOWN
    unknown calling convention

ida_typeinf.CM_CC_VOIDARG
    function without arguments if has other cc and argnum == 0, represent as f() - unknown list 
            

ida_typeinf.CM_M_FF
    large: code=far, data=far

ida_typeinf.CM_M_FN
    medium: code=far, data=near

ida_typeinf.CM_M_NF
    compact: code=near, data=far

ida_typeinf.CM_M_NN
    small: code=near, data=near (or unknown if CM_UNKNOWN)

ida_typeinf.CM_N16_F32
    near 2 bytes, far 4 bytes

ida_typeinf.CM_N32_F48
    near 4 bytes, far 6 bytes

ida_typeinf.CM_N64
    if sizeof(int)>2: near 8 bytes, far 8 bytes

ida_typeinf.CM_N8_F16
    if sizeof(int)<=2: near 1 byte, far 2 bytes

ida_typeinf.CM_UNKNOWN
    unknown

ida_typeinf.COMP_BC
    Borland C++.

ida_typeinf.COMP_BP
    Delphi.

ida_typeinf.COMP_GNU
    GNU C++.

ida_typeinf.COMP_MS
    Visual C++.

ida_typeinf.COMP_UNK
    Unknown.

ida_typeinf.COMP_UNSURE
    uncertain compiler id

ida_typeinf.COMP_VISAGE
    Visual Age C++.

ida_typeinf.COMP_WATCOM
    Watcom C++.

ida_typeinf.DEFMASK64
    default bitmask 64bits

ida_typeinf.ETF_AUTONAME
    udm - generate a member name if was not specified (add_udm, set_udm_type)

ida_typeinf.ETF_BYTIL
    udm - new type was created by the type subsystem

ida_typeinf.ETF_COMPATIBLE
    new type must be compatible with the old

ida_typeinf.ETF_FORCENAME
    anyway use name, see below for more usage description

ida_typeinf.ETF_FUNCARG
    udm - member is a function argument (cannot create arrays)

ida_typeinf.ETF_MAY_DESTROY
    may destroy other members

ida_typeinf.ETF_NO_ARRAY
    add_udm, set_udm_type - do not convert type to an array on the size mismatch

ida_typeinf.ETF_NO_LAYOUT
    don't calc type layout before editing

ida_typeinf.ETF_NO_SAVE
    don't save to til (normally typerefs are saved to til) A call with ETF_NO_SAVE must be followed by a call without it. Otherwise there may be inconsistencies between the memory and the type library. 
              

ida_typeinf.FAH_BYTE
    function argument attribute header byte

ida_typeinf.FAI_ARRAY
    was initially an array; see "__org_typedef" or "__org_arrdim" type attributes to determine the original type 
            

ida_typeinf.FAI_HIDDEN
    hidden argument

ida_typeinf.FAI_RETPTR
    pointer to return value. implies hidden

ida_typeinf.FAI_STRUCT
    was initially a structure

ida_typeinf.FAI_UNUSED
    argument is not used by the function

ida_typeinf.FIRST_NONTRIVIAL_TYPID
    Denotes the first bit describing a nontrivial type.

ida_typeinf.FRB_CHAR
    Char.

ida_typeinf.FRB_CUSTOM
    *Custom data type

ida_typeinf.FRB_ENUM
    *Enumeration

ida_typeinf.FRB_FLOAT
    Floating point number (for interpreting an integer type as a floating value) 
            

ida_typeinf.FRB_INVBITS
    Invert bits (0x01 is represented as ~0xFE)

ida_typeinf.FRB_INVSIGN
    Invert sign (0x01 is represented as -0xFF)

ida_typeinf.FRB_LZERO
    Toggle leading zeroes (used for integers)

ida_typeinf.FRB_MASK
    Mask for the value type (* means requires additional info):

ida_typeinf.FRB_NUMB
    Binary number.

ida_typeinf.FRB_NUMD
    Decimal number.

ida_typeinf.FRB_NUMH
    Hexadecimal number.

ida_typeinf.FRB_NUMO
    Octal number.

ida_typeinf.FRB_OFFSET
    *Offset

ida_typeinf.FRB_SEG
    Segment.

ida_typeinf.FRB_SIGNED
    Force signed representation.

ida_typeinf.FRB_STRLIT
    *String literal (used for arrays)

ida_typeinf.FRB_STROFF
    *Struct offset

ida_typeinf.FRB_TABFORM
    has additional tabular parameters 
            

ida_typeinf.FRB_UNK
    Unknown.

ida_typeinf.FTI_ALL
    all defined bits

ida_typeinf.FTI_ARGLOCS
    info about argument locations has been calculated (stkargs and retloc too) 
            

ida_typeinf.FTI_CALLTYPE
    mask for FTI_*CALL

ida_typeinf.FTI_CONST
    const member function

ida_typeinf.FTI_CTOR
    constructor

ida_typeinf.FTI_DEFCALL
    default call

ida_typeinf.FTI_DTOR
    destructor

ida_typeinf.FTI_EXPLOCS
    all arglocs are specified explicitly

ida_typeinf.FTI_FARCALL
    far call

ida_typeinf.FTI_HIGH
    high level prototype (with possibly hidden args)

ida_typeinf.FTI_INTCALL
    interrupt call

ida_typeinf.FTI_NEARCALL
    near call

ida_typeinf.FTI_NORET
    noreturn

ida_typeinf.FTI_PURE
    __pure

ida_typeinf.FTI_SPOILED
    information about spoiled registers is present

ida_typeinf.FTI_STATIC
    static

ida_typeinf.FTI_VIRTUAL
    virtual

ida_typeinf.GTD_CALC_ARGLOCS
    calculate func arg locations

ida_typeinf.GTD_CALC_LAYOUT
    calculate udt layout

ida_typeinf.GTD_DEL_BITFLDS
    delete udt bitfields

ida_typeinf.GTD_NO_ARGLOCS
    don't calculate func arg locations please note that the locations may have been calculated earlier 
              

ida_typeinf.GTD_NO_LAYOUT
    don't calculate udt layout please note that udt layout may have been calculated earlier 
              

ida_typeinf.GTS_BASECLASS
    is baseclass of a udt

ida_typeinf.GTS_NESTED
    nested type (embedded into a udt)

ida_typeinf.GUESS_FUNC_FAILED
    couldn't guess the function type

ida_typeinf.GUESS_FUNC_OK
    ok, some non-trivial information is gathered

ida_typeinf.GUESS_FUNC_TRIVIAL
    the function type doesn't have interesting info

ida_typeinf.HTI_CPP
    C++ mode (not implemented)

ida_typeinf.HTI_DCL
    don't complain about redeclarations

ida_typeinf.HTI_EXT
    debug: print external representation of types

ida_typeinf.HTI_FIL
    "input" is file name, otherwise "input" contains a C declaration 
            

ida_typeinf.HTI_HIGH
    assume high level prototypes (with hidden args, etc) 
            

ida_typeinf.HTI_INT
    debug: print internal representation of types

ida_typeinf.HTI_LEX
    debug: print tokens

ida_typeinf.HTI_LOWER
    lower the function prototypes

ida_typeinf.HTI_MAC
    define macros from the base tils

ida_typeinf.HTI_NDC
    don't decorate names

ida_typeinf.HTI_NER
    ignore all errors but display them

ida_typeinf.HTI_NOBASE
    do not inspect base tils

ida_typeinf.HTI_NWR
    no warning messages

ida_typeinf.HTI_PAK
    explicit structure pack value (#pragma pack)

ida_typeinf.HTI_PAK1
    #pragma pack(1)

ida_typeinf.HTI_PAK16
    #pragma pack(16)

ida_typeinf.HTI_PAK2
    #pragma pack(2)

ida_typeinf.HTI_PAK4
    #pragma pack(4)

ida_typeinf.HTI_PAK8
    #pragma pack(8)

ida_typeinf.HTI_PAKDEF
    default pack value

ida_typeinf.HTI_PAK_SHIFT
    shift for HTI_PAK. This field should be used if you want to remember an explicit pack value for each structure/union type. See HTI_PAK... definitions 
            

ida_typeinf.HTI_RAWARGS
    leave argument names unchanged (do not remove underscores)

ida_typeinf.HTI_RELAXED
    accept references to unknown namespaces

ida_typeinf.HTI_SEMICOLON
    do not complain if the terminated semicolon is absent

ida_typeinf.HTI_TST
    test mode: discard the result

ida_typeinf.HTI_UNP
    debug: check the result by unpacking it

ida_typeinf.MAX_ENUM_SERIAL
    Max number of identical constants allowed for one enum type.

ida_typeinf.MAX_FUNC_ARGS
    max number of function arguments

ida_typeinf.NTF_64BIT
    value is 64bit

ida_typeinf.NTF_CHKSYNC
    check that synchronization to IDB passed OK (set_numbered_type, set_named_type) 
            

ida_typeinf.NTF_COPY
    save a new type definition, not a typeref (tinfo_t::set_numbered_type, tinfo_t::set_named_type)

ida_typeinf.NTF_FIXNAME
    force-validate the name of the type when setting (set_named_type, set_numbered_type only) 
            

ida_typeinf.NTF_IDBENC
    the name is given in the IDB encoding; non-ASCII bytes will be decoded accordingly (set_named_type, set_numbered_type only) 
            

ida_typeinf.NTF_NOBASE
    don't inspect base tils (for get_named_type)

ida_typeinf.NTF_NOCUR
    don't inspect current til file (for get_named_type)

ida_typeinf.NTF_NO_NAMECHK
    do not validate type name (set_numbered_type, set_named_type) 
            

ida_typeinf.NTF_REPLACE
    replace original type (for set_named_type)

ida_typeinf.NTF_SYMM
    symbol, name is mangled ('_func'); only one of NTF_TYPE and NTF_SYMU, NTF_SYMM can be used 
            

ida_typeinf.NTF_SYMU
    symbol, name is unmangled ('func')

ida_typeinf.NTF_TYPE
    type name

ida_typeinf.NTF_UMANGLED
    name is unmangled (don't use this flag)

ida_typeinf.PDF_DEF_BASE
    Include base types: __int8, __int16, etc..

ida_typeinf.PDF_DEF_FWD
    Allow forward declarations.

ida_typeinf.PDF_HEADER_CMT
    Prepend output with a descriptive comment.

ida_typeinf.PDF_INCL_DEPS
    Include all type dependencies.

ida_typeinf.PIO_IGNORE_PTRS
    do not follow pointers

ida_typeinf.PIO_NOATTR_FAIL
    missing attributes are not ok

ida_typeinf.PRALOC_STKOFF
    print stack offsets

ida_typeinf.PRALOC_VERIFY
    interr if illegal argloc

ida_typeinf.PRTYPE_1LINCMT
    print comments even in the one line mode

ida_typeinf.PRTYPE_1LINE
    print to one line

ida_typeinf.PRTYPE_ARGLOCS
    print function arglocs (not only for usercall)

ida_typeinf.PRTYPE_COLORED
    add color tag COLOR_SYMBOL for any parentheses, commas and colons

ida_typeinf.PRTYPE_CPP
    use c++ name (only for print_type())

ida_typeinf.PRTYPE_DEF
    tinfo_t: print definition, if available

ida_typeinf.PRTYPE_HEADER
    print only type header (only for definitions)

ida_typeinf.PRTYPE_MAXSTR
    limit the output length to 1024 bytes (the output may be slightly longer)

ida_typeinf.PRTYPE_METHODS
    tinfo_t: print udt methods

ida_typeinf.PRTYPE_MULTI
    print to many lines

ida_typeinf.PRTYPE_NOARGS
    tinfo_t: do not print function argument names

ida_typeinf.PRTYPE_NOARRS
    tinfo_t: print arguments with FAI_ARRAY as pointers

ida_typeinf.PRTYPE_NOREGEX
    do not apply regular expressions to beautify name

ida_typeinf.PRTYPE_NORES
    tinfo_t: never resolve types (meaningful with PRTYPE_DEF)

ida_typeinf.PRTYPE_OFFSETS
    print udt member offsets

ida_typeinf.PRTYPE_PRAGMA
    print pragmas for alignment

ida_typeinf.PRTYPE_RESTORE
    tinfo_t: print restored types for FAI_ARRAY and FAI_STRUCT

ida_typeinf.PRTYPE_SEMI
    append ; to the end

ida_typeinf.PRTYPE_TAIL
    print only the definition tail (only for definitions, exclusive with PRTYPE_HEADER)

ida_typeinf.PRTYPE_TYPE
    print type declaration (not variable declaration)

ida_typeinf.PT_EMPTY
    accept empty decl

ida_typeinf.PT_HIGH
    assume high level prototypes (with hidden args, etc) 
            

ida_typeinf.PT_LOWER
    lower the function prototypes

ida_typeinf.PT_NDC
    don't decorate names

ida_typeinf.PT_PACKMASK
    mask for pack alignment values

ida_typeinf.PT_RAWARGS
    leave argument names unchanged (do not remove underscores)

ida_typeinf.PT_RELAXED
    accept references to unknown namespaces

ida_typeinf.PT_REPLACE
    replace the old type (used in idc)

ida_typeinf.PT_SEMICOLON
    append the terminated semicolon

ida_typeinf.PT_SIL
    silent, no messages

ida_typeinf.PT_TYP
    return declared type information

ida_typeinf.PT_VAR
    return declared object information

ida_typeinf.RESERVED_BYTE
    multifunctional purpose

ida_typeinf.SC_AUTO
    auto

ida_typeinf.SC_EXT
    extern

ida_typeinf.SC_FRIEND
    friend

ida_typeinf.SC_REG
    register

ida_typeinf.SC_STAT
    static

ida_typeinf.SC_TYPE
    typedef

ida_typeinf.SC_UNK
    unknown

ida_typeinf.SC_VIRT
    virtual

ida_typeinf.SETCOMP_BY_USER
    invoked by user, cannot be replaced by module/loader

ida_typeinf.SETCOMP_ONLY_ABI
    ignore cc field complete, use only abiname

ida_typeinf.SETCOMP_ONLY_ID
    cc has only 'id' field; the rest will be set to defaults corresponding to the program bitness 
            

ida_typeinf.SETCOMP_OVERRIDE
    may override old compiler info

ida_typeinf.STI_ACCHAR
    const char[]

ida_typeinf.STI_ACHAR
    char[]

ida_typeinf.STI_ACUCHAR
    const uint8[]

ida_typeinf.STI_AEABI_LCMP
    int __fastcall __pure(int64 x, int64 y)

ida_typeinf.STI_AEABI_MEMCLR
    void __fastcall(void *, size_t)

ida_typeinf.STI_AEABI_MEMCPY
    void __fastcall(void *, const void *, size_t)

ida_typeinf.STI_AEABI_MEMSET
    void __fastcall(void *, size_t, int)

ida_typeinf.STI_AEABI_ULCMP
    int __fastcall __pure(uint64 x, uint64 y)

ida_typeinf.STI_AUCHAR
    uint8[]

ida_typeinf.STI_COMPLEX128
    struct complex128_t { double real, imag; }

ida_typeinf.STI_COMPLEX64
    struct complex64_t { float real, imag; }

ida_typeinf.STI_DONT_USE
    unused stock type id; should not be used

ida_typeinf.STI_FDELOP
    void __cdecl(void *)

ida_typeinf.STI_FPURGING
    void __userpurge(int)

ida_typeinf.STI_MSGSEND
    void *(void *, const char *, ...)

ida_typeinf.STI_PBYTE
    _BYTE *

ida_typeinf.STI_PCCHAR
    const char *

ida_typeinf.STI_PCHAR
    char *

ida_typeinf.STI_PCUCHAR
    const uint8 *

ida_typeinf.STI_PCVOID
    const void *

ida_typeinf.STI_PINT
    int *

ida_typeinf.STI_PPVOID
    void **

ida_typeinf.STI_PUCHAR
    uint8 *

ida_typeinf.STI_PUINT
    unsigned int *

ida_typeinf.STI_PUNKNOWN
    _UNKNOWN *

ida_typeinf.STI_PVOID
    void *

ida_typeinf.STI_RTC_CHECK_2
    int16 __fastcall(int16 x)

ida_typeinf.STI_RTC_CHECK_4
    int32 __fastcall(int32 x)

ida_typeinf.STI_RTC_CHECK_8
    int64 __fastcall(int64 x)

ida_typeinf.STI_SIZE_T
    size_t

ida_typeinf.STI_SSIZE_T
    ssize_t

ida_typeinf.STRMEM_ANON
    can be combined with STRMEM_NAME: look inside anonymous members too. 
            

ida_typeinf.STRMEM_AUTO
    get member by offset if struct, or get member by index if union
    * nb: union: index is stored in the udm->offset field!
    * nb: struct: offset is in bytes (not in bits)! 
    
    
            

ida_typeinf.STRMEM_CASTABLE_TO
    can be combined with STRMEM_TYPE: member type must be castable to the specified type 
            

ida_typeinf.STRMEM_INDEX
    get member by number
    * in: udm->offset - is a member number 
    
    
            

ida_typeinf.STRMEM_LOWBND
    get member by offset or the next member (lower bound)
    * in: udm->offset - is a member offset in bits 
    
    
            

ida_typeinf.STRMEM_MAXS
    get biggest member by size.

ida_typeinf.STRMEM_MINS
    get smallest member by size.

ida_typeinf.STRMEM_NAME
    get member by name
    * in: udm->name - the desired member name. 
    
    
            

ida_typeinf.STRMEM_NEXT
    get next member after the offset
    * in: udm->offset - is a member offset in bits 
    
    
            

ida_typeinf.STRMEM_OFFSET
    get member by offset
    * in: udm->offset - is a member offset in bits 
    
    
            

ida_typeinf.STRMEM_SIZE
    get member by size.
    * in: udm->size - the desired member size. 
    
    
            

ida_typeinf.STRMEM_SKIP_EMPTY
    can be combined with STRMEM_OFFSET, STRMEM_AUTO skip empty members (i.e. having zero size) only last empty member can be returned 
            

ida_typeinf.STRMEM_SKIP_GAPS
    can be combined with STRMEM_OFFSET, STRMEM_LOWBND skip gap members 
            

ida_typeinf.STRMEM_TYPE
    get member by type.
    * in: udm->type - the desired member type. member types are compared with tinfo_t::equals_to() 
    
    
            

ida_typeinf.STRMEM_VFTABLE
    can be combined with STRMEM_OFFSET, STRMEM_AUTO get vftable instead of the base class 
            

ida_typeinf.STRUC_SEPARATOR
    structname.fieldname

ida_typeinf.SUDT_ALIGN
    recalculate field alignments, struct packing, etc to match the offsets and size info 
            

ida_typeinf.SUDT_CONST
    only for serialize_udt: make type const

ida_typeinf.SUDT_FAST
    serialize without verifying offsets and alignments

ida_typeinf.SUDT_GAPS
    allow to fill gaps with additional members (_BYTE[])

ida_typeinf.SUDT_SERDEF
    serialize: if a typeref, serialize its definition

ida_typeinf.SUDT_SORT
    fields are not sorted by offset, sort them first

ida_typeinf.SUDT_TRUNC
    serialize: truncate useless strings from fields, fldcmts

ida_typeinf.SUDT_UNEX
    references to nonexistent member types are acceptable; in this case it is better to set the corresponding udm_t::fda field to the type alignment. If this field is not set, ida will try to guess the alignment. 
            

ida_typeinf.SUDT_VOLATILE
    only for serialize_udt: make type volatile

ida_typeinf.TAENUM_64BIT
    enum: store 64-bit values

ida_typeinf.TAENUM_BIN
    enum: binary representation, if BTE_HEX only one of OCT/BIN bits can be set. they are meaningful only if BTE_HEX is used. 
            

ida_typeinf.TAENUM_LZERO
    enum: print numbers with leading zeroes (only for HEX/OCT/BIN)

ida_typeinf.TAENUM_NUMSIGN
    enum: signed representation, if BTE_HEX

ida_typeinf.TAENUM_OCT
    enum: octal representation, if BTE_HEX

ida_typeinf.TAENUM_SIGNED
    enum: signed

ida_typeinf.TAENUM_UNSIGNED
    enum: unsigned

ida_typeinf.TAFLD_BASECLASS
    field: do not include but inherit from the current field

ida_typeinf.TAFLD_BYTIL
    field: was the member created due to the type system

ida_typeinf.TAFLD_FRAME_R
    frame: function return address frame slot

ida_typeinf.TAFLD_FRAME_S
    frame: function saved registers frame slot

ida_typeinf.TAFLD_GAP
    field: gap member (displayed as padding in type details)

ida_typeinf.TAFLD_METHOD
    denotes a udt member function

ida_typeinf.TAFLD_REGCMT
    field: the comment is regular (if not set, it is repeatable)

ida_typeinf.TAFLD_UNALIGNED
    field: unaligned field

ida_typeinf.TAFLD_VFTABLE
    field: ptr to virtual function table

ida_typeinf.TAFLD_VIRTBASE
    field: virtual base (not supported yet)

ida_typeinf.TAH_ALL
    all defined bits

ida_typeinf.TAH_BYTE
    type attribute header byte

ida_typeinf.TAH_HASATTRS
    has extended attributes

ida_typeinf.TAPTR_PTR32
    ptr: __ptr32

ida_typeinf.TAPTR_PTR64
    ptr: __ptr64

ida_typeinf.TAPTR_RESTRICT
    ptr: __restrict

ida_typeinf.TAPTR_SHIFTED
    ptr: __shifted(parent_struct, delta)

ida_typeinf.TAUDT_CPPOBJ
    struct: a c++ object, not simple pod type

ida_typeinf.TAUDT_FIXED
    struct: fixed field offsets, stored in serialized form; cannot be set for unions 
            

ida_typeinf.TAUDT_MSSTRUCT
    struct: gcc msstruct attribute

ida_typeinf.TAUDT_UNALIGNED
    struct: unaligned struct

ida_typeinf.TAUDT_VFTABLE
    struct: is virtual function table

ida_typeinf.TA_FORMAT
    info about the 'format' argument. 3 times pack_dd: format_functype_t, argument number of 'format', argument number of '...' 
            

ida_typeinf.TA_ORG_ARRDIM
    the original array dimension (pack_dd)

ida_typeinf.TA_ORG_TYPEDEF
    the original typedef name (simple string)

ida_typeinf.TA_VALUE_REPR
    serialized value_repr_t (used for scalars and arrays)

ida_typeinf.TCMP_ANYBASE
    accept any base class when casting

ida_typeinf.TCMP_AUTOCAST
    can t1 be cast into t2 automatically?

ida_typeinf.TCMP_CALL
    can t1 be called with t2 type?

ida_typeinf.TCMP_DECL
    compare declarations without resolving them

ida_typeinf.TCMP_DELPTR
    remove pointer from types before comparing

ida_typeinf.TCMP_EQUAL
    are types equal?

ida_typeinf.TCMP_IGNMODS
    ignore const/volatile modifiers

ida_typeinf.TCMP_MANCAST
    can t1 be cast into t2 manually?

ida_typeinf.TCMP_SKIPTHIS
    skip the first function argument in comparison

ida_typeinf.TERR_ALIEN_NAME
    enum member name is used in another enum

ida_typeinf.TERR_BAD_ARG
    bad argument

ida_typeinf.TERR_BAD_ARRAY
    arrays are forbidden as function arguments

ida_typeinf.TERR_BAD_BASE
    bad base class

ida_typeinf.TERR_BAD_BF
    bitfields are forbidden as function arguments

ida_typeinf.TERR_BAD_BMASK
    Bad enum member mask 0xI64X. The specified mask should not intersect with any existing mask in the enum. Zero masks are prohibited too.

ida_typeinf.TERR_BAD_FX_SIZE
    cannot extend struct beyond fixed size

ida_typeinf.TERR_BAD_GAP
    bad gap

ida_typeinf.TERR_BAD_GROUPS
    bad group sizes for bitmask enum

ida_typeinf.TERR_BAD_INDEX
    bad index d

ida_typeinf.TERR_BAD_LAYOUT
    failed to calculate the structure/union layout

ida_typeinf.TERR_BAD_MSKVAL
    bad bmask and value combination (value=0xI64X; bitmask 0xI64X)

ida_typeinf.TERR_BAD_NAME
    name s is not acceptable

ida_typeinf.TERR_BAD_OFFSET
    bad member offset s

ida_typeinf.TERR_BAD_REPR
    bad or incompatible field representation

ida_typeinf.TERR_BAD_SERIAL
    enum value has too many serials

ida_typeinf.TERR_BAD_SIZE
    bad size d

ida_typeinf.TERR_BAD_SUBTYPE
    recursive structure nesting is forbidden

ida_typeinf.TERR_BAD_TAH
    bad bits in the type attributes (TAH bits)

ida_typeinf.TERR_BAD_TYPE
    bad type

ida_typeinf.TERR_BAD_UNIVAR
    unions cannot have variable sized members

ida_typeinf.TERR_BAD_VALUE
    value 0xI64X is not acceptable

ida_typeinf.TERR_BAD_VARLAST
    variable sized member must be the last member in the structure

ida_typeinf.TERR_DUPNAME
    duplicate name s

ida_typeinf.TERR_ENUM_SIZE
    bad enum size

ida_typeinf.TERR_GRP_NOEMPTY
    could not delete group mask for not empty group 0xI64X

ida_typeinf.TERR_NESTED
    recursive structure nesting is forbidden

ida_typeinf.TERR_NOT_COMPAT
    the new type is not compatible with the old type

ida_typeinf.TERR_NOT_FOUND
    member not found

ida_typeinf.TERR_NOT_IMPL
    not implemented

ida_typeinf.TERR_NO_BMASK
    bitmask 0xI64X is not found

ida_typeinf.TERR_OK
    ok

ida_typeinf.TERR_OVERLAP
    the member overlaps with other members that cannot be deleted

ida_typeinf.TERR_SAVE_ERROR
    failed to save

ida_typeinf.TERR_SERIALIZE
    failed to serialize

ida_typeinf.TERR_STOCK
    stock type info cannot be modified

ida_typeinf.TERR_STRUCT_SIZE
    bad fixed structure size

ida_typeinf.TERR_TYPE_WORSE
    the new type is worse than the old type

ida_typeinf.TERR_UNION_BF
    unions cannot have bitfields

ida_typeinf.TIL_ADD_ALREADY
    the base til was already added

ida_typeinf.TIL_ADD_FAILED
    see errbuf

ida_typeinf.TIL_ADD_OK
    some tils were added

ida_typeinf.TIL_ALI
    type aliases are present (this bit is used only on the disk)

ida_typeinf.TIL_ESI
    extended sizeof info (short, long, longlong)

ida_typeinf.TIL_MAC
    til has macro table

ida_typeinf.TIL_MOD
    til has been modified, should be saved

ida_typeinf.TIL_ORD
    type ordinal numbers are present

ida_typeinf.TIL_SLD
    sizeof(long double)

ida_typeinf.TIL_STM
    til has extra streams

ida_typeinf.TIL_UNI
    universal til for any compiler

ida_typeinf.TIL_ZIP
    pack buckets using zip

ida_typeinf.TINFO_DEFINITE
    this is a definite type

ida_typeinf.TINFO_DELAYFUNC
    if type is a function and no function exists at ea, schedule its creation and argument renaming to auto-analysis, otherwise try to create it immediately 
            

ida_typeinf.TINFO_GUESSED
    this is a guessed type

ida_typeinf.TINFO_STRICT
    never convert given type to another one before applying

ida_typeinf.TVIS_CMT
    new comment is present (only for udt members)

ida_typeinf.TVIS_NAME
    new name is present (only for funcargs and udt members)

ida_typeinf.TVIS_RPTCMT
    the new comment is repeatable

ida_typeinf.TVIS_TYPE
    new type info is present

ida_typeinf.TVST_DEF
    visit type definition (meaningful for typerefs)

ida_typeinf.TVST_PRUNE
    don't visit children of current type

ida_typeinf.TYPE_BASE_MASK
    the low 4 bits define the basic type

ida_typeinf.TYPE_FLAGS_MASK
    type flags - they have different meaning depending on the basic type 
            

ida_typeinf.TYPE_FULL_MASK
    basic type with type flags

ida_typeinf.TYPE_MODIF_MASK
    modifiers.
    * for BT_ARRAY see Derived type: array
    * BT_VOID can have them ONLY in 'void *' 
    
    
            

ida_typeinf.TYPID_ISREF
    Identifies that a type that is a typeref.

ida_typeinf.TYPID_SHIFT
    First type detail bit.

ida_typeinf.VALSTR_OPEN
    printed opening curly brace '{'

ida_typeinf._BT_LAST_BASIC
    the last basic type, all basic types may be followed by [tah-typeattrs] 
            

ida_typeinf._wrap_cvar

ida_typeinf._wrap_cvar.__getattr__(self, attr)

ida_typeinf._wrap_cvar.__setattr__(self, attr, value)

ida_typeinf.add_til(name: str, flags: int) -> int
    Load a til file and add it the database type libraries list. IDA will also apply function prototypes for matching function names. 
            
    @param name: til name
    @param flags: combination of Load TIL flags
    @returns one of Load TIL result codes

ida_typeinf.alloc_type_ordinal(ti: "til_t") -> int
    alloc_type_ordinals(ti, 1)

ida_typeinf.alloc_type_ordinals(ti: "til_t", qty: int) -> int
    Allocate a range of ordinal numbers for new types. 
            
    @param ti: type library
    @param qty: number of ordinals to allocate
    @returns the first ordinal. 0 means failure.

ida_typeinf.aloc_visitor_t

ida_typeinf.aloc_visitor_t.__disown__(self)

ida_typeinf.aloc_visitor_t.__init__(self)

ida_typeinf.aloc_visitor_t.visit_location(self, v: "argloc_t", off: int, size: int) -> int

ida_typeinf.append_abi_opts(abi_opts: str, user_level: bool = False) -> bool
    Add/remove/check ABI option General form of full abi name: abiname-opt1-opt2-... or -opt1-opt2-... 
            
    @param abi_opts: - ABI options to add/remove in form opt1-opt2-...
    @param user_level: - initiated by user if TRUE (==SETCOMP_BY_USER)
    @returns success

ida_typeinf.append_argloc(out: "qtype *", vloc: "argloc_t") -> bool
    Serialize argument location 
            

ida_typeinf.append_tinfo_covered(out: "rangeset_t", typid: "typid_t", offset: "uint64") -> bool

ida_typeinf.apply_callee_tinfo(caller: ida_idaapi.ea_t, tif: "tinfo_t") -> bool
    Apply the type of the called function to the calling instruction. This function will append parameter comments and rename the local variables of the calling function. It also stores information about the instructions that initialize call arguments in the database. Use get_arg_addrs() to retrieve it if necessary. Alternatively it is possible to hook to processor_t::arg_addrs_ready event. 
            
    @param caller: linear address of the calling instruction. must belong to a function.
    @param tif: type info
    @returns success

ida_typeinf.apply_cdecl(til: "til_t", ea: ida_idaapi.ea_t, decl: str, flags: int = 0) -> bool
    Apply the specified type to the address. This function parses the declaration and calls apply_tinfo() 
            
    @param til: type library
    @param ea: linear address
    @param decl: type declaration in C form
    @param flags: flags to pass to apply_tinfo (TINFO_DEFINITE is always passed)
    @returns success

ida_typeinf.apply_named_type(ea: ida_idaapi.ea_t, name: str) -> bool
    Apply the specified named type to the address. 
            
    @param ea: linear address
    @param name: the type name, e.g. "FILE"
    @returns success

ida_typeinf.apply_once_tinfo_and_name(dea: ida_idaapi.ea_t, tif: "tinfo_t", name: str) -> bool
    Apply the specified type and name to the address. This function checks if the address already has a type. If the old type 
    does not exist or the new type is 'better' than the old type, then the 
    new type will be applied. A type is considered better if it has more 
    information (e.g. BTMT_STRUCT is better than BT_INT). 
    The same logic is with the name: if the address already have a meaningful 
    name, it will be preserved. Only if the old name does not exist or it 
    is a dummy name like byte_123, it will be replaced by the new name. 
            
    @param dea: linear address
    @param tif: type string in the internal format
    @param name: new name for the address
    @returns success

ida_typeinf.apply_tinfo(ea: ida_idaapi.ea_t, tif: "tinfo_t", flags: int) -> bool
    Apply the specified type to the specified address. This function sets the type and tries to convert the item at the specified address to conform the type. 
            
    @param ea: linear address
    @param tif: type string in internal format
    @param flags: combination of Apply tinfo flags
    @returns success

ida_typeinf.apply_tinfo_to_stkarg(insn: "insn_t const &", x: "op_t const &", v: int, tif: "tinfo_t", name: str) -> bool
    Helper function for the processor modules. to be called from processor_t::use_stkarg_type 
            

ida_typeinf.apply_type(til: til_t, type: bytes, fields: bytes, ea: ida_idaapi.ea_t, flags: int) -> bool
    Apply the specified type to the address
    
    @param til: Type info library. 'None' can be used.
    @param type: type string
    @param fields: fields string (may be empty or None)
    @param ea: the address of the object
    @param flags: combination of TINFO_... constants or 0
    @return: Boolean

ida_typeinf.argloc_t

ida_typeinf.argloc_t.__eq__(self, r: "argloc_t") -> bool

ida_typeinf.argloc_t.__ge__(self, r: "argloc_t") -> bool

ida_typeinf.argloc_t.__gt__(self, r: "argloc_t") -> bool

ida_typeinf.argloc_t.__init__(self, *args)

ida_typeinf.argloc_t.__le__(self, r: "argloc_t") -> bool

ida_typeinf.argloc_t.__lt__(self, r: "argloc_t") -> bool

ida_typeinf.argloc_t.__ne__(self, r: "argloc_t") -> bool

ida_typeinf.argloc_t._consume_rrel(self, p: "rrel_t") -> bool
    Use consume_rrel()

ida_typeinf.argloc_t._consume_scattered(self, p: "scattered_aloc_t") -> bool
    Use consume_scattered()

ida_typeinf.argloc_t._set_badloc(self) -> None
    Use set_badloc()

ida_typeinf.argloc_t._set_biggest(self, ct: "argloc_type_t", data: "argloc_t::biggest_t") -> None
    Set biggest element in internal union (careful - this function does not clean up!)

ida_typeinf.argloc_t._set_custom(self, ct: "argloc_type_t", pdata: "void *") -> None
    Set custom argument location (careful - this function does not clean up!)

ida_typeinf.argloc_t._set_ea(self, _ea: ida_idaapi.ea_t) -> None
    Use set_ea 
            

ida_typeinf.argloc_t._set_reg1(self, reg: int, off: int = 0) -> None
    Use set_reg1()

ida_typeinf.argloc_t._set_reg2(self, _reg1: int, _reg2: int) -> None
    Use set_reg2()

ida_typeinf.argloc_t._set_stkoff(self, off: int) -> None
    Use set_stkoff()

ida_typeinf.argloc_t.advance(self, delta: int) -> bool
    Move the location to point 'delta' bytes further.

ida_typeinf.argloc_t.align_reg_high(self, size: "size_t", _slotsize: "size_t") -> None
    Set register offset to align it to the upper part of _SLOTSIZE.

ida_typeinf.argloc_t.align_stkoff_high(self, size: "size_t", _slotsize: "size_t") -> None
    Set stack offset to align to the upper part of _SLOTSIZE.

ida_typeinf.argloc_t.atype(self) -> "argloc_type_t"
    Get type (Argument location types)

ida_typeinf.argloc_t.calc_offset(self) -> int
    Calculate offset that can be used to compare 2 similar arglocs.

ida_typeinf.argloc_t.compare(self, r: "argloc_t") -> int

ida_typeinf.argloc_t.consume_rrel(self, p: "rrel_t") -> None
    Set register-relative location - can't be nullptr.

ida_typeinf.argloc_t.consume_scattered(self, p: "scattered_aloc_t") -> None
    Set distributed argument location.

ida_typeinf.argloc_t.get_biggest(self) -> "argloc_t::biggest_t"
    Get largest element in internal union.

ida_typeinf.argloc_t.get_custom(self) -> "void *"
    Get custom argloc info. Use if atype() == ALOC_CUSTOM 
            

ida_typeinf.argloc_t.get_ea(self) -> ida_idaapi.ea_t
    Get the global address. Use when atype() == ALOC_STATIC 
            

ida_typeinf.argloc_t.get_reginfo(self) -> int
    Get all register info. Use when atype() == ALOC_REG1 or ALOC_REG2 
            

ida_typeinf.argloc_t.get_rrel(self) -> "rrel_t &"
    Get register-relative info. Use when atype() == ALOC_RREL 
            

ida_typeinf.argloc_t.has_reg(self) -> bool
    TRUE if argloc has a register part.

ida_typeinf.argloc_t.has_stkoff(self) -> bool
    TRUE if argloc has a stack part.

ida_typeinf.argloc_t.in_stack(self) -> bool
    TRUE if argloc is in stack entirely.

ida_typeinf.argloc_t.is_badloc(self) -> bool
    See ALOC_NONE.

ida_typeinf.argloc_t.is_custom(self) -> bool
    See ALOC_CUSTOM.

ida_typeinf.argloc_t.is_ea(self) -> bool
    See ALOC_STATIC.

ida_typeinf.argloc_t.is_fragmented(self) -> bool
    is_scattered() || is_reg2()

ida_typeinf.argloc_t.is_mixed_scattered(self) -> bool
    mixed scattered: consists of register and stack parts

ida_typeinf.argloc_t.is_reg(self) -> bool
    is_reg1() || is_reg2()

ida_typeinf.argloc_t.is_reg1(self) -> bool
    See ALOC_REG1.

ida_typeinf.argloc_t.is_reg2(self) -> bool
    See ALOC_REG2.

ida_typeinf.argloc_t.is_rrel(self) -> bool
    See ALOC_RREL.

ida_typeinf.argloc_t.is_scattered(self) -> bool
    See ALOC_DIST.

ida_typeinf.argloc_t.is_stkoff(self) -> bool
    See ALOC_STACK.

ida_typeinf.argloc_t.reg1(self) -> int
    Get the register info. Use when atype() == ALOC_REG1 or ALOC_REG2 
            

ida_typeinf.argloc_t.reg2(self) -> int
    Get info for the second register. Use when atype() == ALOC_REG2 
            

ida_typeinf.argloc_t.regoff(self) -> int
    Get offset from the beginning of the register in bytes. Use when atype() == ALOC_REG1 
            

ida_typeinf.argloc_t.scattered(self) -> "scattered_aloc_t &"
    Get scattered argument info. Use when atype() == ALOC_DIST 
            

ida_typeinf.argloc_t.set_badloc(self) -> None
    Set to invalid location.

ida_typeinf.argloc_t.set_ea(self, _ea: ida_idaapi.ea_t) -> None
    Set static ea location.

ida_typeinf.argloc_t.set_reg1(self, reg: int, off: int = 0) -> None
    Set register location.

ida_typeinf.argloc_t.set_reg2(self, _reg1: int, _reg2: int) -> None
    Set secondary register location.

ida_typeinf.argloc_t.set_stkoff(self, off: int) -> None
    Set stack offset location.

ida_typeinf.argloc_t.stkoff(self) -> int
    Get the stack offset. Use if atype() == ALOC_STACK 
            

ida_typeinf.argloc_t.swap(self, r: "argloc_t") -> None
    Assign this == r and r == this.

ida_typeinf.argpart_t

ida_typeinf.argpart_t.__init__(self, *args)

ida_typeinf.argpart_t.__lt__(self, r: "argpart_t") -> bool

ida_typeinf.argpart_t.bad_offset(self) -> bool
    Does this argpart have a valid offset?

ida_typeinf.argpart_t.bad_size(self) -> bool
    Does this argpart have a valid size?

ida_typeinf.argpart_t.off
    offset from the beginning of the argument

ida_typeinf.argpart_t.size
    the number of bytes

ida_typeinf.argpart_t.swap(self, r: "argpart_t") -> None
    Assign this = r and r = this.

ida_typeinf.argpartvec_t

ida_typeinf.argpartvec_t.__eq__(self, r: "argpartvec_t") -> bool

ida_typeinf.argpartvec_t.__getitem__(self, i: "size_t") -> "argpart_t const &"

ida_typeinf.argpartvec_t.__init__(self, *args)

ida_typeinf.argpartvec_t.__len__(self) -> "size_t"

ida_typeinf.argpartvec_t.__ne__(self, r: "argpartvec_t") -> bool

ida_typeinf.argpartvec_t.__setitem__(self, i: "size_t", v: "argpart_t") -> None

ida_typeinf.argpartvec_t._del(self, x: "argpart_t") -> bool

ida_typeinf.argpartvec_t.add_unique(self, x: "argpart_t") -> bool

ida_typeinf.argpartvec_t.append(self, x: "argpart_t") -> None

ida_typeinf.argpartvec_t.at(self, _idx: "size_t") -> "argpart_t const &"

ida_typeinf.argpartvec_t.begin(self, *args) -> "qvector< argpart_t >::const_iterator"

ida_typeinf.argpartvec_t.capacity(self) -> "size_t"

ida_typeinf.argpartvec_t.clear(self) -> None

ida_typeinf.argpartvec_t.empty(self) -> bool

ida_typeinf.argpartvec_t.end(self, *args) -> "qvector< argpart_t >::const_iterator"

ida_typeinf.argpartvec_t.erase(self, *args) -> "qvector< argpart_t >::iterator"

ida_typeinf.argpartvec_t.extend(self, x: "argpartvec_t") -> None

ida_typeinf.argpartvec_t.extract(self) -> "argpart_t *"

ida_typeinf.argpartvec_t.find(self, *args) -> "qvector< argpart_t >::const_iterator"

ida_typeinf.argpartvec_t.grow(self, *args) -> None

ida_typeinf.argpartvec_t.has(self, x: "argpart_t") -> bool

ida_typeinf.argpartvec_t.inject(self, s: "argpart_t", len: "size_t") -> None

ida_typeinf.argpartvec_t.insert(self, it: "argpart_t", x: "argpart_t") -> "qvector< argpart_t >::iterator"

ida_typeinf.argpartvec_t.pop_back(self) -> None

ida_typeinf.argpartvec_t.push_back(self, *args) -> "argpart_t &"

ida_typeinf.argpartvec_t.qclear(self) -> None

ida_typeinf.argpartvec_t.reserve(self, cnt: "size_t") -> None

ida_typeinf.argpartvec_t.resize(self, *args) -> None

ida_typeinf.argpartvec_t.size(self) -> "size_t"

ida_typeinf.argpartvec_t.swap(self, r: "argpartvec_t") -> None

ida_typeinf.argpartvec_t.truncate(self) -> None

ida_typeinf.argtinfo_helper_t

ida_typeinf.argtinfo_helper_t.__disown__(self)

ida_typeinf.argtinfo_helper_t.__init__(self)

ida_typeinf.argtinfo_helper_t.has_delay_slot(self, arg0: ida_idaapi.ea_t) -> bool
    The call instruction with a delay slot?.

ida_typeinf.argtinfo_helper_t.is_stkarg_load(self, insn: "insn_t const &", src: "int *", dst: "int *") -> bool
    Is the current insn a stkarg load?. if yes:
    * src: index of the source operand in insn_t::ops
    * dst: index of the destination operand in insn_t::ops insn_t::ops[dst].addr is expected to have the stack offset 
    
    
            

ida_typeinf.argtinfo_helper_t.set_op_tinfo(self, insn: "insn_t const &", x: "op_t const &", tif: "tinfo_t", name: str) -> bool
    Set the operand type as specified.

ida_typeinf.argtinfo_helper_t.use_arg_tinfos(self, caller: ida_idaapi.ea_t, fti: "func_type_data_t", rargs: "funcargvec_t") -> None
    This function is to be called by the processor module in response to ev_use_arg_types. 
            

ida_typeinf.array_type_data_t

ida_typeinf.array_type_data_t.__init__(self, b: "size_t" = 0, n: "size_t" = 0)

ida_typeinf.array_type_data_t.base
    array base

ida_typeinf.array_type_data_t.elem_type
    element type

ida_typeinf.array_type_data_t.nelems
    number of elements

ida_typeinf.array_type_data_t.swap(self, r: "array_type_data_t") -> None
    set this = r and r = this

ida_typeinf.begin_type_updating(utp: "update_type_t") -> None
    Mark the beginning of a large update operation on the types. Can be used with add_enum_member(), add_struc_member, etc... Also see end_type_updating() 
            

ida_typeinf.bitfield_type_data_t

ida_typeinf.bitfield_type_data_t.__eq__(self, r: "bitfield_type_data_t") -> bool

ida_typeinf.bitfield_type_data_t.__ge__(self, r: "bitfield_type_data_t") -> bool

ida_typeinf.bitfield_type_data_t.__gt__(self, r: "bitfield_type_data_t") -> bool

ida_typeinf.bitfield_type_data_t.__init__(self, _nbytes: "uchar" = 0, _width: "uchar" = 0, _is_unsigned: bool = False)

ida_typeinf.bitfield_type_data_t.__le__(self, r: "bitfield_type_data_t") -> bool

ida_typeinf.bitfield_type_data_t.__lt__(self, r: "bitfield_type_data_t") -> bool

ida_typeinf.bitfield_type_data_t.__ne__(self, r: "bitfield_type_data_t") -> bool

ida_typeinf.bitfield_type_data_t.compare(self, r: "bitfield_type_data_t") -> int

ida_typeinf.bitfield_type_data_t.is_unsigned
    is bitfield unsigned?

ida_typeinf.bitfield_type_data_t.is_valid_bitfield(self) -> bool

ida_typeinf.bitfield_type_data_t.nbytes
    enclosing type size (1,2,4,8 bytes)

ida_typeinf.bitfield_type_data_t.swap(self, r: "bitfield_type_data_t") -> None

ida_typeinf.bitfield_type_data_t.width
    number of bits

ida_typeinf.calc_c_cpp_name(name: str, type: "tinfo_t", ccn_flags: int) -> str
    Get C or C++ form of the name. 
            
    @param name: original (mangled or decorated) name
    @param type: name type if known, otherwise nullptr
    @param ccn_flags: one of C/C++ naming flags

ida_typeinf.calc_number_of_children(loc: "argloc_t", tif: "tinfo_t", dont_deref_ptr: bool = False) -> int
    Calculate max number of lines of a formatted c data, when expanded (PTV_EXPAND). 
            
    @param loc: location of the data (ALOC_STATIC or ALOC_CUSTOM)
    @param tif: type info
    @param dont_deref_ptr: consider 'ea' as the ptr value
    @retval 0: data is not expandable
    @retval -1: error, see qerrno
    @retval else: the max number of lines

ida_typeinf.calc_tinfo_gaps(out: "rangeset_t", typid: "typid_t") -> bool

ida_typeinf.calc_type_size(til: til_t, type: bytes)
    Returns the size of a type
    @param til: Type info library. 'None' can be passed.
    @param type: serialized type byte string
    @return:
        - None on failure
        - The size of the type

ida_typeinf.callregs_t

ida_typeinf.callregs_t.__init__(self, *args)

ida_typeinf.callregs_t.by_slots(self) -> bool

ida_typeinf.callregs_t.fpregs
    array of fp registers

ida_typeinf.callregs_t.gpregs
    array of gp registers

ida_typeinf.callregs_t.init_regs(self, cc: "cm_t") -> None
    Init policy & registers for given CC.

ida_typeinf.callregs_t.nregs
    max number of registers that can be used in a call

ida_typeinf.callregs_t.policy
    argument policy

ida_typeinf.callregs_t.regcount(cc: "cm_t") -> int
    Get max number of registers may be used in a function call.

ida_typeinf.callregs_t.reginds(self, gp_ind: "int *", fp_ind: "int *", r: int) -> bool
    Get register indexes within GP/FP arrays. (-1 -> is not present in the corresponding array) 
            

ida_typeinf.callregs_t.reset(self) -> None
    Set policy and registers to invalid values.

ida_typeinf.callregs_t.set(self, _policy: "argreg_policy_t", gprs: "int const *", fprs: "int const *") -> None
    Init policy & registers (arrays are -1-terminated)

ida_typeinf.callregs_t.set_registers(self, kind: "callregs_t::reg_kind_t", first_reg: int, last_reg: int) -> None

ida_typeinf.callregs_t.swap(self, r: "callregs_t") -> None
    swap two instances

ida_typeinf.choose_local_tinfo(ti: "til_t", title: str, func: "local_tinfo_predicate_t *" = None, def_ord: int = 0, ud: "void *" = None) -> int
    Choose a type from the local type library. 
            
    @param ti: pointer to til
    @param title: title of listbox to display
    @param func: predicate to select types to display (maybe nullptr)
    @param def_ord: ordinal to position cursor before choose
    @param ud: user data
    @returns == 0 means nothing is chosen, otherwise an ordinal number

ida_typeinf.choose_local_tinfo_and_delta(delta: "int32 *", ti: "til_t", title: str, func: "local_tinfo_predicate_t *" = None, def_ord: int = 0, ud: "void *" = None) -> int
    Choose a type from the local type library and specify the pointer shift value. 
            
    @param delta: pointer shift value
    @param ti: pointer to til
    @param title: title of listbox to display
    @param func: predicate to select types to display (maybe nullptr)
    @param def_ord: ordinal to position cursor before choose
    @param ud: user data
    @returns == 0 means nothing is chosen, otherwise an ordinal number

ida_typeinf.choose_named_type(out_sym: "til_symbol_t", root_til: "til_t", title: str, ntf_flags: int, predicate: "predicate_t" = None) -> bool
    Choose a type from a type library. 
            
    @param out_sym: pointer to be filled with the chosen type
    @param root_til: pointer to starting til (the function will inspect the base tils if allowed by flags)
    @param title: title of listbox to display
    @param ntf_flags: combination of Flags for named types
    @param predicate: predicate to select types to display (maybe nullptr)
    @returns false if nothing is chosen, otherwise true

ida_typeinf.clear_tinfo_t(_this: "tinfo_t") -> None

ida_typeinf.compact_til(ti: "til_t") -> bool
    Collect garbage in til. Must be called before storing the til. 
            
    @returns true if any memory was freed

ida_typeinf.compare_tinfo(t1: "typid_t", t2: "typid_t", tcflags: int) -> bool

ida_typeinf.const_aloc_visitor_t

ida_typeinf.const_aloc_visitor_t.__disown__(self)

ida_typeinf.const_aloc_visitor_t.__init__(self)

ida_typeinf.const_aloc_visitor_t.visit_location(self, v: "argloc_t", off: int, size: int) -> int

ida_typeinf.convert_pt_flags_to_hti(pt_flags: int) -> int
    Convert Type parsing flags to Type formatting flags. Type parsing flags lesser than 0x10 don't have stable meaning and will be ignored (more on these flags can be seen in idc.idc) 
            

ida_typeinf.copy_named_type(dsttil: "til_t", srctil: "til_t", name: str) -> int
    Copy a named type from one til to another. This function will copy the specified type and all dependent types from the source type library to the destination library. 
            
    @param dsttil: Destination til. It must have original types enabled
    @param srctil: Source til.
    @param name: name of the type to copy
    @returns ordinal number of the copied type. 0 means error

ida_typeinf.copy_tinfo_t(_this: "tinfo_t", r: "tinfo_t") -> None

ida_typeinf.create_enum_type(enum_name: str, ei: "enum_type_data_t", enum_width: int, sign: "type_sign_t", convert_to_bitmask: bool, enum_cmt: str = None) -> "tid_t"
    Create type enum 
            
    @param enum_name: type name
    @param ei: enum type data
    @param enum_width: the width of an enum element allowed values: 0 (unspecified),1,2,4,8,16,32,64
    @param sign: enum sign
    @param convert_to_bitmask: try convert enum to bitmask enum
    @param enum_cmt: enum type comment
    @returns enum TID

ida_typeinf.create_numbered_type_name(ord: int) -> str
    Create anonymous name for numbered type. This name can be used to reference a numbered type by its ordinal Ordinal names have the following format: '#' + set_de(ord) Returns: -1 if error, otherwise the name length 
            

ida_typeinf.create_tinfo(_this: "tinfo_t", bt: "type_t", bt2: "type_t", ptr: "void *") -> bool

ida_typeinf.custom_data_type_info_t

ida_typeinf.custom_data_type_info_t.__init__(self)

ida_typeinf.custom_data_type_info_t.dtid
    data type id

ida_typeinf.custom_data_type_info_t.fid
    data format ids

ida_typeinf.default_compiler() -> "comp_t"
    Get compiler specified by inf.cc.

ida_typeinf.del_named_type(ti: "til_t", name: str, ntf_flags: int) -> bool
    Delete information about a symbol. 
            
    @param ti: type library
    @param name: name of symbol
    @param ntf_flags: combination of Flags for named types
    @returns success

ida_typeinf.del_numbered_type(ti: "til_t", ordinal: int) -> bool
    Delete a numbered type.

ida_typeinf.del_til(name: str) -> bool
    Unload a til file.

ida_typeinf.del_tinfo_attr(tif: "tinfo_t", key: str, make_copy: bool) -> bool

ida_typeinf.del_vftable_ea(ordinal: int) -> bool
    Delete the address of a vftable instance for a vftable type. 
            
    @param ordinal: ordinal number of a vftable type.
    @returns success

ida_typeinf.deref_ptr(ptr_ea: "ea_t *", tif: "tinfo_t", closure_obj: "ea_t *" = None) -> bool
    Dereference a pointer. 
            
    @param ptr_ea: in/out parameter
    * in: address of the pointer
    * out: the pointed address
    @param tif: type of the pointer
    @param closure_obj: closure object (not used yet)
    @returns success

ida_typeinf.deserialize_tinfo(tif: "tinfo_t", til: "til_t", ptype: "type_t const **", pfields: "p_list const **", pfldcmts: "p_list const **", cmt: str = None) -> bool

ida_typeinf.detach_tinfo_t(_this: "tinfo_t") -> bool

ida_typeinf.dstr_tinfo(tif: "tinfo_t") -> str

ida_typeinf.dump_func_type_data(fti: "func_type_data_t", praloc_bits: int) -> str
    Use func_type_data_t::dump()

ida_typeinf.edm_t

ida_typeinf.edm_t.__eq__(self, r: "edm_t") -> bool

ida_typeinf.edm_t.__init__(self, *args)
    Create an enumerator, with the specified name and value
    
    This constructor has the following signatures:
    
        1. edm_t(edm: edm_t)
        2. edm_t(name: str, value: int, cmt: str=None)
    
    @param name  Enumerator name. Must not be empty (1st form)
    @param value Enumerator value (1st form)
    @param cmt   Enumerator repeatable comment. May be empty (1st form)
    @param edm   An enum member to copy

ida_typeinf.edm_t.__ne__(self, r: "edm_t") -> bool

ida_typeinf.edm_t.empty(self) -> bool

ida_typeinf.edm_t.get_tid(self) -> "tid_t"

ida_typeinf.edm_t.swap(self, r: "edm_t") -> None

ida_typeinf.edmvec_t

ida_typeinf.edmvec_t.__eq__(self, r: "edmvec_t") -> bool

ida_typeinf.edmvec_t.__getitem__(self, i: "size_t") -> "edm_t const &"

ida_typeinf.edmvec_t.__init__(self, *args)

ida_typeinf.edmvec_t.__len__(self) -> "size_t"

ida_typeinf.edmvec_t.__ne__(self, r: "edmvec_t") -> bool

ida_typeinf.edmvec_t.__setitem__(self, i: "size_t", v: "edm_t") -> None

ida_typeinf.edmvec_t._del(self, x: "edm_t") -> bool

ida_typeinf.edmvec_t.add_unique(self, x: "edm_t") -> bool

ida_typeinf.edmvec_t.append(self, x: "edm_t") -> None

ida_typeinf.edmvec_t.at(self, _idx: "size_t") -> "edm_t const &"

ida_typeinf.edmvec_t.begin(self, *args) -> "qvector< edm_t >::const_iterator"

ida_typeinf.edmvec_t.capacity(self) -> "size_t"

ida_typeinf.edmvec_t.clear(self) -> None

ida_typeinf.edmvec_t.empty(self) -> bool

ida_typeinf.edmvec_t.end(self, *args) -> "qvector< edm_t >::const_iterator"

ida_typeinf.edmvec_t.erase(self, *args) -> "qvector< edm_t >::iterator"

ida_typeinf.edmvec_t.extend(self, x: "edmvec_t") -> None

ida_typeinf.edmvec_t.extract(self) -> "edm_t *"

ida_typeinf.edmvec_t.find(self, *args) -> "qvector< edm_t >::const_iterator"

ida_typeinf.edmvec_t.grow(self, *args) -> None

ida_typeinf.edmvec_t.has(self, x: "edm_t") -> bool

ida_typeinf.edmvec_t.inject(self, s: "edm_t", len: "size_t") -> None

ida_typeinf.edmvec_t.insert(self, it: "edm_t", x: "edm_t") -> "qvector< edm_t >::iterator"

ida_typeinf.edmvec_t.pop_back(self) -> None

ida_typeinf.edmvec_t.push_back(self, *args) -> "edm_t &"

ida_typeinf.edmvec_t.qclear(self) -> None

ida_typeinf.edmvec_t.reserve(self, cnt: "size_t") -> None

ida_typeinf.edmvec_t.resize(self, *args) -> None

ida_typeinf.edmvec_t.size(self) -> "size_t"

ida_typeinf.edmvec_t.swap(self, r: "edmvec_t") -> None

ida_typeinf.edmvec_t.truncate(self) -> None

ida_typeinf.enable_numbered_types(ti: "til_t", enable: bool) -> bool
    Enable the use of numbered types in til. Currently it is impossible to disable numbered types once they are enabled 
            

ida_typeinf.end_type_updating(utp: "update_type_t") -> None
    Mark the end of a large update operation on the types (see begin_type_updating())

ida_typeinf.enum_type_data_t

ida_typeinf.enum_type_data_t.__init__(self, *args)

ida_typeinf.enum_type_data_t.add_constant(self, name: str, value: "uint64", cmt: str = None) -> None
    add constant for regular enum

ida_typeinf.enum_type_data_t.all_constants(self)
    Generate tupples of all constants except of bitmasks.
    Each tupple is:
    [0] constant index
    [1] enum member index of group start
    [2] group size
    In case of regular enum the second element of tupple is 0 and the third element of tupple is the number of enum members.

ida_typeinf.enum_type_data_t.all_groups(self, skip_trivial = False)
    Generate tuples for bitmask enum groups.
    Each tupple is:
    [0] enum member index of group start
    [1] group size
    Tupples may include or not the group with 1 element.

ida_typeinf.enum_type_data_t.bte
    enum member sizes (shift amount) and style. do not manually set BTE_BITMASK, use set_enum_is_bitmask() 
            

ida_typeinf.enum_type_data_t.calc_mask(self) -> "uint64"

ida_typeinf.enum_type_data_t.calc_nbytes(self) -> int
    get the width of enum in bytes

ida_typeinf.enum_type_data_t.find_member(self, *args) -> "ssize_t"
    This function has the following signatures:
    
        0. find_member(name: str, from: size_t=0, to: size_t=size_t(-1)) -> ssize_t
        1. find_member(value: uint64, serial: uchar, from: size_t=0, to: size_t=size_t(-1), vmask: uint64=uint64(-1)) -> ssize_t
    
    # 0: find_member(name: str, from: size_t=0, to: size_t=size_t(-1)) -> ssize_t
    
    find member (constant or bmask) by name
    
    
    # 1: find_member(value: uint64, serial: uchar, from: size_t=0, to: size_t=size_t(-1), vmask: uint64=uint64(-1)) -> ssize_t
    
    find member (constant or bmask) by value

ida_typeinf.enum_type_data_t.get_constant_group(self, *args) -> "PyObject *"
    get group parameters for the constant, valid for bitmask enum 
            
    @param group_start_index: index of the group mask
    @param group_size: group size (>=1)
    @param idx: constant index
    @returns success

ida_typeinf.enum_type_data_t.get_enum_radix(self) -> int
    Get enum constant radix 
            
    @returns radix or 1 for BTE_CHAR

ida_typeinf.enum_type_data_t.get_max_serial(self, value: "uint64") -> "uchar"
    return the maximum serial for the value

ida_typeinf.enum_type_data_t.get_serial(self, index: "size_t") -> "uchar"
    returns serial for the constant

ida_typeinf.enum_type_data_t.get_value_repr(self, repr: "value_repr_t") -> "tinfo_code_t"
    get enum radix and other representation info 
            
    @param repr: value display info

ida_typeinf.enum_type_data_t.group_sizes
    if present, specifies bitmask group sizes each non-trivial group starts with a mask member 
            

ida_typeinf.enum_type_data_t.has_lzero(self) -> bool

ida_typeinf.enum_type_data_t.is_bf(self) -> bool
    is bitmask or ordinary enum?

ida_typeinf.enum_type_data_t.is_bin(self) -> bool

ida_typeinf.enum_type_data_t.is_char(self) -> bool

ida_typeinf.enum_type_data_t.is_dec(self) -> bool

ida_typeinf.enum_type_data_t.is_group_mask_at(self, idx: "size_t") -> bool
    is the enum member at IDX a non-trivial group mask? a trivial group consist of one bit and has just one member, which can be considered as a mask or a bitfield constant 
            
    @param idx: index
    @returns success

ida_typeinf.enum_type_data_t.is_hex(self) -> bool

ida_typeinf.enum_type_data_t.is_number_signed(self) -> bool

ida_typeinf.enum_type_data_t.is_oct(self) -> bool

ida_typeinf.enum_type_data_t.is_sbin(self) -> bool

ida_typeinf.enum_type_data_t.is_shex(self) -> bool

ida_typeinf.enum_type_data_t.is_soct(self) -> bool

ida_typeinf.enum_type_data_t.is_udec(self) -> bool

ida_typeinf.enum_type_data_t.is_valid_group_sizes(self) -> bool
    is valid group sizes

ida_typeinf.enum_type_data_t.set_enum_radix(self, radix: int, sign: bool) -> None
    Set radix to display constants 
            
    @param radix: radix with the special case 1 to display as character

ida_typeinf.enum_type_data_t.set_lzero(self, on: bool) -> None

ida_typeinf.enum_type_data_t.set_nbytes(self, nbytes: int) -> bool
    set enum width (nbytes)

ida_typeinf.enum_type_data_t.set_value_repr(self, repr: "value_repr_t") -> "tinfo_code_t"
    set enum radix and other representation info 
            
    @param repr: value display info

ida_typeinf.enum_type_data_t.store_64bit_values(self) -> bool

ida_typeinf.enum_type_data_t.swap(self, r: "enum_type_data_t") -> None
    swap two instances

ida_typeinf.enum_type_data_t.taenum_bits
    Type attributes for enums

ida_typeinf.extract_argloc(vloc: "argloc_t", ptype: "type_t const **", forbid_stkoff: bool) -> bool
    Deserialize an argument location. Argument FORBID_STKOFF checks location type. It can be used, for example, to check the return location of a function that cannot return a value in the stack 
            

ida_typeinf.find_tinfo_udt_member(udm: "udm_t", typid: "typid_t", strmem_flags: int) -> int

ida_typeinf.first_named_type(ti: "til_t", ntf_flags: int) -> str
    Enumerate types. 
            
    @param ti: type library. nullptr means the local type library for the current database.
    @param ntf_flags: combination of Flags for named types
    @returns Type or symbol names, depending of ntf_flags. Returns mangled names. Never returns anonymous types. To include them, enumerate types by ordinals.

ida_typeinf.for_all_arglocs(vv: "aloc_visitor_t", vloc: "argloc_t", size: int, off: int = 0) -> int
    Compress larger argloc types and initiate the aloc visitor.

ida_typeinf.for_all_const_arglocs(vv: "const_aloc_visitor_t", vloc: "argloc_t", size: int, off: int = 0) -> int
    See for_all_arglocs()

ida_typeinf.free_til(ti: "til_t") -> None
    Free memory allocated by til.

ida_typeinf.func_has_stkframe_hole(ea: ida_idaapi.ea_t, fti: "func_type_data_t") -> bool
    Looks for a hole at the beginning of the stack arguments. Will make use of the IDB's func_t function at that place (if present) to help determine the presence of such a hole. 
            

ida_typeinf.func_type_data_t

ida_typeinf.func_type_data_t.__init__(self)

ida_typeinf.func_type_data_t.cc
    calling convention

ida_typeinf.func_type_data_t.dump(self, praloc_bits: int = 2) -> bool
    Dump information that is not always visible in the function prototype. (argument locations, return location, total stkarg size) 
            

ida_typeinf.func_type_data_t.find_argument(self, *args) -> "ssize_t"
    find argument by name

ida_typeinf.func_type_data_t.flags
    Function type data property bits 
            

ida_typeinf.func_type_data_t.get_call_method(self) -> int

ida_typeinf.func_type_data_t.guess_cc(self, purged: int, cc_flags: int) -> "cm_t"
    Guess function calling convention use the following info: argument locations and 'stkargs' 
            

ida_typeinf.func_type_data_t.is_const(self) -> bool

ida_typeinf.func_type_data_t.is_ctor(self) -> bool

ida_typeinf.func_type_data_t.is_dtor(self) -> bool

ida_typeinf.func_type_data_t.is_golang_cc(self) -> bool

ida_typeinf.func_type_data_t.is_high(self) -> bool

ida_typeinf.func_type_data_t.is_noret(self) -> bool

ida_typeinf.func_type_data_t.is_pure(self) -> bool

ida_typeinf.func_type_data_t.is_static(self) -> bool

ida_typeinf.func_type_data_t.is_swift_cc(self) -> bool

ida_typeinf.func_type_data_t.is_vararg_cc(self) -> bool

ida_typeinf.func_type_data_t.is_virtual(self) -> bool

ida_typeinf.func_type_data_t.retloc
    return location

ida_typeinf.func_type_data_t.rettype
    return type

ida_typeinf.func_type_data_t.spoiled
    spoiled register information. if spoiled register info is present, it overrides the standard spoil info (eax, edx, ecx for x86) 
            

ida_typeinf.func_type_data_t.stkargs
    size of stack arguments (not used in build_func_type)

ida_typeinf.func_type_data_t.swap(self, r: "func_type_data_t") -> None

ida_typeinf.funcarg_t

ida_typeinf.funcarg_t.__eq__(self, r: "funcarg_t") -> bool

ida_typeinf.funcarg_t.__init__(self, *args)
    Create a function argument, with the specified name and type.
    
    This constructor has the following signatures:
    
        1. funcarg_t(name: str, type, argloc: argloc_t)
        2. funcarg_t(funcarg: funcarg_t)
    
    In the 1st form, the 'type' descriptor, can be one of:
    
        * type_t: if the type is simple (integral/floating/bool). E.g., `BTF_INT`
        * tinfo_t: can handle more complex types (structures, pointers, arrays, ...)
        * str: a C type declaration
    
    If an input argument is incorrect, the constructor may raise an exception
    
    @param name a valid argument name. May not be empty (1st form).
    @param type the member type (1st form).
    @param argloc the argument location. Can be empty (1st form).
    @param funcarg a funcarg_t to copy

ida_typeinf.funcarg_t.__ne__(self, r: "funcarg_t") -> bool

ida_typeinf.funcarg_t.argloc
    argument location

ida_typeinf.funcarg_t.cmt
    argument comment (may be empty)

ida_typeinf.funcarg_t.flags
    Function argument property bits 
            

ida_typeinf.funcarg_t.name
    argument name (may be empty)

ida_typeinf.funcarg_t.type
    argument type

ida_typeinf.funcargvec_t

ida_typeinf.funcargvec_t.__eq__(self, r: "funcargvec_t") -> bool

ida_typeinf.funcargvec_t.__getitem__(self, i: "size_t") -> "funcarg_t const &"

ida_typeinf.funcargvec_t.__init__(self, *args)

ida_typeinf.funcargvec_t.__len__(self) -> "size_t"

ida_typeinf.funcargvec_t.__ne__(self, r: "funcargvec_t") -> bool

ida_typeinf.funcargvec_t.__setitem__(self, i: "size_t", v: "funcarg_t") -> None

ida_typeinf.funcargvec_t._del(self, x: "funcarg_t") -> bool

ida_typeinf.funcargvec_t.add_unique(self, x: "funcarg_t") -> bool

ida_typeinf.funcargvec_t.append(self, x: "funcarg_t") -> None

ida_typeinf.funcargvec_t.at(self, _idx: "size_t") -> "funcarg_t const &"

ida_typeinf.funcargvec_t.begin(self, *args) -> "qvector< funcarg_t >::const_iterator"

ida_typeinf.funcargvec_t.capacity(self) -> "size_t"

ida_typeinf.funcargvec_t.clear(self) -> None

ida_typeinf.funcargvec_t.empty(self) -> bool

ida_typeinf.funcargvec_t.end(self, *args) -> "qvector< funcarg_t >::const_iterator"

ida_typeinf.funcargvec_t.erase(self, *args) -> "qvector< funcarg_t >::iterator"

ida_typeinf.funcargvec_t.extend(self, x: "funcargvec_t") -> None

ida_typeinf.funcargvec_t.extract(self) -> "funcarg_t *"

ida_typeinf.funcargvec_t.find(self, *args) -> "qvector< funcarg_t >::const_iterator"

ida_typeinf.funcargvec_t.grow(self, *args) -> None

ida_typeinf.funcargvec_t.has(self, x: "funcarg_t") -> bool

ida_typeinf.funcargvec_t.inject(self, s: "funcarg_t", len: "size_t") -> None

ida_typeinf.funcargvec_t.insert(self, it: "funcarg_t", x: "funcarg_t") -> "qvector< funcarg_t >::iterator"

ida_typeinf.funcargvec_t.pop_back(self) -> None

ida_typeinf.funcargvec_t.push_back(self, *args) -> "funcarg_t &"

ida_typeinf.funcargvec_t.qclear(self) -> None

ida_typeinf.funcargvec_t.reserve(self, cnt: "size_t") -> None

ida_typeinf.funcargvec_t.resize(self, *args) -> None

ida_typeinf.funcargvec_t.size(self) -> "size_t"

ida_typeinf.funcargvec_t.swap(self, r: "funcargvec_t") -> None

ida_typeinf.funcargvec_t.truncate(self) -> None

ida_typeinf.gcc_layout() -> bool
    Should use the struct/union layout as done by gcc?

ida_typeinf.gen_decorate_name(name: str, mangle: bool, cc: "cm_t", type: "tinfo_t") -> str
    Generic function for decorate_name() (may be used in IDP modules)

ida_typeinf.gen_use_arg_tinfos(_this: "argtinfo_helper_t", caller: ida_idaapi.ea_t, fti: "func_type_data_t", rargs: "funcargvec_t") -> None
    Do not call this function directly, use argtinfo_helper_t.

ida_typeinf.get_abi_name() -> str
    Get ABI name. 
            
    @returns length of the name (>=0)

ida_typeinf.get_alias_target(ti: "til_t", ordinal: int) -> int
    Find the final alias destination. If the ordinal has not been aliased, return the specified ordinal itself If failed, returns 0. 
            

ida_typeinf.get_arg_addrs(caller: ida_idaapi.ea_t)
    Retrieve addresses of argument initialization instructions
    
    @param caller: the address of the call instruction
    @return: list of instruction addresses

ida_typeinf.get_base_type(t: "type_t") -> "type_t"
    Get get basic type bits (TYPE_BASE_MASK)

ida_typeinf.get_c_header_path() -> str
    Get the include directory path of the target compiler.

ida_typeinf.get_c_macros() -> str
    Get predefined macros for the target compiler.

ida_typeinf.get_comp(comp: "comp_t") -> "comp_t"
    Get compiler bits.

ida_typeinf.get_compiler_abbr(id: "comp_t") -> str
    Get abbreviated compiler name.

ida_typeinf.get_compiler_name(id: "comp_t") -> str
    Get full compiler name.

ida_typeinf.get_compilers(ids: "compvec_t *", names: "qstrvec_t *", abbrs: "qstrvec_t *") -> None
    Get names of all built-in compilers.

ida_typeinf.get_enum_member_expr(tif: "tinfo_t", serial: int, value: "uint64") -> str
    Return a C expression that can be used to represent an enum member. If the value does not correspond to any single enum member, this function tries to find a bitwise combination of enum members that correspond to it. If more than half of value bits do not match any enum members, it fails. 
            
    @param tif: enumeration type
    @param serial: which enumeration member to use (0 means the first with the given value)
    @param value: value to search in the enumeration type
    @returns success

ida_typeinf.get_full_type(t: "type_t") -> "type_t"
    Get basic type bits + type flags (TYPE_FULL_MASK)

ida_typeinf.get_idainfo_by_type(tif: "tinfo_t") -> "size_t *, flags64_t *, opinfo_t *, size_t *"
    Extract information from a tinfo_t. 
            
    @param tif: the type to inspect

ida_typeinf.get_idainfo_by_udm(*args) -> bool
    Calculate IDA info from udt member 
            
    @param udm: udt member
    @param refinfo_ea: if specified will be used to adjust the refinfo_t data

ida_typeinf.get_idati() -> "til_t *"
    Pointer to the local type library - this til is private for each IDB file Functions that accept til_t* default to `idati` when is nullptr provided. 
            

ida_typeinf.get_named_type(til: til_t, name: str, ntf_flags: int)
    Get a type data by its name.
    
    @param til: Type library
    @param name: the type name
    @param ntf_flags: a combination of NTF_* constants
    @return:
        None on failure
        tuple(code, type_str, fields_str, cmt, field_cmts, sclass, value) on success

ida_typeinf.get_named_type64(til: til_t, name: str, ntf_flags: int = 0) -> Union[Tuple[int, bytes, bytes, str, str, int, int], None]
    Get a named type from a type library.
    
    Please use til_t.get_named_type instead.

ida_typeinf.get_named_type_tid(name: str) -> "tid_t"
    Get named local type TID 
            
    @param name: type name
    @returns TID or BADADDR

ida_typeinf.get_numbered_type(til: til_t, ordinal: int) -> Union[Tuple[bytes, bytes, str, str, int], None]
    Get a type from a type library, by its ordinal
    
    Please use til_t.get_numbered_type instead.

ida_typeinf.get_numbered_type_name(ti: "til_t", ordinal: int) -> str
    Get type name (if exists) by its ordinal. If the type is anonymous, returns "". If failed, returns nullptr 
            

ida_typeinf.get_ordinal_count(ti: "til_t" = None) -> int
    Get number of allocated ordinals. 
            
    @param ti: type library; nullptr means the local types for the current database.
    @returns 0 if ordinals have not been enabled for the til.

ida_typeinf.get_ordinal_limit(ti: "til_t" = None) -> int
    Get number of allocated ordinals + 1. If there are no allocated ordinals, return 0. To enumerate all ordinals, use: for ( uint32 i = 1; i < limit; ++i ) 
            
    @param ti: type library; nullptr means the local types for the current database.
    @returns uint32(-1) if ordinals have not been enabled for the til. For local types (idati), ordinals are always enabled.

ida_typeinf.get_scalar_bt(size: int) -> "type_t"

ida_typeinf.get_stock_tinfo(tif: "tinfo_t", id: "stock_type_id_t") -> bool

ida_typeinf.get_tid_name(tid: "tid_t") -> str
    Get a type name for the specified TID 
            
    @param tid: type TID
    @returns true if there is type with TID

ida_typeinf.get_tid_ordinal(tid: "tid_t") -> int
    Get type ordinal number for TID 
            
    @param tid: type/enum constant/udt member TID
    @returns type ordinal number or 0

ida_typeinf.get_tinfo_attr(typid: "typid_t", key: str, bv: "bytevec_t *", all_attrs: bool) -> bool

ida_typeinf.get_tinfo_attrs(typid: "typid_t", tav: "type_attrs_t", include_ref_attrs: bool) -> bool

ida_typeinf.get_tinfo_by_edm_name(tif: "tinfo_t", til: "til_t", mname: str) -> "ssize_t"

ida_typeinf.get_tinfo_by_flags(out: "tinfo_t", flags: "flags64_t") -> bool
    Get tinfo object that corresponds to data flags 
            
    @param out: type info
    @param flags: simple flags (byte, word, ..., zword)

ida_typeinf.get_tinfo_details(typid: "typid_t", bt2: "type_t", buf: "void *") -> bool

ida_typeinf.get_tinfo_pdata(outptr: "void *", typid: "typid_t", what: int) -> "size_t"

ida_typeinf.get_tinfo_property(typid: "typid_t", gta_prop: int) -> "size_t"

ida_typeinf.get_tinfo_property4(typid: "typid_t", gta_prop: int, p1: "size_t", p2: "size_t", p3: "size_t", p4: "size_t") -> "size_t"

ida_typeinf.get_tinfo_size(p_effalign: "uint32 *", typid: "typid_t", gts_code: int) -> "size_t"

ida_typeinf.get_type_flags(t: "type_t") -> "type_t"
    Get type flags (TYPE_FLAGS_MASK)

ida_typeinf.get_type_ordinal(ti: "til_t", name: str) -> int
    Get type ordinal by its name.

ida_typeinf.get_udm_by_fullname(udm: "udm_t", fullname: str) -> "ssize_t"
    Get udt member by full name 
            
    @param udm: member, can be NULL
    @param fullname: udt member name in format <udt name>.<member name>
    @returns member index into udt_type_data_t or -1

ida_typeinf.get_vftable_ea(ordinal: int) -> ida_idaapi.ea_t
    Get address of a virtual function table. 
            
    @param ordinal: ordinal number of a vftable type.
    @returns address of the corresponding virtual function table in the current database.

ida_typeinf.get_vftable_ordinal(vftable_ea: ida_idaapi.ea_t) -> int
    Get ordinal number of the virtual function table. 
            
    @param vftable_ea: address of a virtual function table.
    @returns ordinal number of the corresponding vftable type. 0 - failure.

ida_typeinf.guess_func_cc(fti: "func_type_data_t", npurged: int, cc_flags: int) -> "cm_t"
    Use func_type_data_t::guess_cc()

ida_typeinf.guess_tinfo(out: "tinfo_t", id: "tid_t") -> int
    Generate a type information about the id from the disassembly. id can be a structure/union/enum id or an address. 
            
    @returns one of Guess tinfo codes

ida_typeinf.ida_lowertype_helper_t

ida_typeinf.ida_lowertype_helper_t.__init__(self, _tif: "tinfo_t", _ea: ida_idaapi.ea_t, _pb: int)

ida_typeinf.ida_lowertype_helper_t.func_has_stkframe_hole(self, candidate: "tinfo_t", candidate_data: "func_type_data_t") -> bool

ida_typeinf.ida_lowertype_helper_t.get_func_purged_bytes(self, candidate: "tinfo_t", arg3: "func_type_data_t") -> int

ida_typeinf.idc_get_local_type(ordinal: int, flags: int) -> str

ida_typeinf.idc_get_local_type_name(ordinal: int) -> str

ida_typeinf.idc_get_local_type_raw(ordinal) -> Tuple[bytes, bytes]
    

ida_typeinf.idc_get_type(ea: ida_idaapi.ea_t) -> str

ida_typeinf.idc_get_type_raw(ea: ida_idaapi.ea_t) -> "PyObject *"

ida_typeinf.idc_guess_type(ea: ida_idaapi.ea_t) -> str

ida_typeinf.idc_parse_decl(til: til_t, decl: str, flags: int) -> Tuple[str, bytes, bytes]
    

ida_typeinf.idc_parse_types(input: str, flags: int) -> int

ida_typeinf.idc_print_type(type: bytes, fields: bytes, name: str, flags: int) -> str
    

ida_typeinf.idc_set_local_type(ordinal: int, dcl: str, flags: int) -> int

ida_typeinf.inf_big_arg_align(*args) -> bool

ida_typeinf.inf_huge_arg_align(*args) -> bool

ida_typeinf.inf_pack_stkargs(*args) -> bool

ida_typeinf.is_code_far(cm: "cm_t") -> bool
    Does the given model specify far code?.

ida_typeinf.is_comp_unsure(comp: "comp_t") -> "comp_t"
    See COMP_UNSURE.

ida_typeinf.is_data_far(cm: "cm_t") -> bool
    Does the given model specify far data?.

ida_typeinf.is_gcc() -> bool
    Is the target compiler COMP_GNU?

ida_typeinf.is_gcc32() -> bool
    Is the target compiler 32 bit gcc?

ida_typeinf.is_gcc64() -> bool
    Is the target compiler 64 bit gcc?

ida_typeinf.is_golang_cc(cc: "cm_t") -> bool
    GO language calling convention (return value in stack)?

ida_typeinf.is_one_bit_mask(mask: int) -> bool
    Is bitmask one bit?

ida_typeinf.is_ordinal_name(name: str, ord: "uint32 *" = None) -> bool
    Check if the name is an ordinal name. Ordinal names have the following format: '#' + set_de(ord) 
            

ida_typeinf.is_purging_cc(cm: "cm_t") -> bool
    Does the calling convention clean the stack arguments upon return?. 
            

ida_typeinf.is_restype_enum(til: "til_t", type: "type_t const *") -> bool

ida_typeinf.is_restype_struct(til: "til_t", type: "type_t const *") -> bool

ida_typeinf.is_restype_struni(til: "til_t", type: "type_t const *") -> bool

ida_typeinf.is_restype_void(til: "til_t", type: "type_t const *") -> bool

ida_typeinf.is_sdacl_byte(t: "type_t") -> bool
    Identify an sdacl byte. The first sdacl byte has the following format: 11xx000x. The sdacl bytes are appended to udt fields. They indicate the start of type attributes (as the tah-bytes do). The sdacl bytes are used in the udt headers instead of the tah-byte. This is done for compatibility with old databases, they were already using sdacl bytes in udt headers and as udt field postfixes. (see "sdacl-typeattrs" in the type bit definitions) 
            

ida_typeinf.is_swift_cc(cc: "cm_t") -> bool
    Swift calling convention (arguments and return values in registers)?

ida_typeinf.is_tah_byte(t: "type_t") -> bool
    The TAH byte (type attribute header byte) denotes the start of type attributes. (see "tah-typeattrs" in the type bit definitions) 
            

ida_typeinf.is_type_arithmetic(t: "type_t") -> bool
    Is the type an arithmetic type? (floating or integral)

ida_typeinf.is_type_array(t: "type_t") -> bool
    See BT_ARRAY.

ida_typeinf.is_type_bitfld(t: "type_t") -> bool
    See BT_BITFIELD.

ida_typeinf.is_type_bool(t: "type_t") -> bool
    See BTF_BOOL.

ida_typeinf.is_type_char(t: "type_t") -> bool
    Does the type specify a char value? (signed or unsigned, see Basic type: integer)

ida_typeinf.is_type_choosable(ti: "til_t", ordinal: int) -> bool
    Check if a struct/union type is choosable 
            
    @param ti: type library
    @param ordinal: ordinal number of a UDT type

ida_typeinf.is_type_complex(t: "type_t") -> bool
    See BT_COMPLEX.

ida_typeinf.is_type_const(t: "type_t") -> bool
    See BTM_CONST.

ida_typeinf.is_type_double(t: "type_t") -> bool
    See BTF_DOUBLE.

ida_typeinf.is_type_enum(t: "type_t") -> bool
    See BTF_ENUM.

ida_typeinf.is_type_ext_arithmetic(t: "type_t") -> bool
    Is the type an extended arithmetic type? (arithmetic or enum)

ida_typeinf.is_type_ext_integral(t: "type_t") -> bool
    Is the type an extended integral type? (integral or enum)

ida_typeinf.is_type_float(t: "type_t") -> bool
    See BTF_FLOAT.

ida_typeinf.is_type_floating(t: "type_t") -> bool
    Is the type a floating point type?

ida_typeinf.is_type_func(t: "type_t") -> bool
    See BT_FUNC.

ida_typeinf.is_type_int(bt: "type_t") -> bool
    Does the type_t specify one of the basic types in Basic type: integer?

ida_typeinf.is_type_int128(t: "type_t") -> bool
    Does the type specify a 128-bit value? (signed or unsigned, see Basic type: integer)

ida_typeinf.is_type_int16(t: "type_t") -> bool
    Does the type specify a 16-bit value? (signed or unsigned, see Basic type: integer)

ida_typeinf.is_type_int32(t: "type_t") -> bool
    Does the type specify a 32-bit value? (signed or unsigned, see Basic type: integer)

ida_typeinf.is_type_int64(t: "type_t") -> bool
    Does the type specify a 64-bit value? (signed or unsigned, see Basic type: integer)

ida_typeinf.is_type_integral(t: "type_t") -> bool
    Is the type an integral type (char/short/int/long/bool)?

ida_typeinf.is_type_ldouble(t: "type_t") -> bool
    See BTF_LDOUBLE.

ida_typeinf.is_type_paf(t: "type_t") -> bool
    Is the type a pointer, array, or function type?

ida_typeinf.is_type_partial(t: "type_t") -> bool
    Identifies an unknown or void type with a known size (see Basic type: unknown & void)

ida_typeinf.is_type_ptr(t: "type_t") -> bool
    See BT_PTR.

ida_typeinf.is_type_ptr_or_array(t: "type_t") -> bool
    Is the type a pointer or array type?

ida_typeinf.is_type_struct(t: "type_t") -> bool
    See BTF_STRUCT.

ida_typeinf.is_type_struni(t: "type_t") -> bool
    Is the type a struct or union?

ida_typeinf.is_type_sue(t: "type_t") -> bool
    Is the type a struct/union/enum?

ida_typeinf.is_type_tbyte(t: "type_t") -> bool
    See BTF_FLOAT.

ida_typeinf.is_type_typedef(t: "type_t") -> bool
    See BTF_TYPEDEF.

ida_typeinf.is_type_uchar(t: "type_t") -> bool
    See BTF_UCHAR.

ida_typeinf.is_type_uint(t: "type_t") -> bool
    See BTF_UINT.

ida_typeinf.is_type_uint128(t: "type_t") -> bool
    See BTF_UINT128.

ida_typeinf.is_type_uint16(t: "type_t") -> bool
    See BTF_UINT16.

ida_typeinf.is_type_uint32(t: "type_t") -> bool
    See BTF_UINT32.

ida_typeinf.is_type_uint64(t: "type_t") -> bool
    See BTF_UINT64.

ida_typeinf.is_type_union(t: "type_t") -> bool
    See BTF_UNION.

ida_typeinf.is_type_unknown(t: "type_t") -> bool
    See BT_UNKNOWN.

ida_typeinf.is_type_void(t: "type_t") -> bool
    See BTF_VOID.

ida_typeinf.is_type_volatile(t: "type_t") -> bool
    See BTM_VOLATILE.

ida_typeinf.is_typeid_last(t: "type_t") -> bool
    Is the type_t the last byte of type declaration? (there are no additional bytes after a basic type, see _BT_LAST_BASIC) 
            

ida_typeinf.is_user_cc(cm: "cm_t") -> bool
    Does the calling convention specify argument locations explicitly?

ida_typeinf.is_vararg_cc(cm: "cm_t") -> bool
    Does the calling convention use ellipsis?

ida_typeinf.lexcompare_tinfo(t1: "typid_t", t2: "typid_t", arg3: int) -> int

ida_typeinf.load_til(name: str, tildir: str = None) -> str
    Load til from a file without adding it to the database list (see also add_til). Failure to load base tils are reported into 'errbuf'. They do not prevent loading of the main til. 
            
    @param name: filename of the til. If it's an absolute path, tildir is ignored.
    * NB: the file extension is forced to .til
    @param tildir: directory where to load the til from. nullptr means default til subdirectories.
    @returns pointer to resulting til, nullptr if failed and error message is in errbuf

ida_typeinf.load_til_header(tildir: str, name: str) -> str
    Get human-readable til description.

ida_typeinf.lower_type(til: "til_t", tif: "tinfo_t", name: str = None, _helper: "lowertype_helper_t" = None) -> int
    Lower type. Inspect the type and lower all function subtypes using lower_func_type(). 
    We call the prototypes usually encountered in source files "high level" 
    They may have implicit arguments, array arguments, big structure retvals, etc 
    We introduce explicit arguments (i.e. 'this' pointer) and call the result 
    "low level prototype". See FTI_HIGH.
    In order to improve heuristics for recognition of big structure retvals, 
    it is recommended to pass a helper that will be used to make decisions. 
    That helper will be used only for lowering 'tif', and not for the children 
    types walked through by recursion. 
            
    @retval 1: removed FTI_HIGH,
    @retval 2: made substantial changes
    @retval -1: failure

ida_typeinf.lowertype_helper_t

ida_typeinf.lowertype_helper_t.__init__(self, *args, **kwargs)

ida_typeinf.lowertype_helper_t.func_has_stkframe_hole(self, candidate: "tinfo_t", candidate_data: "func_type_data_t") -> bool

ida_typeinf.lowertype_helper_t.get_func_purged_bytes(self, candidate: "tinfo_t", candidate_data: "func_type_data_t") -> int

ida_typeinf.new_til(name: str, desc: str) -> "til_t *"
    Initialize a til.

ida_typeinf.next_named_type(ti: "til_t", name: str, ntf_flags: int) -> str
    Enumerate types. 
            
    @param ti: type library. nullptr means the local type library for the current database.
    @param name: the current name. the name that follows this one will be returned.
    @param ntf_flags: combination of Flags for named types
    @returns Type or symbol names, depending of ntf_flags. Returns mangled names. Never returns anonymous types. To include them, enumerate types by ordinals.

ida_typeinf.no_sign
    no sign, or unknown

ida_typeinf.optimize_argloc(vloc: "argloc_t", size: int, gaps: "rangeset_t") -> bool
    Verify and optimize scattered argloc into simple form. All new arglocs must be processed by this function. 
            
    @retval true: success
    @retval false: the input argloc was illegal

ida_typeinf.pack_idcobj_to_bv(obj: "idc_value_t const *", tif: "tinfo_t", bytes: "relobj_t", objoff: "void *", pio_flags: int = 0) -> "error_t"
    Write a typed idc object to the byte vector. Byte vector may be non-empty, this function will append data to it 
            

ida_typeinf.pack_idcobj_to_idb(obj: "idc_value_t const *", tif: "tinfo_t", ea: ida_idaapi.ea_t, pio_flags: int = 0) -> "error_t"
    Write a typed idc object to the database.

ida_typeinf.pack_object_to_bv(obj, til: til_t, type: bytes, fields: bytes, base_ea: ida_idaapi.ea_t, pio_flags: int = 0)
    Packs a typed object to a string
    
    @param til: Type library. 'None' can be passed.
    @param type: type string
    @param fields: fields string (may be empty or None)
    @param base_ea: base ea used to relocate the pointers in the packed object
    @param pio_flags: flags used while unpacking
    @return:
        tuple(0, err_code) on failure
        tuple(1, packed_buf) on success

ida_typeinf.pack_object_to_idb(obj, til: til_t, type: bytes, fields: bytes, ea: ida_idaapi.ea_t, pio_flags: int = 0)
    Write a typed object to the database.
    Raises an exception if wrong parameters were passed or conversion fails
    Returns the error_t returned by idaapi.pack_object_to_idb
    
    @param til: Type library. 'None' can be passed.
    @param type: type string
    @param fields: fields string (may be empty or None)
    @param ea: ea to be used while packing
    @param pio_flags: flags used while unpacking

ida_typeinf.parse_decl(out_tif: "tinfo_t", til: "til_t", decl: str, pt_flags: int) -> str
    Parse ONE declaration. If the input string contains more than one declaration, the first complete type declaration (PT_TYP) or the last variable declaration (PT_VAR) will be used. 
            
    @param out_tif: type info
    @param til: type library to use. may be nullptr
    @param decl: C declaration to parse
    @param pt_flags: combination of Type parsing flags bits
    @retval true: ok
    @retval false: declaration is bad, the error message is displayed if !PT_SIL

ida_typeinf.parse_decls(til: "til_t", input: str, printer: "printer_t *", hti_flags: int) -> int
    Parse many declarations and store them in a til. If there are any errors, they will be printed using 'printer'. This function uses default include path and predefined macros from the database settings. It always uses the HTI_DCL bit. 
            
    @param til: type library to store the result
    @param input: input string or file name (see hti_flags)
    @param printer: function to output error messages (use msg or nullptr or your own callback)
    @param hti_flags: combination of Type formatting flags
    @returns number of errors, 0 means ok.

ida_typeinf.predicate_t

ida_typeinf.predicate_t.__disown__(self)

ida_typeinf.predicate_t.__init__(self)

ida_typeinf.predicate_t.should_display(self, til: "til_t", name: str, type: "type_t const *", fields: "p_list const *") -> bool

ida_typeinf.print_argloc(vloc: "argloc_t", size: int = 0, vflags: int = 0) -> "size_t"
    Convert an argloc to human readable form.

ida_typeinf.print_decls(printer: text_sink_t, til: til_t, ordinals: List[int], flags: int) -> int
    Print types (and possibly their dependencies) in a format suitable for using in
    a header file. This is the reverse parse_decls().
    
    @param printer a handler for printing text
    @param til the type library holding the ordinals
    @param ordinals a list of ordinals corresponding to the types to print
    @param flags a combination of PDF_ constants
    @return
            >0: the number of types exported
             0: an error occurred
            <0: the negated number of types exported. There were minor errors and
                the resulting output might not be compilable.

ida_typeinf.print_tinfo(prefix: str, indent: int, cmtindent: int, flags: int, tif: "tinfo_t", name: str, cmt: str) -> str

ida_typeinf.print_type(ea: ida_idaapi.ea_t, prtype_flags: int) -> str
    Get type declaration for the specified address. 
            
    @param ea: address
    @param prtype_flags: combination of Type printing flags
    @returns success

ida_typeinf.ptr_type_data_t

ida_typeinf.ptr_type_data_t.__eq__(self, r: "ptr_type_data_t") -> bool

ida_typeinf.ptr_type_data_t.__init__(self, *args)

ida_typeinf.ptr_type_data_t.__ne__(self, r: "ptr_type_data_t") -> bool

ida_typeinf.ptr_type_data_t.closure
    cannot have both closure and based_ptr_size

ida_typeinf.ptr_type_data_t.delta
    Offset from the beginning of the parent struct.

ida_typeinf.ptr_type_data_t.is_code_ptr(self) -> bool
    Are we pointing to code?

ida_typeinf.ptr_type_data_t.is_shifted(self) -> bool

ida_typeinf.ptr_type_data_t.obj_type
    pointed object type

ida_typeinf.ptr_type_data_t.parent
    Parent struct.

ida_typeinf.ptr_type_data_t.swap(self, r: "ptr_type_data_t") -> None
    Set this = r and r = this.

ida_typeinf.ptr_type_data_t.taptr_bits
    TAH bits.

ida_typeinf.read_tinfo_bitfield_value(typid: "typid_t", v: "uint64", bitoff: int) -> "uint64"

ida_typeinf.reginfovec_t

ida_typeinf.reginfovec_t.__eq__(self, r: "reginfovec_t") -> bool

ida_typeinf.reginfovec_t.__getitem__(self, i: "size_t") -> "reg_info_t const &"

ida_typeinf.reginfovec_t.__init__(self, *args)

ida_typeinf.reginfovec_t.__len__(self) -> "size_t"

ida_typeinf.reginfovec_t.__ne__(self, r: "reginfovec_t") -> bool

ida_typeinf.reginfovec_t.__setitem__(self, i: "size_t", v: "reg_info_t") -> None

ida_typeinf.reginfovec_t._del(self, x: "reg_info_t") -> bool

ida_typeinf.reginfovec_t.add_unique(self, x: "reg_info_t") -> bool

ida_typeinf.reginfovec_t.append(self, x: "reg_info_t") -> None

ida_typeinf.reginfovec_t.at(self, _idx: "size_t") -> "reg_info_t const &"

ida_typeinf.reginfovec_t.begin(self, *args) -> "qvector< reg_info_t >::const_iterator"

ida_typeinf.reginfovec_t.capacity(self) -> "size_t"

ida_typeinf.reginfovec_t.clear(self) -> None

ida_typeinf.reginfovec_t.empty(self) -> bool

ida_typeinf.reginfovec_t.end(self, *args) -> "qvector< reg_info_t >::const_iterator"

ida_typeinf.reginfovec_t.erase(self, *args) -> "qvector< reg_info_t >::iterator"

ida_typeinf.reginfovec_t.extend(self, x: "reginfovec_t") -> None

ida_typeinf.reginfovec_t.extract(self) -> "reg_info_t *"

ida_typeinf.reginfovec_t.find(self, *args) -> "qvector< reg_info_t >::const_iterator"

ida_typeinf.reginfovec_t.grow(self, *args) -> None

ida_typeinf.reginfovec_t.has(self, x: "reg_info_t") -> bool

ida_typeinf.reginfovec_t.inject(self, s: "reg_info_t", len: "size_t") -> None

ida_typeinf.reginfovec_t.insert(self, it: "reg_info_t", x: "reg_info_t") -> "qvector< reg_info_t >::iterator"

ida_typeinf.reginfovec_t.pop_back(self) -> None

ida_typeinf.reginfovec_t.push_back(self, *args) -> "reg_info_t &"

ida_typeinf.reginfovec_t.qclear(self) -> None

ida_typeinf.reginfovec_t.reserve(self, cnt: "size_t") -> None

ida_typeinf.reginfovec_t.resize(self, *args) -> None

ida_typeinf.reginfovec_t.size(self) -> "size_t"

ida_typeinf.reginfovec_t.swap(self, r: "reginfovec_t") -> None

ida_typeinf.reginfovec_t.truncate(self) -> None

ida_typeinf.regobj_t

ida_typeinf.regobj_t.__init__(self)

ida_typeinf.regobj_t.regidx
    index into dbg->registers

ida_typeinf.regobj_t.relocate
    0-plain num, 1-must relocate

ida_typeinf.regobj_t.size(self) -> "size_t"

ida_typeinf.regobjs_t

ida_typeinf.regobjs_t.__init__(self)

ida_typeinf.regobjvec_t

ida_typeinf.regobjvec_t.__getitem__(self, i: "size_t") -> "regobj_t const &"

ida_typeinf.regobjvec_t.__init__(self, *args)

ida_typeinf.regobjvec_t.__len__(self) -> "size_t"

ida_typeinf.regobjvec_t.__setitem__(self, i: "size_t", v: "regobj_t") -> None

ida_typeinf.regobjvec_t.append(self, x: "regobj_t") -> None

ida_typeinf.regobjvec_t.at(self, _idx: "size_t") -> "regobj_t const &"

ida_typeinf.regobjvec_t.begin(self, *args) -> "qvector< regobj_t >::const_iterator"

ida_typeinf.regobjvec_t.capacity(self) -> "size_t"

ida_typeinf.regobjvec_t.clear(self) -> None

ida_typeinf.regobjvec_t.empty(self) -> bool

ida_typeinf.regobjvec_t.end(self, *args) -> "qvector< regobj_t >::const_iterator"

ida_typeinf.regobjvec_t.erase(self, *args) -> "qvector< regobj_t >::iterator"

ida_typeinf.regobjvec_t.extend(self, x: "regobjvec_t") -> None

ida_typeinf.regobjvec_t.extract(self) -> "regobj_t *"

ida_typeinf.regobjvec_t.grow(self, *args) -> None

ida_typeinf.regobjvec_t.inject(self, s: "regobj_t", len: "size_t") -> None

ida_typeinf.regobjvec_t.insert(self, it: "regobj_t", x: "regobj_t") -> "qvector< regobj_t >::iterator"

ida_typeinf.regobjvec_t.pop_back(self) -> None

ida_typeinf.regobjvec_t.push_back(self, *args) -> "regobj_t &"

ida_typeinf.regobjvec_t.qclear(self) -> None

ida_typeinf.regobjvec_t.reserve(self, cnt: "size_t") -> None

ida_typeinf.regobjvec_t.resize(self, *args) -> None

ida_typeinf.regobjvec_t.size(self) -> "size_t"

ida_typeinf.regobjvec_t.swap(self, r: "regobjvec_t") -> None

ida_typeinf.regobjvec_t.truncate(self) -> None

ida_typeinf.remove_abi_opts(abi_opts: str, user_level: bool = False) -> bool

ida_typeinf.remove_pointer(tif: "tinfo_t") -> "tinfo_t"
    BT_PTR: If the current type is a pointer, return the pointed object. If the current type is not a pointer, return the current type. See also get_ptrarr_object() and get_pointed_object() 
            

ida_typeinf.remove_tinfo_pointer(tif: tinfo_t, name: str, til: til_t) -> Tuple[bool, str]
    Remove pointer of a type. (i.e. convert "char *" into "char"). Optionally remove
    the "lp" (or similar) prefix of the input name. If the input type is not a
    pointer, then fail.
    
    @param tif the type info
    @param name the name of the type to "unpointerify"
    @param til the type library
    @return a tuple (success, new-name)

ida_typeinf.replace_ordinal_typerefs(til: "til_t", tif: "tinfo_t") -> int
    Replace references to ordinal types by name references. This function 'unties' the type from the current local type library and makes it easier to export it. 
            
    @param til: type library to use. may be nullptr.
    @param tif: type to modify (in/out)
    @retval number: of replaced subtypes, -1 on failure

ida_typeinf.resolve_typedef(til: "til_t", type: "type_t const *") -> "type_t const *"

ida_typeinf.rrel_t

ida_typeinf.rrel_t.__init__(self)

ida_typeinf.rrel_t.off
    displacement from the address pointed by the register

ida_typeinf.rrel_t.reg
    register index (into ph.reg_names)

ida_typeinf.save_tinfo(tif: "tinfo_t", til: "til_t", ord: "size_t", name: str, ntf_flags: int) -> "tinfo_code_t"

ida_typeinf.scattered_aloc_t

ida_typeinf.scattered_aloc_t.__init__(self)

ida_typeinf.score_tinfo(tif: "tinfo_t") -> int

ida_typeinf.serialize_tinfo(type: "qtype *", fields: "qtype *", fldcmts: "qtype *", tif: "tinfo_t", sudt_flags: int) -> bool

ida_typeinf.set_abi_name(abiname: str, user_level: bool = False) -> bool
    Set abi name (see Compiler IDs)

ida_typeinf.set_c_header_path(incdir: str) -> None
    Set include directory path the target compiler.

ida_typeinf.set_c_macros(macros: str) -> None
    Set predefined macros for the target compiler.

ida_typeinf.set_compiler(cc: "compiler_info_t", flags: int, abiname: str = None) -> bool
    Change current compiler. 
            
    @param cc: compiler to switch to
    @param flags: Set compiler flags
    @param abiname: ABI name
    @returns success

ida_typeinf.set_compiler_id(id: "comp_t", abiname: str = None) -> bool
    Set the compiler id (see Compiler IDs)

ida_typeinf.set_compiler_string(compstr: str, user_level: bool) -> bool
    @param compstr: - compiler description in form <abbr>:<abiname>
    @param user_level: - initiated by user if TRUE
    @returns success

ida_typeinf.set_numbered_type(ti: "til_t", ordinal: int, ntf_flags: int, name: str, type: "type_t const *", fields: "p_list const *" = None, cmt: str = None, fldcmts: "p_list const *" = None, sclass: "sclass_t const *" = None) -> "tinfo_code_t"

ida_typeinf.set_tinfo_attr(tif: "tinfo_t", ta: "type_attr_t", may_overwrite: bool) -> bool

ida_typeinf.set_tinfo_attrs(tif: "tinfo_t", ta: "type_attrs_t") -> bool

ida_typeinf.set_tinfo_property(tif: "tinfo_t", sta_prop: int, x: "size_t") -> "size_t"

ida_typeinf.set_tinfo_property4(tif: "tinfo_t", sta_prop: int, p1: "size_t", p2: "size_t", p3: "size_t", p4: "size_t") -> "size_t"

ida_typeinf.set_type_alias(ti: "til_t", src_ordinal: int, dst_ordinal: int) -> bool
    Create a type alias. Redirects all references to source type to the destination type. This is equivalent to instantaneous replacement all references to srctype by dsttype. 
            

ida_typeinf.set_type_choosable(ti: "til_t", ordinal: int, value: bool) -> None
    Enable/disable 'choosability' flag for a struct/union type 
            
    @param ti: type library
    @param ordinal: ordinal number of a UDT type
    @param value: flag value

ida_typeinf.set_vftable_ea(ordinal: int, vftable_ea: ida_idaapi.ea_t) -> bool
    Set the address of a vftable instance for a vftable type. 
            
    @param ordinal: ordinal number of the corresponding vftable type.
    @param vftable_ea: address of a virtual function table.
    @returns success

ida_typeinf.simd_info_t

ida_typeinf.simd_info_t.__init__(self, *args)

ida_typeinf.simd_info_t.match_pattern(self, pattern: "simd_info_t") -> bool

ida_typeinf.simd_info_t.memtype
    member type BTF_INT8/16/32/64/128, BTF_UINT8/16/32/64/128 BTF_INT - integrals of any size/sign BTF_FLOAT, BTF_DOUBLE BTF_TBYTE - floatings of any size BTF_UNION - union of integral and floating types BTF_UNK - undefined 
            

ida_typeinf.simd_info_t.name
    name of SIMD type (nullptr-undefined)

ida_typeinf.simd_info_t.size
    SIMD type size in bytes (0-undefined)

ida_typeinf.simd_info_t.tif
    SIMD type (empty-undefined)

ida_typeinf.stkarg_area_info_t

ida_typeinf.stkarg_area_info_t.__init__(self)

ida_typeinf.stkarg_area_info_t.linkage_area
    Size of the linkage area. explanations at: [https://www.ibm.com/docs/en/xl-fortran-aix/16.1.0?topic=conventions-linkage-area](https://www.ibm.com/docs/en/xl-fortran-aix/16.1.0?topic=conventions-linkage-area) examples: pc: 0, hppa: 0, ppc aix: 0x18 (equal to stkarg_offset) 
            

ida_typeinf.stkarg_area_info_t.shadow_size
    Size of the shadow area. explanations at: [https://stackoverflow.com/questions/30190132/what-is-the-shadow-space-in-x64-assembly](https://stackoverflow.com/questions/30190132/what-is-the-shadow-space-in-x64-assembly) examples: x64 Visual Studio C++: 0x20, x64 gcc: 0, ppc aix: 0x20 
            

ida_typeinf.stkarg_area_info_t.stkarg_offset
    Offset from the SP to the first stack argument (can include linkage area) examples: pc: 0, hppa: -0x34, ppc aix: 0x18 
            

ida_typeinf.store_til(ti: "til_t", tildir: str, name: str) -> bool
    Store til to a file. If the til contains garbage, it will be collected before storing the til. Your plugin should call compact_til() before calling store_til(). 
            
    @param ti: type library to store
    @param tildir: directory where to store the til. nullptr means current directory.
    @param name: filename of the til. If it's an absolute path, tildir is ignored.
    * NB: the file extension is forced to .til
    @returns success

ida_typeinf.stroff_as_size(plen: int, tif: "tinfo_t", value: "asize_t") -> bool
    Should display a structure offset expression as the structure size?

ida_typeinf.switch_to_golang() -> None
    switch to GOLANG calling convention (to be used as default CC)

ida_typeinf.text_sink_t

ida_typeinf.text_sink_t.__disown__(self)

ida_typeinf.text_sink_t.__init__(self)

ida_typeinf.text_sink_t._print(self, str: str) -> int

ida_typeinf.til_symbol_t

ida_typeinf.til_symbol_t.__init__(self, n: str = None, t: "til_t" = None)

ida_typeinf.til_symbol_t.name
    symbol name

ida_typeinf.til_symbol_t.til
    pointer to til

ida_typeinf.til_t

ida_typeinf.til_t.__eq__(self, r: "til_t") -> bool

ida_typeinf.til_t.__init__(self)

ida_typeinf.til_t.__ne__(self, r: "til_t") -> bool

ida_typeinf.til_t.base(self, n: int) -> "til_t *"

ida_typeinf.til_t.cc
    information about the target compiler

ida_typeinf.til_t.desc
    human readable til description

ida_typeinf.til_t.find_base(self, n: str) -> "til_t *"
    Find the base til with the provided name 
            
    @param n: the base til name
    @returns the found til_t, or nullptr

ida_typeinf.til_t.flags
    Type info library property bits 
            

ida_typeinf.til_t.get_named_type(self, name)
    Retrieves a tinfo_t representing the named type in this type library.
    
    @param name a type name
    @return a new tinfo_t object, or None if not found

ida_typeinf.til_t.get_numbered_type(self, ordinal)
    Retrieves a tinfo_t representing the numbered type in this type library.
    
    @param ordinal a type ordinal
    @return a new tinfo_t object, or None if not found

ida_typeinf.til_t.get_type_names(self)

ida_typeinf.til_t.import_type(self, src)
    Import a type (and all its dependencies) into this type info library.
    
    @param src The type to import
    @return the imported copy, or None

ida_typeinf.til_t.is_dirty(self) -> bool
    Has the til been modified? (TIL_MOD)

ida_typeinf.til_t.name
    short file name (without path and extension)

ida_typeinf.til_t.named_types(self)
    Returns a generator over the named types contained in this
    type library.
    
    Every iteration returns a fresh new tinfo_t object
    
    @return a tinfo_t-producing generator

ida_typeinf.til_t.nbases
    number of base tils

ida_typeinf.til_t.nrefs
    number of references to the til

ida_typeinf.til_t.nstreams
    number of extra streams

ida_typeinf.til_t.numbered_types(self)
    Returns a generator over the numbered types contained in this
    type library.
    
    Every iteration returns a fresh new tinfo_t object
    
    @return a tinfo_t-producing generator

ida_typeinf.til_t.set_dirty(self) -> None
    Mark the til as modified (TIL_MOD)

ida_typeinf.til_t.streams
    symbol stream storage

ida_typeinf.til_type_ref_t

ida_typeinf.til_type_ref_t.__init__(self)

ida_typeinf.til_type_ref_t.clear(self) -> None

ida_typeinf.til_type_ref_t.edm
    BTF_ENUM: the current enum member.

ida_typeinf.til_type_ref_t.fa
    BT_FUNC: the current argument, nullptr - ellipsis.

ida_typeinf.til_type_ref_t.is_enum(self) -> bool

ida_typeinf.til_type_ref_t.is_func(self) -> bool

ida_typeinf.til_type_ref_t.is_struct(self) -> bool

ida_typeinf.til_type_ref_t.is_typedef(self) -> bool

ida_typeinf.til_type_ref_t.is_udt(self) -> bool

ida_typeinf.til_type_ref_t.is_union(self) -> bool

ida_typeinf.til_type_ref_t.on_member(self) -> bool

ida_typeinf.til_type_ref_t.udm
    BTF_STRUCT or BTF_UNION: the current member.

ida_typeinf.tinfo_errstr(code: "tinfo_code_t") -> str
    Helper function to convert an error code into a printable string. Additional arguments are handled using the functions from err.h 
            

ida_typeinf.tinfo_t

ida_typeinf.tinfo_t.ENUMBM_AUTO
    convert to bitmask if the outcome is nice and useful

ida_typeinf.tinfo_t.ENUMBM_OFF
    convert to ordinal enum

ida_typeinf.tinfo_t.ENUMBM_ON
    convert to bitmask enum

ida_typeinf.tinfo_t.__eq__(self, r: "tinfo_t") -> bool

ida_typeinf.tinfo_t.__ge__(self, r: "tinfo_t") -> bool

ida_typeinf.tinfo_t.__gt__(self, r: "tinfo_t") -> bool

ida_typeinf.tinfo_t.__init__(self, *args, ordinal = None, name = None, tid = None, til = None)
    Create a type object with the provided argumens.
    
    This constructor has the following signatures:
    
        1. tinfo_t(decl_type: type_t)
        2. tinfo_t(decl: str, til: til_t = None, pt_flags: int = 0)
    
    The latter form will create the type object by parsing the type declaration
    
    Alternatively, you can use a form accepting the following keyword arguments:
    
    * ordinal: int
    * name: str
    * tid: int
    * til: til_t=None # `None` means `get_idati()`
    
    E.g.,
    
    * tinfo_t(ordinal=3)
    * tinfo_t(ordinal=10, til=get_idati())
    * tinfo_t(name="mytype_t")
    * tinfo_t(name="thattype_t", til=my_other_til)
    * tinfo_t(tid=ida_nalt.get_strid(some_address))
    
    The constructor may raise an exception if data was invalid, or if parsing failed.
    
    @param decl_type A simple type
    @param decl A valid C declaration
    @param til A type library, or `None` to use the (`get_idati()`) default
    @param ordinal An ordinal in the type library
    @param name A valid type name
    @param pt_flags Parsing flags

ida_typeinf.tinfo_t.__le__(self, r: "tinfo_t") -> bool

ida_typeinf.tinfo_t.__lt__(self, r: "tinfo_t") -> bool

ida_typeinf.tinfo_t.__ne__(self, r: "tinfo_t") -> bool

ida_typeinf.tinfo_t.__repr__(self)

ida_typeinf.tinfo_t.__str__(self) -> str

ida_typeinf.tinfo_t._print(self, name: str = None, prtype_flags: int = 0, indent: int = 0, cmtindent: int = 0, prefix: str = None, cmt: str = None) -> bool

ida_typeinf.tinfo_t.add_edm(self, *args)
    Add an enumerator to the current enumeration.
    
    When creating a new enumeration from scratch, you might
    want to first call `create_enum()`
    
    This method has the following signatures:
    
        1. add_edm(edm: edm_t, bmask: int = -1, etf_flags: int = 0, idx: int = -1)
        2. add_edm(name: str, value: int, bmask: int = -1, etf_flags: int = 0, idx: int = -1)
    
    If an input argument is incorrect, the constructor may raise an exception
    
    @param edm       The member, fully initialized (1st form)
    @param name      Enumerator name - must not be empty
    @param value     Enumerator value
    @param bmask     A bitmask to which the enumerator belongs
    @param etf_flags an OR'ed combination of ETF_ flags
    @param idx       the index in the edm array where the new udm should be placed.
                     If the specified index cannot be honored because it would spoil
                     the edm sorting order, it is silently ignored.

ida_typeinf.tinfo_t.add_funcarg(self, farg: "funcarg_t", etf_flags: "uint" = 0, idx: "ssize_t" = -1) -> "tinfo_code_t"
    Add a function argument. 
            
    @param farg: argument to add
    @param etf_flags: type changing flags flags
    @param idx: the index in the funcarg array where the new funcarg should be placed. if the specified index cannot be honored because it would spoil the funcarg sorting order, it is silently ignored.

ida_typeinf.tinfo_t.add_udm(self, *args)
    Add a member to the current structure/union.
    
    When creating a new structure/union from scratch, you might
    want to first call `create_udt()`
    
    This method has the following signatures:
    
        1. add_udm(udm: udm_t, etf_flags: int = 0, times: int = 1, idx: int = -1)
        2. add_udm(name: str, type: type_t | tinfo_t | str, offset: int = 0, etf_flags: int = 0, times: int = 1, idx: int = -1)
    
    In the 2nd form, the 'type' descriptor, can be one of:
    
    * type_t: if the type is simple (integral/floating/bool). E.g., `BTF_INT`
    * tinfo_t: can handle more complex types (structures, pointers, arrays, ...)
    * str: a C type declaration
    
    If an input argument is incorrect, the constructor may raise an exception
    
    @param udm       The member, fully initialized (1st form)
    @param name      Member name - must not be empty
    @param type      Member type
    @param offset    the member offset in bits. It is the caller's responsibility
           to specify correct offsets.
    @param etf_flags an OR'ed combination of ETF_ flags
    @param times     how many times to add the new member
    @param idx       the index in the udm array where the new udm should be placed.
                     If the specified index cannot be honored because it would spoil
                     the udm sorting order, it is silently ignored.

ida_typeinf.tinfo_t.append_covered(self, out: "rangeset_t", offset: "uint64" = 0) -> bool
    Calculate set of covered bytes for the type 
            
    @param out: pointer to the output buffer. covered bytes will be appended to it.
    @param offset: delta in bytes to add to all calculations. used internally during recurion.

ida_typeinf.tinfo_t.calc_enum_mask(self) -> "uint64"

ida_typeinf.tinfo_t.calc_gaps(self, out: "rangeset_t") -> bool
    Calculate set of padding bytes for the type 
            
    @param out: pointer to the output buffer; old buffer contents will be lost.

ida_typeinf.tinfo_t.calc_purged_bytes(self) -> int
    BT_FUNC: Calculate number of purged bytes

ida_typeinf.tinfo_t.calc_score(self) -> int
    Calculate the type score (the higher - the nicer is the type)

ida_typeinf.tinfo_t.calc_udt_aligns(self, sudt_flags: int = 4) -> bool
    Calculate the udt alignments using the field offsets/sizes and the total udt size This function does not work on typerefs 
            

ida_typeinf.tinfo_t.change_sign(self, sign: "type_sign_t") -> bool
    Change the type sign. Works only for the types that may have sign.

ida_typeinf.tinfo_t.clear(self) -> None
    Clear contents of this tinfo, and remove from the type system.

ida_typeinf.tinfo_t.clr_const(self) -> bool

ida_typeinf.tinfo_t.clr_const_volatile(self) -> bool

ida_typeinf.tinfo_t.clr_decl_const_volatile(self) -> None

ida_typeinf.tinfo_t.clr_volatile(self) -> bool

ida_typeinf.tinfo_t.compare(self, r: "tinfo_t") -> int

ida_typeinf.tinfo_t.compare_with(self, r: "tinfo_t", tcflags: int = 0) -> bool
    Compare two types, based on given flags (see tinfo_t comparison flags)

ida_typeinf.tinfo_t.convert_array_to_ptr(self) -> bool
    Convert an array into a pointer. type[] => type * 
            

ida_typeinf.tinfo_t.copy(self) -> "tinfo_t"

ida_typeinf.tinfo_t.copy_type(self, *args) -> "tinfo_code_t"

ida_typeinf.tinfo_t.create_array(self, *args) -> bool

ida_typeinf.tinfo_t.create_bitfield(self, *args) -> bool

ida_typeinf.tinfo_t.create_enum(self, *args) -> bool
    Create an empty enum.

ida_typeinf.tinfo_t.create_forward_decl(self, til: "til_t", decl_type: "type_t", name: str, ntf_flags: int = 0) -> "tinfo_code_t"
    Create a forward declaration. decl_type: BTF_STRUCT, BTF_UNION, or BTF_ENUM 
            

ida_typeinf.tinfo_t.create_func(self, *args) -> bool

ida_typeinf.tinfo_t.create_ptr(self, *args) -> bool

ida_typeinf.tinfo_t.create_simple_type(self, decl_type: "type_t") -> bool

ida_typeinf.tinfo_t.create_typedef(self, *args) -> None

ida_typeinf.tinfo_t.create_udt(self, *args) -> bool
    Create an empty structure/union.

ida_typeinf.tinfo_t.del_attr(self, key: str, make_copy: bool = True) -> bool
    Del a type attribute. typerefs cannot be modified by this function.

ida_typeinf.tinfo_t.del_attrs(self) -> None
    Del all type attributes. typerefs cannot be modified by this function.

ida_typeinf.tinfo_t.del_edm(self, *args)
    Delete an enumerator with the specified name
    or the specified index, in the specified tinfo_t object.
    
    This method has the following signatures:
    
        1. del_edm(name: str) -> int
        2. del_edm(index: int) -> int
    
    @param name an enumerator name (1st form)
    @param index an enumerator index (2nd form)
    @return TERR_OK in case of success, or another TERR_* value in case of error

ida_typeinf.tinfo_t.del_edm_by_value(self, value: int, etf_flags: int = 0, bmask: int = DEFMASK64, serial: int = 0)
    Delete an enumerator with the specified value,
    in the specified tinfo_t object.
    
    @param value the enumerator value
    @return TERR_OK in case of success, or another TERR_* value in case of error

ida_typeinf.tinfo_t.del_edms(self, idx1: "size_t", idx2: "size_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Delete enum members 
            
    @param idx1: index in edmvec_t
    @param idx2: index in edmvec_t or size_t(-1)
    @param etf_flags: etf_flag_t Delete enum members in [idx1, idx2)

ida_typeinf.tinfo_t.del_funcarg(self, idx: "size_t", etf_flags: "uint" = 0) -> "tinfo_code_t"

ida_typeinf.tinfo_t.del_funcargs(self, idx1: "size_t", idx2: "size_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Delete function arguments 
            
    @param idx1: index in funcargvec_t
    @param idx2: index in funcargvec_t or size_t(-1)
    @param etf_flags: etf_flag_t Delete function arguments in [idx1, idx2)

ida_typeinf.tinfo_t.del_udm(self, index: "size_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Delete a structure/union member.

ida_typeinf.tinfo_t.del_udms(self, idx1: "size_t", idx2: "size_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Delete structure/union members in the range [idx1, idx2)

ida_typeinf.tinfo_t.deserialize(self, *args) -> bool
    This function has the following signatures:
    
        0. deserialize(til: const til_t *, ptype: const type_t **, pfields: const p_list **=nullptr, pfldcmts: const p_list **=nullptr, cmt: str=nullptr) -> bool
        1. deserialize(til: const til_t *, ptype: const qtype *, pfields: const qtype *=nullptr, pfldcmts: const qtype *=nullptr, cmt: str=nullptr) -> bool
    
    # 0: deserialize(til: const til_t *, ptype: const type_t **, pfields: const p_list **=nullptr, pfldcmts: const p_list **=nullptr, cmt: str=nullptr) -> bool
    
    Deserialize a type string into a tinfo_t object.
    
    
    # 1: deserialize(til: const til_t *, ptype: const qtype *, pfields: const qtype *=nullptr, pfldcmts: const qtype *=nullptr, cmt: str=nullptr) -> bool
    
    Deserialize a type string into a tinfo_t object.

ida_typeinf.tinfo_t.detach(self) -> bool
    Detach tinfo_t from the underlying type. After calling this finction, tinfo_t will lose its link to the underlying named or numbered type (if any) and will become a reference to a unique type. After that, any modifications to tinfo_t will affect only its type. 
            

ida_typeinf.tinfo_t.dstr(self) -> str
    Function to facilitate debugging.

ida_typeinf.tinfo_t.edit_edm(self, *args) -> "tinfo_code_t"
    Change constant value and/or bitmask 
            
    @param idx: index in edmvec_t
    @param value: old or new value
    @param bmask: old or new bitmask
    @param etf_flags: etf_flag_t

ida_typeinf.tinfo_t.empty(self) -> bool
    Was tinfo_t initialized with some type info or not?

ida_typeinf.tinfo_t.equals_to(self, r: "tinfo_t") -> bool

ida_typeinf.tinfo_t.expand_udt(self, idx: "size_t", delta: "adiff_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Expand/shrink a structure by adding/removing a gap before the specified member.
    For regular structures, either the gap can be accommodated by aligning the next member with an alignment directive, or an explicit "gap" member will be inserted. Also note that it is impossible to add a gap at the end of a regular structure.
    When it comes to fixed-layout structures, there is no need to either add new "gap" members or align existing members, since all members have a fixed offset. It is possible to add a gap at the end of a fixed-layout structure, by passing `-1` as index.
    
    @param idx: index of the member
    @param delta: number of bytes to add or remove
    @param etf_flags: etf_flag_t

ida_typeinf.tinfo_t.find_edm(self, *args) -> "ssize_t"

ida_typeinf.tinfo_t.find_udm(self, *args) -> int
    This function has the following signatures:
    
        0. find_udm(udm: udm_t *, strmem_flags: int) -> int
        1. find_udm(offset: uint64, strmem_flags: int=0) -> int
        2. find_udm(name: str, strmem_flags: int=0) -> int
    
    # 0: find_udm(udm: udm_t *, strmem_flags: int) -> int
    
    BTF_STRUCT,BTF_UNION: Find a udt member.
    * at the specified offset (STRMEM_OFFSET)
    * with the specified index (STRMEM_INDEX)
    * with the specified type (STRMEM_TYPE)
    * with the specified name (STRMEM_NAME)
    
    
    
    @returns the index of the found member or -1
    
    # 1: find_udm(offset: uint64, strmem_flags: int=0) -> int
    
    BTF_STRUCT,BTF_UNION: Find an udt member at the specified offset 
            
    @returns the index of the found member or -1
    
    # 2: find_udm(name: str, strmem_flags: int=0) -> int
    
    BTF_STRUCT,BTF_UNION: Find an udt member by name 
            
    @returns the index of the found member or -1

ida_typeinf.tinfo_t.force_tid(self) -> "tid_t"
    Get the type tid. Create if it does not exist yet. If the type comes from a base til, the type will be copied to the local til and a new tid will be created for it. (if the type comes from a base til, it does not have a tid yet). If the type comes from the local til, this function is equivalent to get_tid() 
            
    @returns tid or BADADDR

ida_typeinf.tinfo_t.get_alias_target(self) -> int
    Get type alias If the type has no alias, return 0. 
            

ida_typeinf.tinfo_t.get_alignment(self) -> int
    Get type alignment This function returns the effective type alignment. Zero means error. 
            

ida_typeinf.tinfo_t.get_array_details(self, ai: "array_type_data_t") -> bool
    Get the array specific info.

ida_typeinf.tinfo_t.get_array_element(self) -> "tinfo_t"
    BT_ARRAY: get type of array element. See also get_ptrarr_object()

ida_typeinf.tinfo_t.get_array_nelems(self) -> int
    BT_ARRAY: get number of elements (-1 means error)

ida_typeinf.tinfo_t.get_attr(self, key: str, all_attrs: bool = True) -> "PyObject *"
    Get a type attribute.

ida_typeinf.tinfo_t.get_attrs(self, tav: "type_attrs_t", all_attrs: bool = False) -> bool
    Get type attributes (all_attrs: include attributes of referenced types, if any)

ida_typeinf.tinfo_t.get_bit_buckets(self, buckets: "range64vec_t") -> bool
    ::BT_STRUCT: get bit buckets Bit buckets are used to layout bitfields 
            
    @returns false if wrong type was passed

ida_typeinf.tinfo_t.get_bitfield_details(self, bi: "bitfield_type_data_t") -> bool
    Get the bitfield specific info.

ida_typeinf.tinfo_t.get_by_edm_name(self, mname: str, til: "til_t" = None) -> "ssize_t"
    Retrieve enum tinfo using enum member name 
            
    @param mname: enum type member name
    @param til: type library
    @returns member index, otherwise returns -1. If the function fails, THIS object becomes empty.

ida_typeinf.tinfo_t.get_declalign(self) -> "uchar"
    Get declared alignment of the type.

ida_typeinf.tinfo_t.get_decltype(self) -> "type_t"
    Get declared type (without resolving type references; they are returned as is). Obviously this is a very fast function and should be used instead of get_realtype() if possible. Please note that for typerefs this function will return BTF_TYPEDEF. To determine if a typeref is a typedef, use is_typedef() 
            

ida_typeinf.tinfo_t.get_edm(self, *args) -> Tuple[int, "edm_t"]
    Retrieve an enumerator with either the specified name
    or the specified index, in the specified tinfo_t object.
    
    This function has the following signatures:
    
        1. get_edm(index: int)
        2. get_edm(name: str)
    
    @param index an enumerator index (1st form).
    @param name an enumerator name (2nd form).
    @return a tuple (int, edm_t), or (-1, None) if member not found

ida_typeinf.tinfo_t.get_edm_by_tid(self, edm: "edm_t", tid: "tid_t") -> "ssize_t"

ida_typeinf.tinfo_t.get_edm_by_value(self, value: int, bmask: int = DEFMASK64, serial: int = 0) -> Tuple[int, "edm_t"]
    Retrieve an enumerator with the specified value,
    in the specified tinfo_t object.
    
    @param value the enumerator value
    @return a tuple (int, edm_t), or (-1, None) if member not found

ida_typeinf.tinfo_t.get_edm_tid(self, idx: "size_t") -> "tid_t"
    Get enum member TID 
            
    @param idx: enum member index
    @returns tid or BADADDR The tid is used to collect xrefs to the member, it can be passed to xref-related functions instead of the address.

ida_typeinf.tinfo_t.get_enum_base_type(self) -> "type_t"
    Get enum base type (convert enum to integer type) Returns BT_UNK if failed to convert 
            

ida_typeinf.tinfo_t.get_enum_details(self, ei: "enum_type_data_t") -> bool
    Get the enum specific info.

ida_typeinf.tinfo_t.get_enum_nmembers(self) -> "size_t"
    Get number of enum members. 
            
    @returns BADSIZE if error

ida_typeinf.tinfo_t.get_enum_radix(self) -> int
    Get enum constant radix 
            
    @returns radix or 1 for BTE_CHAR enum_type_data_t::get_enum_radix()

ida_typeinf.tinfo_t.get_enum_repr(self, repr: "value_repr_t") -> "tinfo_code_t"
    Set the representation of enum members. 
            
    @param repr: value_repr_t

ida_typeinf.tinfo_t.get_enum_width(self) -> int
    Get enum width 
            
    @returns width of enum base type in bytes, 0 - unspecified, or -1 enum_type_data_t::calc_nbytes()

ida_typeinf.tinfo_t.get_final_element(self) -> "tinfo_t"
    repeat recursively: if an array, return the type of its element; else return the type itself.

ida_typeinf.tinfo_t.get_final_ordinal(self) -> int
    Get final type ordinal (0 if none)

ida_typeinf.tinfo_t.get_final_type_name(self) -> bool
    Use in the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn). 
            
    @returns the name of the last type in the chain (TYPEn). if there is no chain, returns TYPE1

ida_typeinf.tinfo_t.get_forward_type(self) -> "type_t"
    Get type of a forward declaration. For a forward declaration this function returns its base type. In other cases it returns BT_UNK 
            

ida_typeinf.tinfo_t.get_frame_func(self) -> ida_idaapi.ea_t
    Get function address for the frame.

ida_typeinf.tinfo_t.get_func_details(self, fi: "func_type_data_t", gtd: "gtd_func_t" = GTD_CALC_ARGLOCS) -> bool
    Get only the function specific info for this tinfo_t.

ida_typeinf.tinfo_t.get_func_frame(self, pfn: "func_t const *") -> bool
    Create a tinfo_t object for the function frame 
            
    @param pfn: function

ida_typeinf.tinfo_t.get_innermost_member_type(self, bitoffset: "uint64") -> "tinfo_t"
    Get the innermost member type at the given offset 
            
    @param bitoffset: bit offset into the structure
    @retval the: innermost member type

ida_typeinf.tinfo_t.get_innermost_udm(self, bitoffset: "uint64") -> "tinfo_t"
    Get the innermost member at the given offset 
            
    @param bitoffset: bit offset into the structure
    @retval udt: with the innermost member
    @retval empty: type if it is not a struct type or OFFSET could not be found

ida_typeinf.tinfo_t.get_methods(self, methods: "udtmembervec_t") -> bool
    BT_COMPLEX: get a list of member functions declared in this udt. 
            
    @returns false if no member functions exist

ida_typeinf.tinfo_t.get_modifiers(self) -> "type_t"

ida_typeinf.tinfo_t.get_named_type(self, *args) -> bool
    This function has the following signatures:
    
        0. get_named_type(til: const til_t *, name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool
        1. get_named_type(name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool
    
    # 0: get_named_type(til: const til_t *, name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool
    
    Create a tinfo_t object for an existing named type. 
            
    
    # 1: get_named_type(name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool

ida_typeinf.tinfo_t.get_nargs(self) -> int
    BT_FUNC or BT_PTR BT_FUNC: Calculate number of arguments (-1 - error)

ida_typeinf.tinfo_t.get_next_type_name(self) -> bool
    Use In the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn). 
            
    @returns the name of the next type in the chain (TYPE2). if there is no chain, returns failure

ida_typeinf.tinfo_t.get_nice_type_name(self) -> bool
    Get the beautified type name. Get the referenced name and apply regular expressions from goodname.cfg to beautify the name 
            

ida_typeinf.tinfo_t.get_nth_arg(self, n: int) -> "tinfo_t"
    BT_FUNC or BT_PTR BT_FUNC: Get type of n-th arg (-1 means return type, see get_rettype())

ida_typeinf.tinfo_t.get_numbered_type(self, *args) -> bool
    This function has the following signatures:
    
        0. get_numbered_type(til: const til_t *, ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool
        1. get_numbered_type(ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool
    
    # 0: get_numbered_type(til: const til_t *, ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool
    
    Create a tinfo_t object for an existing ordinal type. 
            
    
    # 1: get_numbered_type(ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool

ida_typeinf.tinfo_t.get_onemember_type(self) -> "tinfo_t"
    For objects consisting of one member entirely: return type of the member.

ida_typeinf.tinfo_t.get_ordinal(self) -> int
    Get type ordinal (only if the type was created as a numbered type, 0 if none)

ida_typeinf.tinfo_t.get_pointed_object(self) -> "tinfo_t"
    BT_PTR: get type of pointed object. If the current type is not a pointer, return empty type info. See also get_ptrarr_object() and remove_pointer() 
            

ida_typeinf.tinfo_t.get_ptr_details(self, pi: "ptr_type_data_t") -> bool
    Get the pointer info.

ida_typeinf.tinfo_t.get_ptrarr_object(self) -> "tinfo_t"
    BT_PTR & BT_ARRAY: get the pointed object or array element. If the current type is not a pointer or array, return empty type info. 
            

ida_typeinf.tinfo_t.get_ptrarr_objsize(self) -> int
    BT_PTR & BT_ARRAY: get size of pointed object or array element. On error returns -1

ida_typeinf.tinfo_t.get_realtype(self, full: bool = False) -> "type_t"
    Get the resolved base type. Deserialization options:
    * if full=true, the referenced type will be deserialized fully, this may not always be desirable (slows down things)
    * if full=false, we just return the base type, the referenced type will be resolved again later if necessary (this may lead to multiple resolvings of the same type) imho full=false is a better approach because it does not perform unnecessary actions just in case. however, in some cases the caller knows that it is very likely that full type info will be required. in those cases full=true makes sense 
    
    
            

ida_typeinf.tinfo_t.get_rettype(self) -> "tinfo_t"
    BT_FUNC or BT_PTR BT_FUNC: Get the function's return type

ida_typeinf.tinfo_t.get_sign(self) -> "type_sign_t"
    Get type sign.

ida_typeinf.tinfo_t.get_size(self, p_effalign: "uint32 *" = None, gts_code: int = 0) -> "size_t"
    Get the type size in bytes. 
            
    @param p_effalign: buffer for the alignment value
    @param gts_code: combination of GTS_... constants
    @returns BADSIZE in case of problems

ida_typeinf.tinfo_t.get_stkvar(self, insn: "insn_t const &", x: "op_t const", v: int) -> "ssize_t"
    Retrieve frame tinfo for a stack variable 
            
    @param insn: the instruction
    @param x: reference to instruction operand, may be nullptr
    @param v: immediate value in the operand (usually x.addr)
    @returns returns the member index, otherwise returns -1. if the function fails, THIS object becomes empty.

ida_typeinf.tinfo_t.get_stock(id: "stock_type_id_t") -> "tinfo_t"
    Get stock type information. This function can be used to get tinfo_t for some common types. The same tinfo_t will be returned for the same id, thus saving memory and increasing the speed Please note that retrieving the STI_SIZE_T or STI_SSIZE_T stock type, will also have the side-effect of adding that type to the 'idati' TIL, under the well-known name 'size_t' or 'ssize_t' (respectively). The same is valid for STI_COMPLEX64 and STI_COMPLEX64 stock types with names 'complex64_t' and 'complex128_t' (respectively). 
            

ida_typeinf.tinfo_t.get_tid(self) -> "tid_t"
    Get the type tid Each type in the local type library has a so-called `tid` associated with it. The tid is used to collect xrefs to the type. The tid is created when the type is created in the local type library and does not change afterwards. It can be passed to xref-related functions instead of the address. 
            
    @returns tid or BADADDR

ida_typeinf.tinfo_t.get_til(self) -> "til_t *"
    Get the type library for tinfo_t.

ida_typeinf.tinfo_t.get_type_by_tid(self, tid: "tid_t") -> bool

ida_typeinf.tinfo_t.get_type_cmt(self) -> int
    Get type comment 
            
    @returns 0-failed, 1-returned regular comment, 2-returned repeatable comment

ida_typeinf.tinfo_t.get_type_name(self) -> bool
    Does a type refer to a name?. If yes, fill the provided buffer with the type name and return true. Names are returned for numbered types too: either a user-defined nice name or, if a user-provided name does not exist, an ordinal name (like #xx, see create_numbered_type_name()). 
            

ida_typeinf.tinfo_t.get_type_rptcmt(self) -> bool
    Get type comment only if it is repeatable.

ida_typeinf.tinfo_t.get_udm(self, *args) -> Union[Tuple[int, "udm_t"], Tuple[None, None]]
    Retrieve a structure/union member with either the specified name
    or the specified index, in the specified tinfo_t object.
    
    This function has the following signatures:
    
        1. get_udm(index: int)
        2. get_udm(name: str)
    
    @param index a member index (1st form)
    @param name a member name (2nd form)
    @return a tuple (int, udm_t), or (-1, None) if member not found

ida_typeinf.tinfo_t.get_udm_by_offset(self, offset: int)
    Retrieve a structure/union member with the specified offset,
    in the specified tinfo_t object.
    
    @param offset the member offset
    @return a tuple (int, udm_t), or (-1, None) if member not found

ida_typeinf.tinfo_t.get_udm_by_tid(self, udm: "udm_t", tid: "tid_t") -> "ssize_t"

ida_typeinf.tinfo_t.get_udm_tid(self, idx: "size_t") -> "tid_t"
    Get udt member TID 
            
    @param idx: the index of udt the member
    @returns tid or BADADDR The tid is used to collect xrefs to the member, it can be passed to xref-related functions instead of the address.

ida_typeinf.tinfo_t.get_udt_details(self, udt: "udt_type_data_t", gtd: "gtd_udt_t" = GTD_CALC_LAYOUT) -> bool
    Get the udt specific info.

ida_typeinf.tinfo_t.get_udt_nmembers(self) -> int
    Get number of udt members. -1-error.

ida_typeinf.tinfo_t.get_unpadded_size(self) -> "size_t"
    Get the type size in bytes without the final padding, in bytes. For some UDTs get_unpadded_size() != get_size() 
            

ida_typeinf.tinfo_t.has_details(self) -> bool
    Does this type refer to a nontrivial type?

ida_typeinf.tinfo_t.has_union(self) -> bool
    Has a member of type "union"?

ida_typeinf.tinfo_t.has_vftable(self) -> bool
    Has a vftable?

ida_typeinf.tinfo_t.is_aliased(self) -> bool

ida_typeinf.tinfo_t.is_anonymous_udt(self) -> bool
    Is an anonymous struct/union? We assume that types with names are anonymous if the name starts with $ 
            

ida_typeinf.tinfo_t.is_arithmetic(self) -> bool
    is_type_arithmetic(get_realtype())

ida_typeinf.tinfo_t.is_array(self) -> bool
    is_type_array(get_realtype())

ida_typeinf.tinfo_t.is_bitfield(self) -> bool
    is_type_bitfld(get_realtype())

ida_typeinf.tinfo_t.is_bitmask_enum(self) -> bool
    Is bitmask enum? 
            
    @returns true for bitmask enum and false in other cases enum_type_data_t::is_bf()

ida_typeinf.tinfo_t.is_bool(self) -> bool
    is_type_bool(get_realtype())

ida_typeinf.tinfo_t.is_castable_to(self, target: "tinfo_t") -> bool

ida_typeinf.tinfo_t.is_char(self) -> bool
    is_type_char(get_realtype())

ida_typeinf.tinfo_t.is_complex(self) -> bool
    is_type_complex(get_realtype())

ida_typeinf.tinfo_t.is_const(self) -> bool
    is_type_const(get_realtype())

ida_typeinf.tinfo_t.is_correct(self) -> bool
    Is the type object correct?. It is possible to create incorrect types. For example, we can define a function that returns an enum and then delete the enum type. If this function returns false, the type should not be used in disassembly. Please note that this function does not verify all involved types: for example, pointers to undefined types are permitted. 
            

ida_typeinf.tinfo_t.is_decl_array(self) -> bool
    is_type_array(get_decltype())

ida_typeinf.tinfo_t.is_decl_bitfield(self) -> bool
    is_type_bitfld(get_decltype())

ida_typeinf.tinfo_t.is_decl_bool(self) -> bool
    is_type_bool(get_decltype())

ida_typeinf.tinfo_t.is_decl_char(self) -> bool
    is_type_char(get_decltype())

ida_typeinf.tinfo_t.is_decl_complex(self) -> bool
    is_type_complex(get_decltype())

ida_typeinf.tinfo_t.is_decl_const(self) -> bool
    is_type_const(get_decltype())

ida_typeinf.tinfo_t.is_decl_double(self) -> bool
    is_type_double(get_decltype())

ida_typeinf.tinfo_t.is_decl_enum(self) -> bool
    is_type_enum(get_decltype())

ida_typeinf.tinfo_t.is_decl_float(self) -> bool
    is_type_float(get_decltype())

ida_typeinf.tinfo_t.is_decl_floating(self) -> bool
    is_type_floating(get_decltype())

ida_typeinf.tinfo_t.is_decl_func(self) -> bool
    is_type_func(get_decltype())

ida_typeinf.tinfo_t.is_decl_int(self) -> bool
    is_type_int(get_decltype())

ida_typeinf.tinfo_t.is_decl_int128(self) -> bool
    is_type_int128(get_decltype())

ida_typeinf.tinfo_t.is_decl_int16(self) -> bool
    is_type_int16(get_decltype())

ida_typeinf.tinfo_t.is_decl_int32(self) -> bool
    is_type_int32(get_decltype())

ida_typeinf.tinfo_t.is_decl_int64(self) -> bool
    is_type_int64(get_decltype())

ida_typeinf.tinfo_t.is_decl_last(self) -> bool
    is_typeid_last(get_decltype())

ida_typeinf.tinfo_t.is_decl_ldouble(self) -> bool
    is_type_ldouble(get_decltype())

ida_typeinf.tinfo_t.is_decl_paf(self) -> bool
    is_type_paf(get_decltype())

ida_typeinf.tinfo_t.is_decl_partial(self) -> bool
    is_type_partial(get_decltype())

ida_typeinf.tinfo_t.is_decl_ptr(self) -> bool
    is_type_ptr(get_decltype())

ida_typeinf.tinfo_t.is_decl_struct(self) -> bool
    is_type_struct(get_decltype())

ida_typeinf.tinfo_t.is_decl_sue(self) -> bool
    is_type_sue(get_decltype())

ida_typeinf.tinfo_t.is_decl_tbyte(self) -> bool
    is_type_tbyte(get_decltype())

ida_typeinf.tinfo_t.is_decl_typedef(self) -> bool
    is_type_typedef(get_decltype())

ida_typeinf.tinfo_t.is_decl_uchar(self) -> bool
    is_type_uchar(get_decltype())

ida_typeinf.tinfo_t.is_decl_udt(self) -> bool
    is_type_struni(get_decltype())

ida_typeinf.tinfo_t.is_decl_uint(self) -> bool
    is_type_uint(get_decltype())

ida_typeinf.tinfo_t.is_decl_uint128(self) -> bool
    is_type_uint128(get_decltype())

ida_typeinf.tinfo_t.is_decl_uint16(self) -> bool
    is_type_uint16(get_decltype())

ida_typeinf.tinfo_t.is_decl_uint32(self) -> bool
    is_type_uint32(get_decltype())

ida_typeinf.tinfo_t.is_decl_uint64(self) -> bool
    is_type_uint64(get_decltype())

ida_typeinf.tinfo_t.is_decl_union(self) -> bool
    is_type_union(get_decltype())

ida_typeinf.tinfo_t.is_decl_unknown(self) -> bool
    is_type_unknown(get_decltype())

ida_typeinf.tinfo_t.is_decl_void(self) -> bool
    is_type_void(get_decltype())

ida_typeinf.tinfo_t.is_decl_volatile(self) -> bool
    is_type_volatile(get_decltype())

ida_typeinf.tinfo_t.is_double(self) -> bool
    is_type_double(get_realtype())

ida_typeinf.tinfo_t.is_empty_enum(self) -> bool
    Is an empty enum? (has no constants)

ida_typeinf.tinfo_t.is_empty_udt(self) -> bool
    Is an empty struct/union? (has no fields)

ida_typeinf.tinfo_t.is_enum(self) -> bool
    is_type_enum(get_realtype())

ida_typeinf.tinfo_t.is_ext_arithmetic(self) -> bool
    is_type_ext_arithmetic(get_realtype()) 
            

ida_typeinf.tinfo_t.is_ext_integral(self) -> bool
    is_type_ext_integral(get_realtype())

ida_typeinf.tinfo_t.is_fixed_struct(self) -> bool
    Is a structure with fixed offsets?

ida_typeinf.tinfo_t.is_float(self) -> bool
    is_type_float(get_realtype())

ida_typeinf.tinfo_t.is_floating(self) -> bool
    is_type_floating(get_realtype())

ida_typeinf.tinfo_t.is_forward_decl(self) -> bool
    Is this a forward declaration?. Forward declarations are placeholders: the type definition does not exist 
            

ida_typeinf.tinfo_t.is_forward_enum(self) -> bool

ida_typeinf.tinfo_t.is_forward_struct(self) -> bool

ida_typeinf.tinfo_t.is_forward_union(self) -> bool

ida_typeinf.tinfo_t.is_frame(self) -> bool
    Is a function frame?

ida_typeinf.tinfo_t.is_from_subtil(self) -> bool
    Was the named type found in some base type library (not the top level type library)?. If yes, it usually means that the type comes from some loaded type library, not the local type library for the database 
            

ida_typeinf.tinfo_t.is_func(self) -> bool
    is_type_func(get_realtype())

ida_typeinf.tinfo_t.is_funcptr(self) -> bool
    Is this pointer to a function?

ida_typeinf.tinfo_t.is_high_func(self) -> bool
    BT_FUNC: Is high level type?

ida_typeinf.tinfo_t.is_int(self) -> bool
    is_type_int(get_realtype())

ida_typeinf.tinfo_t.is_int128(self) -> bool
    is_type_int128(get_realtype())

ida_typeinf.tinfo_t.is_int16(self) -> bool
    is_type_int16(get_realtype())

ida_typeinf.tinfo_t.is_int32(self) -> bool
    is_type_int32(get_realtype())

ida_typeinf.tinfo_t.is_int64(self) -> bool
    is_type_int64(get_realtype())

ida_typeinf.tinfo_t.is_integral(self) -> bool
    is_type_integral(get_realtype())

ida_typeinf.tinfo_t.is_ldouble(self) -> bool
    is_type_ldouble(get_realtype())

ida_typeinf.tinfo_t.is_manually_castable_to(self, target: "tinfo_t") -> bool

ida_typeinf.tinfo_t.is_one_fpval(self) -> bool
    Floating value or an object consisting of one floating member entirely.

ida_typeinf.tinfo_t.is_paf(self) -> bool
    is_type_paf(get_realtype())

ida_typeinf.tinfo_t.is_partial(self) -> bool
    is_type_partial(get_realtype())

ida_typeinf.tinfo_t.is_ptr(self) -> bool
    is_type_ptr(get_realtype())

ida_typeinf.tinfo_t.is_ptr_or_array(self) -> bool
    is_type_ptr_or_array(get_realtype())

ida_typeinf.tinfo_t.is_punknown(self) -> bool
    Is "_UNKNOWN *"?. This function does not check the pointer attributes and type modifiers.

ida_typeinf.tinfo_t.is_purging_cc(self) -> bool
    is_purging_cc(get_cc())

ida_typeinf.tinfo_t.is_pvoid(self) -> bool
    Is "void *"?. This function does not check the pointer attributes and type modifiers.

ida_typeinf.tinfo_t.is_scalar(self) -> bool
    Does the type represent a single number?

ida_typeinf.tinfo_t.is_shifted_ptr(self) -> bool
    Is a shifted pointer?

ida_typeinf.tinfo_t.is_signed(self) -> bool
    Is this a signed type?

ida_typeinf.tinfo_t.is_small_udt(self) -> bool
    Is a small udt? (can fit a register or a pair of registers)

ida_typeinf.tinfo_t.is_sse_type(self) -> bool
    Is a SSE vector type?

ida_typeinf.tinfo_t.is_struct(self) -> bool
    is_type_struct(get_realtype())

ida_typeinf.tinfo_t.is_sue(self) -> bool
    is_type_sue(get_realtype())

ida_typeinf.tinfo_t.is_tbyte(self) -> bool
    is_type_tbyte(get_realtype())

ida_typeinf.tinfo_t.is_typedef(self) -> bool
    Is this a typedef?. This function will return true for a reference to a local type that is declared as a typedef. 
            

ida_typeinf.tinfo_t.is_typeref(self) -> bool
    Is this type a type reference?.

ida_typeinf.tinfo_t.is_uchar(self) -> bool
    is_type_uchar(get_realtype())

ida_typeinf.tinfo_t.is_udm_by_til(self, idx: "size_t") -> bool
    Was the member created due to the type system 
            
    @param idx: index of the member

ida_typeinf.tinfo_t.is_udt(self) -> bool
    is_type_struni(get_realtype())

ida_typeinf.tinfo_t.is_uint(self) -> bool
    is_type_uint(get_realtype())

ida_typeinf.tinfo_t.is_uint128(self) -> bool
    is_type_uint128(get_realtype())

ida_typeinf.tinfo_t.is_uint16(self) -> bool
    is_type_uint16(get_realtype())

ida_typeinf.tinfo_t.is_uint32(self) -> bool
    is_type_uint32(get_realtype())

ida_typeinf.tinfo_t.is_uint64(self) -> bool
    is_type_uint64(get_realtype())

ida_typeinf.tinfo_t.is_union(self) -> bool
    is_type_union(get_realtype())

ida_typeinf.tinfo_t.is_unknown(self) -> bool
    is_type_unknown(get_realtype())

ida_typeinf.tinfo_t.is_unsigned(self) -> bool
    Is this an unsigned type?

ida_typeinf.tinfo_t.is_user_cc(self) -> bool
    is_user_cc(get_cc())

ida_typeinf.tinfo_t.is_vararg_cc(self) -> bool
    is_vararg_cc(get_cc())

ida_typeinf.tinfo_t.is_varmember(self) -> bool
    Can the type be of a variable struct member? This function checks for: is_array() && array.nelems==0 Such a member can be only the very last member of a structure 
            

ida_typeinf.tinfo_t.is_varstruct(self) -> bool
    Is a variable-size structure?

ida_typeinf.tinfo_t.is_vftable(self) -> bool
    Is a vftable type?

ida_typeinf.tinfo_t.is_void(self) -> bool
    is_type_void(get_realtype())

ida_typeinf.tinfo_t.is_volatile(self) -> bool
    is_type_volatile(get_realtype())

ida_typeinf.tinfo_t.is_well_defined(self) -> bool
    !(empty()) && !(is_decl_partial()) && !(is_punknown())

ida_typeinf.tinfo_t.iter_enum(self)
    Iterate on the members composing this enumeration.
    
    Example:
    
        til = ida_typeinf.get_idati()
        tif = til.get_named_type("my_enum")
        for edm in tif.iter_enum():
            print(f"{edm.name} = {edm.value}")
    
    Will raise an exception if this type is not an enumeration
    
    @return a edm_t-producing generator

ida_typeinf.tinfo_t.iter_func(self)
    Iterate on the arguments contained in this function prototype
    
    Example:
    
        address = ...
        func = ida_funcs.get_func(address)
        func_type = func.prototype
        for arg in func_type.iter_func():
            print(f"{arg.name}, of type {arg.type}")
    
    Will raise an exception if this type is not a function
    
    @return a funcarg_t-producing generator

ida_typeinf.tinfo_t.iter_struct(self)
    Iterate on the members composing this structure.
    
    Example:
    
        til = ida_typeinf.get_idati()
        tif = til.get_named_type("my_struc")
        for udm in tif.iter_struct():
            print(f"{udm.name} at bit offset {udm.offset}")
    
    Will raise an exception if this type is not a structure.
    
    @return a udm_t-producing generator

ida_typeinf.tinfo_t.iter_udt(self)
    Iterate on the members composing this structure, or union.
    
    Example:
    
        til = ida_typeinf.get_idati()
        tif = til.get_named_type("my_type")
        for udm in tif.iter_udt():
            print(f"{udm.name} at bit offset {udm.offset} with type {udm.type}")
    
    Will raise an exception if this type is not a structure, or union
    
    @return a udm_t-producing generator

ida_typeinf.tinfo_t.iter_union(self)
    Iterate on the members composing this union.
    
    Example:
    
        til = ida_typeinf.get_idati()
        tif = til.get_named_type("my_union")
        for udm in tif.iter_union():
            print(f"{udm.name}, with type {udm.type}")
    
    Will raise an exception if this type is not a union.
    
    @return a udm_t-producing generator

ida_typeinf.tinfo_t.parse(self, decl: str, til: "til_t" = None, pt_flags: int = 0) -> bool
    Convenience function to parse a string with a type declaration 
            
    @param decl: a type declaration
    @param til: type library to use
    @param pt_flags: combination of Type parsing flags bits

ida_typeinf.tinfo_t.present(self) -> bool
    Is the type really present? (not a reference to a missing type, for example)

ida_typeinf.tinfo_t.read_bitfield_value(self, v: "uint64", bitoff: int) -> "uint64"

ida_typeinf.tinfo_t.remove_ptr_or_array(self) -> bool
    Replace the current type with the ptr obj or array element. This function performs one of the following conversions:
    * type[] => type
    * type* => type If the conversion is performed successfully, return true 
    
    
            

ida_typeinf.tinfo_t.rename_edm(self, idx: "size_t", name: str, etf_flags: "uint" = 0) -> "tinfo_code_t"
    Rename a enum member 
            
    @param idx: index in edmvec_t
    @param name: new name
    @param etf_flags: etf_flag_t ETF_FORCENAME may be used in case of TERR_ALIEN_NAME

ida_typeinf.tinfo_t.rename_funcarg(self, index: "size_t", name: str, etf_flags: "uint" = 0) -> "tinfo_code_t"
    Rename a function argument. The new name must be unique. 
            
    @param index: argument index in the function array
    @param name: new name
    @param etf_flags: etf_flag_t

ida_typeinf.tinfo_t.rename_type(self, name: str, ntf_flags: int = 0) -> "tinfo_code_t"
    Rename a type 
            
    @param name: new type name
    @param ntf_flags: Flags for named types

ida_typeinf.tinfo_t.rename_udm(self, index: "size_t", name: str, etf_flags: "uint" = 0) -> "tinfo_code_t"
    Rename a structure/union member. The new name must be unique. 
            

ida_typeinf.tinfo_t.requires_qualifier(self, name: str, offset: "uint64") -> bool
    Requires full qualifier? (name is not unique) 
            
    @param name: field name
    @param offset: field offset in bits
    @returns if the name is not unique, returns true

ida_typeinf.tinfo_t.save_type(self, *args) -> "tinfo_code_t"

ida_typeinf.tinfo_t.serialize(self, *args) -> "PyObject *"
    Serialize tinfo_t object into a type string.

ida_typeinf.tinfo_t.set_attr(self, ta: "type_attr_t", may_overwrite: bool = True) -> bool
    Set a type attribute. If necessary, a new typid will be created.

ida_typeinf.tinfo_t.set_attrs(self, tav: "type_attrs_t") -> bool
    Set type attributes. If necessary, a new typid will be created. this function modifies tav! (returns old attributes, if any) 
            
    @returns false: bad attributes

ida_typeinf.tinfo_t.set_const(self) -> None

ida_typeinf.tinfo_t.set_declalign(self, declalign: "uchar") -> bool

ida_typeinf.tinfo_t.set_edm_cmt(self, idx: "size_t", cmt: str, etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set a comment for an enum member. Such comments are always considered as repeatable. 
            
    @param idx: index in edmvec_t
    @param cmt: comment
    @param etf_flags: etf_flag_t

ida_typeinf.tinfo_t.set_enum_is_bitmask(self, *args) -> "tinfo_code_t"

ida_typeinf.tinfo_t.set_enum_radix(self, radix: int, sign: bool, etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set enum radix to display constants 
            
    @param radix: radix 2, 4, 8, 16, with the special case 1 to display as character
    @param sign: display as signed or unsigned
    @param etf_flags: etf_flag_t

ida_typeinf.tinfo_t.set_enum_repr(self, repr: "value_repr_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set the representation of enum members. 
            
    @param repr: value_repr_t
    @param etf_flags: etf_flag_t

ida_typeinf.tinfo_t.set_enum_sign(self, sign: "type_sign_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set enum sign 
            
    @param sign: type_sign_t
    @param etf_flags: etf_flag_t

ida_typeinf.tinfo_t.set_enum_width(self, nbytes: int, etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set the width of enum base type 
            
    @param nbytes: width of enum base type, allowed values: 0 (unspecified),1,2,4,8,16,32,64
    @param etf_flags: etf_flag_t

ida_typeinf.tinfo_t.set_fixed_struct(self, on: bool = True) -> "tinfo_code_t"
    Declare struct member offsets as fixed. For such structures, IDA will not recalculate the member offsets. If a member does not fit into its place anymore, it will be deleted. This function works only with structures (not unions). 
            

ida_typeinf.tinfo_t.set_func_cc(self, cc: "cm_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set function calling convention.

ida_typeinf.tinfo_t.set_func_retloc(self, argloc: "argloc_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set location of function return value. 
            
    @param argloc: new location for the return value
    @param etf_flags: etf_flag_t
    @returns tinfo_code_t

ida_typeinf.tinfo_t.set_func_rettype(self, tif: "tinfo_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set function return type . 
            
    @param tif: new type for the return type
    @param etf_flags: etf_flag_t
    @returns tinfo_code_t

ida_typeinf.tinfo_t.set_funcarg_loc(self, index: "size_t", argloc: "argloc_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set location of a function argument. 
            
    @param index: argument index in the function array
    @param argloc: new location for the argument
    @param etf_flags: etf_flag_t
    @returns tinfo_code_t

ida_typeinf.tinfo_t.set_funcarg_type(self, index: "size_t", tif: "tinfo_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set type of a function argument. 
            
    @param index: argument index in the function array
    @param tif: new type for the argument
    @param etf_flags: etf_flag_t
    @returns tinfo_code_t

ida_typeinf.tinfo_t.set_methods(self, methods: "udtmembervec_t") -> bool
    BT_COMPLEX: set the list of member functions. This function consumes 'methods' (makes it empty). 
            
    @returns false if this type is not a udt, or if the given list is empty

ida_typeinf.tinfo_t.set_modifiers(self, mod: "type_t") -> None

ida_typeinf.tinfo_t.set_named_type(self, til: "til_t", name: str, ntf_flags: int = 0) -> "tinfo_code_t"

ida_typeinf.tinfo_t.set_numbered_type(self, til: "til_t", ord: int, ntf_flags: int = 0, name: str = None) -> "tinfo_code_t"

ida_typeinf.tinfo_t.set_struct_size(self, new_size: "size_t") -> "tinfo_code_t"
    Explicitly specify the struct size. This function works only with fixed structures. The new struct size can be equal or higher the unpadded struct size (IOW, all existing members should fit into the specified size). 
            
    @param new_size: new structure size in bytes

ida_typeinf.tinfo_t.set_symbol_type(self, til: "til_t", name: str, ntf_flags: int = 0) -> "tinfo_code_t"

ida_typeinf.tinfo_t.set_type_alias(self, dest_ord: int) -> bool
    Set type alias Redirects all references to source type to the destination type. This is equivalent to instantaneous replacement all references to srctype by dsttype. 
            

ida_typeinf.tinfo_t.set_type_alignment(self, declalign: "uchar", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set type alignment.

ida_typeinf.tinfo_t.set_type_cmt(self, cmt: str, is_regcmt: bool = False, etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set type comment This function works only for non-trivial types 
            

ida_typeinf.tinfo_t.set_udm_by_til(self, idx: "size_t", on: bool = True, etf_flags: "uint" = 0) -> "tinfo_code_t"
    The member is created due to the type system 
            
    @param idx: index of the member
    @param etf_flags: etf_flag_t

ida_typeinf.tinfo_t.set_udm_cmt(self, index: "size_t", cmt: str, is_regcmt: bool = False, etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set a comment for a structure/union member. A member may have just one comment, and it is either repeatable or regular. 
            

ida_typeinf.tinfo_t.set_udm_repr(self, index: "size_t", repr: "value_repr_t", etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set the representation of a structure/union member.

ida_typeinf.tinfo_t.set_udm_type(self, index: "size_t", tif: "tinfo_t", etf_flags: "uint" = 0, repr: "value_repr_t" = None) -> "tinfo_code_t"
    Set type of a structure/union member. 
            
    @param index: member index in the udm array
    @param tif: new type for the member
    @param etf_flags: etf_flag_t
    @param repr: new representation for the member (optional)
    @returns tinfo_code_t

ida_typeinf.tinfo_t.set_udt_alignment(self, sda: int, etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set declared structure alignment (sda) This alignment supersedes the alignment returned by get_declalign() and is really used when calculating the struct layout. However, the effective structure alignment may differ from `sda` because of packing. The type editing functions (they accept etf_flags) may overwrite this attribute. 
            

ida_typeinf.tinfo_t.set_udt_pack(self, pack: int, etf_flags: "uint" = 0) -> "tinfo_code_t"
    Set structure packing. The value controls how little a structure member alignment can be. Example: if pack=1, then it is possible to align a double to a byte. __attribute__((aligned(1))) double x; However, if pack=3, a double will be aligned to 8 (2**3) even if requested to be aligned to a byte. pack==0 will have the same effect. The type editing functions (they accept etf_flags) may overwrite this attribute. 
            

ida_typeinf.tinfo_t.set_volatile(self) -> None

ida_typeinf.tinfo_t.swap(self, r: "tinfo_t") -> None
    Assign this = r and r = this.

ida_typeinf.tinfo_t.write_bitfield_value(self, dst: "uint64", v: "uint64", bitoff: int) -> "uint64"

ida_typeinf.tinfo_visitor_t

ida_typeinf.tinfo_visitor_t.__disown__(self)

ida_typeinf.tinfo_visitor_t.__init__(self, s: int = 0)

ida_typeinf.tinfo_visitor_t.apply_to(self, tif: "tinfo_t", out: "type_mods_t" = None, name: str = None, cmt: str = None) -> int
    Call this function to initiate the traversal.

ida_typeinf.tinfo_visitor_t.prune_now(self) -> None
    To refuse to visit children of the current type, use this:

ida_typeinf.tinfo_visitor_t.state
    tinfo visitor states 
            

ida_typeinf.tinfo_visitor_t.visit_type(self, out: "type_mods_t", tif: "tinfo_t", name: str, cmt: str) -> int
    Visit a subtype. this function must be implemented in the derived class. it may optionally fill out with the new type info. this can be used to modify types (in this case the 'out' argument of apply_to() may not be nullptr) return 0 to continue the traversal. return !=0 to stop the traversal. 
            

ida_typeinf.type_attr_t

ida_typeinf.type_attr_t.__ge__(self, r: "type_attr_t") -> bool

ida_typeinf.type_attr_t.__init__(self)

ida_typeinf.type_attr_t.__lt__(self, r: "type_attr_t") -> bool

ida_typeinf.type_attr_t.key
    one symbol keys are reserved to be used by the kernel the ones starting with an underscore are reserved too 
            

ida_typeinf.type_attr_t.value
    attribute bytes

ida_typeinf.type_attrs_t

ida_typeinf.type_attrs_t.__getitem__(self, i: "size_t") -> "type_attr_t const &"

ida_typeinf.type_attrs_t.__init__(self, *args)

ida_typeinf.type_attrs_t.__len__(self) -> "size_t"

ida_typeinf.type_attrs_t.__setitem__(self, i: "size_t", v: "type_attr_t") -> None

ida_typeinf.type_attrs_t.append(self, x: "type_attr_t") -> None

ida_typeinf.type_attrs_t.at(self, _idx: "size_t") -> "type_attr_t const &"

ida_typeinf.type_attrs_t.begin(self, *args) -> "qvector< type_attr_t >::const_iterator"

ida_typeinf.type_attrs_t.capacity(self) -> "size_t"

ida_typeinf.type_attrs_t.clear(self) -> None

ida_typeinf.type_attrs_t.empty(self) -> bool

ida_typeinf.type_attrs_t.end(self, *args) -> "qvector< type_attr_t >::const_iterator"

ida_typeinf.type_attrs_t.erase(self, *args) -> "qvector< type_attr_t >::iterator"

ida_typeinf.type_attrs_t.extend(self, x: "type_attrs_t") -> None

ida_typeinf.type_attrs_t.extract(self) -> "type_attr_t *"

ida_typeinf.type_attrs_t.grow(self, *args) -> None

ida_typeinf.type_attrs_t.inject(self, s: "type_attr_t", len: "size_t") -> None

ida_typeinf.type_attrs_t.insert(self, it: "type_attr_t", x: "type_attr_t") -> "qvector< type_attr_t >::iterator"

ida_typeinf.type_attrs_t.pop_back(self) -> None

ida_typeinf.type_attrs_t.push_back(self, *args) -> "type_attr_t &"

ida_typeinf.type_attrs_t.qclear(self) -> None

ida_typeinf.type_attrs_t.reserve(self, cnt: "size_t") -> None

ida_typeinf.type_attrs_t.resize(self, *args) -> None

ida_typeinf.type_attrs_t.size(self) -> "size_t"

ida_typeinf.type_attrs_t.swap(self, r: "type_attrs_t") -> None

ida_typeinf.type_attrs_t.truncate(self) -> None

ida_typeinf.type_mods_t

ida_typeinf.type_mods_t.__init__(self)

ida_typeinf.type_mods_t.clear(self) -> None

ida_typeinf.type_mods_t.cmt
    comment for current type

ida_typeinf.type_mods_t.flags
    Type modification bits 
            

ida_typeinf.type_mods_t.has_cmt(self) -> bool

ida_typeinf.type_mods_t.has_info(self) -> bool

ida_typeinf.type_mods_t.has_name(self) -> bool

ida_typeinf.type_mods_t.has_type(self) -> bool

ida_typeinf.type_mods_t.is_rptcmt(self) -> bool

ida_typeinf.type_mods_t.name
    current type name

ida_typeinf.type_mods_t.set_new_cmt(self, c: str, rptcmt: bool) -> None

ida_typeinf.type_mods_t.set_new_name(self, n: str) -> None

ida_typeinf.type_mods_t.set_new_type(self, t: "tinfo_t") -> None
    The visit_type() function may optionally save the modified type info. Use the following functions for that. The new name and comment will be applied only if the current tinfo element has storage for them. 
            

ida_typeinf.type_mods_t.type
    current type

ida_typeinf.type_signed
    signed type

ida_typeinf.type_unsigned
    unsigned type

ida_typeinf.typedef_type_data_t

ida_typeinf.typedef_type_data_t.__init__(self, *args)

ida_typeinf.typedef_type_data_t.is_ordref
    is reference by ordinal?

ida_typeinf.typedef_type_data_t.name
    is_ordref=false: target type name. we do not own this pointer!

ida_typeinf.typedef_type_data_t.ordinal
    is_ordref=true: type ordinal number

ida_typeinf.typedef_type_data_t.resolve
    should resolve immediately?

ida_typeinf.typedef_type_data_t.swap(self, r: "typedef_type_data_t") -> None

ida_typeinf.typedef_type_data_t.til
    type library to use when resolving

ida_typeinf.udm_t

ida_typeinf.udm_t.__eq__(self, r: "udm_t") -> bool

ida_typeinf.udm_t.__init__(self, *args)
    Create a structure/union member, with the specified name and type.
    
    This constructor has the following signatures:
    
        1. udm_t(udm: udm_t)
        2. udm_t(name: str, type, offset: int)
    
    The 'type' descriptor, can be one of:
    
    * type_t: if the type is simple (integral/floating/bool). E.g., `BTF_INT`
    * tinfo_t: can handle more complex types (structures, pointers, arrays, ...)
    * str: a C type declaration
    
    If an input argument is incorrect, the constructor may raise an exception
    The size will be computed automatically.
    
    @param udm a source udm_t
    @param name a valid member name. Must not be empty.
    @param type the member type
    @param offset the member offset in bits. It is the caller's responsibility
           to specify correct offsets.

ida_typeinf.udm_t.__lt__(self, r: "udm_t") -> bool

ida_typeinf.udm_t.__ne__(self, r: "udm_t") -> bool

ida_typeinf.udm_t.begin(self) -> "uint64"

ida_typeinf.udm_t.can_be_dtor(self) -> bool

ida_typeinf.udm_t.can_rename(self) -> bool

ida_typeinf.udm_t.clr_baseclass(self) -> None

ida_typeinf.udm_t.clr_method(self) -> None

ida_typeinf.udm_t.clr_unaligned(self) -> None

ida_typeinf.udm_t.clr_vftable(self) -> None

ida_typeinf.udm_t.clr_virtbase(self) -> None

ida_typeinf.udm_t.cmt
    member comment

ida_typeinf.udm_t.effalign
    effective field alignment (in bytes)

ida_typeinf.udm_t.empty(self) -> bool

ida_typeinf.udm_t.end(self) -> "uint64"

ida_typeinf.udm_t.fda
    field alignment (shift amount)

ida_typeinf.udm_t.is_anonymous_udm(self) -> bool

ida_typeinf.udm_t.is_baseclass(self) -> bool

ida_typeinf.udm_t.is_bitfield(self) -> bool

ida_typeinf.udm_t.is_by_til(self) -> bool

ida_typeinf.udm_t.is_gap(self) -> bool

ida_typeinf.udm_t.is_method(self) -> bool

ida_typeinf.udm_t.is_regcmt(self) -> bool

ida_typeinf.udm_t.is_retaddr(self) -> bool

ida_typeinf.udm_t.is_savregs(self) -> bool

ida_typeinf.udm_t.is_special_member(self) -> bool

ida_typeinf.udm_t.is_unaligned(self) -> bool

ida_typeinf.udm_t.is_vftable(self) -> bool

ida_typeinf.udm_t.is_virtbase(self) -> bool

ida_typeinf.udm_t.is_zero_bitfield(self) -> bool

ida_typeinf.udm_t.name
    member name

ida_typeinf.udm_t.offset
    member offset in bits

ida_typeinf.udm_t.repr
    radix, refinfo, strpath, custom_id, strtype

ida_typeinf.udm_t.set_baseclass(self, on: bool = True) -> None

ida_typeinf.udm_t.set_by_til(self, on: bool = True) -> None

ida_typeinf.udm_t.set_method(self, on: bool = True) -> None

ida_typeinf.udm_t.set_regcmt(self, on: bool = True) -> None

ida_typeinf.udm_t.set_retaddr(self, on: bool = True) -> None

ida_typeinf.udm_t.set_savregs(self, on: bool = True) -> None

ida_typeinf.udm_t.set_unaligned(self, on: bool = True) -> None

ida_typeinf.udm_t.set_value_repr(self, r: "value_repr_t") -> None

ida_typeinf.udm_t.set_vftable(self, on: bool = True) -> None

ida_typeinf.udm_t.set_virtbase(self, on: bool = True) -> None

ida_typeinf.udm_t.size
    size in bits

ida_typeinf.udm_t.swap(self, r: "udm_t") -> None

ida_typeinf.udm_t.tafld_bits
    TAH bits.

ida_typeinf.udm_t.type
    member type

ida_typeinf.udm_visitor_t

ida_typeinf.udm_visitor_t.__disown__(self)

ida_typeinf.udm_visitor_t.__init__(self)

ida_typeinf.udm_visitor_t.visit_udm(self, tid: "tid_t", tif: "tinfo_t", udt: "udt_type_data_t", idx: "ssize_t") -> int
    @param tid: udt tid
    @param tif: udt type info (may be nullptr for corrupted idbs)
    @param udt: udt type data (may be nullptr for corrupted idbs)
    @param idx: the index of udt the member (may be -1 if udm was not found)

ida_typeinf.udt_type_data_t

ida_typeinf.udt_type_data_t.__init__(self)

ida_typeinf.udt_type_data_t.add_member(self, _name: str, _type: "tinfo_t", _offset: "uint64" = 0) -> "udm_t &"
    Add a new member to a structure or union. This function just pushes a new member to the back of the structure/union member vector.
    
    @param _name: Member name. Must not be nullptr.
    @param _type: Member type. Must not be empty.
    @param _offset: Member offset in bits. It is the caller's responsibility to specify correct offsets.
    @returns { Reference to the newly added member }

ida_typeinf.udt_type_data_t.effalign
    effective structure alignment (in bytes)

ida_typeinf.udt_type_data_t.find_member(self, *args) -> "ssize_t"
    This function has the following signatures:
    
        0. find_member(pattern_udm: udm_t *, strmem_flags: int) -> ssize_t
        1. find_member(name: str) -> ssize_t
        2. find_member(bit_offset: uint64) -> ssize_t
    
    # 0: find_member(pattern_udm: udm_t *, strmem_flags: int) -> ssize_t
    
    tinfo_t::find_udm 
            
    @returns the index of the found member or -1
    
    # 1: find_member(name: str) -> ssize_t
    
    
    # 2: find_member(bit_offset: uint64) -> ssize_t

ida_typeinf.udt_type_data_t.get_best_fit_member(self, disp)
    Get the member that is most likely referenced by the specified offset.
    
    @param disp the byte offset
    @return a tuple (int, udm_t), or (-1, None) if member not found

ida_typeinf.udt_type_data_t.is_cppobj(self) -> bool

ida_typeinf.udt_type_data_t.is_fixed(self) -> bool

ida_typeinf.udt_type_data_t.is_last_baseclass(self, idx: "size_t") -> bool

ida_typeinf.udt_type_data_t.is_msstruct(self) -> bool

ida_typeinf.udt_type_data_t.is_unaligned(self) -> bool

ida_typeinf.udt_type_data_t.is_union
    is union or struct?

ida_typeinf.udt_type_data_t.is_vftable(self) -> bool

ida_typeinf.udt_type_data_t.pack
    #pragma pack() alignment (shift amount)

ida_typeinf.udt_type_data_t.sda
    declared structure alignment (shift amount+1). 0 - unspecified

ida_typeinf.udt_type_data_t.set_fixed(self, on: bool = True) -> None

ida_typeinf.udt_type_data_t.set_vftable(self, on: bool = True) -> None

ida_typeinf.udt_type_data_t.swap(self, r: "udt_type_data_t") -> None

ida_typeinf.udt_type_data_t.taudt_bits
    TA... and TAUDT... bits.

ida_typeinf.udt_type_data_t.total_size
    total structure size in bytes

ida_typeinf.udt_type_data_t.unpadded_size
    unpadded structure size in bytes

ida_typeinf.udt_type_data_t.version
    version of udt_type_data_t

ida_typeinf.udt_type_data_t__find_member(_this: "udt_type_data_t", udm: "udm_t", strmem_flags: int) -> "ssize_t"

ida_typeinf.udt_type_data_t__get_best_fit_member(_this: "udt_type_data_t", disp: "asize_t") -> "ssize_t"

ida_typeinf.udtmembervec_t

ida_typeinf.udtmembervec_t.__init__(self)

ida_typeinf.udtmembervec_template_t

ida_typeinf.udtmembervec_template_t.__eq__(self, r: "udtmembervec_template_t") -> bool

ida_typeinf.udtmembervec_template_t.__getitem__(self, i: "size_t") -> "udm_t const &"

ida_typeinf.udtmembervec_template_t.__init__(self, *args)

ida_typeinf.udtmembervec_template_t.__len__(self) -> "size_t"

ida_typeinf.udtmembervec_template_t.__ne__(self, r: "udtmembervec_template_t") -> bool

ida_typeinf.udtmembervec_template_t.__setitem__(self, i: "size_t", v: "udm_t") -> None

ida_typeinf.udtmembervec_template_t._del(self, x: "udm_t") -> bool

ida_typeinf.udtmembervec_template_t.add_unique(self, x: "udm_t") -> bool

ida_typeinf.udtmembervec_template_t.append(self, x: "udm_t") -> None

ida_typeinf.udtmembervec_template_t.at(self, _idx: "size_t") -> "udm_t const &"

ida_typeinf.udtmembervec_template_t.begin(self, *args) -> "qvector< udm_t >::const_iterator"

ida_typeinf.udtmembervec_template_t.capacity(self) -> "size_t"

ida_typeinf.udtmembervec_template_t.clear(self) -> None

ida_typeinf.udtmembervec_template_t.empty(self) -> bool

ida_typeinf.udtmembervec_template_t.end(self, *args) -> "qvector< udm_t >::const_iterator"

ida_typeinf.udtmembervec_template_t.erase(self, *args) -> "qvector< udm_t >::iterator"

ida_typeinf.udtmembervec_template_t.extend(self, x: "udtmembervec_template_t") -> None

ida_typeinf.udtmembervec_template_t.extract(self) -> "udm_t *"

ida_typeinf.udtmembervec_template_t.find(self, *args) -> "qvector< udm_t >::const_iterator"

ida_typeinf.udtmembervec_template_t.grow(self, *args) -> None

ida_typeinf.udtmembervec_template_t.has(self, x: "udm_t") -> bool

ida_typeinf.udtmembervec_template_t.inject(self, s: "udm_t", len: "size_t") -> None

ida_typeinf.udtmembervec_template_t.insert(self, it: "udm_t", x: "udm_t") -> "qvector< udm_t >::iterator"

ida_typeinf.udtmembervec_template_t.pop_back(self) -> None

ida_typeinf.udtmembervec_template_t.push_back(self, *args) -> "udm_t &"

ida_typeinf.udtmembervec_template_t.qclear(self) -> None

ida_typeinf.udtmembervec_template_t.reserve(self, cnt: "size_t") -> None

ida_typeinf.udtmembervec_template_t.resize(self, *args) -> None

ida_typeinf.udtmembervec_template_t.size(self) -> "size_t"

ida_typeinf.udtmembervec_template_t.swap(self, r: "udtmembervec_template_t") -> None

ida_typeinf.udtmembervec_template_t.truncate(self) -> None

ida_typeinf.unpack_idcobj_from_bv(obj: "idc_value_t *", tif: "tinfo_t", bytes: "bytevec_t const &", pio_flags: int = 0) -> "error_t"
    Read a typed idc object from the byte vector.

ida_typeinf.unpack_idcobj_from_idb(obj: "idc_value_t *", tif: "tinfo_t", ea: ida_idaapi.ea_t, off0: "bytevec_t const *", pio_flags: int = 0) -> "error_t"
    Collection of register objects.
    
    Read a typed idc object from the database 
            

ida_typeinf.unpack_object_from_bv(til: til_t, type: bytes, fields: bytes, bytes, pio_flags: int = 0)
    Unpacks a buffer into an object.
    Returns the error_t returned by idaapi.pack_object_to_idb
    
    @param til: Type library. 'None' can be passed.
    @param type: type string
    @param fields: fields string (may be empty or None)
    @param bytes: the bytes to unpack
    @param pio_flags: flags used while unpacking
    @return:
        - tuple(0, err) on failure
        - tuple(1, obj) on success

ida_typeinf.unpack_object_from_idb(til: til_t, type: bytes, fields: bytes, ea: ida_idaapi.ea_t, pio_flags: int = 0)
    Unpacks from the database at 'ea' to an object.
    Please refer to unpack_object_from_bv()

ida_typeinf.use_golang_cc() -> bool
    is GOLANG calling convention used by default?

ida_typeinf.valstr_t

ida_typeinf.valstr_t.__init__(self)

ida_typeinf.valstr_t.info
    additional info

ida_typeinf.valstr_t.length
    length if printed on one line

ida_typeinf.valstr_t.members
    strings for members, each member separately

ida_typeinf.valstr_t.oneline
    result if printed on one line in UTF-8 encoding

ida_typeinf.valstr_t.props
    temporary properties, used internally

ida_typeinf.valstrs_t

ida_typeinf.valstrs_t.__init__(self)

ida_typeinf.valstrvec_t

ida_typeinf.valstrvec_t.__getitem__(self, i: "size_t") -> "valstr_t const &"

ida_typeinf.valstrvec_t.__init__(self, *args)

ida_typeinf.valstrvec_t.__len__(self) -> "size_t"

ida_typeinf.valstrvec_t.__setitem__(self, i: "size_t", v: "valstr_t") -> None

ida_typeinf.valstrvec_t.append(self, x: "valstr_t") -> None

ida_typeinf.valstrvec_t.at(self, _idx: "size_t") -> "valstr_t const &"

ida_typeinf.valstrvec_t.begin(self, *args) -> "qvector< valstr_t >::const_iterator"

ida_typeinf.valstrvec_t.capacity(self) -> "size_t"

ida_typeinf.valstrvec_t.clear(self) -> None

ida_typeinf.valstrvec_t.empty(self) -> bool

ida_typeinf.valstrvec_t.end(self, *args) -> "qvector< valstr_t >::const_iterator"

ida_typeinf.valstrvec_t.erase(self, *args) -> "qvector< valstr_t >::iterator"

ida_typeinf.valstrvec_t.extend(self, x: "valstrvec_t") -> None

ida_typeinf.valstrvec_t.extract(self) -> "valstr_t *"

ida_typeinf.valstrvec_t.grow(self, *args) -> None

ida_typeinf.valstrvec_t.inject(self, s: "valstr_t", len: "size_t") -> None

ida_typeinf.valstrvec_t.insert(self, it: "valstr_t", x: "valstr_t") -> "qvector< valstr_t >::iterator"

ida_typeinf.valstrvec_t.pop_back(self) -> None

ida_typeinf.valstrvec_t.push_back(self, *args) -> "valstr_t &"

ida_typeinf.valstrvec_t.qclear(self) -> None

ida_typeinf.valstrvec_t.reserve(self, cnt: "size_t") -> None

ida_typeinf.valstrvec_t.resize(self, *args) -> None

ida_typeinf.valstrvec_t.size(self) -> "size_t"

ida_typeinf.valstrvec_t.swap(self, r: "valstrvec_t") -> None

ida_typeinf.valstrvec_t.truncate(self) -> None

ida_typeinf.value_repr_t

ida_typeinf.value_repr_t.__init__(self)

ida_typeinf.value_repr_t.__str__(self) -> str

ida_typeinf.value_repr_t._print(self, colored: bool = False) -> "size_t"

ida_typeinf.value_repr_t.ap
    FRB_TABFORM, AP_SIGNED is ignored, use FRB_SIGNED instead 
            

ida_typeinf.value_repr_t.cd
    FRB_CUSTOM.

ida_typeinf.value_repr_t.clear(self) -> None

ida_typeinf.value_repr_t.delta
    FRB_STROFF.

ida_typeinf.value_repr_t.empty(self) -> bool

ida_typeinf.value_repr_t.from_opinfo(self, flags: "flags64_t", afl: "aflags_t", opinfo: "opinfo_t", _ap: "array_parameters_t") -> bool

ida_typeinf.value_repr_t.get_vtype(self) -> "uint64"

ida_typeinf.value_repr_t.has_lzeroes(self) -> bool

ida_typeinf.value_repr_t.has_tabform(self) -> bool

ida_typeinf.value_repr_t.init_ap(self, _ap: "array_parameters_t") -> None

ida_typeinf.value_repr_t.is_custom(self) -> bool

ida_typeinf.value_repr_t.is_enum(self) -> bool

ida_typeinf.value_repr_t.is_offset(self) -> bool

ida_typeinf.value_repr_t.is_signed(self) -> bool

ida_typeinf.value_repr_t.is_strlit(self) -> bool

ida_typeinf.value_repr_t.is_stroff(self) -> bool

ida_typeinf.value_repr_t.is_typref(self) -> bool

ida_typeinf.value_repr_t.parse_value_repr(self, *args) -> bool

ida_typeinf.value_repr_t.ri
    FRB_OFFSET.

ida_typeinf.value_repr_t.set_ap(self, _ap: "array_parameters_t") -> None

ida_typeinf.value_repr_t.set_lzeroes(self, on: bool) -> None

ida_typeinf.value_repr_t.set_signed(self, on: bool) -> None

ida_typeinf.value_repr_t.set_tabform(self, on: bool) -> None

ida_typeinf.value_repr_t.set_vtype(self, vt: "uint64") -> None

ida_typeinf.value_repr_t.strtype
    FRB_STRLIT.

ida_typeinf.value_repr_t.swap(self, r: "value_repr_t") -> None

ida_typeinf.value_repr_t.type_ordinal
    FRB_STROFF, FRB_ENUM.

ida_typeinf.value_repr_t__from_opinfo(_this: "value_repr_t", flags: "flags64_t", afl: "aflags_t", opinfo: "opinfo_t", ap: "array_parameters_t") -> bool

ida_typeinf.value_repr_t__print_(_this: "value_repr_t", colored: bool) -> str

ida_typeinf.verify_argloc(vloc: "argloc_t", size: int, gaps: "rangeset_t") -> int
    Verify argloc_t. 
            
    @param vloc: argloc to verify
    @param size: total size of the variable
    @param gaps: if not nullptr, specifies gaps in structure definition. these gaps should not map to any argloc, but everything else must be covered
    @returns 0 if ok, otherwise an interr code.

ida_typeinf.verify_tinfo(typid: "typid_t") -> int

ida_typeinf.visit_stroff_udms(sfv: "udm_visitor_t", path: "tid_t const *", disp: "adiff_t *", appzero: bool) -> "adiff_t *"
    Visit structure fields in a stroff expression or in a reference to a struct data variable. This function can be used to enumerate all components of an expression like 'a.b.c'. 
            
    @param sfv: visitor object
    @param path: struct path (path[0] contains the initial struct id)
    @param disp: offset into structure
    @param appzero: should visit field at offset zero?
    @returns visitor result

ida_typeinf.visit_subtypes(visitor: "tinfo_visitor_t", out: "type_mods_t", tif: "tinfo_t", name: str, cmt: str) -> int

ida_typeinf.write_tinfo_bitfield_value(typid: "typid_t", dst: "uint64", v: "uint64", bitoff: int) -> "uint64"

ida_ua
    Functions that deal with the disassembling of program instructions.
    
    There are 2 kinds of functions:
    * functions that are called from the kernel to disassemble an instruction. These functions call IDP module for it.
    * functions that are called from IDP module to disassemble an instruction. We will call them 'helper functions'.
    
    
    Disassembly of an instruction is made in three steps:
    0. analysis: ana.cpp
    1. emulation: emu.cpp
    2. conversion to text: out.cpp
    
    
    The kernel calls the IDP module to perform these steps. At first, the kernel always calls the analysis. The analyzer must decode the instruction and fill the insn_t instance that it receives through its callback. It must not change anything in the database.
    The second step, the emulation, is called for each instruction. This step must make necessary changes to the database, plan analysis of subsequent instructions, track register values, memory contents, etc. Please keep in mind that the kernel may call the emulation step for any address in the program - there is no ordering of addresses. Usually, the emulation is called for consecutive addresses but this is not guaranteed.
    The last step, conversion to text, is called each time an instruction is displayed on the screen. The kernel will always call the analysis step before calling the text conversion step. The emulation and the text conversion steps should use the information stored in the insn_t instance they receive. They should not access the bytes of the instruction and decode it again - this should only be done in the analysis step. 
        

ida_ua.BINOPSTATE_DONE
    have been generated

ida_ua.BINOPSTATE_GO
    being generated

ida_ua.BINOPSTATE_NONE
    not generated yet

ida_ua.COMMSTATE_DONE
    have been generated

ida_ua.COMMSTATE_GO
    being generated

ida_ua.COMMSTATE_NONE
    not generated yet

ida_ua.CTXF_BINOP_STATE
    opcode bytes state:

ida_ua.CTXF_BIT_PREFIX
    generate a line prefix with a bit offset, e.g.: 12345678.3

ida_ua.CTXF_CMT_STATE
    comment state:

ida_ua.CTXF_CODE
    display as code regardless of the database flags

ida_ua.CTXF_DBLIND_OPND
    an operand was printed with double indirection (e.g. =var in arm)

ida_ua.CTXF_DEMANGLED_LABEL
    generate only demangled label as comment

ida_ua.CTXF_DEMANGLED_OK
    the label has been demangled successfully

ida_ua.CTXF_GEN_CMT
    generate the comment along with the next line

ida_ua.CTXF_GEN_XREFS
    generate the xrefs along with the next line

ida_ua.CTXF_HIDDEN_ADDR
    To generate an hidden addr tag at the beginning of the line.

ida_ua.CTXF_LABEL_OK
    the label have been generated

ida_ua.CTXF_MAIN
    produce only the essential line(s)

ida_ua.CTXF_MULTI
    enable multi-line essential lines

ida_ua.CTXF_NORMAL_LABEL
    generate plain label (+demangled label as cmt)

ida_ua.CTXF_OUTCTX_T
    instance is, in fact, a outctx_t

ida_ua.CTXF_OVSTORE_PRNT
    out_value should store modified values

ida_ua.CTXF_STACK
    stack view (display undefined items as 2/4/8 bytes)

ida_ua.CTXF_VOIDS
    display void marks

ida_ua.CTXF_XREF_STATE
    xref state:

ida_ua.FCBF_CONT
    don't stop on decoding, or any other kind of error

ida_ua.FCBF_DELIM
    add the 'ash'-specified delimiters around the generated data. Note: if those are not defined and the INFFL_ALLASM is not set, format_charlit() will return an error 
            

ida_ua.FCBF_ERR_REPL
    in case of an error, use a CP_REPLCHAR instead of a hex representation of the problematic byte 
            

ida_ua.FCBF_FF_LIT
    in case of codepoints == 0xFF, use it as-is (i.e., LATIN SMALL LETTER Y WITH DIAERESIS). If both this, and FCBF_REPL are specified, this will take precedence 
            

ida_ua.GH_BYTESEX_HAS_HIGHBYTE
    describe inf.is_wide_high_byte_first()

ida_ua.GH_PRINT_ASM
    selected assembler

ida_ua.GH_PRINT_BYTESEX
    byte sex

ida_ua.GH_PRINT_HEADER
    lines from ash.header

ida_ua.GH_PRINT_PROC
    processor name

ida_ua.INSN_64BIT
    belongs to 64bit segment?

ida_ua.INSN_MACRO
    macro instruction

ida_ua.INSN_MODMAC
    may modify the database to make room for the macro insn

ida_ua.MAKELINE_BINPREF
    allow display of binary prefix

ida_ua.MAKELINE_STACK
    allow display of sp trace prefix

ida_ua.MAKELINE_VOID
    allow display of '<suspicious>' marks

ida_ua.OF_NO_BASE_DISP
    base displacement doesn't exist. meaningful only for o_displ type. if set, base displacement (op_t::addr) doesn't exist. 
            

ida_ua.OF_NUMBER
    the operand can be converted to a number only

ida_ua.OF_OUTER_DISP
    outer displacement exists. meaningful only for o_displ type. if set, outer displacement (op_t::value) exists. 
            

ida_ua.OF_SHOW
    should the operand be displayed?

ida_ua.OOFS_IFSIGN
    output sign if needed

ida_ua.OOFS_NEEDSIGN
    always out sign (+-)

ida_ua.OOFS_NOSIGN
    don't output sign, forbid the user to change the sign

ida_ua.OOFW_16
    16 bit width

ida_ua.OOFW_24
    24 bit width

ida_ua.OOFW_32
    32 bit width

ida_ua.OOFW_64
    64 bit width

ida_ua.OOFW_8
    8 bit width

ida_ua.OOFW_IMM
    take from x.dtype

ida_ua.OOF_ADDR
    output x.addr, otherwise x.value

ida_ua.OOF_ANYSERIAL
    if enum: select first available serial

ida_ua.OOF_LZEROES
    print leading zeroes

ida_ua.OOF_NOBNOT
    prohibit use of binary not

ida_ua.OOF_NO_LZEROES
    do not print leading zeroes; if none of OOF_LZEROES and OOF_NO_LZEROES was specified, is_lzero() is used 
            

ida_ua.OOF_NUMBER
    always as a number

ida_ua.OOF_OUTER
    output outer operand

ida_ua.OOF_SIGNED
    output as signed if < 0

ida_ua.OOF_SIGNMASK
    sign symbol (+/-) output

ida_ua.OOF_SPACES
    do not suppress leading spaces; currently works only for floating point numbers 
            

ida_ua.OOF_WIDTHMASK
    width of value in bits

ida_ua.OOF_ZSTROFF
    meaningful only if is_stroff(F); append a struct field name if the field offset is zero? if AFL_ZSTROFF is set, then this flag is ignored. 
            

ida_ua.PACK_FORM_DEF
    packed factor defined. (!o_reg + dt_packreal) 
            

ida_ua.STKVAR_VALID_SIZE
    x.dtype contains correct variable type (for insns like 'lea' this bit must be off). in general, dr_O references do not allow to determine the variable size 
            

ida_ua.XREFSTATE_DONE
    have been generated

ida_ua.XREFSTATE_GO
    being generated

ida_ua.XREFSTATE_NONE
    not generated yet

ida_ua.calc_dataseg(insn: "insn_t", n: int = -1, rgnum: int = -1) -> ida_idaapi.ea_t

ida_ua.can_decode(ea: ida_idaapi.ea_t) -> bool
    Can the bytes at address 'ea' be decoded as instruction? 
            
    @param ea: linear address
    @returns whether or not the contents at that address could be a valid instruction

ida_ua.construct_macro(*args)
    See ua.hpp's construct_macro().
    
    This function has the following signatures
    
        1. construct_macro(insn: insn_t, enable: bool, build_macro: callable) -> bool
        2. construct_macro(constuctor: macro_constructor_t, insn: insn_t, enable: bool) -> bool
    
    @param insn: the instruction to build the macro for
    @param enable: enable macro generation
    @param build_macro: a callable with 2 arguments: an insn_t, and
                        whether it is ok to consider the next instruction
                        for the macro
    @param constructor: a macro_constructor_t implementation
    @return: success

ida_ua.create_insn(ea: ida_idaapi.ea_t, out: "insn_t" = None) -> int
    Create an instruction at the specified address. This function checks if an instruction is present at the specified address and will try to create one if there is none. It will fail if there is a data item or other items hindering the creation of the new instruction. This function will also fill the 'out' structure. 
            
    @param ea: linear address
    @param out: the resulting instruction
    @returns the length of the instruction or 0

ida_ua.create_outctx(ea: ida_idaapi.ea_t, F: "flags64_t" = 0, suspop: int = 0) -> "outctx_base_t *"
    Create a new output context. To delete it, just use "delete pctx" 
            

ida_ua.decode_insn(out: "insn_t", ea: ida_idaapi.ea_t) -> int
    Analyze the specified address and fill 'out'. This function does not modify the database. It just tries to interpret the specified address as an instruction and fills the 'out' structure. 
            
    @param out: the resulting instruction
    @param ea: linear address
    @returns the length of the (possible) instruction or 0

ida_ua.decode_preceding_insn(out: insn_t, ea: ida_idaapi.ea_t) -> Tuple[ida_idaapi.ea_t, bool]
    Decodes the preceding instruction.
    
    @param out: instruction storage
    @param ea: current ea
    @return: tuple(preceeding_ea or BADADDR, farref = Boolean)

ida_ua.decode_prev_insn(out: "insn_t", ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Decode previous instruction if it exists, fill 'out'. 
            
    @param out: the resulting instruction
    @param ea: the address to decode the previous instruction from
    @returns the previous instruction address (BADADDR-no such insn)

ida_ua.dt_bitfild
    bit field (mc680x0)

ida_ua.dt_byte
    8 bit integer

ida_ua.dt_byte16
    128 bit integer

ida_ua.dt_byte32
    256 bit integer

ida_ua.dt_byte64
    512 bit integer

ida_ua.dt_code
    ptr to code (not used?)

ida_ua.dt_double
    8 byte floating point

ida_ua.dt_dword
    32 bit integer

ida_ua.dt_float
    4 byte floating point

ida_ua.dt_fword
    48 bit

ida_ua.dt_half
    2-byte floating point

ida_ua.dt_ldbl
    long double (which may be different from tbyte)

ida_ua.dt_packreal
    packed real format for mc68040

ida_ua.dt_qword
    64 bit integer

ida_ua.dt_string
    pointer to asciiz string

ida_ua.dt_tbyte
    variable size ( processor_t::tbyte_size) floating point

ida_ua.dt_unicode
    pointer to unicode string

ida_ua.dt_void
    none

ida_ua.dt_word
    16 bit integer

ida_ua.get_dtype_by_size(size: "asize_t") -> int
    Get op_t::dtype from size.

ida_ua.get_dtype_flag(dtype: "op_dtype_t") -> "flags64_t"
    Get flags for op_t::dtype field.

ida_ua.get_dtype_size(dtype: "op_dtype_t") -> "size_t"
    Get size of opt_::dtype field.

ida_ua.get_immvals(ea: ida_idaapi.ea_t, n: int, F: "flags64_t" = 0) -> "PyObject *"
    Get immediate values at the specified address. This function decodes instruction at the specified address or inspects the data item. It finds immediate values and copies them to 'out'. This function will store the original value of the operands in 'out', unless the last bits of 'F' are "...0 11111111", in which case the transformed values (as needed for printing) will be stored instead. 
            
    @param ea: address to analyze
    @param n: 0..UA_MAXOP-1 operand number, OPND_ALL all the operands
    @param F: flags for the specified address
    @returns number of immediate values (0..2*UA_MAXOP)

ida_ua.get_lookback() -> int
    Number of instructions to look back. This variable is not used by the kernel. Its value may be specified in ida.cfg: LOOKBACK = <number>. IDP may use it as you like it. (TMS module uses it) 
            

ida_ua.get_printable_immvals(ea: ida_idaapi.ea_t, n: int, F: "flags64_t" = 0) -> "PyObject *"
    Get immediate ready-to-print values at the specified address 
            
    @param ea: address to analyze
    @param n: 0..UA_MAXOP-1 operand number, OPND_ALL all the operands
    @param F: flags for the specified address
    @returns number of immediate values (0..2*UA_MAXOP)

ida_ua.insn_add_cref(insn: "insn_t", to: ida_idaapi.ea_t, opoff: int, type: "cref_t") -> None

ida_ua.insn_add_dref(insn: "insn_t", to: ida_idaapi.ea_t, opoff: int, type: "dref_t") -> None

ida_ua.insn_add_off_drefs(insn: "insn_t", x: "op_t", type: "dref_t", outf: int) -> ida_idaapi.ea_t

ida_ua.insn_create_stkvar(insn: "insn_t", x: "op_t", v: "adiff_t", flags: int) -> bool

ida_ua.insn_t

ida_ua.insn_t.__get_auxpref__(self) -> int

ida_ua.insn_t.__get_operand__(self, n: int) -> "op_t *"

ida_ua.insn_t.__get_ops__(self) -> "wrapped_array_t< op_t,8 >"

ida_ua.insn_t.__getitem__(self, idx)
    Operands can be accessed directly as indexes
    @return op_t: Returns an operand of type op_t

ida_ua.insn_t.__init__(self)

ida_ua.insn_t.__iter__(self)

ida_ua.insn_t.__set_auxpref__(self, v: int) -> None

ida_ua.insn_t.add_cref(self, to: ida_idaapi.ea_t, opoff: int, type: "cref_t") -> None
    Add a code cross-reference from the instruction. 
            
    @param to: target linear address
    @param opoff: offset of the operand from the start of instruction. if the offset is unknown, then 0.
    @param type: type of xref

ida_ua.insn_t.add_dref(self, to: ida_idaapi.ea_t, opoff: int, type: "dref_t") -> None
    Add a data cross-reference from the instruction. See add_off_drefs() - usually it can be used in most cases. 
            
    @param to: target linear address
    @param opoff: offset of the operand from the start of instruction if the offset is unknown, then 0
    @param type: type of xref

ida_ua.insn_t.add_off_drefs(self, x: "op_t", type: "dref_t", outf: int) -> ida_idaapi.ea_t
    Add xrefs for an operand of the instruction. This function creates all cross references for 'enum', 'offset' and 'structure offset' operands. Use add_off_drefs() in the presence of negative offsets. 
            
    @param x: reference to operand
    @param type: type of xref
    @param outf: out_value() flags. These flags should match the flags used to output the operand
    @retval if: is_off(): the reference target address (the same as calc_reference_data).
    @retval if: is_stroff(): BADADDR because for stroffs the target address is unknown
    @retval otherwise: BADADDR because enums do not represent addresses

ida_ua.insn_t.assign(self, other: "insn_t") -> None

ida_ua.insn_t.auxpref
    processor dependent field

ida_ua.insn_t.auxpref
    processor dependent field

ida_ua.insn_t.create_op_data(self, *args) -> bool

ida_ua.insn_t.create_stkvar(self, x: "op_t", v: "adiff_t", flags_: int) -> bool

ida_ua.insn_t.cs
    Current segment base paragraph. Initialized by the kernel.

ida_ua.insn_t.ea
    Linear address of the instruction. Initialized by the kernel. 
            

ida_ua.insn_t.flags
    Instruction flags

ida_ua.insn_t.get_canon_feature(self, *args) -> int
    see instruc_t::feature

ida_ua.insn_t.get_canon_mnem(self, *args) -> str
    see instruc_t::name

ida_ua.insn_t.get_next_byte(self) -> "uint8"

ida_ua.insn_t.get_next_dword(self) -> int

ida_ua.insn_t.get_next_qword(self) -> "uint64"

ida_ua.insn_t.get_next_word(self) -> "uint16"

ida_ua.insn_t.insnpref
    processor dependent field

ida_ua.insn_t.ip
    Virtual address of the instruction (address within the segment). Initialized by the kernel. 
            

ida_ua.insn_t.is_64bit(self) -> bool
    Belongs to a 64bit segment?

ida_ua.insn_t.is_canon_insn(self, *args) -> bool
    see processor_t::is_canon_insn()

ida_ua.insn_t.is_macro(self) -> bool
    Is a macro instruction?

ida_ua.insn_t.itype
    Internal code of instruction (only for canonical insns - not user defined!). IDP should define its own instruction codes. These codes are usually defined in ins.hpp. The array of instruction names and features (ins.cpp) is accessed using this code. 
            

ida_ua.insn_t.ops
    array of operands

ida_ua.insn_t.ops
    array of operands

ida_ua.insn_t.segpref
    processor dependent field

ida_ua.insn_t.size
    Size of instruction in bytes. The analyzer should put here the actual size of the instruction. 
            

ida_ua.insn_t__from_ptrval__(ptrval: "size_t") -> "insn_t *"

ida_ua.is_floating_dtype(dtype: "op_dtype_t") -> bool
    Is a floating type operand?

ida_ua.macro_constructor_t

ida_ua.macro_constructor_t.__disown__(self)

ida_ua.macro_constructor_t.__init__(self)

ida_ua.macro_constructor_t.build_macro(self, insn: "insn_t", may_go_forward: bool) -> bool
    Try to extend the instruction.
    This function may modify 'insn' and return false; these changes will be accepted by the kernel but the instruction will not be considered as a macro.
    
    @param insn: Instruction to modify, usually the first instruction of the macro
    @param may_go_forward: Is it ok to consider the next instruction for the macro? This argument may be false, for example, if there is a cross reference to the end of INSN. In this case creating a macro is not desired. However, it may still be useful to perform minor tweaks to the instruction using the information about the surrounding instructions.
    @returns true if created an macro instruction.

ida_ua.macro_constructor_t.construct_macro(self, insn: "insn_t", enable: bool) -> bool
    Construct a macro instruction. This function may be called from ana() to generate a macro instruction.
    The real work is done by the 'build_macro()' virtual function. It must be defined by the processor module.
    construct_macro() modifies the database using the info provided by build_macro(). It verifies if the instruction can really be created (for example, that other items do not hinder), may plan to reanalyze the macro, etc. If the macro instructions are disabled by the user, construct_macro() will destroy the macro instruction. Note: if INSN_MODMAC is not set in insn.flags, the database will not be modified.
    
    @param insn: the instruction to modify into a macro
    @param enable: enable macro generation
    @retval true: the macro instruction is generated in 'insn'
    @retval false: did not create a macro

ida_ua.map_code_ea(*args) -> ida_idaapi.ea_t

ida_ua.map_data_ea(*args) -> ida_idaapi.ea_t

ida_ua.map_ea(*args) -> ida_idaapi.ea_t

ida_ua.o_displ
    Memory Ref [Base Reg + Index Reg + Displacement].
    
    A memory reference using register contents with displacement. The displacement should be stored in the op_t::addr field. The rest of information is stored the same way as in o_phrase. 
            

ida_ua.o_far
    Immediate Far Address (CODE).
    
    If the current processor has a special addressing mode for inter-segment references, then this operand type should be used instead of o_near. If you want, you may use PR_CHK_XREF in processor_t::flag to disable inter-segment calls if o_near operand type is used. Currently only IBM PC uses this flag. 
            

ida_ua.o_idpspec0
    processor specific type.

ida_ua.o_idpspec1
    processor specific type.

ida_ua.o_idpspec2
    processor specific type.

ida_ua.o_idpspec3
    processor specific type.

ida_ua.o_idpspec4
    processor specific type.

ida_ua.o_idpspec5
    processor specific type. (there can be more processor specific types) 
            

ida_ua.o_imm
    Immediate Value.
    
    Any operand consisting of only a number is represented by this operand type. The value should be stored in op_t::value. You may sign extend short (1-2 byte) values. In any case don't forget to specify op_t::dtype (should be set for all operand types). 
            

ida_ua.o_mem
    Direct Memory Reference (DATA).
    
    A direct memory data reference whose target address is known at compilation time. The target virtual address is stored in op_t::addr and the full address is calculated as to_ea(  insn_t::cs, op_t::addr ). For the processors with complex memory organization the final address can be calculated using other segment registers. For flat memories, op_t::addr is the final address and insn_t::cs is usually equal to zero. In any case, the address within the segment should be stored in op_t::addr. 
            

ida_ua.o_near
    Immediate Near Address (CODE).
    
    A direct memory code reference whose target address is known at the compilation time. The target virtual address is stored in op_t::addr and the final address is always to_ea( insn_t::cs, op_t::addr). Usually this operand type is used for the branches and calls whose target address is known. If the current processor has 2 different types of references for inter-segment and intra-segment references, then this should be used only for intra-segment references.
    If the above operand types do not cover all possible addressing modes, then use o_idpspec... operand types. 
            

ida_ua.o_phrase
    Memory Ref [Base Reg + Index Reg].
    
    A memory reference using register contents. Indexed, register based, and other addressing modes can be represented with the operand type. This addressing mode cannot contain immediate values (use o_displ instead). The phrase number should be stored in op_t::phrase. To denote the pre-increment and similar features please use additional operand fields like op_t::specflag... Usually op_t::phrase contains the register number and additional information is stored in op_t::specflags... Please note that this operand type cannot contain immediate values (except the scaling coefficients). 
            

ida_ua.o_reg
    General Register (al,ax,es,ds...).
    
    The register number should be stored in op_t::reg. All processor registers, including special registers, can be represented by this operand type. 
            

ida_ua.o_void
    No Operand.

ida_ua.op_t

ida_ua.op_t.__get_addr__(self) -> ida_idaapi.ea_t

ida_ua.op_t.__get_reg_phrase__(self) -> "uint16"

ida_ua.op_t.__get_specval__(self) -> ida_idaapi.ea_t

ida_ua.op_t.__get_value64__(self) -> "uint64"

ida_ua.op_t.__get_value__(self) -> ida_idaapi.ea_t

ida_ua.op_t.__init__(self)

ida_ua.op_t.__set_addr__(self, v: ida_idaapi.ea_t) -> None

ida_ua.op_t.__set_reg_phrase__(self, r: "uint16") -> None

ida_ua.op_t.__set_specval__(self, v: ida_idaapi.ea_t) -> None

ida_ua.op_t.__set_value64__(self, v: "uint64") -> None

ida_ua.op_t.__set_value__(self, v: ida_idaapi.ea_t) -> None

ida_ua.op_t.addr
    virtual address pointed or used by the operand. (o_mem,o_displ,o_far,o_near) 
            

ida_ua.op_t.addr
    virtual address pointed or used by the operand. (o_mem,o_displ,o_far,o_near) 
            

ida_ua.op_t.assign(self, other: "op_t") -> None

ida_ua.op_t.clr_shown(self) -> None
    Set operand to hidden.

ida_ua.op_t.dtype
    Type of operand value (see Operand value types). Usually first 9 types are used. This is the type of the operand itself, not the size of the addressing mode. for example, byte ptr [epb+32_bit_offset] will have dt_byte type. 
            

ida_ua.op_t.flags
    Operand flags 
            

ida_ua.op_t.has_reg(self, r)
    Checks if the operand accesses the given processor register

ida_ua.op_t.is_imm(self, v: int) -> bool
    Is immediate operand?

ida_ua.op_t.is_reg(self, r: int) -> bool
    Is register operand?

ida_ua.op_t.n
    Number of operand (0,1,2). Initialized once at the start of work. You have no right to change its value. 
            

ida_ua.op_t.offb
    Offset of operand value from the instruction start (0 means unknown). Of course this field is meaningful only for certain types of operands. Leave it equal to zero if the operand has no offset. This offset should point to the 'interesting' part of operand. For example, it may point to the address of a function in `call func ` or it may point to bytes holding '5' in `mov  ax, [bx+5] ` Usually bytes pointed to this offset are relocated (have fixup information). 
            

ida_ua.op_t.offo
    Same as offb (some operands have 2 numeric values used to form an operand). This field is used for the second part of operand if it exists. Currently this field is used only for outer offsets of Motorola processors. Leave it equal to zero if the operand has no offset. 
            

ida_ua.op_t.phrase
    number of register phrase (o_phrase,o_displ). you yourself define numbers of phrases as you like 
            

ida_ua.op_t.phrase
    number of register phrase (o_phrase,o_displ). you yourself define numbers of phrases as you like 
            

ida_ua.op_t.reg
    number of register (o_reg)

ida_ua.op_t.reg
    number of register (o_reg)

ida_ua.op_t.set_shown(self) -> None
    Set operand to be shown.

ida_ua.op_t.shown(self) -> bool
    Is operand set to be shown?

ida_ua.op_t.specval
    This field may be used as you want. 
            

ida_ua.op_t.specval
    This field may be used as you want. 
            

ida_ua.op_t.type
    Type of operand (see Operand types)

ida_ua.op_t.value
    operand value (o_imm) or outer displacement (o_displ+OF_OUTER_DISP). integer values should be in IDA's (little-endian) order. when using ieee_realcvt(), floating point values should be in the processor's native byte order. dt_double and dt_qword values take up 8 bytes (value and addr fields for 32-bit modules). NB: in case a dt_dword/dt_qword immediate is forced to float by user, the kernel converts it to processor's native order before calling FP conversion routines. 
            

ida_ua.op_t.value
    operand value (o_imm) or outer displacement (o_displ+OF_OUTER_DISP). integer values should be in IDA's (little-endian) order. when using ieee_realcvt(), floating point values should be in the processor's native byte order. dt_double and dt_qword values take up 8 bytes (value and addr fields for 32-bit modules). NB: in case a dt_dword/dt_qword immediate is forced to float by user, the kernel converts it to processor's native order before calling FP conversion routines. 
            

ida_ua.op_t__from_ptrval__(ptrval: "size_t") -> "op_t *"

ida_ua.operands_array

ida_ua.operands_array.__getitem__(self, i: "size_t") -> "op_t const &"

ida_ua.operands_array.__init__(self, data: "op_t (&)[8]")

ida_ua.operands_array.__len__(self) -> "size_t"

ida_ua.operands_array.__setitem__(self, i: "size_t", v: "op_t") -> None

ida_ua.operands_array._get_bytes(self) -> "bytevec_t"

ida_ua.operands_array._set_bytes(self, bts: "bytevec_t const &") -> None

ida_ua.outctx_base_t

ida_ua.outctx_base_t.F32
    please use outctx_t::F instead

ida_ua.outctx_base_t.__init__(self, *args, **kwargs)

ida_ua.outctx_base_t.close_comment(self) -> None

ida_ua.outctx_base_t.clr_gen_label(self) -> None

ida_ua.outctx_base_t.default_lnnum
    index of the most important line in lnar

ida_ua.outctx_base_t.display_voids(self) -> bool

ida_ua.outctx_base_t.flush_buf(self, buf: str, indent: int = -1) -> bool
    Append contents of 'buf' to the line array. Behaves like flush_outbuf but accepts an arbitrary buffer 
            

ida_ua.outctx_base_t.flush_outbuf(self, indent: int = -1) -> bool
    ------------------------------------------------------------------------- Functions to populate the output line array (lnar) Move the contents of the output buffer to the line array (outbuf->lnar) The kernel augments the outbuf contents with additional text like the line prefix, user-defined comments, xrefs, etc at this call. 
            

ida_ua.outctx_base_t.forbid_annotations(self) -> int

ida_ua.outctx_base_t.force_code(self) -> bool

ida_ua.outctx_base_t.gen_block_cmt(self, cmt: str, color: "color_t") -> bool
    Generate big non-indented comment lines. 
            
    @param cmt: comment text. may contain \n characters to denote new lines. should not contain comment character (;)
    @param color: color of comment text (one of Color tags)
    @returns overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_border_line(self, solid: bool = False) -> bool
    Generate thin border line. This function does nothing if generation of border lines is disabled. 
            
    @param solid: generate solid border line (with =), otherwise with -
    @returns overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_cmt_line(self, format: str) -> bool
    Generate one non-indented comment line, colored with COLOR_AUTOCMT. 
            
    @param format: printf() style format line. The resulting comment line should not include comment character (;)
    @returns overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_collapsed_line(self, format: str) -> bool
    Generate one non-indented comment line, colored with COLOR_COLLAPSED. 
            
    @param format: printf() style format line. The resulting comment line should not include comment character (;)
    @returns overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_empty_line(self) -> bool
    Generate empty line. This function does nothing if generation of empty lines is disabled. 
            
    @returns overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_empty_line_without_annotations(self) -> None

ida_ua.outctx_base_t.gen_printf(self, indent: int, format: str) -> bool
    printf-like function to add lines to the line array. 
            
    @param indent: indention of the line. if indent == -1, the kernel will indent the line at idainfo::indent. if indent < 0, -indent will be used for indention. The first line printed with indent < 0 is considered as the most important line at the current address. Usually it is the line with the instruction itself. This line will be displayed in the cross-reference lists and other places. If you need to output an additional line before the main line then pass DEFAULT_INDENT instead of -1. The kernel will know that your line is not the most important one.
    @param format: printf style colored line to generate
    @returns overflow, lnar_maxsize has been reached

ida_ua.outctx_base_t.gen_xref_lines(self) -> bool

ida_ua.outctx_base_t.getF(self) -> "flags64_t"

ida_ua.outctx_base_t.get_stkvar(self, x: "op_t", v: int, vv: "sval_t *", is_sp_based: "int *", _frame: "tinfo_t") -> "ssize_t"

ida_ua.outctx_base_t.init_lines_array(self, answers: "qstrvec_t *", maxsize: int) -> None

ida_ua.outctx_base_t.multiline(self) -> bool

ida_ua.outctx_base_t.only_main_line(self) -> bool

ida_ua.outctx_base_t.out_addr_tag(self, ea: ida_idaapi.ea_t) -> None
    Output "address" escape sequence.

ida_ua.outctx_base_t.out_btoa(self, Word: int, radix: "char" = 0) -> None
    Output a number with the specified base (binary, octal, decimal, hex) The number is output without color codes. see also out_long() 
            

ida_ua.outctx_base_t.out_char(self, c: "char") -> None
    Output one character. The character is output without color codes. see also out_symbol() 
            

ida_ua.outctx_base_t.out_chars(self, c: "char", n: int) -> None
    Append a character multiple times.

ida_ua.outctx_base_t.out_colored_register_line(self, str: str) -> None
    Output a colored line with register names in it. The register names will be substituted by user-defined names (regvar_t) Please note that out_tagoff tries to make substitutions too (when called with COLOR_REG) 
            

ida_ua.outctx_base_t.out_keyword(self, str: str) -> None
    Output a string with COLOR_KEYWORD color.

ida_ua.outctx_base_t.out_line(self, str: str, color: "color_t" = 0) -> None
    Output a string with the specified color.

ida_ua.outctx_base_t.out_long(self, v: int, radix: "char") -> None
    Output a number with appropriate color. Low level function. Use out_value() if you can. if 'suspop' is set then this function uses COLOR_VOIDOP instead of COLOR_NUMBER. 'suspop' is initialized:
    * in out_one_operand()
    * in ..\ida\gl.cpp (before calling processor_t::d_out())
    
    
    
    @param v: value to output
    @param radix: base (2,8,10,16)

ida_ua.outctx_base_t.out_lvar(self, name: str, width: int = -1) -> None
    Output local variable name with COLOR_LOCNAME color.

ida_ua.outctx_base_t.out_name_expr(self, *args) -> bool
    Output a name expression. 
            
    @param x: instruction operand referencing the name expression
    @param ea: address to convert to name expression
    @param off: the value of name expression. this parameter is used only to check that the name expression will have the wanted value. You may pass BADADDR for this parameter but I discourage it because it prohibits checks.
    @returns true if the name expression has been produced

ida_ua.outctx_base_t.out_printf(self, format: str) -> "size_t"
    ------------------------------------------------------------------------- Functions to append text to the current output buffer (outbuf) Append a formatted string to the output string. 
            
    @returns the number of characters appended

ida_ua.outctx_base_t.out_register(self, str: str) -> None
    Output a character with COLOR_REG color.

ida_ua.outctx_base_t.out_spaces(self, len: "ssize_t") -> None
    Appends spaces to outbuf until its tag_strlen becomes 'len'.

ida_ua.outctx_base_t.out_symbol(self, c: "char") -> None
    Output a character with COLOR_SYMBOL color.

ida_ua.outctx_base_t.out_tagoff(self, tag: "color_t") -> None
    Output "turn color off" escape sequence.

ida_ua.outctx_base_t.out_tagon(self, tag: "color_t") -> None
    Output "turn color on" escape sequence.

ida_ua.outctx_base_t.out_value(self, x: "op_t", outf: int = 0) -> "flags64_t"
    Output immediate value. Try to use this function to output all constants of instruction operands. This function outputs a number from x.addr or x.value in the form determined by F. It outputs colored text. 
            
    @param x: value to output
    @param outf: Output value flags
    @returns flags of the output value, otherwise:
    @retval -1: if printed a number with COLOR_ERROR
    @retval 0: if printed a nice number or character or segment or enum

ida_ua.outctx_base_t.outbuf
    buffer for the current output line once ready, it is moved to lnar 
            

ida_ua.outctx_base_t.print_label_now(self) -> bool

ida_ua.outctx_base_t.restore_ctxflags(self, saved_flags: int) -> None

ida_ua.outctx_base_t.retrieve_cmt(self) -> "ssize_t"

ida_ua.outctx_base_t.retrieve_name(self, arg2: str, arg3: "color_t *") -> "ssize_t"

ida_ua.outctx_base_t.set_comment_addr(self, ea: ida_idaapi.ea_t) -> None

ida_ua.outctx_base_t.set_dlbind_opnd(self) -> None

ida_ua.outctx_base_t.set_gen_cmt(self, on: bool = True) -> None

ida_ua.outctx_base_t.set_gen_demangled_label(self) -> None

ida_ua.outctx_base_t.set_gen_label(self) -> None

ida_ua.outctx_base_t.set_gen_xrefs(self, on: bool = True) -> None

ida_ua.outctx_base_t.setup_outctx(self, prefix: str, makeline_flags: int) -> None
    Initialization; normally used only by the kernel.

ida_ua.outctx_base_t.stack_view(self) -> bool

ida_ua.outctx_base_t.term_outctx(self, prefix: str = None) -> int
    Finalize the output context. 
            
    @returns the number of generated lines.

ida_ua.outctx_base_t__from_ptrval__(ptrval: "size_t") -> "outctx_base_t *"

ida_ua.outctx_t

ida_ua.outctx_t.__init__(self, *args, **kwargs)

ida_ua.outctx_t.gen_func_footer(self, pfn: "func_t const *") -> None

ida_ua.outctx_t.gen_func_header(self, pfn: "func_t *") -> None

ida_ua.outctx_t.gen_header(self, *args) -> None

ida_ua.outctx_t.gen_header_extra(self) -> None

ida_ua.outctx_t.gen_xref_lines(self) -> bool

ida_ua.outctx_t.out_btoa(self, Word: int, radix: "char" = 0) -> None
    Output a number with the specified base (binary, octal, decimal, hex) The number is output without color codes. see also out_long() 
            

ida_ua.outctx_t.out_custom_mnem(self, mnem: str, width: int = 8, postfix: str = None) -> None
    Output custom mnemonic for 'insn'. E.g. if it should differ from the one in 'ph.instruc'. This function outputs colored text. See out_mnem 
            
    @param mnem: custom mnemonic
    @param width: width of field with mnemonic. if < 0, then 'postfix' will be output before the mnemonic, i.e. as a prefix
    @param postfix: optional postfix added to 'mnem'

ida_ua.outctx_t.out_data(self, analyze_only: bool) -> None

ida_ua.outctx_t.out_fcref_names(self) -> None
    Print addresses referenced *from* the specified address as commented symbolic names. This function is used to show, for example, multiple callees of an indirect call. This function outputs colored text. 
            

ida_ua.outctx_t.out_immchar_cmts(self) -> None
    Print all operand values as commented character constants. This function is used to comment void operands with their representation in the form of character constants. This function outputs colored text. 
            

ida_ua.outctx_t.out_mnem(self, width: int = 8, postfix: str = None) -> None
    Output instruction mnemonic for 'insn' using information in 'ph.instruc' array. This function outputs colored text. It should be called from processor_t::ev_out_insn() or processor_t::ev_out_mnem() handler. It will output at least one space after the instruction. mnemonic even if the specified 'width' is not enough. 
            
    @param width: width of field with mnemonic. if < 0, then 'postfix' will be output before the mnemonic, i.e. as a prefix
    @param postfix: optional postfix added to the instruction mnemonic

ida_ua.outctx_t.out_mnemonic(self) -> None
    Output instruction mnemonic using information in 'insn'. It should be called from processor_t::ev_out_insn() and it will call processor_t::ev_out_mnem() or out_mnem. This function outputs colored text. 
            

ida_ua.outctx_t.out_one_operand(self, n: int) -> bool
    Use this function to output an operand of an instruction. This function checks for the existence of a manually defined operand and will output it if it exists. It should be called from processor_t::ev_out_insn() and it will call processor_t::ev_out_operand(). This function outputs colored text. 
            
    @param n: 0..UA_MAXOP-1 operand number
    @retval 1: operand is displayed
    @retval 0: operand is hidden

ida_ua.outctx_t.out_specea(self, segtype: "uchar") -> bool

ida_ua.outctx_t.retrieve_cmt(self) -> "ssize_t"

ida_ua.outctx_t.retrieve_name(self, arg2: str, arg3: "color_t *") -> "ssize_t"

ida_ua.outctx_t.set_bin_state(self, value: int) -> None

ida_ua.outctx_t.setup_outctx(self, prefix: str, flags: int) -> None
    Initialization; normally used only by the kernel.

ida_ua.outctx_t.term_outctx(self, prefix: str = None) -> int
    Finalize the output context. 
            
    @returns the number of generated lines.

ida_ua.outctx_t__from_ptrval__(ptrval: "size_t") -> "outctx_t *"

ida_ua.print_insn_mnem(ea: ida_idaapi.ea_t) -> str
    Print instruction mnemonics. 
            
    @param ea: linear address of the instruction
    @returns success

ida_ua.print_operand(ea: ida_idaapi.ea_t, n: int, getn_flags: int = 0, newtype: "printop_t" = None) -> str
    Generate text representation for operand #n. This function will generate the text representation of the specified operand (includes color codes.) 
            
    @param ea: the item address (instruction or data)
    @param n: 0..UA_MAXOP-1 operand number, meaningful only for instructions
    @param getn_flags: Name expression flags Currently only GETN_NODUMMY is accepted.
    @param newtype: if specified, print the operand using the specified type
    @returns success

ida_xref
    Functions that deal with cross-references.
    
    There are 2 types of xrefs: CODE and DATA references. All xrefs are kept in the bTree except ordinary execution flow to the next instruction. Ordinary execution flow to the next instruction is kept in flags (see bytes.hpp)
    The source address of a cross-reference must be an item head (is_head) or a structure member id.
    Cross-references are automatically sorted. 
        

ida_xref.XREF_BASE
    Reference to the base part of an offset.

ida_xref.XREF_CODE
    return only code references (fl_...)

ida_xref.XREF_DATA
    return only data references (dr_...)

ida_xref.XREF_EA
    return only program addresses

ida_xref.XREF_FLOW
    return all references, including ordinary flow xrefs

ida_xref.XREF_MASK
    Mask to get xref type.

ida_xref.XREF_NOFLOW
    skip ordinary flow xrefs (code xrefs to the next insn) 
            

ida_xref.XREF_PASTEND
    Reference is past item. This bit may be passed to add_dref() functions but it won't be saved in the database. It will prevent the destruction of eventual alignment directives. 
            

ida_xref.XREF_TAIL
    Reference to tail byte in extrn symbols.

ida_xref.XREF_TID
    return only type ids. XREF_EA and XREF_TID are exclusive, only one of them can be specified 
            

ida_xref.XREF_USER
    User specified xref. This xref will not be deleted by IDA. This bit should be combined with the existing xref types (cref_t & dref_t) Cannot be used for fl_F xrefs 
            

ida_xref.add_cref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: "cref_t") -> bool
    Create a code cross-reference. 
            
    @param to: linear address of referenced instruction
    @param type: cross-reference type
    @returns success

ida_xref.add_dref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: "dref_t") -> bool
    Create a data cross-reference. 
            
    @param to: linear address of referenced data
    @param type: cross-reference type
    @returns success (may fail if user-defined xref exists from->to)

ida_xref.calc_switch_cases(ea, si)
    Get information about a switch's cases.
    
    The returned information can be used as follows:
    
        for idx in range(len(results.cases)):
            cur_case = results.cases[idx]
            for cidx in range(len(cur_case)):
                print("case: %d" % cur_case[cidx])
            print("  goto 0x%x" % results.targets[idx])
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: a structure with 2 members: 'cases', and 'targets'.

ida_xref.cases_and_targets_t

ida_xref.cases_and_targets_t.__init__(self)

ida_xref.casevec_t

ida_xref.casevec_t.__eq__(self, r: "casevec_t") -> bool

ida_xref.casevec_t.__getitem__(self, i: "size_t") -> "qvector< long long > const &"

ida_xref.casevec_t.__init__(self, *args)

ida_xref.casevec_t.__len__(self) -> "size_t"

ida_xref.casevec_t.__ne__(self, r: "casevec_t") -> bool

ida_xref.casevec_t.__setitem__(self, i: "size_t", v: "qvector< long long > const &") -> None

ida_xref.casevec_t._del(self, x: "qvector< long long > const &") -> bool

ida_xref.casevec_t.add_unique(self, x: "qvector< long long > const &") -> bool

ida_xref.casevec_t.append(self, x: "qvector< long long > const &") -> None

ida_xref.casevec_t.at(self, _idx: "size_t") -> "qvector< long long > const &"

ida_xref.casevec_t.begin(self, *args) -> "qvector< qvector< long long > >::const_iterator"

ida_xref.casevec_t.capacity(self) -> "size_t"

ida_xref.casevec_t.clear(self) -> None

ida_xref.casevec_t.empty(self) -> bool

ida_xref.casevec_t.end(self, *args) -> "qvector< qvector< long long > >::const_iterator"

ida_xref.casevec_t.erase(self, *args) -> "qvector< qvector< long long > >::iterator"

ida_xref.casevec_t.extend(self, x: "casevec_t") -> None

ida_xref.casevec_t.extract(self) -> "qvector< long long > *"

ida_xref.casevec_t.find(self, *args) -> "qvector< qvector< long long > >::const_iterator"

ida_xref.casevec_t.grow(self, *args) -> None

ida_xref.casevec_t.has(self, x: "qvector< long long > const &") -> bool

ida_xref.casevec_t.inject(self, s: "qvector< long long > *", len: "size_t") -> None

ida_xref.casevec_t.insert(self, it: "qvector< qvector< long long > >::iterator", x: "qvector< long long > const &") -> "qvector< qvector< long long > >::iterator"

ida_xref.casevec_t.pop_back(self) -> None

ida_xref.casevec_t.push_back(self, *args) -> "qvector< long long > &"

ida_xref.casevec_t.qclear(self) -> None

ida_xref.casevec_t.reserve(self, cnt: "size_t") -> None

ida_xref.casevec_t.resize(self, *args) -> None

ida_xref.casevec_t.size(self) -> "size_t"

ida_xref.casevec_t.swap(self, r: "casevec_t") -> None

ida_xref.casevec_t.truncate(self) -> None

ida_xref.create_switch_table(ea, si)
    Create switch table from the switch information
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: Boolean

ida_xref.create_switch_xrefs(ea, si)
    This function creates xrefs from the indirect jump.
    
    Usually there is no need to call this function directly because the kernel
    will call it for switch tables
    
    Note: Custom switch information are not supported yet.
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: Boolean

ida_xref.del_cref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t, expand: bool) -> bool
    Delete a code cross-reference. 
            
    @param to: linear address of referenced instruction
    @param expand: policy to delete the referenced instruction
    * 1: plan to delete the referenced instruction if it has no more references.
    * 0: don't delete the referenced instruction even if no more cross-references point to it
    @retval true: if the referenced instruction will be deleted

ida_xref.del_dref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> None
    Delete a data cross-reference. 
            
    @param to: linear address of referenced data

ida_xref.delete_switch_table(jump_ea: ida_idaapi.ea_t, si: "switch_info_t") -> None

ida_xref.dr_I
    Informational (a derived java class references its base class informationally) 
              

ida_xref.dr_O
    Offset The reference uses 'offset' of data rather than its value OR The reference appeared because the "OFFSET" flag of instruction is set. The meaning of this type is IDP dependent. 
              

ida_xref.dr_R
    Read access.

ida_xref.dr_S
    Reference to enum member (symbolic constant)

ida_xref.dr_T
    Text (for forced operands only) Name of data is used in manual operand 
              

ida_xref.dr_U
    Unknown - for compatibility with old versions. Should not be used anymore. 
              

ida_xref.dr_W
    Write access.

ida_xref.fl_CF
    Call Far This xref creates a function at the referenced location 
              

ida_xref.fl_CN
    Call Near This xref creates a function at the referenced location 
              

ida_xref.fl_F
    Ordinary flow: used to specify execution flow to the next instruction. 
              

ida_xref.fl_JF
    Jump Far.

ida_xref.fl_JN
    Jump Near.

ida_xref.fl_U
    unknown - for compatibility with old versions. Should not be used anymore. 
              

ida_xref.fl_USobsolete
    User specified (obsolete)

ida_xref.get_first_cref_from(frm: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get first instruction referenced from the specified instruction. If the specified instruction passes execution to the next instruction then the next instruction is returned. Otherwise the lowest referenced address is returned (remember that xrefs are kept sorted!). 
            
    @returns first referenced address. If the specified instruction doesn't reference to other instructions then returns BADADDR.

ida_xref.get_first_cref_to(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get first instruction referencing to the specified instruction. If the specified instruction may be executed immediately after its previous instruction then the previous instruction is returned. Otherwise the lowest referencing address is returned. (remember that xrefs are kept sorted!). 
            
    @param to: linear address of referenced instruction
    @returns linear address of the first referencing instruction or BADADDR.

ida_xref.get_first_dref_from(frm: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get first data referenced from the specified address. 
            
    @returns linear address of first (lowest) data referenced from the specified address. Return BADADDR if the specified instruction/data doesn't reference to anything.

ida_xref.get_first_dref_to(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get address of instruction/data referencing to the specified data. 
            
    @param to: linear address of referencing instruction or data
    @returns BADADDR if nobody refers to the specified data.

ida_xref.get_first_fcref_from(frm: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_xref.get_first_fcref_to(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_xref.get_next_cref_from(frm: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get next instruction referenced from the specified instruction. 
            
    @param current: linear address of current referenced instruction This value is returned by get_first_cref_from() or previous call to get_next_cref_from() functions.
    @returns next referenced address or BADADDR.

ida_xref.get_next_cref_to(to: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get next instruction referencing to the specified instruction. 
            
    @param to: linear address of referenced instruction
    @param current: linear address of current referenced instruction This value is returned by get_first_cref_to() or previous call to get_next_cref_to() functions.
    @returns linear address of the next referencing instruction or BADADDR.

ida_xref.get_next_dref_from(frm: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get next data referenced from the specified address. 
            
    @param current: linear address of current referenced data. This value is returned by get_first_dref_from() or previous call to get_next_dref_from() functions.
    @returns linear address of next data or BADADDR.

ida_xref.get_next_dref_to(to: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t
    Get address of instruction/data referencing to the specified data 
            
    @param to: linear address of referencing instruction or data
    @param current: current linear address. This value is returned by get_first_dref_to() or previous call to get_next_dref_to() functions.
    @returns BADADDR if nobody refers to the specified data.

ida_xref.get_next_fcref_from(frm: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_xref.get_next_fcref_to(to: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_xref.has_external_refs(pfn: "func_t *", ea: ida_idaapi.ea_t) -> bool
    Does 'ea' have references from outside of 'pfn'?

ida_xref.has_jump_or_flow_xref(ea: ida_idaapi.ea_t) -> bool
    Are there jump or flow references to EA?

ida_xref.xrefblk_t

ida_xref.xrefblk_t.__init__(self)

ida_xref.xrefblk_t.crefs_from(self, ea)
    Provide an iterator on code references from ea including flow references

ida_xref.xrefblk_t.crefs_to(self, ea)
    Provide an iterator on code references to ea including flow references

ida_xref.xrefblk_t.drefs_from(self, ea)
    Provide an iterator on data references from ea

ida_xref.xrefblk_t.drefs_to(self, ea)
    Provide an iterator on data references to ea

ida_xref.xrefblk_t.fcrefs_from(self, ea)
    Provide an iterator on code references from ea

ida_xref.xrefblk_t.fcrefs_to(self, ea)
    Provide an iterator on code references to ea

ida_xref.xrefblk_t.first_from(self, _from: ida_idaapi.ea_t, flags: int = 0) -> bool

ida_xref.xrefblk_t.first_to(self, _to: ida_idaapi.ea_t, flags: int = 0) -> bool

ida_xref.xrefblk_t.iscode
    is code reference (cref_t)? otherwise it is a data reference (dref_t) 
            

ida_xref.xrefblk_t.next_from(self, *args) -> bool

ida_xref.xrefblk_t.next_to(self, *args) -> bool

ida_xref.xrefblk_t.refs_from(self, ea, flag)
    Provide an iterator on from reference represented by flag

ida_xref.xrefblk_t.refs_from._copy_xref()
    Make a private copy of the xref class to preserve its contents 

ida_xref.xrefblk_t.refs_to(self, ea, flag)
    Provide an iterator on to reference represented by flag

ida_xref.xrefblk_t.refs_to._copy_xref()
    Make a private copy of the xref class to preserve its contents 

ida_xref.xrefblk_t.to
    the referenced address - filled by first_from(), next_from()

ida_xref.xrefblk_t.type
    type of the last returned reference (cref_t & dref_t)

ida_xref.xrefblk_t.user
    is user defined xref? otherwise defined by ida

ida_xref.xrefchar(xrtype: "char") -> "char"
    Get character describing the xref type. 
            
    @param xrtype: combination of Cross-Reference type flags and a cref_t of dref_t value

ida_mergemod
    Merge functionality for modules.
    
    NOTE: this functionality is available in IDA Teams (not IDA Pro)
    This file contains helper classes and convenience functions for module (plugin or processor module) merging.
    Each module is responsible for merging the data it owns (the module data). At the very beginning, the merging engine generates the ev_create_merge_handlers event. Modules should hook to this event to create merge handlers (mergers) that are responsible for the module data.
    We assume that each module may have:
    
    * its data structure, derived from plugmod_t or procmod_t. we call this structure moddata.
    * a dedicated netnode (module node), modnode for short.
    
    
    Moddata is registered with the IDA kernel using the set_module_data() function, which returns an integer, moddata_id. moddata_id is used to access the module data structure during merging, so it is mandatory for all modules that support merging.
    The following sources of mergeable data are supported:
    1. Data fields inside moddata 2. Values (scalar or binary, including blobs) stored in the module node 3. Values (scalar or binary, including blobs) stored in arbitrary netnodes 4. Data fields inside an auxiliary structure (provided by a special helper) 5. Indexed arrays of data stored in netnodes
    Usually the sources #1-4 are handled by a single merger, which can be parameterized using the folowing information:
    
    * moddata_id
    * module name
    * module node name
    * array of field descriptors (idbattr_info_t idpopts_info[], see ida.hpp)
    
    
    See plugins/mex1 for an example of such a merger.
    These parameters are stored in a helper class (moddata_diff_helper_t or derived). The helper class can override the following virtual methods:
    merge_starting - prepare module data for merging (e.g. load data from idb) merge_ending - opposite to merge_starting (e.g. save merged data to idb) get_struc_ptr - get pointer to the auxiliary structure (to handle source #4); this method will be called only if the fields with the IDI_HLPSTRUC bit are present in the idpopts_info[] array
    For most plugins, the default implementation of moddata_diff_helper_t or the std_moddata_diff_helper_t helper (presented below) is sufficient. You can find examples of non-standard helpers in plugins/mex2 and plugins/callgraph.
    The source #5 is handled by a different set of mergers described by an array of merge_node_info_t entries: a merger per entry. A non-trivial example can be found in plugins/mex3 and plugins/ex_merge_ldrdata.
    A module can use the create_std_modmerge_handlers() function to create necessary merge handlers. Please pay attention to the following arguments:
    helper - a helper class responsible for access to the internal module data for the sources #1-4. It can be used to prepare a pointer to the internal module structure and load/save data before/after merging (example: plugins/mex2). Im most cases the default helper class moddata_diff_helper_t can be used. merge_node_info - array of descriptions for the source #5. Note that the same module node is used for all array elements. If you need this kind of mergers for other netnodes, you should add them manually using the create_nodeval_merge_handler() function (example: plugins/mex3)
    See also module/mergecmn.cpp for procmod-specific functions and macros.
    Glossary:
    modmerger = module merger moddata = module data moddata_id = module data id 
        

ida_mergemod.create_std_modmerge_handlers(mhp: "merge_handler_params_t &", helper: "moddata_diff_helper_t &", merge_node_info: "merge_node_info2_t const *" = None) -> None
    convinience function to create merge handlers for modules/plugins

ida_merge
    Merge functionality.
    
    NOTE: this functionality is available in IDA Teams (not IDA Pro)
    There are 3 databases involved in merging: base_idb, local_db, and remote_idb.
    * base_idb: the common base ancestor of 'local_db' and 'remote_db'. in the UI this database is located in the middle.
    * local_idb: local database that will contain the result of the merging. in the UI this database is located on the left.
    * remote_idb: remote database that will merge into local_idb. It may reside locally on the current computer, despite its name. in the UI this database is located on the right. base_idb and remote_idb are opened for reading only. base_idb may be absent, in this case a 2-way merging is performed.
    
    
    Conflicts can be resolved automatically or interactively. The automatic resolving scores the conflicting blocks and takes the better one. The interactive resolving displays the full rendered contents side by side, and expects the user to select the better side for each conflict.
    Since IDB files contain various kinds of information, there are many merging phases. The entire list can be found in merge.cpp. Below are just some selected examples:
    * merge global database settings (inf and other global vars)
    * merge segmentation and changes to the database bytes
    * merge various lists: exports, imports, loaded tils, etc
    * merge names, functions, function frames
    * merge debugger settings, breakpoints
    * merge struct/enum views
    * merge local type libraries
    * merge the disassembly items (i.e. the segment contents) this includes operand types, code/data separation, etc
    * merge plugin specific info like decompiler types, dwarf mappings, etc
    
    
    To unify UI elements of each merge phase, we use merger views:
    * A view that consists of 2 or 3 panes: left (local_idb) and right (remote_idb). The common base is in the middle, if present.
    * Rendering of the panes depends on the phase, different phases show different contents.
    * The conflicts are highlighted by a colored background. Also, the detail pane can be consulted for additional info.
    * The user can select a conflict (or a bunch of conflicts) and say "use this block".
    * The user can browse the panes as he wishes. He will not be forced to handle conflicts in any particular order. However, once he finishes working with a merge handler and proceeds to the next one, he cannot go back.
    * Scrolling the left pane will synchronously scroll the right pane and vice versa.
    * There are the navigation commands like "go to the prev/next conflict"
    * The number of remaining conflicts to resolve is printed in the "Progress" chooser.
    * The user may manually modify local database inside the merger view. For that he may use the regular hotkeys. However, editing the database may lead to new conflicts, so we better restrict the available actions to some reasonable minimum. Currently, this is not implemented.
    
    
    IDA works in a new "merge" mode during merging. In this mode most events are not generated. We forbid them to reduce the risk that a rogue third-party plugin that is not aware of the "merge" mode would spoil something.
    For example, normally renaming a function causes a cascade of events and may lead to other database modifications. Some of them may be desired, some - not. Since there are some undesired events, it is better to stop generating them. However, some events are required to render the disassembly listing. For example, ev_ana_insn, av_out_insn. This is why some events are still generated in the "merge" mode.
    To let processor modules and plugins merge their data, we introduce a new event: ev_create_merge_handlers. It is generated immediately after opening all three idbs. The interested modules should react to this event by creating new merge handlers, if they need them.
    While the kernel can create arbitrary merge handlers, modules can create only the standard ones returned by:
    create_nodeval_merge_handler() create_nodeval_merge_handlers() create_std_modmerge_handlers()
    We do not document merge_handler_t because once a merge handler is created, it is used exclusively by the kernel.
    See mergemod.hpp for more information about the merge mode for modules. 
        

ida_merge.MERGE_KIND_AFLAGS_EA
    merge aflags for mapped EA

ida_merge.MERGE_KIND_AUTOQ
    auto queues

ida_merge.MERGE_KIND_BOOKMARKS
    merge bookmarks

ida_merge.MERGE_KIND_BPTS
    merge breakpoints

ida_merge.MERGE_KIND_BYTEVAL
    merge byte values

ida_merge.MERGE_KIND_CREFS
    merge crefs

ida_merge.MERGE_KIND_CUSTDATA
    merge custom data type and formats

ida_merge.MERGE_KIND_DBG_MEMREGS
    manual memory regions (debugger)

ida_merge.MERGE_KIND_DEBUGGER
    debugger data

ida_merge.MERGE_KIND_DEKSTOPS
    dekstops

ida_merge.MERGE_KIND_DIRTREE
    merge std dirtrees

ida_merge.MERGE_KIND_DREFS
    merge drefs

ida_merge.MERGE_KIND_ENCODINGS
    merge encodings

ida_merge.MERGE_KIND_ENCODINGS2
    merge default encodings

ida_merge.MERGE_KIND_END
    insert to the end of handler list, valid for merge_handler_params_t::insert_after 
              

ida_merge.MERGE_KIND_ENUMS
    merge enums

ida_merge.MERGE_KIND_EXPORTS
    merge exports

ida_merge.MERGE_KIND_EXTRACMT
    merge extra next or prev lines

ida_merge.MERGE_KIND_FILEREGIONS
    merge fileregions

ida_merge.MERGE_KIND_FIXUPS
    merge fixups

ida_merge.MERGE_KIND_FLAGS
    merge flags64_t

ida_merge.MERGE_KIND_FLOWS
    merge flows

ida_merge.MERGE_KIND_FRAME
    merge function frame info (frame members)

ida_merge.MERGE_KIND_FRAMEMGR
    merge frames (globally: add/delete frames entirely)

ida_merge.MERGE_KIND_FUNC
    merge func info

ida_merge.MERGE_KIND_GHSTRCMT
    merge ghost structure comment

ida_merge.MERGE_KIND_HIDDENRANGES
    merge hidden ranges

ida_merge.MERGE_KIND_IGNOREMICRO
    IM ("$ ignore micro") flags.

ida_merge.MERGE_KIND_IMPORTS
    merge imports

ida_merge.MERGE_KIND_INF
    merge the inf variable (global settings)

ida_merge.MERGE_KIND_LAST
    last predefined merge handler type. please note that there can be more merge handler types, registered by plugins and processor modules. 
              

ida_merge.MERGE_KIND_LOADER
    loader data

ida_merge.MERGE_KIND_LUMINA
    lumina function metadata

ida_merge.MERGE_KIND_MAPPING
    merge manual memory mapping

ida_merge.MERGE_KIND_NETNODE
    netnode (no merging, to be used in idbunits)

ida_merge.MERGE_KIND_NOTEPAD
    notepad

ida_merge.MERGE_KIND_ORPHANS
    merge orphan bytes

ida_merge.MERGE_KIND_PATCHES
    merge patched bytes

ida_merge.MERGE_KIND_PROBLEMS
    problems

ida_merge.MERGE_KIND_SCRIPTS
    merge scripts

ida_merge.MERGE_KIND_SCRIPTS2
    merge scripts common info

ida_merge.MERGE_KIND_SEGGRPS
    merge segment groups

ida_merge.MERGE_KIND_SEGMENTS
    merge segments

ida_merge.MERGE_KIND_SEGREGS
    merge segment registers

ida_merge.MERGE_KIND_SELECTORS
    merge selectors

ida_merge.MERGE_KIND_SIGNATURES
    signatures

ida_merge.MERGE_KIND_SOURCEFILES
    merge source files ranges

ida_merge.MERGE_KIND_STKPNTS
    merge SP change points

ida_merge.MERGE_KIND_STRMEM
    merge struct members

ida_merge.MERGE_KIND_STRMEMCMT
    merge member comments for ghost struc

ida_merge.MERGE_KIND_STRUCTS
    merge structs (globally: add/delete structs entirely)

ida_merge.MERGE_KIND_STT
    merge flag storage types

ida_merge.MERGE_KIND_TILS
    merge type libraries

ida_merge.MERGE_KIND_TINFO
    merge tinfo

ida_merge.MERGE_KIND_TRYBLKS
    merge try blocks

ida_merge.MERGE_KIND_UDTMEM
    merge UDT members (local types)

ida_merge.MERGE_KIND_UI
    UI.

ida_merge.MERGE_KIND_VFTABLES
    merge vftables

ida_merge.MERGE_KIND_WATCHPOINTS
    merge watchpoints

ida_merge.MH_LISTEN
    merge handler will receive merge events

ida_merge.MH_TERSE
    do not display equal lines in the merge results table

ida_merge.MH_UI_CHAR_MASK
    7-bit ASCII split character

ida_merge.MH_UI_COLONNAME
    ida will split the diffpos name by ':' to create chooser columns

ida_merge.MH_UI_COMMANAME
    ida will split the diffpos name by ',' to create chooser columns

ida_merge.MH_UI_COMPLEX
    diffpos details won't be displayed in the diffpos chooser

ida_merge.MH_UI_DP_NOLINEDIFF
    Detail pane: do not show differences inside the line.

ida_merge.MH_UI_DP_SHORTNAME
    Detail pane: use the first part of a complex diffpos name as the tree node name.

ida_merge.MH_UI_INDENT
    preserve indent for diffpos name in diffpos chooser

ida_merge.MH_UI_NODETAILS
    ida will not show the diffpos details

ida_merge.MH_UI_SPLITNAME
    ida will split the diffpos name by 7-bit ASCII char to create chooser columns 
            

ida_merge.NDS_BLOB
    stored as netnode blobs

ida_merge.NDS_EV_FUNC
    enable default handling of mev_added_func/mev_deleting_func

ida_merge.NDS_EV_RANGE
    enable default handling of mev_modified_ranges, mev_deleting_segm

ida_merge.NDS_INC
    stored value is incremented (scalars only)

ida_merge.NDS_IS_BOOL
    boolean value

ida_merge.NDS_IS_EA
    EA value.

ida_merge.NDS_IS_RELATIVE
    value is relative to index (stored as delta)

ida_merge.NDS_IS_STR
    string value

ida_merge.NDS_MAP_IDX
    apply ea2node() to index (==NETMAP_IDX)

ida_merge.NDS_MAP_VAL
    apply ea2node() to value. Along with NDS_INC it gives effect of NETMAP_VAL, examples: altval_ea : NDS_MAP_IDX charval : NDS_VAL8 charval_ea: NDS_MAP_IDX|NDS_VAL8 eaget : NDS_MAP_IDX|NDS_MAP_VAL|NDS_INC 
              

ida_merge.NDS_SUPVAL
    stored as netnode supvals (not scalar)

ida_merge.NDS_UI_ND
    UI: no need to show diffpos detail pane, MH_UI_NODETAILS, make sense if merge_node_helper_t is used 
              

ida_merge.NDS_VAL8
    use 8-bit values (==NETMAP_V8)

ida_merge.create_nodeval_merge_handler(mhp: "merge_handler_params_t", label: str, nodename: str, tag: "uchar", nds_flags: int, node_helper: "merge_node_helper_t" = None, skip_empty_nodes: bool = True) -> "merge_handler_t *"
    Create a merge handler for netnode scalar/string values 
            
    @param mhp: merging parameters
    @param label: handler short name (to be be appended to mhp.label)
    @param nodename: netnode name
    @param tag: a tag used to access values in the netnode
    @param nds_flags: netnode value attributes (a combination of nds_flags_t)
    @param skip_empty_nodes: do not create handler in case of empty netnode
    @returns diff source object (normally should be attahced to a merge handler)

ida_merge.create_nodeval_merge_handlers(out: "merge_handlers_t *", mhp: "merge_handler_params_t", nodename: str, valdesc: "merge_node_info_t", skip_empty_nodes: bool = True) -> None
    Create a serie of merge handlers for netnode scalar/string values (call create_nodeval_merge_handler() for each member of VALDESC) 
            
    @param out: [out] created handlers will be placed here
    @param mhp: merging parameters
    @param nodename: netnode name
    @param valdesc: array of handler descriptions
    @param skip_empty_nodes: do not create handlers for empty netnodes
    @returns diff source object (normally should be attahced to a merge handler)

ida_merge.destroy_moddata_merge_handlers(data_id: int) -> None

ida_merge.get_ea_diffpos_name(ea: ida_idaapi.ea_t) -> str
    Get nice name for EA diffpos 
            
    @param ea: diffpos

ida_merge.is_diff_merge_mode() -> bool
    Return TRUE if IDA is running in diff mode (MERGE_POLICY_MDIFF/MERGE_POLICY_VDIFF)

ida_merge.item_block_locator_t

ida_merge.item_block_locator_t.__disown__(self)

ida_merge.item_block_locator_t.__init__(self)

ida_merge.item_block_locator_t.get_block_head(self, md: "merge_data_t", idx: "diff_source_idx_t", item_head: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_merge.item_block_locator_t.setup_blocks(self, md: "merge_data_t", _from: "diff_source_idx_t", to: "diff_source_idx_t", region: "diff_range_t const &") -> bool

ida_merge.merge_data_t

ida_merge.merge_data_t.__init__(self, *args, **kwargs)

ida_merge.merge_data_t.add_event_handler(self, handler: "merge_handler_t *") -> None

ida_merge.merge_data_t.base_id(self) -> int

ida_merge.merge_data_t.compare_merging_tifs(self, tif1: "tinfo_t", diffidx1: "diff_source_idx_t", tif2: "tinfo_t", diffidx2: "diff_source_idx_t") -> int
    compare types from two databases 
            
    @param tif1: type
    @param diffidx1: database index, diff_source_idx_t
    @param tif2: type
    @param diffidx2: database index, diff_source_idx_t
    @returns -1, 0, 1

ida_merge.merge_data_t.dbctx_ids
    local, remote, base ids

ida_merge.merge_data_t.ev_handlers
    event handlers

ida_merge.merge_data_t.get_block_head(self, idx: "diff_source_idx_t", item_head: ida_idaapi.ea_t) -> ida_idaapi.ea_t

ida_merge.merge_data_t.has_existing_node(self, nodename: str) -> bool
    check that node exists in any of databases

ida_merge.merge_data_t.local_id(self) -> int

ida_merge.merge_data_t.map_privrange_id(self, tid: "tid_t *", ea: ida_idaapi.ea_t, _from: "diff_source_idx_t", to: "diff_source_idx_t", strict: bool = True) -> bool
    map IDs of structures, enumerations and their members 
            
    @param tid: item ID in TO database
    @param ea: item ID to find counterpart
    @param to: destination database index, diff_source_idx_t
    @param strict: raise interr if could not map
    @returns success

ida_merge.merge_data_t.map_tinfo(self, tif: "tinfo_t", _from: "diff_source_idx_t", to: "diff_source_idx_t", strict: bool = True) -> bool
    migrate type, replaces type references into FROM database to references into TO database 
            
    @param tif: type to migrate, will be cleared in case of fail
    @param to: destination database index, diff_source_idx_t
    @param strict: raise interr if could not map
    @returns success

ida_merge.merge_data_t.nbases
    number of database participating in merge process, maybe 2 or 3 
            

ida_merge.merge_data_t.remote_id(self) -> int

ida_merge.merge_data_t.remove_event_handler(self, handler: "merge_handler_t *") -> None

ida_merge.merge_data_t.set_dbctx_ids(self, local: int, remote: int, base: int) -> None

ida_merge.merge_data_t.setup_blocks(self, dst_idx: "diff_source_idx_t", src_idx: "diff_source_idx_t", region: "diff_range_t const &") -> bool

ida_merge.merge_handler_params_t

ida_merge.merge_handler_params_t.__init__(self, _md: "merge_data_t", _label: str, _kind: "merge_kind_t", _insert_after: "merge_kind_t", _mh_flags: int)

ida_merge.merge_handler_params_t.insert_after
    desired position inside 'handlers' merge_kind_t

ida_merge.merge_handler_params_t.kind
    merge handler kind merge_kind_t

ida_merge.merge_handler_params_t.ui_complex_details(self, *args) -> bool
    This function has the following signatures:
    
        0. ui_complex_details() -> bool
        1. ui_complex_details(_mh_flags: int) -> bool
    
    # 0: ui_complex_details() -> bool
    
    
    # 1: ui_complex_details(_mh_flags: int) -> bool
    
    Do not display the diffpos details in the chooser. For example, the MERGE_KIND_SCRIPTS handler puts the script body as the diffpos detail. It would not be great to show them as part of the chooser. 
            

ida_merge.merge_handler_params_t.ui_complex_name(self, *args) -> bool
    This function has the following signatures:
    
        0. ui_complex_name() -> bool
        1. ui_complex_name(_mh_flags: int) -> bool
    
    # 0: ui_complex_name() -> bool
    
    
    # 1: ui_complex_name(_mh_flags: int) -> bool
    
    It customary to create long diffpos names having many components that are separated by any 7-bit ASCII character (besides of '\0'). In this case it is possible to instruct IDA to use this separator to create a multi-column chooser. For example the MERGE_KIND_ENUMS handler has the following diffpos name: enum_1,enum_2 If MH_UI_COMMANAME is specified, IDA will create 2 columns for these names. 
            

ida_merge.merge_handler_params_t.ui_dp_shortname(self, *args) -> bool
    This function has the following signatures:
    
        0. ui_dp_shortname() -> bool
        1. ui_dp_shortname(_mh_flags: int) -> bool
    
    # 0: ui_dp_shortname() -> bool
    
    
    # 1: ui_dp_shortname(_mh_flags: int) -> bool
    
    The detail pane shows the diffpos details for the current diffpos range as a tree-like view. In this pane the diffpos names are used as tree node names and the diffpos details as their children. Sometimes, for complex diffpos names, the first part of the name looks better than the entire name. For example, the MERGE_KIND_SEGMENTS handler has the following diffpos name: <range>,<segm1>,<segm2>,<segm3> if MH_UI_DP_SHORTNAME is specified, IDA will use <range> as a tree node name 
            

ida_merge.merge_handler_params_t.ui_has_details(self, *args) -> bool
    This function has the following signatures:
    
        0. ui_has_details() -> bool
        1. ui_has_details(_mh_flags: int) -> bool
    
    # 0: ui_has_details() -> bool
    
    
    # 1: ui_has_details(_mh_flags: int) -> bool
    
    Should IDA display the diffpos detail pane?

ida_merge.merge_handler_params_t.ui_indent(self, *args) -> bool
    This function has the following signatures:
    
        0. ui_indent() -> bool
        1. ui_indent(_mh_flags: int) -> bool
    
    # 0: ui_indent() -> bool
    
    
    # 1: ui_indent(_mh_flags: int) -> bool
    
    In the ordinary situation the spaces from the both sides of diffpos name are trimmed. Use this UI hint to preserve the leading spaces. 
            

ida_merge.merge_handler_params_t.ui_linediff(self, *args) -> bool
    This function has the following signatures:
    
        0. ui_linediff() -> bool
        1. ui_linediff(_mh_flags: int) -> bool
    
    # 0: ui_linediff() -> bool
    
    
    # 1: ui_linediff(_mh_flags: int) -> bool
    
    In detail pane IDA shows difference between diffpos details. IDA marks added or deleted detail by color. In the modified detail the changes are marked. Use this UI hint if you do not want to show the differences inside detail. 
            

ida_merge.merge_handler_params_t.ui_split_char(self, *args) -> "char"
    This function has the following signatures:
    
        0. ui_split_char() -> char
        1. ui_split_char(_mh_flags: int) -> char
    
    # 0: ui_split_char() -> char
    
    
    # 1: ui_split_char(_mh_flags: int) -> char

ida_merge.merge_handler_params_t.ui_split_str(self, *args) -> str
    This function has the following signatures:
    
        0. ui_split_str() -> str
        1. ui_split_str(_mh_flags: int) -> str
    
    # 0: ui_split_str() -> str
    
    
    # 1: ui_split_str(_mh_flags: int) -> str

ida_merge.merge_node_helper_t

ida_merge.merge_node_helper_t.__disown__(self)

ida_merge.merge_node_helper_t.__init__(self)

ida_merge.merge_node_helper_t.append_eavec(s: str, prefix: str, eas: "eavec_t const &") -> None
    can be used by derived classes

ida_merge.merge_node_helper_t.get_column_headers(self, arg0: "qstrvec_t *", arg1: "uchar", arg2: "void *") -> None
    get column headers for chooser (to be used in linear_diff_source_t::get_column_headers) 
            

ida_merge.merge_node_helper_t.get_netnode(self) -> "netnode"
    return netnode to be used as source. If this function returns BADNODE netnode will be created using netnode name passed to create_nodeval_diff_source 
            

ida_merge.merge_node_helper_t.is_mergeable(self, arg0: "uchar", arg1: "nodeidx_t") -> bool
    filter: check if we should perform merging for given record

ida_merge.merge_node_helper_t.map_scalar(self, arg0: "nodeidx_t *", arg1: "void *", arg2: "diff_source_idx_t", arg3: "diff_source_idx_t") -> None
    map scalar/string/buffered value

ida_merge.merge_node_helper_t.map_string(self, arg0: str, arg1: "void *", arg2: "diff_source_idx_t", arg3: "diff_source_idx_t") -> None

ida_merge.merge_node_helper_t.print_entry_details(self, arg0: "qstrvec_t *", arg1: "uchar", arg2: "nodeidx_t", arg3: "void *") -> None
    print the details of the specified entry usually contains multiple lines, one for each attribute or detail. (to be used in print_diffpos_details) 
            

ida_merge.merge_node_helper_t.print_entry_name(self, arg0: "uchar", arg1: "nodeidx_t", arg2: "void *") -> str
    print the name of the specified entry (to be used in print_diffpos_name) 
            

ida_merge.merge_node_helper_t.refresh(self, arg0: "uchar", arg1: "void *") -> None
    notify helper that some data was changed in the database and internal structures (e.g. caches) should be refreshed 
            

ida_merge.merge_node_info_t

ida_merge.merge_node_info_t.__init__(self, name: str, tag: "uchar", nds_flags: int, node_helper: "merge_node_helper_t" = None)

ida_merge.merge_node_info_t.name
    name of the array (label)

ida_merge.merge_node_info_t.nds_flags
    node value attributes (a combination of nds_flags_t)

ida_merge.merge_node_info_t.tag
    a tag used to access values in the netnode

ida_merge.moddata_diff_helper_t

ida_merge.moddata_diff_helper_t.__disown__(self)

ida_merge.moddata_diff_helper_t.__init__(self, _module_name: str, _netnode_name: str, _fields: "idbattr_info_t")

ida_merge.moddata_diff_helper_t.additional_mh_flags
    additional merge handler flags

ida_merge.moddata_diff_helper_t.fields
    module data attribute descriptions

ida_merge.moddata_diff_helper_t.get_struc_ptr(self, arg0: "merge_data_t", arg1: "diff_source_idx_t", arg2: "idbattr_info_t") -> "void *"

ida_merge.moddata_diff_helper_t.merge_ending(self, arg0: "diff_source_idx_t", arg1: "void *") -> None

ida_merge.moddata_diff_helper_t.merge_starting(self, arg0: "diff_source_idx_t", arg1: "void *") -> None

ida_merge.moddata_diff_helper_t.module_name
    will be used as a prefix for field desc

ida_merge.moddata_diff_helper_t.netnode_name
    name of netnode with module data attributes

ida_merge.moddata_diff_helper_t.nfields
    number of descriptions

ida_merge.moddata_diff_helper_t.print_diffpos_details(self, arg0: "qstrvec_t *", arg1: "idbattr_info_t") -> None

ida_merge.moddata_diff_helper_t.str2val(self, arg0: "uint64 *", arg1: "idbattr_info_t", arg2: str) -> bool

ida_merge.moddata_diff_helper_t.val2str(self, arg0: str, arg1: "idbattr_info_t", arg2: "uint64") -> bool

ida_undo

ida_undo.create_undo_point(*args) -> bool
    Create a new restore point. The user can undo to this point in the future. 
            
    @param bytes: body of the record for UNDO_ACTION_START
    @param size: size of the record for UNDO_ACTION_START
    @returns success; fails if undo is disabled

ida_undo.get_redo_action_label() -> str
    Get the label of the action that will be redone. This function returns the text that can be displayed in the redo menu 
            
    @returns success

ida_undo.get_undo_action_label() -> str
    Get the label of the action that will be undone. This function returns the text that can be displayed in the undo menu 
            
    @returns success

ida_undo.perform_redo() -> bool
    Perform redo. 
            
    @returns success

ida_undo.perform_undo() -> bool
    Perform undo. 
            
    @returns success


```
